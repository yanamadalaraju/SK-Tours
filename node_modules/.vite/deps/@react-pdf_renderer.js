import {
  __decorate
} from "./chunk-WHJPBTQF.js";
import {
  require_object_assign
} from "./chunk-PWODU4QM.js";
import {
  require_jsx_runtime
} from "./chunk-RPA7DSTZ.js";
import {
  require_react
} from "./chunk-2FSLC3XA.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
      return value2 !== value2;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once5;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners3(n5) {
      if (typeof n5 !== "number" || n5 < 0 || NumberIsNaN(n5)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n5 + ".");
      }
      this._maxListeners = n5;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners3() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit5(type) {
      var args = [];
      for (var i4 = 1; i4 < arguments.length; i4++) args.push(arguments[i4]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners3 = arrayClone3(handler, len);
        for (var i4 = 0; i4 < len; ++i4)
          ReflectApply(listeners3[i4], this, args);
      }
      return true;
    };
    function _addListener3(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener5(type, listener) {
      return _addListener3(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener5(type, listener) {
      return _addListener3(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap3(target, type, listener) {
      var state2 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state2);
      wrapped.listener = listener;
      state2.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once6(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener3(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener5(type, listener) {
      var list, events2, position, i4, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i4 = list.length - 1; i4 >= 0; i4--) {
          if (list[i4] === listener || list[i4].listener === listener) {
            originalListener = list[i4].listener;
            position = i4;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne3(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners5(type) {
      var listeners3, events2, i4;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events2);
        var key;
        for (i4 = 0; i4 < keys2.length; ++i4) {
          key = keys2[i4];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners3 = events2[type];
      if (typeof listeners3 === "function") {
        this.removeListener(type, listeners3);
      } else if (listeners3 !== void 0) {
        for (i4 = listeners3.length - 1; i4 >= 0; i4--) {
          this.removeListener(type, listeners3[i4]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners3(evlistener) : arrayClone3(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners3(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount3.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount3;
    function listenerCount3(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames3() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone3(arr, n5) {
      var copy5 = new Array(n5);
      for (var i4 = 0; i4 < n5; ++i4)
        copy5[i4] = arr[i4];
      return copy5;
    }
    function spliceOne3(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners3(arr) {
      var ret = new Array(arr.length);
      for (var i4 = 0; i4 < ret.length; ++i4) {
        ret[i4] = arr[i4].listener || arr[i4];
      }
      return ret;
    }
    function once5(emitter, name) {
      return new Promise(function(resolve3, reject) {
        function errorListener(err2) {
          emitter.removeListener(name, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve3([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/queue/index.js
var require_queue = __commonJS({
  "node_modules/queue/index.js"(exports, module) {
    var inherits3 = require_inherits_browser();
    var EventEmitter3 = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter3.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits3(Queue, EventEmitter3);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end2) {
      this.jobs = this.jobs.slice(begin, end2);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done3.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once5 = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err2, result) {
        if (once5 && self2.session === session) {
          once5 = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err2) {
            self2.emit("error", err2, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done3.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err2) {
          return next(err2 || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err2) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done3.call(this, err2);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend3);
      function onerror(err2) {
        self2.end(err2);
      }
      function onend3(err2) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend3);
        cb(err2, this.results);
      }
    }
    function done3(err2) {
      this.session++;
      this.running = false;
      this.emit("end", err2);
    }
  }
});

// node_modules/is-url/index.js
var require_is_url = __commonJS({
  "node_modules/is-url/index.js"(exports, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal3(a4, b3) {
      if (a4 === b3) return true;
      if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
        if (a4.constructor !== b3.constructor) return false;
        var length2, i4, keys2;
        if (Array.isArray(a4)) {
          length2 = a4.length;
          if (length2 != b3.length) return false;
          for (i4 = length2; i4-- !== 0; )
            if (!equal3(a4[i4], b3[i4])) return false;
          return true;
        }
        if (a4.constructor === RegExp) return a4.source === b3.source && a4.flags === b3.flags;
        if (a4.valueOf !== Object.prototype.valueOf) return a4.valueOf() === b3.valueOf();
        if (a4.toString !== Object.prototype.toString) return a4.toString() === b3.toString();
        keys2 = Object.keys(a4);
        length2 = keys2.length;
        if (length2 !== Object.keys(b3).length) return false;
        for (i4 = length2; i4-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys2[i4])) return false;
        for (i4 = length2; i4-- !== 0; ) {
          var key = keys2[i4];
          if (!equal3(a4[key], b3[key])) return false;
        }
        return true;
      }
      return a4 !== a4 && b3 !== b3;
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength5;
    exports.toByteArray = toByteArray4;
    exports.fromByteArray = fromByteArray4;
    var lookup4 = [];
    var revLookup4 = [];
    var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i4 = 0, len = code.length; i4 < len; ++i4) {
      lookup4[i4] = code[i4];
      revLookup4[code.charCodeAt(i4)] = i4;
    }
    var i4;
    var len;
    revLookup4["-".charCodeAt(0)] = 62;
    revLookup4["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength5(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray4(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr4(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i5;
      for (i5 = 0; i5 < len2; i5 += 4) {
        tmp = revLookup4[b64.charCodeAt(i5)] << 18 | revLookup4[b64.charCodeAt(i5 + 1)] << 12 | revLookup4[b64.charCodeAt(i5 + 2)] << 6 | revLookup4[b64.charCodeAt(i5 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup4[b64.charCodeAt(i5)] << 2 | revLookup4[b64.charCodeAt(i5 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup4[b64.charCodeAt(i5)] << 10 | revLookup4[b64.charCodeAt(i5 + 1)] << 4 | revLookup4[b64.charCodeAt(i5 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase644(num) {
      return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
    }
    function encodeChunk4(uint82, start2, end2) {
      var tmp;
      var output = [];
      for (var i5 = start2; i5 < end2; i5 += 3) {
        tmp = (uint82[i5] << 16 & 16711680) + (uint82[i5 + 1] << 8 & 65280) + (uint82[i5 + 2] & 255);
        output.push(tripletToBase644(tmp));
      }
      return output.join("");
    }
    function fromByteArray4(uint82) {
      var tmp;
      var len2 = uint82.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
        parts.push(encodeChunk4(uint82, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "node_modules/tiny-inflate/index.js"(exports, module) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i4, sum;
      for (i4 = 0; i4 < delta; ++i4) bits[i4] = 0;
      for (i4 = 0; i4 < 30 - delta; ++i4) bits[i4 + delta] = i4 / delta | 0;
      for (sum = first, i4 = 0; i4 < 30; ++i4) {
        base[i4] = sum;
        sum += 1 << bits[i4];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i4;
      for (i4 = 0; i4 < 7; ++i4) lt.table[i4] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i4 = 0; i4 < 24; ++i4) lt.trans[i4] = 256 + i4;
      for (i4 = 0; i4 < 144; ++i4) lt.trans[24 + i4] = i4;
      for (i4 = 0; i4 < 8; ++i4) lt.trans[24 + 144 + i4] = 280 + i4;
      for (i4 = 0; i4 < 112; ++i4) lt.trans[24 + 144 + 8 + i4] = 144 + i4;
      for (i4 = 0; i4 < 5; ++i4) dt.table[i4] = 0;
      dt.table[5] = 32;
      for (i4 = 0; i4 < 32; ++i4) dt.trans[i4] = i4;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t4, lengths2, off3, num) {
      var i4, sum;
      for (i4 = 0; i4 < 16; ++i4) t4.table[i4] = 0;
      for (i4 = 0; i4 < num; ++i4) t4.table[lengths2[off3 + i4]]++;
      t4.table[0] = 0;
      for (sum = 0, i4 = 0; i4 < 16; ++i4) {
        offs[i4] = sum;
        sum += t4.table[i4];
      }
      for (i4 = 0; i4 < num; ++i4) {
        if (lengths2[off3 + i4]) t4.trans[offs[lengths2[off3 + i4]]++] = i4;
      }
    }
    function tinf_getbit(d2) {
      if (!d2.bitcount--) {
        d2.tag = d2.source[d2.sourceIndex++];
        d2.bitcount = 7;
      }
      var bit = d2.tag & 1;
      d2.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d2, num, base) {
      if (!num)
        return base;
      while (d2.bitcount < 24) {
        d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
        d2.bitcount += 8;
      }
      var val = d2.tag & 65535 >>> 16 - num;
      d2.tag >>>= num;
      d2.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d2, t4) {
      while (d2.bitcount < 24) {
        d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
        d2.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d2.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t4.table[len];
        cur -= t4.table[len];
      } while (cur >= 0);
      d2.tag = tag;
      d2.bitcount -= len;
      return t4.trans[sum + cur];
    }
    function tinf_decode_trees(d2, lt, dt) {
      var hlit, hdist, hclen;
      var i4, num, length2;
      hlit = tinf_read_bits(d2, 5, 257);
      hdist = tinf_read_bits(d2, 5, 1);
      hclen = tinf_read_bits(d2, 4, 4);
      for (i4 = 0; i4 < 19; ++i4) lengths[i4] = 0;
      for (i4 = 0; i4 < hclen; ++i4) {
        var clen = tinf_read_bits(d2, 3, 0);
        lengths[clcidx[i4]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d2, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length2 = tinf_read_bits(d2, 2, 3); length2; --length2) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length2 = tinf_read_bits(d2, 3, 3); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length2 = tinf_read_bits(d2, 7, 11); length2; --length2) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d2, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d2, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d2.dest[d2.destLen++] = sym;
        } else {
          var length2, dist, offs2;
          var i4;
          sym -= 257;
          length2 = tinf_read_bits(d2, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d2, dt);
          offs2 = d2.destLen - tinf_read_bits(d2, dist_bits[dist], dist_base[dist]);
          for (i4 = offs2; i4 < offs2 + length2; ++i4) {
            d2.dest[d2.destLen++] = d2.dest[i4];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d2) {
      var length2, invlength;
      var i4;
      while (d2.bitcount > 8) {
        d2.sourceIndex--;
        d2.bitcount -= 8;
      }
      length2 = d2.source[d2.sourceIndex + 1];
      length2 = 256 * length2 + d2.source[d2.sourceIndex];
      invlength = d2.source[d2.sourceIndex + 3];
      invlength = 256 * invlength + d2.source[d2.sourceIndex + 2];
      if (length2 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d2.sourceIndex += 4;
      for (i4 = length2; i4; --i4)
        d2.dest[d2.destLen++] = d2.source[d2.sourceIndex++];
      d2.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d2 = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d2);
        btype = tinf_read_bits(d2, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d2);
            break;
          case 1:
            res = tinf_inflate_block_data(d2, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d2, d2.ltree, d2.dtree);
            res = tinf_inflate_block_data(d2, d2.ltree, d2.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d2.destLen < d2.dest.length) {
        if (typeof d2.dest.slice === "function")
          return d2.dest.slice(0, d2.destLen);
        else
          return d2.dest.subarray(0, d2.destLen);
      }
      return d2.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "node_modules/unicode-trie/swap.js"(exports, module) {
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap4 = (b3, n5, m) => {
      let i4 = b3[n5];
      b3[n5] = b3[m];
      b3[m] = i4;
    };
    var swap324 = (array) => {
      const len = array.length;
      for (let i4 = 0; i4 < len; i4 += 4) {
        swap4(array, i4, i4 + 3);
        swap4(array, i4 + 1, i4 + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian2) {
        swap324(array);
      }
    };
    module.exports = {
      swap32LE
    };
  }
});

// node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "node_modules/unicode-trie/index.js"(exports, module) {
    var inflate2 = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data2) {
        const isBuffer4 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
        if (isBuffer4 || data2 instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer4) {
            this.highStart = data2.readUInt32LE(0);
            this.errorValue = data2.readUInt32LE(4);
            uncompressedLength = data2.readUInt32LE(8);
            data2 = data2.slice(12);
          } else {
            const view = new DataView(data2.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data2 = data2.subarray(12);
          }
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          swap32LE(data2);
          this.data = new Uint32Array(data2.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
        }
      }
      get(codePoint) {
        let index2;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint <= 65535) {
          index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint < this.highStart) {
          index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// node_modules/dfa/index.js
var require_dfa = __commonJS({
  "node_modules/dfa/index.js"(exports, module) {
    "use strict";
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state2 = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p3 = 0; p3 < str.length; p3++) {
              var c4 = str[p3];
              lastState = state2;
              state2 = self2.stateTable[state2][c4];
              if (state2 === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state2 = self2.stateTable[INITIAL_STATE][c4];
                startRun = null;
              }
              if (state2 !== FAIL_STATE && startRun == null) {
                startRun = p3;
              }
              if (self2.accepting[state2]) {
                lastAccepting = p3;
              }
              if (state2 === FAIL_STATE) {
                state2 = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state2]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str, actions) {
        for (var [start2, end2, tags2] of this.match(str)) {
          for (var tag of tags2) {
            if (typeof actions[tag] === "function") {
              actions[tag](start2, end2, str.slice(start2, end2 + 1));
            }
          }
        }
      }
    };
    module.exports = StateMachine;
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve3, reject) {
              parent2.then(function(value2) {
                resolve3(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i4 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i4);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i4] = _clone(parent2[i4], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i4 = 0; i4 < symbols.length; i4++) {
              var symbol = symbols[i4];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i4 = 0; i4 < allPropertyNames.length; i4++) {
              var propertyName = allPropertyNames[i4];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c4 = function() {
        };
        c4.prototype = parent;
        return new c4();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "node_modules/brotli/dec/streams.js"(exports) {
    function BrotliInput(buffer) {
      this.buffer = buffer;
      this.pos = 0;
    }
    BrotliInput.prototype.read = function(buf, i4, count) {
      if (this.pos + count > this.buffer.length) {
        count = this.buffer.length - this.pos;
      }
      for (var p3 = 0; p3 < count; p3++)
        buf[i4 + p3] = this.buffer[this.pos + p3];
      this.pos += count;
      return count;
    };
    exports.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    BrotliOutput.prototype.write = function(buf, count) {
      if (this.pos + count > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count), this.pos);
      this.pos += count;
      return count;
    };
    exports.BrotliOutput = BrotliOutput;
  }
});

// node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "node_modules/brotli/dec/bit_reader.js"(exports, module) {
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i4 = 0; i4 < 4; i4++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i4;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p3 = 0; p3 < 32; p3++)
            this.buf_[dst + bytes_read + p3] = 0;
        }
        if (dst === 0) {
          for (var p3 = 0; p3 < 32; p3++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p3] = this.buf_[p3];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module.exports = BrotliBitReader;
  }
});

// node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "node_modules/brotli/dec/dictionary.bin.js"(exports, module) {
    module.exports = "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";
  }
});

// node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "node_modules/brotli/dec/dictionary-browser.js"(exports) {
    var base64 = require_base64_js();
    exports.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/brotli/dec/dictionary.js"(exports) {
    var data2 = require_dictionary_browser();
    exports.init = function() {
      exports.dictionary = data2.init();
    };
    exports.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports.minDictionaryWordLength = 4;
    exports.maxDictionaryWordLength = 24;
  }
});

// node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "node_modules/brotli/dec/huffman.js"(exports) {
    function HuffmanCode(bits, value2) {
      this.bits = bits;
      this.value = value2;
    }
    exports.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len) {
      var step = 1 << len - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    function ReplicateValue(table, i4, step, end2, code) {
      do {
        end2 -= step;
        table[i4 + end2] = new HuffmanCode(code.bits, code.value);
      } while (end2 > 0);
    }
    function NextTableBitSize(count, len, root_bits) {
      var left = 1 << len - root_bits;
      while (len < MAX_LENGTH) {
        left -= count[len];
        if (left <= 0) break;
        ++len;
        left <<= 1;
      }
      return len - root_bits;
    }
    exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
      var start_table = table;
      var code;
      var len;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count = new Int32Array(MAX_LENGTH + 1);
      var offset2 = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count[code_lengths[symbol]]++;
      }
      offset2[1] = 0;
      for (len = 1; len < MAX_LENGTH; len++) {
        offset2[len + 1] = offset2[len] + count[len];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset2[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset2[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + key, step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          if ((key & mask) !== low) {
            table += table_size;
            table_bits = NextTableBitSize(count, len, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
          }
          code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      return total_size;
    };
  }
});

// node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "node_modules/brotli/dec/context.js"(exports) {
    exports.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "node_modules/brotli/dec/prefix.js"(exports) {
    function PrefixCodeRange(offset2, nbits) {
      this.offset = offset2;
      this.nbits = nbits;
    }
    exports.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "node_modules/brotli/dec/transform.js"(exports) {
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform3(prefix, transform, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform;
      this.suffix = new Uint8Array(suffix.length);
      for (var i4 = 0; i4 < prefix.length; i4++)
        this.prefix[i4] = prefix.charCodeAt(i4);
      for (var i4 = 0; i4 < suffix.length; i4++)
        this.suffix[i4] = suffix.charCodeAt(i4);
    }
    var kTransforms = [
      new Transform3("", kIdentity, ""),
      new Transform3("", kIdentity, " "),
      new Transform3(" ", kIdentity, " "),
      new Transform3("", kOmitFirst1, ""),
      new Transform3("", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " the "),
      new Transform3(" ", kIdentity, ""),
      new Transform3("s ", kIdentity, " "),
      new Transform3("", kIdentity, " of "),
      new Transform3("", kUppercaseFirst, ""),
      new Transform3("", kIdentity, " and "),
      new Transform3("", kOmitFirst2, ""),
      new Transform3("", kOmitLast1, ""),
      new Transform3(", ", kIdentity, " "),
      new Transform3("", kIdentity, ", "),
      new Transform3(" ", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " in "),
      new Transform3("", kIdentity, " to "),
      new Transform3("e ", kIdentity, " "),
      new Transform3("", kIdentity, '"'),
      new Transform3("", kIdentity, "."),
      new Transform3("", kIdentity, '">'),
      new Transform3("", kIdentity, "\n"),
      new Transform3("", kOmitLast3, ""),
      new Transform3("", kIdentity, "]"),
      new Transform3("", kIdentity, " for "),
      new Transform3("", kOmitFirst3, ""),
      new Transform3("", kOmitLast2, ""),
      new Transform3("", kIdentity, " a "),
      new Transform3("", kIdentity, " that "),
      new Transform3(" ", kUppercaseFirst, ""),
      new Transform3("", kIdentity, ". "),
      new Transform3(".", kIdentity, ""),
      new Transform3(" ", kIdentity, ", "),
      new Transform3("", kOmitFirst4, ""),
      new Transform3("", kIdentity, " with "),
      new Transform3("", kIdentity, "'"),
      new Transform3("", kIdentity, " from "),
      new Transform3("", kIdentity, " by "),
      new Transform3("", kOmitFirst5, ""),
      new Transform3("", kOmitFirst6, ""),
      new Transform3(" the ", kIdentity, ""),
      new Transform3("", kOmitLast4, ""),
      new Transform3("", kIdentity, ". The "),
      new Transform3("", kUppercaseAll, ""),
      new Transform3("", kIdentity, " on "),
      new Transform3("", kIdentity, " as "),
      new Transform3("", kIdentity, " is "),
      new Transform3("", kOmitLast7, ""),
      new Transform3("", kOmitLast1, "ing "),
      new Transform3("", kIdentity, "\n	"),
      new Transform3("", kIdentity, ":"),
      new Transform3(" ", kIdentity, ". "),
      new Transform3("", kIdentity, "ed "),
      new Transform3("", kOmitFirst9, ""),
      new Transform3("", kOmitFirst7, ""),
      new Transform3("", kOmitLast6, ""),
      new Transform3("", kIdentity, "("),
      new Transform3("", kUppercaseFirst, ", "),
      new Transform3("", kOmitLast8, ""),
      new Transform3("", kIdentity, " at "),
      new Transform3("", kIdentity, "ly "),
      new Transform3(" the ", kIdentity, " of "),
      new Transform3("", kOmitLast5, ""),
      new Transform3("", kOmitLast9, ""),
      new Transform3(" ", kUppercaseFirst, ", "),
      new Transform3("", kUppercaseFirst, '"'),
      new Transform3(".", kIdentity, "("),
      new Transform3("", kUppercaseAll, " "),
      new Transform3("", kUppercaseFirst, '">'),
      new Transform3("", kIdentity, '="'),
      new Transform3(" ", kIdentity, "."),
      new Transform3(".com/", kIdentity, ""),
      new Transform3(" the ", kIdentity, " of the "),
      new Transform3("", kUppercaseFirst, "'"),
      new Transform3("", kIdentity, ". This "),
      new Transform3("", kIdentity, ","),
      new Transform3(".", kIdentity, " "),
      new Transform3("", kUppercaseFirst, "("),
      new Transform3("", kUppercaseFirst, "."),
      new Transform3("", kIdentity, " not "),
      new Transform3(" ", kIdentity, '="'),
      new Transform3("", kIdentity, "er "),
      new Transform3(" ", kUppercaseAll, " "),
      new Transform3("", kIdentity, "al "),
      new Transform3(" ", kUppercaseAll, ""),
      new Transform3("", kIdentity, "='"),
      new Transform3("", kUppercaseAll, '"'),
      new Transform3("", kUppercaseFirst, ". "),
      new Transform3(" ", kIdentity, "("),
      new Transform3("", kIdentity, "ful "),
      new Transform3(" ", kUppercaseFirst, ". "),
      new Transform3("", kIdentity, "ive "),
      new Transform3("", kIdentity, "less "),
      new Transform3("", kUppercaseAll, "'"),
      new Transform3("", kIdentity, "est "),
      new Transform3(" ", kUppercaseFirst, "."),
      new Transform3("", kUppercaseAll, '">'),
      new Transform3(" ", kIdentity, "='"),
      new Transform3("", kUppercaseFirst, ","),
      new Transform3("", kIdentity, "ize "),
      new Transform3("", kUppercaseAll, "."),
      new Transform3("", kIdentity, ""),
      new Transform3(" ", kIdentity, ","),
      new Transform3("", kUppercaseFirst, '="'),
      new Transform3("", kUppercaseAll, '="'),
      new Transform3("", kIdentity, "ous "),
      new Transform3("", kUppercaseAll, ", "),
      new Transform3("", kUppercaseFirst, "='"),
      new Transform3(" ", kUppercaseFirst, ","),
      new Transform3(" ", kUppercaseAll, '="'),
      new Transform3(" ", kUppercaseAll, ", "),
      new Transform3("", kUppercaseAll, ","),
      new Transform3("", kUppercaseAll, "("),
      new Transform3("", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseAll, "."),
      new Transform3("", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseFirst, '="'),
      new Transform3(" ", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseFirst, "='")
    ];
    exports.kTransforms = kTransforms;
    exports.kNumTransforms = kTransforms.length;
    function ToUpperCase(p3, i4) {
      if (p3[i4] < 192) {
        if (p3[i4] >= 97 && p3[i4] <= 122) {
          p3[i4] ^= 32;
        }
        return 1;
      }
      if (p3[i4] < 224) {
        p3[i4 + 1] ^= 32;
        return 2;
      }
      p3[i4 + 2] ^= 5;
      return 3;
    }
    exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
      var prefix = kTransforms[transform].prefix;
      var suffix = kTransforms[transform].suffix;
      var t4 = kTransforms[transform].transform;
      var skip = t4 < kOmitFirst1 ? 0 : t4 - (kOmitFirst1 - 1);
      var i4 = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len) {
        skip = len;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len -= skip;
      if (t4 <= kOmitLast9) {
        len -= t4;
      }
      for (i4 = 0; i4 < len; i4++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i4];
      }
      uppercase = idx - len;
      if (t4 === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t4 === kUppercaseAll) {
        while (len > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "node_modules/brotli/dec/decode.js"(exports) {
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context = require_context();
    var Prefix = require_prefix();
    var Transform3 = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n5;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n5 = br.readBits(3);
      if (n5 > 0) {
        return 17 + n5;
      }
      n5 = br.readBits(3);
      if (n5 > 0) {
        return 8 + n5;
      }
      return 17;
    }
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i4;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i4 = 0; i4 < size_bytes; i4++) {
          var next_byte = br.readBits(8);
          if (i4 + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i4 * 8;
        }
      } else {
        for (i4 = 0; i4 < size_nibbles; ++i4) {
          var next_nibble = br.readBits(4);
          if (i4 + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i4 * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    function ReadSymbol(table, index2, br) {
      var start_index = index2;
      var nbits;
      br.fillBitWindow();
      index2 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table[index2].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index2 += table[index2].value;
        index2 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table[index2].bits;
      return table[index2].value;
    }
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat2 = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table = [];
      for (var i4 = 0; i4 < 32; i4++)
        table.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p3 = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p3 += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table[p3].bits;
        code_len = table[p3].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat2 = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat2 = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat2;
          if (repeat2 > 0) {
            repeat2 -= 2;
            repeat2 <<= extra_bits;
          }
          repeat2 += br.readBits(extra_bits) + 3;
          repeat_delta = repeat2 - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x = 0; x < repeat_delta; x++)
            code_lengths[symbol + x] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    function ReadHuffmanCode(alphabet_size, tables, table, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i4;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i4 = 0; i4 < num_symbols; ++i4) {
          symbols[i4] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i4]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i4;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i4 = simple_code_or_skip; i4 < CODE_LENGTH_CODES && space > 0; ++i4) {
          var code_len_idx = kCodeLengthCodeOrder[i4];
          var p3 = 0;
          var v3;
          br.fillBitWindow();
          p3 += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p3].bits;
          v3 = huff[p3].value;
          code_length_code_lengths[code_len_idx] = v3;
          if (v3 !== 0) {
            space -= 32 >> v3;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    function ReadBlockLength(table, index2, br) {
      var code;
      var nbits;
      code = ReadSymbol(table, index2, br);
      nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
      return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
    }
    function TranslateShortCodes(code, ringbuffer, index2) {
      var val;
      if (code < NUM_DISTANCE_SHORT_CODES) {
        index2 += kDistanceShortCodeIndexOffset[code];
        index2 &= 3;
        val = ringbuffer[index2] + kDistanceShortCodeValueOffset[code];
      } else {
        val = code - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    function MoveToFront(v3, index2) {
      var value2 = v3[index2];
      var i4 = index2;
      for (; i4; --i4) v3[i4] = v3[i4 - 1];
      v3[0] = value2;
    }
    function InverseMoveToFrontTransform(v3, v_len) {
      var mtf = new Uint8Array(256);
      var i4;
      for (i4 = 0; i4 < 256; ++i4) {
        mtf[i4] = i4;
      }
      for (i4 = 0; i4 < v_len; ++i4) {
        var index2 = v3[i4];
        v3[i4] = mtf[index2];
        if (index2) MoveToFront(mtf, index2);
      }
    }
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i4;
      var table_size;
      var next = 0;
      for (i4 = 0; i4 < this.num_htrees; ++i4) {
        this.htrees[i4] = next;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
        next += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table;
      var i4;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table = [];
      for (i4 = 0; i4 < HUFFMAN_MAX_TABLE_SIZE; i4++) {
        table[i4] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
      for (i4 = 0; i4 < context_map_size; ) {
        var code;
        br.readMoreInput();
        code = ReadSymbol(table, 0, br);
        if (code === 0) {
          context_map[i4] = 0;
          ++i4;
        } else if (code <= max_run_length_prefix) {
          var reps = 1 + (1 << code) + br.readBits(code);
          while (--reps) {
            if (i4 >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i4] = 0;
            ++i4;
          }
        } else {
          context_map[i4] = code - max_run_length_prefix;
          ++i4;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index2 = tree_type;
      var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index2] & 1)] = block_type;
      ++indexes[index2];
    }
    function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
        while (len-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x = 0; x < tail; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        nbytes -= tail;
        rb_pos += tail;
        len -= tail;
        br_pos = 0;
      }
      for (var x = 0; x < nbytes; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      rb_pos += nbytes;
      len -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x = 0; x < rb_pos; x++)
          ringbuffer[x] = ringbuffer[rb_size + x];
      }
      while (rb_pos + len >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len) < len) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    function BrotliDecompressedSize(buffer) {
      var input = new BrotliInput(buffer);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    exports.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer, output_size) {
      var input = new BrotliInput(buffer);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    exports.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i4;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
        block_type_trees[x] = new HuffmanCode(0, 0);
        block_len_trees[x] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i4 = 0; i4 < 3; ++i4) {
          hgroup[i4].codes = null;
          hgroup[i4].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i4 = 0; i4 < 3; ++i4) {
          num_block_types[i4] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i4] >= 2) {
            ReadHuffmanCode(num_block_types[i4] + 2, block_type_trees, i4 * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i4 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i4] = ReadBlockLength(block_len_trees, i4 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i4] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i4 = 0; i4 < num_block_types[0]; ++i4) {
          br.readMoreInput();
          context_modes[i4] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i4 = 0; i4 < 3; ++i4) {
          hgroup[i4].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context.lookupOffsets[context_mode];
        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance;
          var context;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context.lookupOffsets[context_mode];
              context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
            }
            context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0) break;
          if (distance_code < 0) {
            var context;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset2;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset2 = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset2 + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset2 = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset2 += word_idx * copy_length;
              if (transform_idx < Transform3.kNumTransforms) {
                var len = Transform3.transformDictionaryWord(ringbuffer, copy_dst, offset2, copy_length, transform_idx);
                copy_dst += len;
                pos += len;
                meta_block_remaining_len -= len;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    exports.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "node_modules/brotli/decompress.js"(exports, module) {
    module.exports = require_decode().BrotliDecompressBuffer;
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream2() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream2;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p3 in source) {
          if (_has(source, p3)) {
            obj[p3] = source[p3];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i4, l2, len, pos, chunk, result;
        len = 0;
        for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
          len += chunks[i4].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
          chunk = chunks[i4];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on3) {
      if (on3) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var Z_FIXED2 = 4;
    var Z_BINARY2 = 0;
    var Z_TEXT2 = 1;
    var Z_UNKNOWN2 = 2;
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK2 = 0;
    var STATIC_TREES2 = 1;
    var DYN_TREES2 = 2;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var Buf_size2 = 16;
    var MAX_BL_BITS2 = 7;
    var END_BLOCK2 = 256;
    var REP_3_62 = 16;
    var REPZ_3_102 = 17;
    var REPZ_11_1382 = 18;
    var extra_lbits2 = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits2 = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits2 = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN2 = 512;
    var static_ltree2 = new Array((L_CODES2 + 2) * 2);
    zero2(static_ltree2);
    var static_dtree2 = new Array(D_CODES2 * 2);
    zero2(static_dtree2);
    var _dist_code2 = new Array(DIST_CODE_LEN2);
    zero2(_dist_code2);
    var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
    zero2(_length_code2);
    var base_length2 = new Array(LENGTH_CODES2);
    zero2(base_length2);
    var base_dist2 = new Array(D_CODES2);
    zero2(base_dist2);
    function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc2;
    var static_d_desc2;
    var static_bl_desc2;
    function TreeDesc2(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code2(dist) {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    }
    function put_short2(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits2(s2, value2, length2) {
      if (s2.bi_valid > Buf_size2 - length2) {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = value2 >> Buf_size2 - s2.bi_valid;
        s2.bi_valid += length2 - Buf_size2;
      } else {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        s2.bi_valid += length2;
      }
    }
    function send_code2(s2, c4, tree) {
      send_bits2(
        s2,
        tree[c4 * 2],
        tree[c4 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse2(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush2(s2) {
      if (s2.bi_valid === 16) {
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen2(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h3;
      var n5, m;
      var bits;
      var xbits;
      var f3;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h3 = s2.heap_max + 1; h3 < HEAP_SIZE2; h3++) {
        n5 = s2.heap[h3];
        bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n5 * 2 + 1] = bits;
        if (n5 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n5 >= base) {
          xbits = extra[n5 - base];
        }
        f3 = tree[n5 * 2];
        s2.opt_len += f3 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f3 * (stree[n5 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n5 = s2.bl_count[bits];
        while (n5 !== 0) {
          m = s2.heap[--h3];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n5--;
        }
      }
    }
    function gen_codes2(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS2 + 1);
      var code = 0;
      var bits;
      var n5;
      for (bits = 1; bits <= MAX_BITS2; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        var len = tree[n5 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n5 * 2] = bi_reverse2(next_code[len]++, len);
      }
    }
    function tr_static_init2() {
      var n5;
      var bits;
      var length2;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS2 + 1);
      length2 = 0;
      for (code = 0; code < LENGTH_CODES2 - 1; code++) {
        base_length2[code] = length2;
        for (n5 = 0; n5 < 1 << extra_lbits2[code]; n5++) {
          _length_code2[length2++] = code;
        }
      }
      _length_code2[length2 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist2[code] = dist;
        for (n5 = 0; n5 < 1 << extra_dbits2[code]; n5++) {
          _dist_code2[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES2; code++) {
        base_dist2[code] = dist << 7;
        for (n5 = 0; n5 < 1 << extra_dbits2[code] - 7; n5++) {
          _dist_code2[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        bl_count[bits] = 0;
      }
      n5 = 0;
      while (n5 <= 143) {
        static_ltree2[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      while (n5 <= 255) {
        static_ltree2[n5 * 2 + 1] = 9;
        n5++;
        bl_count[9]++;
      }
      while (n5 <= 279) {
        static_ltree2[n5 * 2 + 1] = 7;
        n5++;
        bl_count[7]++;
      }
      while (n5 <= 287) {
        static_ltree2[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
      for (n5 = 0; n5 < D_CODES2; n5++) {
        static_dtree2[n5 * 2 + 1] = 5;
        static_dtree2[n5 * 2] = bi_reverse2(n5, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
    }
    function init_block2(s2) {
      var n5;
      for (n5 = 0; n5 < L_CODES2; n5++) {
        s2.dyn_ltree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < D_CODES2; n5++) {
        s2.dyn_dtree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < BL_CODES2; n5++) {
        s2.bl_tree[n5 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK2 * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup2(s2) {
      if (s2.bi_valid > 8) {
        put_short2(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block2(s2, buf, len, header) {
      bi_windup2(s2);
      if (header) {
        put_short2(s2, len);
        put_short2(s2, ~len);
      }
      utils2.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller2(tree, n5, m, depth) {
      var _n2 = n5 * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m];
    }
    function pqdownheap2(s2, tree, k3) {
      var v3 = s2.heap[k3];
      var j = k3 << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller2(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller2(tree, v3, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k3] = s2.heap[j];
        k3 = j;
        j <<= 1;
      }
      s2.heap[k3] = v3;
    }
    function compress_block2(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code2(s2, lc, ltree);
          } else {
            code = _length_code2[lc];
            send_code2(s2, code + LITERALS2 + 1, ltree);
            extra = extra_lbits2[code];
            if (extra !== 0) {
              lc -= base_length2[code];
              send_bits2(s2, lc, extra);
            }
            dist--;
            code = d_code2(dist);
            send_code2(s2, code, dtree);
            extra = extra_dbits2[code];
            if (extra !== 0) {
              dist -= base_dist2[code];
              send_bits2(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code2(s2, END_BLOCK2, ltree);
    }
    function build_tree2(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n5, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE2;
      for (n5 = 0; n5 < elems; n5++) {
        if (tree[n5 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n5;
          s2.depth[n5] = 0;
        } else {
          tree[n5 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n5 = s2.heap_len >> 1; n5 >= 1; n5--) {
        pqdownheap2(s2, tree, n5);
      }
      node = elems;
      do {
        n5 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n5;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n5 * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n5] >= s2.depth[m] ? s2.depth[n5] : s2.depth[m]) + 1;
        tree[n5 * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s2, desc);
      gen_codes2(tree, max_code, s2.bl_count);
    }
    function scan_tree2(s2, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_62 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_102 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_1382 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree2(s2, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code2(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code2(s2, REP_3_62, s2.bl_tree);
          send_bits2(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code2(s2, REPZ_3_102, s2.bl_tree);
          send_bits2(s2, count - 3, 3);
        } else {
          send_code2(s2, REPZ_11_1382, s2.bl_tree);
          send_bits2(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree2(s2) {
      var max_blindex;
      scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree2(s2, s2.bl_desc);
      for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees2(s2, lcodes, dcodes, blcodes) {
      var rank2;
      send_bits2(s2, lcodes - 257, 5);
      send_bits2(s2, dcodes - 1, 5);
      send_bits2(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
      }
      send_tree2(s2, s2.dyn_ltree, lcodes - 1);
      send_tree2(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type2(s2) {
      var black_mask = 4093624447;
      var n5;
      for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n5 * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n5 = 32; n5 < LITERALS2; n5++) {
        if (s2.dyn_ltree[n5 * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    }
    var static_init_done2 = false;
    function _tr_init2(s2) {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
      s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
      s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block2(s2);
    }
    function _tr_stored_block2(s2, buf, stored_len, last2) {
      send_bits2(s2, (STORED_BLOCK2 << 1) + (last2 ? 1 : 0), 3);
      copy_block2(s2, buf, stored_len, true);
    }
    function _tr_align2(s2) {
      send_bits2(s2, STATIC_TREES2 << 1, 3);
      send_code2(s2, END_BLOCK2, static_ltree2);
      bi_flush2(s2);
    }
    function _tr_flush_block2(s2, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN2) {
          s2.strm.data_type = detect_data_type2(s2);
        }
        build_tree2(s2, s2.l_desc);
        build_tree2(s2, s2.d_desc);
        max_blindex = build_bl_tree2(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block2(s2, buf, stored_len, last2);
      } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
        send_bits2(s2, (STATIC_TREES2 << 1) + (last2 ? 1 : 0), 3);
        compress_block2(s2, static_ltree2, static_dtree2);
      } else {
        send_bits2(s2, (DYN_TREES2 << 1) + (last2 ? 1 : 0), 3);
        send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block2(s2);
      if (last2) {
        bi_windup2(s2);
      }
    }
    function _tr_tally2(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
        s2.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init2;
    exports._tr_stored_block = _tr_stored_block2;
    exports._tr_flush_block = _tr_flush_block2;
    exports._tr_tally = _tr_tally2;
    exports._tr_align = _tr_align2;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler322(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n5 = 0;
      while (len !== 0) {
        n5 = len > 2e3 ? 2e3 : len;
        len -= n5;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n5);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler322;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable2() {
      var c4, table = [];
      for (var n5 = 0; n5 < 256; n5++) {
        c4 = n5;
        for (var k3 = 0; k3 < 8; k3++) {
          c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
        }
        table[n5] = c4;
      }
      return table;
    }
    var crcTable2 = makeTable2();
    function crc322(crc, buf, len, pos) {
      var t4 = crcTable2, end2 = pos + len;
      crc ^= -1;
      for (var i4 = pos; i4 < end2; i4++) {
        crc = crc >>> 8 ^ t4[(crc ^ buf[i4]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc322;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var trees2 = require_trees();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var msg2 = require_messages();
    var Z_NO_FLUSH2 = 0;
    var Z_PARTIAL_FLUSH2 = 1;
    var Z_FULL_FLUSH2 = 3;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFAULT_COMPRESSION2 = -1;
    var Z_FILTERED2 = 1;
    var Z_HUFFMAN_ONLY2 = 2;
    var Z_RLE2 = 3;
    var Z_FIXED2 = 4;
    var Z_DEFAULT_STRATEGY2 = 0;
    var Z_UNKNOWN2 = 2;
    var Z_DEFLATED2 = 8;
    var MAX_MEM_LEVEL2 = 9;
    var MAX_WBITS2 = 15;
    var DEF_MEM_LEVEL2 = 8;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    var PRESET_DICT2 = 32;
    var INIT_STATE2 = 42;
    var EXTRA_STATE2 = 69;
    var NAME_STATE2 = 73;
    var COMMENT_STATE2 = 91;
    var HCRC_STATE2 = 103;
    var BUSY_STATE2 = 113;
    var FINISH_STATE2 = 666;
    var BS_NEED_MORE2 = 1;
    var BS_BLOCK_DONE2 = 2;
    var BS_FINISH_STARTED2 = 3;
    var BS_FINISH_DONE2 = 4;
    var OS_CODE2 = 3;
    function err2(strm, errorCode) {
      strm.msg = msg2[errorCode];
      return errorCode;
    }
    function rank2(f3) {
      return (f3 << 1) - (f3 > 4 ? 9 : 0);
    }
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending2(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only2(s2, last2) {
      trees2._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
      s2.block_start = s2.strstart;
      flush_pending2(s2.strm);
    }
    function put_byte2(s2, b3) {
      s2.pending_buf[s2.pending++] = b3;
    }
    function putShortMSB2(s2, b3) {
      s2.pending_buf[s2.pending++] = b3 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b3 & 255;
    }
    function read_buf2(strm, buf, start2, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start2);
      if (strm.state.wrap === 1) {
        strm.adler = adler322(strm.adler, buf, len, start2);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start2);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match2(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH2;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH2 - (strend - scan);
        scan = strend - MAX_MATCH2;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window2(s2) {
      var _w_size = s2.w_size;
      var p3, n5, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
          utils2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n5 = s2.hash_size;
          p3 = n5;
          do {
            m = s2.head[--p3];
            s2.head[p3] = m >= _w_size ? m - _w_size : 0;
          } while (--n5);
          n5 = _w_size;
          p3 = n5;
          do {
            m = s2.prev[--p3];
            s2.prev[p3] = m >= _w_size ? m - _w_size : 0;
          } while (--n5);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n5 = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n5;
        if (s2.lookahead + s2.insert >= MIN_MATCH2) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH2) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
    }
    function deflate_stored2(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window2(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD2) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_NEED_MORE2;
    }
    function deflate_fast2(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_slow2(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH2 - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH2 - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
          bflush = trees2._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH2 - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s2.match_available) {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only2(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_rle2(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH2) {
          fill_window2(s2);
          if (s2.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH2;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH2 - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, 1, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_huff2(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window2(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH2) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table2;
    configuration_table2 = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    function lm_init2(s2) {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
      s2.good_match = configuration_table2[s2.level].good_length;
      s2.nice_match = configuration_table2[s2.level].nice_length;
      s2.max_chain_length = configuration_table2[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState2() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE2 * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES2 + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES2 + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS2 + 1);
      this.heap = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep2(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE2 : BUSY_STATE2;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH2;
      trees2._tr_init(s2);
      return Z_OK2;
    }
    function deflateReset2(strm) {
      var ret = deflateResetKeep2(strm);
      if (ret === Z_OK2) {
        lm_init2(strm.state);
      }
      return ret;
    }
    function deflateSetHeader2(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR2;
      }
      strm.state.gzhead = head;
      return Z_OK2;
    }
    function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION2) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState2();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
      s2.window = new utils2.Buf8(s2.w_size * 2);
      s2.head = new utils2.Buf16(s2.hash_size);
      s2.prev = new utils2.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils2.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset2(strm);
    }
    function deflateInit3(strm, level) {
      return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
    }
    function deflate2(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE2 && flush !== Z_FINISH2) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE2) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte2(s2, 31);
          put_byte2(s2, 139);
          put_byte2(s2, 8);
          if (!s2.gzhead) {
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, OS_CODE2);
            s2.status = BUSY_STATE2;
          } else {
            put_byte2(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte2(s2, s2.gzhead.time & 255);
            put_byte2(s2, s2.gzhead.time >> 8 & 255);
            put_byte2(s2, s2.gzhead.time >> 16 & 255);
            put_byte2(s2, s2.gzhead.time >> 24 & 255);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte2(s2, s2.gzhead.extra.length & 255);
              put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE2;
          }
        } else {
          var header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT2;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE2;
          putShortMSB2(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB2(s2, strm.adler >>> 16);
            putShortMSB2(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE2) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE2;
          }
        } else {
          s2.status = NAME_STATE2;
        }
      }
      if (s2.status === NAME_STATE2) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE2;
          }
        } else {
          s2.status = COMMENT_STATE2;
        }
      }
      if (s2.status === COMMENT_STATE2) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE2;
          }
        } else {
          s2.status = HCRC_STATE2;
        }
      }
      if (s2.status === HCRC_STATE2) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending2(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte2(s2, strm.adler & 255);
            put_byte2(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE2;
          }
        } else {
          s2.status = BUSY_STATE2;
        }
      }
      if (s2.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE2) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s2.status = FINISH_STATE2;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK2;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH2) {
            trees2._tr_align(s2);
          } else if (flush !== Z_BLOCK2) {
            trees2._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH2) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK2;
          }
        }
      }
      if (flush !== Z_FINISH2) {
        return Z_OK2;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END2;
      }
      if (s2.wrap === 2) {
        put_byte2(s2, strm.adler & 255);
        put_byte2(s2, strm.adler >> 8 & 255);
        put_byte2(s2, strm.adler >> 16 & 255);
        put_byte2(s2, strm.adler >> 24 & 255);
        put_byte2(s2, strm.total_in & 255);
        put_byte2(s2, strm.total_in >> 8 & 255);
        put_byte2(s2, strm.total_in >> 16 & 255);
        put_byte2(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s2, strm.adler >>> 16);
        putShortMSB2(s2, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
    }
    function deflateEnd2(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      status = strm.state.status;
      if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.state = null;
      return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
    }
    function deflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n5;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
        return Z_STREAM_ERROR2;
      }
      if (wrap === 1) {
        strm.adler = adler322(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils2.Buf8(s2.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s2);
      while (s2.lookahead >= MIN_MATCH2) {
        str = s2.strstart;
        n5 = s2.lookahead - (MIN_MATCH2 - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n5);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH2 - 1;
        fill_window2(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK2;
    }
    exports.deflateInit = deflateInit3;
    exports.deflateInit2 = deflateInit22;
    exports.deflateReset = deflateReset2;
    exports.deflateResetKeep = deflateResetKeep2;
    exports.deflateSetHeader = deflateSetHeader2;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd2;
    exports.deflateSetDictionary = deflateSetDictionary2;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD2 = 30;
    var TYPE2 = 12;
    module.exports = function inflate_fast3(strm, start2) {
      var state2;
      var _in;
      var last2;
      var _out;
      var beg;
      var end2;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from4;
      var from_source;
      var input, output;
      state2 = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start2 - strm.avail_out);
      end2 = _out + (strm.avail_out - 257);
      dmax = state2.dmax;
      wsize = state2.wsize;
      whave = state2.whave;
      wnext = state2.wnext;
      s_window = state2.window;
      hold = state2.hold;
      bits = state2.bits;
      lcode = state2.lencode;
      dcode = state2.distcode;
      lmask = (1 << state2.lenbits) - 1;
      dmask = (1 << state2.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD2;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state2.sane) {
                            strm.msg = "invalid distance too far back";
                            state2.mode = BAD2;
                            break top;
                          }
                        }
                        from4 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from4 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from4 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from4++];
                              } while (--op);
                              from4 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from4 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from4++];
                          if (len > 1) {
                            output[_out++] = from_source[from4++];
                          }
                        }
                      } else {
                        from4 = _out - dist;
                        do {
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from4++];
                          if (len > 1) {
                            output[_out++] = output[from4++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state2.mode = BAD2;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state2.mode = TYPE2;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end2);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
      state2.hold = hold;
      state2.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils2 = require_common();
    var MAXBITS2 = 15;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var lbase2 = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext2 = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase2 = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext2 = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table3(type, lens, lens_index, codes2, table, table_index, work, opts2) {
      var bits = opts2.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill4;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end2;
      var count = new utils2.Buf16(MAXBITS2 + 1);
      var offs = new utils2.Buf16(MAXBITS2 + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS2; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts2.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES2 || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES2) {
        base = extra = work;
        end2 = 19;
      } else if (type === LENS2) {
        base = lbase2;
        base_index -= 257;
        extra = lext2;
        extra_index -= 257;
        end2 = 256;
      } else {
        base = dbase2;
        extra = dext2;
        end2 = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end2) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill4 = 1 << curr;
        min2 = fill4;
        do {
          fill4 -= incr;
          table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill4 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts2.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var inflate_fast3 = require_inffast();
    var inflate_table3 = require_inftrees();
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_TREES2 = 6;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_NEED_DICT2 = 2;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_MEM_ERROR2 = -4;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFLATED2 = 8;
    var HEAD2 = 1;
    var FLAGS2 = 2;
    var TIME2 = 3;
    var OS2 = 4;
    var EXLEN2 = 5;
    var EXTRA2 = 6;
    var NAME2 = 7;
    var COMMENT2 = 8;
    var HCRC2 = 9;
    var DICTID2 = 10;
    var DICT2 = 11;
    var TYPE2 = 12;
    var TYPEDO2 = 13;
    var STORED2 = 14;
    var COPY_2 = 15;
    var COPY2 = 16;
    var TABLE2 = 17;
    var LENLENS2 = 18;
    var CODELENS2 = 19;
    var LEN_2 = 20;
    var LEN2 = 21;
    var LENEXT2 = 22;
    var DIST2 = 23;
    var DISTEXT2 = 24;
    var MATCH2 = 25;
    var LIT2 = 26;
    var CHECK2 = 27;
    var LENGTH2 = 28;
    var DONE2 = 29;
    var BAD2 = 30;
    var MEM2 = 31;
    var SYNC2 = 32;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var MAX_WBITS2 = 15;
    var DEF_WBITS2 = MAX_WBITS2;
    function zswap322(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState2() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep2(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      strm.total_in = strm.total_out = state2.total = 0;
      strm.msg = "";
      if (state2.wrap) {
        strm.adler = state2.wrap & 1;
      }
      state2.mode = HEAD2;
      state2.last = 0;
      state2.havedict = 0;
      state2.dmax = 32768;
      state2.head = null;
      state2.hold = 0;
      state2.bits = 0;
      state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS2);
      state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS2);
      state2.sane = 1;
      state2.back = -1;
      return Z_OK2;
    }
    function inflateReset3(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      state2.wsize = 0;
      state2.whave = 0;
      state2.wnext = 0;
      return inflateResetKeep2(strm);
    }
    function inflateReset22(strm, windowBits) {
      var wrap;
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR2;
      }
      if (state2.window !== null && state2.wbits !== windowBits) {
        state2.window = null;
      }
      state2.wrap = wrap;
      state2.wbits = windowBits;
      return inflateReset3(strm);
    }
    function inflateInit22(strm, windowBits) {
      var ret;
      var state2;
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      state2 = new InflateState2();
      strm.state = state2;
      state2.window = null;
      ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK2) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit3(strm) {
      return inflateInit22(strm, DEF_WBITS2);
    }
    var virgin2 = true;
    var lenfix2;
    var distfix2;
    function fixedtables2(state2) {
      if (virgin2) {
        var sym;
        lenfix2 = new utils2.Buf32(512);
        distfix2 = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state2.lens[sym++] = 8;
        }
        while (sym < 256) {
          state2.lens[sym++] = 9;
        }
        while (sym < 280) {
          state2.lens[sym++] = 7;
        }
        while (sym < 288) {
          state2.lens[sym++] = 8;
        }
        inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state2.lens[sym++] = 5;
        }
        inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
        virgin2 = false;
      }
      state2.lencode = lenfix2;
      state2.lenbits = 9;
      state2.distcode = distfix2;
      state2.distbits = 5;
    }
    function updatewindow2(strm, src, end2, copy5) {
      var dist;
      var state2 = strm.state;
      if (state2.window === null) {
        state2.wsize = 1 << state2.wbits;
        state2.wnext = 0;
        state2.whave = 0;
        state2.window = new utils2.Buf8(state2.wsize);
      }
      if (copy5 >= state2.wsize) {
        utils2.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
        state2.wnext = 0;
        state2.whave = state2.wsize;
      } else {
        dist = state2.wsize - state2.wnext;
        if (dist > copy5) {
          dist = copy5;
        }
        utils2.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
        copy5 -= dist;
        if (copy5) {
          utils2.arraySet(state2.window, src, end2 - copy5, copy5, 0);
          state2.wnext = copy5;
          state2.whave = state2.wsize;
        } else {
          state2.wnext += dist;
          if (state2.wnext === state2.wsize) {
            state2.wnext = 0;
          }
          if (state2.whave < state2.wsize) {
            state2.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state2;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy5;
      var from4;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts2;
      var n5;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.mode === TYPE2) {
        state2.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state2.hold;
      bits = state2.bits;
      _in = have;
      _out = left;
      ret = Z_OK2;
      inf_leave:
        for (; ; ) {
          switch (state2.mode) {
            case HEAD2:
              if (state2.wrap === 0) {
                state2.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 2 && hold === 35615) {
                state2.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state2.mode = FLAGS2;
                break;
              }
              state2.flags = 0;
              if (state2.head) {
                state2.head.done = false;
              }
              if (!(state2.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state2.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state2.wbits === 0) {
                state2.wbits = len;
              } else if (len > state2.wbits) {
                strm.msg = "invalid window size";
                state2.mode = BAD2;
                break;
              }
              state2.dmax = 1 << len;
              strm.adler = state2.check = 1;
              state2.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.flags = hold;
              if ((state2.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              if (state2.flags & 57344) {
                strm.msg = "unknown header flags set";
                state2.mode = BAD2;
                break;
              }
              if (state2.head) {
                state2.head.text = hold >> 8 & 1;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = TIME2;
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.time = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state2.check = crc322(state2.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = OS2;
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.xflags = hold & 255;
                state2.head.os = hold >> 8;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = EXLEN2;
            case EXLEN2:
              if (state2.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length = hold;
                if (state2.head) {
                  state2.head.extra_len = hold;
                }
                if (state2.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state2.check = crc322(state2.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state2.head) {
                state2.head.extra = null;
              }
              state2.mode = EXTRA2;
            case EXTRA2:
              if (state2.flags & 1024) {
                copy5 = state2.length;
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5) {
                  if (state2.head) {
                    len = state2.head.extra_len - state2.length;
                    if (!state2.head.extra) {
                      state2.head.extra = new Array(state2.head.extra_len);
                    }
                    utils2.arraySet(
                      state2.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy5,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state2.flags & 512) {
                    state2.check = crc322(state2.check, input, copy5, next);
                  }
                  have -= copy5;
                  next += copy5;
                  state2.length -= copy5;
                }
                if (state2.length) {
                  break inf_leave;
                }
              }
              state2.length = 0;
              state2.mode = NAME2;
            case NAME2:
              if (state2.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.name += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.name = null;
              }
              state2.length = 0;
              state2.mode = COMMENT2;
            case COMMENT2:
              if (state2.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy5 = 0;
                do {
                  len = input[next + copy5++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy5 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.comment = null;
              }
              state2.mode = HCRC2;
            case HCRC2:
              if (state2.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state2.head) {
                state2.head.hcrc = state2.flags >> 9 & 1;
                state2.head.done = true;
              }
              strm.adler = state2.check = 0;
              state2.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state2.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state2.mode = DICT2;
            case DICT2:
              if (state2.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state2.check = 1;
              state2.mode = TYPE2;
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            case TYPEDO2:
              if (state2.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state2.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state2.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state2);
                  state2.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state2.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state2.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state2.mode = BAD2;
                break;
              }
              state2.length = hold & 65535;
              hold = 0;
              bits = 0;
              state2.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case COPY_2:
              state2.mode = COPY2;
            case COPY2:
              copy5 = state2.length;
              if (copy5) {
                if (copy5 > have) {
                  copy5 = have;
                }
                if (copy5 > left) {
                  copy5 = left;
                }
                if (copy5 === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next, copy5, put);
                have -= copy5;
                next += copy5;
                left -= copy5;
                put += copy5;
                state2.length -= copy5;
                break;
              }
              state2.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state2.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state2.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state2.nlen > 286 || state2.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = LENLENS2;
            case LENLENS2:
              while (state2.have < state2.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.lens[order[state2.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state2.have < 19) {
                state2.lens[order[state2.have++]] = 0;
              }
              state2.lencode = state2.lendyn;
              state2.lenbits = 7;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = CODELENS2;
            case CODELENS2:
              while (state2.have < state2.nlen + state2.ndist) {
                for (; ; ) {
                  here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state2.lens[state2.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n5 = here_bits + 2;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state2.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state2.mode = BAD2;
                      break;
                    }
                    len = state2.lens[state2.have - 1];
                    copy5 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n5 = here_bits + 3;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n5 = here_bits + 7;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy5 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state2.have + copy5 > state2.nlen + state2.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  while (copy5--) {
                    state2.lens[state2.have++] = len;
                  }
                }
              }
              if (state2.mode === BAD2) {
                break;
              }
              if (state2.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state2.mode = BAD2;
                break;
              }
              state2.lenbits = 9;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.distbits = 6;
              state2.distcode = state2.distdyn;
              opts2 = { bits: state2.distbits };
              ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
              state2.distbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state2.mode = BAD2;
                break;
              }
              state2.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case LEN_2:
              state2.mode = LEN2;
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                inflate_fast3(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state2.hold;
                bits = state2.bits;
                if (state2.mode === TYPE2) {
                  state2.back = -1;
                }
                break;
              }
              state2.back = 0;
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              state2.length = here_val;
              if (here_op === 0) {
                state2.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state2.back = -1;
                state2.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break;
              }
              state2.extra = here_op & 15;
              state2.mode = LENEXT2;
            case LENEXT2:
              if (state2.extra) {
                n5 = state2.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              state2.was = state2.length;
              state2.mode = DIST2;
            case DIST2:
              for (; ; ) {
                here = state2.distcode[hold & (1 << state2.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state2.mode = BAD2;
                break;
              }
              state2.offset = here_val;
              state2.extra = here_op & 15;
              state2.mode = DISTEXT2;
            case DISTEXT2:
              if (state2.extra) {
                n5 = state2.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.offset += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              if (state2.offset > state2.dmax) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD2;
                break;
              }
              state2.mode = MATCH2;
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy5 = _out - left;
              if (state2.offset > copy5) {
                copy5 = state2.offset - copy5;
                if (copy5 > state2.whave) {
                  if (state2.sane) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD2;
                    break;
                  }
                }
                if (copy5 > state2.wnext) {
                  copy5 -= state2.wnext;
                  from4 = state2.wsize - copy5;
                } else {
                  from4 = state2.wnext - copy5;
                }
                if (copy5 > state2.length) {
                  copy5 = state2.length;
                }
                from_source = state2.window;
              } else {
                from_source = output;
                from4 = put - state2.offset;
                copy5 = state2.length;
              }
              if (copy5 > left) {
                copy5 = left;
              }
              left -= copy5;
              state2.length -= copy5;
              do {
                output[put++] = from_source[from4++];
              } while (--copy5);
              if (state2.length === 0) {
                state2.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state2.length;
              left--;
              state2.mode = LEN2;
              break;
            case CHECK2:
              if (state2.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state2.total += _out;
                if (_out) {
                  strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                  state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
                }
                _out = left;
                if ((state2.flags ? hold : zswap322(hold)) !== state2.check) {
                  strm.msg = "incorrect data check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = LENGTH2;
            case LENGTH2:
              if (state2.wrap && state2.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = DONE2;
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            default:
              return Z_STREAM_ERROR2;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state2.hold = hold;
      state2.bits = bits;
      if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state2.mode = MEM2;
          return Z_MEM_ERROR2;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state2.total += _out;
      if (state2.wrap && _out) {
        strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
        ret = Z_BUF_ERROR2;
      }
      return ret;
    }
    function inflateEnd2(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      var state2 = strm.state;
      if (state2.window) {
        state2.window = null;
      }
      strm.state = null;
      return Z_OK2;
    }
    function inflateGetHeader2(strm, head) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if ((state2.wrap & 2) === 0) {
        return Z_STREAM_ERROR2;
      }
      state2.head = head;
      head.done = false;
      return Z_OK2;
    }
    function inflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var state2;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.wrap !== 0 && state2.mode !== DICT2) {
        return Z_STREAM_ERROR2;
      }
      if (state2.mode === DICT2) {
        dictid = 1;
        dictid = adler322(dictid, dictionary, dictLength, 0);
        if (dictid !== state2.check) {
          return Z_DATA_ERROR2;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state2.mode = MEM2;
        return Z_MEM_ERROR2;
      }
      state2.havedict = 1;
      return Z_OK2;
    }
    exports.inflateReset = inflateReset3;
    exports.inflateReset2 = inflateReset22;
    exports.inflateResetKeep = inflateResetKeep2;
    exports.inflateInit = inflateInit3;
    exports.inflateInit2 = inflateInit22;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd2;
    exports.inflateGetHeader = inflateGetHeader2;
    exports.inflateSetDictionary = inflateSetDictionary2;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i4 = 0; i4 < thatSigBytes; i4++) {
                var thatByte = thatWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                thisWords[thisSigBytes + i4 >>> 2] |= thatByte << 24 - (thisSigBytes + i4) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i4 = 0; i4 < nBytes; i4 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i4 = 0; i4 < sigBytes; i4++) {
              var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i4 = 0; i4 < hexStrLength; i4 += 2) {
              words[i4 >>> 3] |= parseInt(hexStr.substr(i4, 2), 16) << 24 - i4 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4++) {
              var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i4 = 0; i4 < latin1StrLength; i4++) {
              words[i4 >>> 2] |= (latin1Str.charCodeAt(i4) & 255) << 24 - i4 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e4) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i4 = 0; i4 < 64; i4++) {
            T[i4] = Math2.abs(Math2.sin(i4 + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i4 = 0; i4 < 16; i4++) {
              var offset_i = offset2 + i4;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset2 + 0];
            var M_offset_1 = M[offset2 + 1];
            var M_offset_2 = M[offset2 + 2];
            var M_offset_3 = M[offset2 + 3];
            var M_offset_4 = M[offset2 + 4];
            var M_offset_5 = M[offset2 + 5];
            var M_offset_6 = M[offset2 + 6];
            var M_offset_7 = M[offset2 + 7];
            var M_offset_8 = M[offset2 + 8];
            var M_offset_9 = M[offset2 + 9];
            var M_offset_10 = M[offset2 + 10];
            var M_offset_11 = M[offset2 + 11];
            var M_offset_12 = M[offset2 + 12];
            var M_offset_13 = M[offset2 + 13];
            var M_offset_14 = M[offset2 + 14];
            var M_offset_15 = M[offset2 + 15];
            var a4 = H[0];
            var b3 = H[1];
            var c4 = H[2];
            var d2 = H[3];
            a4 = FF(a4, b3, c4, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a4, b3, c4, M_offset_1, 12, T[1]);
            c4 = FF(c4, d2, a4, b3, M_offset_2, 17, T[2]);
            b3 = FF(b3, c4, d2, a4, M_offset_3, 22, T[3]);
            a4 = FF(a4, b3, c4, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a4, b3, c4, M_offset_5, 12, T[5]);
            c4 = FF(c4, d2, a4, b3, M_offset_6, 17, T[6]);
            b3 = FF(b3, c4, d2, a4, M_offset_7, 22, T[7]);
            a4 = FF(a4, b3, c4, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a4, b3, c4, M_offset_9, 12, T[9]);
            c4 = FF(c4, d2, a4, b3, M_offset_10, 17, T[10]);
            b3 = FF(b3, c4, d2, a4, M_offset_11, 22, T[11]);
            a4 = FF(a4, b3, c4, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a4, b3, c4, M_offset_13, 12, T[13]);
            c4 = FF(c4, d2, a4, b3, M_offset_14, 17, T[14]);
            b3 = FF(b3, c4, d2, a4, M_offset_15, 22, T[15]);
            a4 = GG(a4, b3, c4, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a4, b3, c4, M_offset_6, 9, T[17]);
            c4 = GG(c4, d2, a4, b3, M_offset_11, 14, T[18]);
            b3 = GG(b3, c4, d2, a4, M_offset_0, 20, T[19]);
            a4 = GG(a4, b3, c4, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a4, b3, c4, M_offset_10, 9, T[21]);
            c4 = GG(c4, d2, a4, b3, M_offset_15, 14, T[22]);
            b3 = GG(b3, c4, d2, a4, M_offset_4, 20, T[23]);
            a4 = GG(a4, b3, c4, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a4, b3, c4, M_offset_14, 9, T[25]);
            c4 = GG(c4, d2, a4, b3, M_offset_3, 14, T[26]);
            b3 = GG(b3, c4, d2, a4, M_offset_8, 20, T[27]);
            a4 = GG(a4, b3, c4, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a4, b3, c4, M_offset_2, 9, T[29]);
            c4 = GG(c4, d2, a4, b3, M_offset_7, 14, T[30]);
            b3 = GG(b3, c4, d2, a4, M_offset_12, 20, T[31]);
            a4 = HH(a4, b3, c4, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a4, b3, c4, M_offset_8, 11, T[33]);
            c4 = HH(c4, d2, a4, b3, M_offset_11, 16, T[34]);
            b3 = HH(b3, c4, d2, a4, M_offset_14, 23, T[35]);
            a4 = HH(a4, b3, c4, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a4, b3, c4, M_offset_4, 11, T[37]);
            c4 = HH(c4, d2, a4, b3, M_offset_7, 16, T[38]);
            b3 = HH(b3, c4, d2, a4, M_offset_10, 23, T[39]);
            a4 = HH(a4, b3, c4, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a4, b3, c4, M_offset_0, 11, T[41]);
            c4 = HH(c4, d2, a4, b3, M_offset_3, 16, T[42]);
            b3 = HH(b3, c4, d2, a4, M_offset_6, 23, T[43]);
            a4 = HH(a4, b3, c4, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a4, b3, c4, M_offset_12, 11, T[45]);
            c4 = HH(c4, d2, a4, b3, M_offset_15, 16, T[46]);
            b3 = HH(b3, c4, d2, a4, M_offset_2, 23, T[47]);
            a4 = II(a4, b3, c4, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a4, b3, c4, M_offset_7, 10, T[49]);
            c4 = II(c4, d2, a4, b3, M_offset_14, 15, T[50]);
            b3 = II(b3, c4, d2, a4, M_offset_5, 21, T[51]);
            a4 = II(a4, b3, c4, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a4, b3, c4, M_offset_3, 10, T[53]);
            c4 = II(c4, d2, a4, b3, M_offset_10, 15, T[54]);
            b3 = II(b3, c4, d2, a4, M_offset_1, 21, T[55]);
            a4 = II(a4, b3, c4, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a4, b3, c4, M_offset_15, 10, T[57]);
            c4 = II(c4, d2, a4, b3, M_offset_6, 15, T[58]);
            b3 = II(b3, c4, d2, a4, M_offset_13, 21, T[59]);
            a4 = II(a4, b3, c4, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a4, b3, c4, M_offset_11, 10, T[61]);
            c4 = II(c4, d2, a4, b3, M_offset_2, 15, T[62]);
            b3 = II(b3, c4, d2, a4, M_offset_9, 21, T[63]);
            H[0] = H[0] + a4 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c4 | 0;
            H[3] = H[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i4 = 0; i4 < 4; i4++) {
              var H_i = H[i4];
              H[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a4, b3, c4, d2, x, s2, t4) {
          var n5 = a4 + (b3 & c4 | ~b3 & d2) + x + t4;
          return (n5 << s2 | n5 >>> 32 - s2) + b3;
        }
        function GG(a4, b3, c4, d2, x, s2, t4) {
          var n5 = a4 + (b3 & d2 | c4 & ~d2) + x + t4;
          return (n5 << s2 | n5 >>> 32 - s2) + b3;
        }
        function HH(a4, b3, c4, d2, x, s2, t4) {
          var n5 = a4 + (b3 ^ c4 ^ d2) + x + t4;
          return (n5 << s2 | n5 >>> 32 - s2) + b3;
        }
        function II(a4, b3, c4, d2, x, s2, t4) {
          var n5 = a4 + (c4 ^ (b3 | ~d2)) + x + t4;
          return (n5 << s2 | n5 >>> 32 - s2) + b3;
        }
        C.MD5 = Hasher._createHelper(MD52);
        C.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// node_modules/linebreak/node_modules/base64-js/lib/b64.js
var require_b64 = __commonJS({
  "node_modules/linebreak/node_modules/base64-js/lib/b64.js"(exports) {
    var lookup4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    (function(exports2) {
      "use strict";
      var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var PLUS = "+".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NUMBER = "0".charCodeAt(0);
      var LOWER = "a".charCodeAt(0);
      var UPPER = "A".charCodeAt(0);
      var PLUS_URL_SAFE = "-".charCodeAt(0);
      var SLASH_URL_SAFE = "_".charCodeAt(0);
      function decode2(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      function b64ToByteArray(b64) {
        var i4, j, l2, tmp, placeHolders, arr;
        if (b64.length % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var len = b64.length;
        placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
        arr = new Arr4(b64.length * 3 / 4 - placeHolders);
        l2 = placeHolders > 0 ? b64.length - 4 : b64.length;
        var L = 0;
        function push(v3) {
          arr[L++] = v3;
        }
        for (i4 = 0, j = 0; i4 < l2; i4 += 4, j += 3) {
          tmp = decode2(b64.charAt(i4)) << 18 | decode2(b64.charAt(i4 + 1)) << 12 | decode2(b64.charAt(i4 + 2)) << 6 | decode2(b64.charAt(i4 + 3));
          push((tmp & 16711680) >> 16);
          push((tmp & 65280) >> 8);
          push(tmp & 255);
        }
        if (placeHolders === 2) {
          tmp = decode2(b64.charAt(i4)) << 2 | decode2(b64.charAt(i4 + 1)) >> 4;
          push(tmp & 255);
        } else if (placeHolders === 1) {
          tmp = decode2(b64.charAt(i4)) << 10 | decode2(b64.charAt(i4 + 1)) << 4 | decode2(b64.charAt(i4 + 2)) >> 2;
          push(tmp >> 8 & 255);
          push(tmp & 255);
        }
        return arr;
      }
      function uint8ToBase64(uint82) {
        var i4, extraBytes = uint82.length % 3, output = "", temp, length2;
        function encode(num) {
          return lookup4.charAt(num);
        }
        function tripletToBase644(num) {
          return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
        }
        for (i4 = 0, length2 = uint82.length - extraBytes; i4 < length2; i4 += 3) {
          temp = (uint82[i4] << 16) + (uint82[i4 + 1] << 8) + uint82[i4 + 2];
          output += tripletToBase644(temp);
        }
        switch (extraBytes) {
          case 1:
            temp = uint82[uint82.length - 1];
            output += encode(temp >> 2);
            output += encode(temp << 4 & 63);
            output += "==";
            break;
          case 2:
            temp = (uint82[uint82.length - 2] << 8) + uint82[uint82.length - 1];
            output += encode(temp >> 10);
            output += encode(temp >> 4 & 63);
            output += encode(temp << 2 & 63);
            output += "=";
            break;
        }
        return output;
      }
      exports2.toByteArray = b64ToByteArray;
      exports2.fromByteArray = uint8ToBase64;
    })(typeof exports === "undefined" ? exports.base64js = {} : exports);
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i4 = 0; i4 < x64WordsLength; i4++) {
              var x64Word = x64Words[i4];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i4 = 0; i4 < wordsLength; i4++) {
              words[i4] = words[i4].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i4 = 0; i4 < typedArrayByteLength; i4++) {
              words[i4 >>> 2] |= typedArray[i4] << 24 - i4 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 2) {
              var codePoint = words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i4 = 0; i4 < utf16StrLength; i4++) {
              words[i4 >>> 1] |= utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 2) {
              var codePoint = swapEndian(words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i4 = 0; i4 < utf16StrLength; i4++) {
              words[i4 >>> 1] |= swapEndian(utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 3) {
              var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
              var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i4 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i4 = 0; i4 < base64StrLength; i4++) {
            if (i4 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i4 = 0; i4 < sigBytes; i4 += 3) {
              var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
              var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
              var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i4 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i4 = 0; i4 < base64StrLength; i4++) {
            if (i4 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var a4 = H[0];
            var b3 = H[1];
            var c4 = H[2];
            var d2 = H[3];
            var e4 = H[4];
            for (var i4 = 0; i4 < 80; i4++) {
              if (i4 < 16) {
                W[i4] = M[offset2 + i4] | 0;
              } else {
                var n5 = W[i4 - 3] ^ W[i4 - 8] ^ W[i4 - 14] ^ W[i4 - 16];
                W[i4] = n5 << 1 | n5 >>> 31;
              }
              var t4 = (a4 << 5 | a4 >>> 27) + e4 + W[i4];
              if (i4 < 20) {
                t4 += (b3 & c4 | ~b3 & d2) + 1518500249;
              } else if (i4 < 40) {
                t4 += (b3 ^ c4 ^ d2) + 1859775393;
              } else if (i4 < 60) {
                t4 += (b3 & c4 | b3 & d2 | c4 & d2) - 1894007588;
              } else {
                t4 += (b3 ^ c4 ^ d2) - 899497514;
              }
              e4 = d2;
              d2 = c4;
              c4 = b3 << 30 | b3 >>> 2;
              b3 = a4;
              a4 = t4;
            }
            H[0] = H[0] + a4 | 0;
            H[1] = H[1] + b3 | 0;
            H[2] = H[2] + c4 | 0;
            H[3] = H[3] + d2 | 0;
            H[4] = H[4] + e4 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n6) {
            var sqrtN = Math2.sqrt(n6);
            for (var factor2 = 2; factor2 <= sqrtN; factor2++) {
              if (!(n6 % factor2)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n6) {
            return (n6 - (n6 | 0)) * 4294967296 | 0;
          }
          var n5 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n5)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n5, 1 / 3));
              nPrime++;
            }
            n5++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset2) {
            var H2 = this._hash.words;
            var a4 = H2[0];
            var b3 = H2[1];
            var c4 = H2[2];
            var d2 = H2[3];
            var e4 = H2[4];
            var f3 = H2[5];
            var g3 = H2[6];
            var h3 = H2[7];
            for (var i4 = 0; i4 < 64; i4++) {
              if (i4 < 16) {
                W[i4] = M[offset2 + i4] | 0;
              } else {
                var gamma0x = W[i4 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i4 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i4] = gamma0 + W[i4 - 7] + gamma1 + W[i4 - 16];
              }
              var ch = e4 & f3 ^ ~e4 & g3;
              var maj = a4 & b3 ^ a4 & c4 ^ b3 & c4;
              var sigma0 = (a4 << 30 | a4 >>> 2) ^ (a4 << 19 | a4 >>> 13) ^ (a4 << 10 | a4 >>> 22);
              var sigma1 = (e4 << 26 | e4 >>> 6) ^ (e4 << 21 | e4 >>> 11) ^ (e4 << 7 | e4 >>> 25);
              var t1 = h3 + sigma1 + ch + K[i4] + W[i4];
              var t22 = sigma0 + maj;
              h3 = g3;
              g3 = f3;
              f3 = e4;
              e4 = d2 + t1 | 0;
              d2 = c4;
              c4 = b3;
              b3 = a4;
              a4 = t1 + t22 | 0;
            }
            H2[0] = H2[0] + a4 | 0;
            H2[1] = H2[1] + b3 | 0;
            H2[2] = H2[2] + c4 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e4 | 0;
            H2[5] = H2[5] + f3 | 0;
            H2[6] = H2[6] + g3 | 0;
            H2[7] = H2[7] + h3 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i4 = 0; i4 < 80; i4++) {
            W[i4] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i4 = 0; i4 < 80; i4++) {
              var Wil;
              var Wih;
              var Wi = W[i4];
              if (i4 < 16) {
                Wih = Wi.high = M[offset2 + i4 * 2] | 0;
                Wil = Wi.low = M[offset2 + i4 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i4 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i4 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i4 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i4 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i4];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y3 = 0;
          for (var t4 = 0; t4 < 24; t4++) {
            RHO_OFFSETS[x + 5 * y3] = (t4 + 1) * (t4 + 2) / 2 % 64;
            var newX = y3 % 5;
            var newY = (2 * x + 3 * y3) % 5;
            x = newX;
            y3 = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y3 = 0; y3 < 5; y3++) {
              PI_INDEXES[x + 5 * y3] = y3 + (2 * x + 3 * y3) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i4 = 0; i4 < 24; i4++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i4] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i4 = 0; i4 < 25; i4++) {
            T[i4] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state2 = this._state = [];
            for (var i4 = 0; i4 < 25; i4++) {
              state2[i4] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset2) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i4 = 0; i4 < nBlockSizeLanes; i4++) {
              var M2i = M[offset2 + 2 * i4];
              var M2i1 = M[offset2 + 2 * i4 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i4];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state2[x + 5 * y3];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state2[x + 5 * y3];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y3 = 0; y3 < 5; y3++) {
                  var laneIndex = x + 5 * y3;
                  var lane = state2[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y3];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y3];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i4 = 0; i4 < outputLengthLanes; i4++) {
              var lane = state2[i4];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state2 = clone._state = this._state.slice(0);
            for (var i4 = 0; i4 < 25; i4++) {
              state2[i4] = state2[i4].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i4 = 0; i4 < 16; i4++) {
              var offset_i = offset2 + i4;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t4;
            for (var i4 = 0; i4 < 80; i4 += 1) {
              t4 = al + M[offset2 + zl[i4]] | 0;
              if (i4 < 16) {
                t4 += f1(bl, cl, dl) + hl[0];
              } else if (i4 < 32) {
                t4 += f22(bl, cl, dl) + hl[1];
              } else if (i4 < 48) {
                t4 += f3(bl, cl, dl) + hl[2];
              } else if (i4 < 64) {
                t4 += f4(bl, cl, dl) + hl[3];
              } else {
                t4 += f5(bl, cl, dl) + hl[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sl[i4]);
              t4 = t4 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t4;
              t4 = ar + M[offset2 + zr[i4]] | 0;
              if (i4 < 16) {
                t4 += f5(br, cr, dr) + hr[0];
              } else if (i4 < 32) {
                t4 += f4(br, cr, dr) + hr[1];
              } else if (i4 < 48) {
                t4 += f3(br, cr, dr) + hr[2];
              } else if (i4 < 64) {
                t4 += f22(br, cr, dr) + hr[3];
              } else {
                t4 += f1(br, cr, dr) + hr[4];
              }
              t4 = t4 | 0;
              t4 = rotl(t4, sr[i4]);
              t4 = t4 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t4;
            }
            t4 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t4;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i4 = 0; i4 < 5; i4++) {
              var H_i = H[i4];
              H[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y3, z) {
          return x ^ y3 ^ z;
        }
        function f22(x, y3, z) {
          return x & y3 | ~x & z;
        }
        function f3(x, y3, z) {
          return (x | ~y3) ^ z;
        }
        function f4(x, y3, z) {
          return x & z | y3 & ~z;
        }
        function f5(x, y3, z) {
          return x ^ (y3 | ~z);
        }
        function rotl(x, n5) {
          return x << n5 | x >>> 32 - n5;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i4 = 0; i4 < hasherBlockSize; i4++) {
              oKeyWords[i4] ^= 1549556828;
              iKeyWords[i4] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i4 = 1; i4 < iterations; i4++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD52 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD52,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i4 = 1; i4 < iterations; i4++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset2, blockSize);
              cipher.encryptBlock(words, offset2);
              this._prevBlock = words.slice(offset2, offset2 + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset2, offset2 + blockSize);
              cipher.decryptBlock(words, offset2);
              xorBlock.call(this, words, offset2, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset2, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset2 + i4] ^= block[i4];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i4 = 0; i4 < nPaddingBytes; i4 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset2) {
            this._mode.processBlock(words, offset2);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format3) {
            if (typeof ciphertext == "string") {
              return format3.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = words.slice(offset2, offset2 + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset2, offset2 + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset2, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i4 = 0; i4 < blockSize; i4++) {
            words[offset2 + i4] ^= keystream[i4];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset2 + i4] ^= keystream[i4];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b22 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b22 === 255) {
                b22 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b22;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b22 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset2 + i4] ^= keystream[i4];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset2 + i4] ^= keystream[i4];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.encryptBlock(words, offset2);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.decryptBlock(words, offset2);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data2, blockSize) {
          data2.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data2, blockSize);
        },
        unpad: function(data2) {
          CryptoJS2.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data2) {
          var dataWords = data2.words;
          var i4 = data2.sigBytes - 1;
          for (var i4 = data2.sigBytes - 1; i4 >= 0; i4--) {
            if (dataWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255) {
              data2.sigBytes = i4 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i4 = 0; i4 < 256; i4++) {
            if (i4 < 128) {
              d2[i4] = i4 << 1;
            } else {
              d2[i4] = i4 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i4 = 0; i4 < 256; i4++) {
            var sx2 = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx2 = sx2 >>> 8 ^ sx2 & 255 ^ 99;
            SBOX[x] = sx2;
            INV_SBOX[sx2] = x;
            var x2 = d2[x];
            var x4 = d2[x2];
            var x8 = d2[x4];
            var t4 = d2[sx2] * 257 ^ sx2 * 16843008;
            SUB_MIX_0[x] = t4 << 24 | t4 >>> 8;
            SUB_MIX_1[x] = t4 << 16 | t4 >>> 16;
            SUB_MIX_2[x] = t4 << 8 | t4 >>> 24;
            SUB_MIX_3[x] = t4;
            var t4 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx2] = t4 << 24 | t4 >>> 8;
            INV_SUB_MIX_1[sx2] = t4 << 16 | t4 >>> 16;
            INV_SUB_MIX_2[sx2] = t4 << 8 | t4 >>> 24;
            INV_SUB_MIX_3[sx2] = t4;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d2[d2[d2[x8 ^ x2]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t4;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t4 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t4 = t4 << 8 | t4 >>> 24;
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                  t4 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t4 = SBOX[t4 >>> 24] << 24 | SBOX[t4 >>> 16 & 255] << 16 | SBOX[t4 >>> 8 & 255] << 8 | SBOX[t4 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t4;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t4 = keySchedule[ksRow];
              } else {
                var t4 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t4;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t4 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t4 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t4 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t4 & 255]];
              }
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset2) {
            var t4 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t4;
            this._doCryptBlock(M, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t4 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t4;
          },
          _doCryptBlock: function(M, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset2] ^ keySchedule[0];
            var s1 = M[offset2 + 1] ^ keySchedule[1];
            var s2 = M[offset2 + 2] ^ keySchedule[2];
            var s3 = M[offset2 + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t32 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t22;
              s3 = t32;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t32 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset2] = t0;
            M[offset2 + 1] = t1;
            M[offset2 + 2] = t22;
            M[offset2 + 3] = t32;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i4 = 0; i4 < 56; i4++) {
              var keyBitPos = PC1[i4] - 1;
              keyBits[i4] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i4 = 0; i4 < 24; i4++) {
                subKey[i4 / 6 | 0] |= keyBits[(PC2[i4] - 1 + bitShift) % 28] << 31 - i4 % 6;
                subKey[4 + (i4 / 6 | 0)] |= keyBits[28 + (PC2[i4 + 24] - 1 + bitShift) % 28] << 31 - i4 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i4 = 1; i4 < 7; i4++) {
                subKey[i4] = subKey[i4] >>> (i4 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i4 = 0; i4 < 16; i4++) {
              invSubKeys[i4] = subKeys[15 - i4];
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._subKeys);
          },
          decryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset2, subKeys) {
            this._lBlock = M[offset2];
            this._rBlock = M[offset2 + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f3 = 0;
              for (var i4 = 0; i4 < 8; i4++) {
                f3 |= SBOX_P[i4][((rBlock ^ subKey[i4]) & SBOX_MASK[i4]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f3;
            }
            var t4 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t4;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset2] = this._lBlock;
            M[offset2 + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset2, mask) {
          var t4 = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
          this._rBlock ^= t4;
          this._lBlock ^= t4 << offset2;
        }
        function exchangeRL(offset2, mask) {
          var t4 = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
          this._lBlock ^= t4;
          this._rBlock ^= t4 << offset2;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset2) {
            this._des1.encryptBlock(M, offset2);
            this._des2.decryptBlock(M, offset2);
            this._des3.encryptBlock(M, offset2);
          },
          decryptBlock: function(M, offset2) {
            this._des3.decryptBlock(M, offset2);
            this._des2.encryptBlock(M, offset2);
            this._des1.decryptBlock(M, offset2);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S3 = this._S = [];
            for (var i4 = 0; i4 < 256; i4++) {
              S3[i4] = i4;
            }
            for (var i4 = 0, j = 0; i4 < 256; i4++) {
              var keyByteIndex = i4 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S3[i4] + keyByte) % 256;
              var t4 = S3[i4];
              S3[i4] = S3[j];
              S3[j] = t4;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset2) {
            M[offset2] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S3 = this._S;
          var i4 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n5 = 0; n5 < 4; n5++) {
            i4 = (i4 + 1) % 256;
            j = (j + S3[i4]) % 256;
            var t4 = S3[i4];
            S3[i4] = S3[j];
            S3[j] = t4;
            keystreamWord |= S3[(S3[i4] + S3[j]) % 256] << 24 - n5 * 8;
          }
          this._i = i4;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i4 = this.cfg.drop; i4 > 0; i4--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i4 = 0; i4 < 4; i4++) {
              K[i4] = (K[i4] << 8 | K[i4] >>> 24) & 16711935 | (K[i4] << 24 | K[i4] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i4 = 0; i4 < 4; i4++) {
              nextState.call(this);
            }
            for (var i4 = 0; i4 < 8; i4++) {
              C2[i4] ^= X[i4 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i32;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i32;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S3[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S3[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S3[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S3[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i4 = 0; i4 < 4; i4++) {
              S3[i4] = (S3[i4] << 8 | S3[i4] >>> 24) & 16711935 | (S3[i4] << 24 | S3[i4] >>> 8) & 4278255360;
              M[offset2 + i4] ^= S3[i4];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i4 = 0; i4 < 8; i4++) {
            C_[i4] = C2[i4];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i4 = 0; i4 < 8; i4++) {
            var gx = X[i4] + C2[i4];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i4] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S3 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i4 = 0; i4 < 4; i4++) {
              nextState.call(this);
            }
            for (var i4 = 0; i4 < 8; i4++) {
              C2[i4] ^= X[i4 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i32;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i32;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S3[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S3[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S3[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S3[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i4 = 0; i4 < 4; i4++) {
              S3[i4] = (S3[i4] << 8 | S3[i4] >>> 24) & 16711935 | (S3[i4] << 24 | S3[i4] >>> 8) & 4278255360;
              M[offset2 + i4] ^= S3[i4];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i4 = 0; i4 < 8; i4++) {
            C_[i4] = C2[i4];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i4 = 0; i4 < 8; i4++) {
            var gx = X[i4] + C2[i4];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i4] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a4 = x >> 24 & 255;
          let b3 = x >> 16 & 255;
          let c4 = x >> 8 & 255;
          let d2 = x & 255;
          let y3 = ctx.sbox[0][a4] + ctx.sbox[1][b3];
          y3 = y3 ^ ctx.sbox[2][c4];
          y3 = y3 + ctx.sbox[3][d2];
          return y3;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i4 = 0; i4 < N; ++i4) {
            Xl = Xl ^ ctx.pbox[i4];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i4 = N + 1; i4 > 1; --i4) {
            Xl = Xl ^ ctx.pbox[i4];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index2 = 0; index2 < N + 2; index2++) {
            ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i4 = 0; i4 < N + 2; i4 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i4] = Data1;
            ctx.pbox[i4 + 1] = Data2;
          }
          for (let i4 = 0; i4 < 4; i4++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i4][j] = Data1;
              ctx.sbox[i4][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset2) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          decryptBlock: function(M, offset2) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "node_modules/abs-svg-path/index.js"(exports, module) {
    module.exports = absolutize;
    function absolutize(path) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y3 = 0;
      return path.map(function(seg) {
        seg = seg.slice();
        var type = seg[0];
        var command = type.toUpperCase();
        if (type != command) {
          seg[0] = command;
          switch (type) {
            case "a":
              seg[6] += x;
              seg[7] += y3;
              break;
            case "v":
              seg[1] += y3;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i4 = 1; i4 < seg.length; ) {
                seg[i4++] += x;
                seg[i4++] += y3;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y3 = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y3 = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y3 = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y3 = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports, module) {
    module.exports = parse3;
    var length2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse3(path) {
      var data2 = [];
      path.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data2.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length2[type]) {
            args.unshift(command);
            return data2.push(args);
          }
          if (args.length < length2[type]) throw new Error("malformed path data");
          data2.push([command].concat(args.splice(0, length2[type])));
        }
      });
      return data2;
    }
    var number3 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number3);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat5 = Array.prototype.concat;
    var slice5 = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i4 = 0, len = args.length; i4 < len; i4++) {
        var arg = args[i4];
        if (isArrayish(arg)) {
          results = concat5.call(results, slice5.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty3 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty3.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i4;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i4 = 0; i4 < 3; i4++) {
          var i22 = i4 * 2;
          rgb[i4] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = parseInt(match[i4] + match[i4], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = parseInt(match[i4 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i4 = 0; i4 < 3; i4++) {
          rgb[i4] = Math.round(parseFloat(match[i4 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty3.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i4 = 0; i4 < 3; i4++) {
        rgb[i4] = clamp(rgb[i4], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h3 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match[2]), 0, 100);
        var l2 = clamp(parseFloat(match[3]), 0, 100);
        var a4 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h3, s2, l2, a4];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h3 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b3 = clamp(parseFloat(match[3]), 0, 100);
        var a4 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h3, w, b3, a4];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r5 = Math.round(rgba[0] / 255 * 100);
      var g3 = Math.round(rgba[1] / 255 * 100);
      var b3 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r5 + "%, " + g3 + "%, " + b3 + "%)" : "rgba(" + r5 + "%, " + g3 + "%, " + b3 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a4 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a4 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a4 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min2, max2) {
      return Math.min(Math.max(min2, num), max2);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/media-engine/src/queries.js
var require_queries = __commonJS({
  "node_modules/media-engine/src/queries.js"(exports, module) {
    function MaxHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.height;
      };
    }
    function MinHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.height;
      };
    }
    function MaxWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.width;
      };
    }
    function MinWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.width;
      };
    }
    function Orientation(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value === options.orientation;
      };
    }
    module.exports = function Query(type, value2) {
      switch (type) {
        case "max-height":
          return new MaxHeight(value2);
        case "min-height":
          return new MinHeight(value2);
        case "max-width":
          return new MaxWidth(value2);
        case "min-width":
          return new MinWidth(value2);
        case "orientation":
          return new Orientation(value2);
        default:
          throw new Error(value2);
      }
    };
  }
});

// node_modules/media-engine/src/operators.js
var require_operators = __commonJS({
  "node_modules/media-engine/src/operators.js"(exports, module) {
    function And(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) && right.match(options);
      };
    }
    function Or(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) || right.match(options);
      };
    }
    module.exports = function Operator(type, left, right) {
      switch (type) {
        case "and":
          return new And(left, right);
        case ",":
          return new Or(left, right);
        default:
          throw new Error(value);
      }
    };
  }
});

// node_modules/media-engine/src/parser.js
var require_parser = __commonJS({
  "node_modules/media-engine/src/parser.js"(exports, module) {
    var Query = require_queries();
    var Operator = require_operators();
    var NUMBERS = /[0-9]/;
    var LETTERS = /[a-z|\-]/i;
    var WHITESPACE = /\s/;
    var COLON = /:/;
    var COMMA = /,/;
    var AND = /and$/;
    var AT = /@/;
    function tokenizer(input) {
      var current = 0;
      var tokens = [];
      while (current < input.length) {
        var char = input[current];
        if (AT.test(char)) {
          char = input[++current];
          while (LETTERS.test(char) && char !== void 0) {
            char = input[++current];
          }
        }
        if (WHITESPACE.test(char) || char === ")" || char === "(") {
          current++;
          continue;
        }
        if (COLON.test(char) || COMMA.test(char)) {
          current++;
          tokens.push({ type: "operator", value: char });
          continue;
        }
        if (NUMBERS.test(char)) {
          var value2 = "";
          while (NUMBERS.test(char)) {
            value2 += char;
            char = input[++current];
          }
          tokens.push({ type: "number", value: value2 });
          continue;
        }
        if (LETTERS.test(char)) {
          var value2 = "";
          while (LETTERS.test(char) && char !== void 0) {
            value2 += char;
            char = input[++current];
          }
          if (AND.test(value2)) {
            tokens.push({ type: "operator", value: value2 });
          } else {
            tokens.push({ type: "literal", value: value2 });
          }
          continue;
        }
        throw new TypeError(
          "Tokenizer: I dont know what this character is: " + char
        );
      }
      return tokens;
    }
    function parser(tokens) {
      var output = [];
      var stack = [];
      while (tokens.length > 0) {
        var token = tokens.shift();
        if (token.type === "number" || token.type === "literal") {
          output.push(token);
          continue;
        }
        if (token.type === "operator") {
          if (COLON.test(token.value)) {
            token = { type: "query", key: output.pop(), value: tokens.shift() };
            output.push(token);
            continue;
          }
          while (stack.length > 0) {
            output.unshift(stack.pop());
          }
          stack.push(token);
        }
      }
      while (stack.length > 0) {
        output.unshift(stack.pop());
      }
      function walk() {
        var head = output.shift();
        if (head.type === "number") {
          return parseInt(head.value);
        }
        if (head.type === "literal") {
          return head.value;
        }
        if (head.type === "operator") {
          var l2 = walk();
          var r5 = walk();
          return Operator(head.value, l2, r5);
        }
        if (head.type === "query") {
          var l2 = head.key.value;
          var r5 = head.value.value;
          return Query(l2, r5);
        }
      }
      return walk();
    }
    module.exports = {
      parse: function(query) {
        var tokens = tokenizer(query);
        var ast = parser(tokens);
        return ast;
      }
    };
  }
});

// node_modules/media-engine/src/index.js
var require_src = __commonJS({
  "node_modules/media-engine/src/index.js"(exports, module) {
    var Parser = require_parser();
    module.exports = function(queries, options) {
      var result = {};
      Object.keys(queries).forEach(function(query) {
        if (Parser.parse(query).match(options)) {
          Object.assign(result, queries[query]);
        }
      });
      return result;
    };
  }
});

// node_modules/hsl-to-rgb-for-reals/converter.js
var require_converter = __commonJS({
  "node_modules/hsl-to-rgb-for-reals/converter.js"(exports, module) {
    var hslToRgb = function(hue, saturation, lightness) {
      if (hue == void 0) {
        return [0, 0, 0];
      }
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var huePrime = hue / 60;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      huePrime = Math.floor(huePrime);
      var red;
      var green;
      var blue;
      if (huePrime === 0) {
        red = chroma;
        green = secondComponent;
        blue = 0;
      } else if (huePrime === 1) {
        red = secondComponent;
        green = chroma;
        blue = 0;
      } else if (huePrime === 2) {
        red = 0;
        green = chroma;
        blue = secondComponent;
      } else if (huePrime === 3) {
        red = 0;
        green = secondComponent;
        blue = chroma;
      } else if (huePrime === 4) {
        red = secondComponent;
        green = 0;
        blue = chroma;
      } else if (huePrime === 5) {
        red = chroma;
        green = 0;
        blue = secondComponent;
      }
      var lightnessAdjustment = lightness - chroma / 2;
      red += lightnessAdjustment;
      green += lightnessAdjustment;
      blue += lightnessAdjustment;
      return [
        Math.abs(Math.round(red * 255)),
        Math.abs(Math.round(green * 255)),
        Math.abs(Math.round(blue * 255))
      ];
    };
    module.exports = hslToRgb;
  }
});

// node_modules/hsl-to-hex/index.js
var require_hsl_to_hex = __commonJS({
  "node_modules/hsl-to-hex/index.js"(exports, module) {
    var toRgb = require_converter();
    function max2(val, n5) {
      return val > n5 ? n5 : val;
    }
    function min2(val, n5) {
      return val < n5 ? n5 : val;
    }
    function cycle(val) {
      val = max2(val, 1e7);
      val = min2(val, -1e7);
      while (val < 0) {
        val += 360;
      }
      while (val > 359) {
        val -= 360;
      }
      return val;
    }
    function hsl(hue, saturation, luminosity) {
      hue = cycle(hue);
      saturation = min2(max2(saturation, 100), 0);
      luminosity = min2(max2(luminosity, 100), 0);
      saturation /= 100;
      luminosity /= 100;
      var rgb = toRgb(hue, saturation, luminosity);
      return "#" + rgb.map(function(n5) {
        return (256 + n5).toString(16).substr(-2);
      }).join("");
    }
    module.exports = hsl;
  }
});

// node_modules/postcss-value-parser/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max2 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max2) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module.exports = function(value2) {
      var pos = 0;
      var length2 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length2 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// node_modules/hyphen/hyphen.js
var require_hyphen = __commonJS({
  "node_modules/hyphen/hyphen.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(exports, function() {
      function createTextReader(setup) {
        var char1 = "";
        var char2 = "";
        var i4 = 0;
        var verifier = setup();
        return function(text) {
          while (i4 < text.length) {
            char1 = text.charAt(i4++);
            char2 = text.charAt(i4);
            var verified = verifier(char1, char2);
            if (verified !== void 0) {
              return verified;
            }
          }
        };
      }
      var isNotLetter = RegExp.prototype.test.bind(
        /\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/
      );
      function createHTMLVerifier() {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (chars[0] === ">") {
              accumulate();
              skip = false;
            }
          } else if (chars[0] === "<" && (!isNotLetter(chars[1]) || chars[1] === "/")) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenCharVerifier(hyphenChar) {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {
              accumulate();
              skip = false;
            }
          } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenationVerifier(verifiers, minWordLength) {
        return function() {
          var accum0 = "";
          var accum = "";
          function accumulate() {
            accum0 += accum;
            accum = "";
          }
          function resolveWith(value2) {
            accum0 = "";
            accum = "";
            return value2;
          }
          return function(char1, char2) {
            accum += char1;
            var skip = verifiers.reduce(function(skip2, verify) {
              return skip2 || verify(accumulate, [char1, char2]);
            }, false);
            if (!skip) {
              if (isNotLetter(char1) && !isNotLetter(char2)) {
                accumulate();
              }
              if (!isNotLetter(char1) && isNotLetter(char2)) {
                if (accum.length >= minWordLength) {
                  return resolveWith([accum0, accum]);
                } else {
                  accumulate();
                }
              }
            }
            if (char2 === "") {
              if (accum.length < minWordLength || skip) {
                accumulate();
              }
              return resolveWith([accum0, accum]);
            }
          };
        };
      }
      function levelsToMarkers(levels) {
        var markers = [];
        for (var i4 = 0; i4 < levels.length; i4++)
          if ((levels[i4] & 1) === 1) markers.push(i4);
        return markers;
      }
      function insertChar(text, hyphenChar, markers) {
        if (markers.length === 0) {
          return text;
        }
        var resultText = [text.slice(0, markers[0])];
        if (markers.length > 1)
          for (var i4 = 0, j = 1; j < markers.length; i4++, j++) {
            resultText.push(text.slice(markers[i4], markers[j]));
          }
        resultText.push(text.slice(markers[markers.length - 1]));
        return resultText.join(hyphenChar);
      }
      function markersFromExceptionsDefinition(exceptionsList) {
        return exceptionsList.reduce(function(markersDict, definition) {
          var i4 = 0, markers = [];
          while ((i4 = definition.indexOf("-", i4 + 1)) > -1) {
            markers.push(i4);
          }
          markersDict[definition.toLocaleLowerCase().replace(/\-/g, "")] = markers;
          return markersDict;
        }, {});
      }
      function createCharIterator(str) {
        var i4 = 0;
        function nextChar() {
          return str[i4++];
        }
        return nextChar;
      }
      function createStringSlicer(str) {
        var i4 = 0, slice5 = str;
        function next() {
          slice5 = str.slice(i4++);
          if (slice5.length < 3) {
            return;
          }
          return slice5;
        }
        function isFirstCharacter() {
          return i4 === 2;
        }
        return [next, isFirstCharacter];
      }
      function hyphenateWord(text, loweredText, levelsTable, patternTrie) {
        var levels = new Array(text.length + 1), loweredText = ("." + loweredText + ".").split(""), wordSlice, letter, triePtr, trieNode, patternLevelsIndex, patternLevels, patternEntityIndex = -1, slicer, nextSlice, isFirstCharacter, nextLetter;
        for (var i4 = levels.length; i4--; ) levels[i4] = 0;
        slicer = createStringSlicer(loweredText);
        nextSlice = slicer[0];
        isFirstCharacter = slicer[1];
        while (wordSlice = nextSlice()) {
          patternEntityIndex++;
          if (isFirstCharacter()) {
            patternEntityIndex--;
          }
          triePtr = patternTrie;
          nextLetter = createCharIterator(wordSlice);
          while (letter = nextLetter()) {
            if ((trieNode = triePtr[letter]) === void 0) {
              break;
            }
            triePtr = {};
            patternLevelsIndex = -1;
            switch (Object.prototype.toString.call(trieNode)) {
              case "[object Array]":
                triePtr = trieNode[0];
                patternLevelsIndex = trieNode[1];
                break;
              case "[object Object]":
                triePtr = trieNode;
                break;
              case "[object Number]":
                patternLevelsIndex = trieNode;
                break;
            }
            if (patternLevelsIndex < 0) {
              continue;
            }
            if (!levelsTable[patternLevelsIndex].splice) {
              levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice("");
            }
            patternLevels = levelsTable[patternLevelsIndex];
            for (var k3 = 0; k3 < patternLevels.length; k3++)
              levels[patternEntityIndex + k3] = Math.max(
                patternLevels[k3],
                levels[patternEntityIndex + k3]
              );
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        return levelsToMarkers(levels);
      }
      function start2(text, levelsTable, patterns, cache2, markersDict, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done3() {
          resolveNewText(newText);
        }
        var newText = "", fragments, readText = createTextReader(
          createHyphenationVerifier(
            (skipHTML ? [createHTMLVerifier()] : []).concat(
              createHyphenCharVerifier(hyphenChar)
            ),
            minWordLength
          )
        ), resolveNewText = function() {
        };
        function nextTick3() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (fragments = readText(text))) {
            if (fragments[1]) {
              var cacheKey = fragments[1].length ? "~" + fragments[1] : "";
              if (!Object.prototype.hasOwnProperty.call(cache2, cacheKey)) {
                var loweredWord = fragments[1].toLocaleLowerCase();
                if (!Object.prototype.hasOwnProperty.call(markersDict, loweredWord))
                  markersDict[loweredWord] = hyphenateWord(
                    fragments[1],
                    loweredWord,
                    levelsTable,
                    patterns
                  );
                cache2[cacheKey] = insertChar(
                  fragments[1],
                  hyphenChar,
                  markersDict[loweredWord]
                );
              }
              fragments[1] = cache2[cacheKey];
            }
            newText += fragments[0] + fragments[1];
          }
          if (!fragments) {
            done3();
          } else {
            setTimeout(nextTick3);
          }
        }
        if (isAsync) {
          setTimeout(nextTick3);
          return new Promise(function(resolve3) {
            resolveNewText = resolve3;
          });
        } else {
          nextTick3();
          return newText;
        }
      }
      var SETTING_DEFAULT_ASYNC = false;
      var SETTING_DEFAULT_EXCEPTIONS = [];
      var SETTING_DEFAULT_HTML = true;
      var SETTING_DEFAULT_HYPH_CHAR = "";
      var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;
      var SETTING_NAME_ASYNC = "async";
      var SETTING_NAME_EXCEPTIONS = "exceptions";
      var SETTING_NAME_HTML = "html";
      var SETTING_NAME_HYPH_CHAR = "hyphenChar";
      var SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : false ? void 0 : {};
      function extend(target, source) {
        target = target || {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      function validateArray(value2) {
        return value2 instanceof Array;
      }
      function keyOrDefault(object, key, defaultValue, test) {
        if (key in object && (test ? test(object[key]) : true)) {
          return object[key];
        }
        return defaultValue;
      }
      function exceptionsFromDefinition(exceptionsList, hyphenChar) {
        return exceptionsList.reduce(function(exceptions, exception) {
          exceptions["~" + exception.replace(/\-/g, "")] = exception.replace(
            /\-/g,
            hyphenChar
          );
          return exceptions;
        }, {});
      }
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, markersDict = {}, exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), levelsTable = patternsDefinition[0].split(","), patterns = JSON.parse(patternsDefinition[1]), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML), userExceptions = keyOrDefault(
          options,
          SETTING_NAME_EXCEPTIONS,
          SETTING_DEFAULT_EXCEPTIONS,
          validateArray
        );
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = {};
        if (patternsDefinition[2]) {
          exceptions[cacheKey] = exceptionsFromDefinition(
            patternsDefinition[2],
            hyphenChar
          );
          markersDict = markersFromExceptionsDefinition(patternsDefinition[2]);
        }
        if (userExceptions && userExceptions.length) {
          exceptions[cacheKey] = extend(
            exceptions[cacheKey],
            exceptionsFromDefinition(userExceptions, hyphenChar)
          );
          markersDict = extend(
            markersDict,
            markersFromExceptionsDefinition(userExceptions)
          );
        }
        caches[cacheKey] = extend({}, exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text, options2) {
          options2 = options2 || {};
          var localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, localUserExceptions = keyOrDefault(
            options2,
            SETTING_NAME_EXCEPTIONS,
            SETTING_DEFAULT_EXCEPTIONS,
            validateArray
          ), cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2] && patternsDefinition[2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition[2],
              localHyphenChar
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          if (localUserExceptions && localUserExceptions.length) {
            exceptions[cacheKey2] = extend(
              exceptions[cacheKey2],
              exceptionsFromDefinition(localUserExceptions, localHyphenChar)
            );
            markersDict = extend(
              markersDict,
              markersFromExceptionsDefinition(localUserExceptions)
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          return start2(
            text,
            levelsTable,
            patterns,
            caches[cacheKey2],
            markersDict,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      return createHyphenator;
    });
  }
});

// node_modules/hyphen/patterns/en-us.js
var require_en_us = __commonJS({
  "node_modules/hyphen/patterns/en-us.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(exports, function() {
      return [
        "0004,004,001,003,005,0005,00005,000005,0002,002,0000005,0003,00003,00505,00034,0001,00055,00004,4,05,0055,04,42,03,02,2,404,3,044,01,0505,55,5,045,041,0033,000004,22,00504,5504,0042,1,21,41,402,405,4004,43,23,000054,303,3005,022,5004,000003,252,45,25,2004,000505,054,403,401,3002,0025,144,432,00054,34,12,234,0022,014,0304,012,143,503,0403,101,052,414,212,011,043,00002,0041,0024,05005,03003,00102,0404,04303,01004,0034,025,0044,00404,00025,0103,042,0205,412,104,54,344,433,5005,253,055,0402,3004,0043,204,505,454,0000004,00303,04004,552,201,4005,0255,52,444,14,44,02004,033,05004,00045,00013,0021,0405,00044,0054,50055,000303,00001,304,0204,11,301,232,122,00305,504,000043,0104,00052,000045,50004,0023,00033,00032,00202,5003,202,0401,0000505,214,102,032,000161,004101,00501,00301,0036,0052,00023,006101,006,00401,000521,0014,0063,00012,000501,000006,000604,000601,005001,005005,0010305,00006,003012,003005,0003011,0061,013,000021,000022,000105,00211,00062,00051,000112,006013,000011,0200306,1021,0050001,003003,2102,305,000015,01030005,000035,001011,00021,16330001,0234,030006,5020001,000001,00016,0031,021,21431,002305,0350014,0000012,000063,00101,106,105,00435,00063,0300061,00041,100306,003602,023,0503,0010011,10003,1005,30011,00031,0001001,0000061,0030003,30305,001201,0301,5000101,500101,00015,000401,000065,000016,0000402,0500002,000205,030201,500301,00014,5001,000002,00030011,01034,0300006,030213,00400304,050001,05003,000311,0634,00061,0006,00000604,00050013,00213,0030001,100003,000033,30002,00003632,0003004,050003,0000021,006303,0000006,00005005,30451,03001,00231,00056,00011,6,001001,00500001,03005,503005,0000010001,1002,003001,001065,300001,32011,32,0000003,0213001,0500053,021005,10001,0000011,0001041,0020016,100032,50011,0606,5002,3001,03002,0015001,0102,00003001,000000033,0000001,300101,300015,0101003,00000101,0100501,0101,0010033,00000362,000014,0005001,031",
        '{".":{"a":{"c":{"h":0},"d":{"d":{"e":{"r":1}}},"f":{"t":2},"l":{"t":3},"m":{"a":{"t":4}},"n":{"c":4,"g":0,"i":{"m":5},"t":[{"e":3,"i":{"s":6}},0]},"r":{"s":4,"t":{"i":{"e":1},"y":1}},"s":{"c":3,"p":2,"s":2,"t":{"e":{"r":7}}},"t":{"o":{"m":6}},"u":{"d":2},"v":{"i":1},"w":{"n":0}},"b":{"a":{"g":1,"n":{"a":4},"s":{"e":0}},"e":{"r":[{"a":4},0],"s":{"m":3,"t":{"o":4}}},"r":{"i":8},"u":{"t":{"t":{"i":0}}}},"c":{"a":{"m":{"p":{"e":0}},"n":{"c":5},"p":{"a":{"b":6}},"r":{"o":{"l":5}},"t":1},"e":{"l":{"a":1}},"h":[{"i":{"l":{"l":{"i":7}}}},1],"i":[{"t":{"r":5}},9],"o":{"e":3,"r":[{"n":{"e":{"r":5}}},1],"n":{"g":{"r":5}}}},"d":{"e":{"m":{"o":{"i":1}},"o":3,"r":{"a":3,"i":[{"v":{"a":4}},3]},"s":{"c":0}},"i":{"c":{"t":{"i":{"o":10}}}},"o":{"t":1},"u":{"c":1,"m":{"b":6}},"r":{"i":{"v":67}}},"e":{"a":{"r":{"t":{"h":7}},"s":{"i":11}},"b":1,"e":{"r":0},"g":9,"l":{"d":4,"e":{"m":3}},"n":{"a":{"m":12},"g":3,"s":3},"q":{"u":{"i":{"t":13}}},"r":{"r":{"i":1}},"s":3,"u":[{"l":{"e":{"r":1}}},3],"y":{"e":5},"t":{"h":{"y":{"l":162}}},"v":[{"e":{"r":{"s":{"i":{"b":158}}}}},9]},"f":{"e":{"s":11},"o":{"r":{"m":{"e":{"r":5}}}}},"g":{"a":[{"s":{"o":{"m":163}}},9],"e":[{"n":{"t":14},"o":{"g":4,"m":{"e":1},"t":164}},9],"i":{"a":4,"b":1},"o":{"r":1}},"h":{"a":{"n":{"d":{"i":6},"k":5}},"e":[{"r":{"o":{"i":6,"e":3}},"s":11,"t":11,"m":{"o":165},"p":{"a":166}},9],"i":{"b":3,"e":{"r":3}},"o":{"n":{"e":{"y":5},"o":11},"v":5}},"i":{"d":{"l":1,"o":{"l":12}},"m":{"m":3,"p":{"i":{"n":4}}},"n":[{"c":{"i":3},"e":8,"k":9,"s":3,"u":{"t":167}},2],"r":{"r":4},"s":{"i":1}},"j":{"u":{"r":3}},"l":{"a":{"c":{"y":1},"m":1,"t":{"e":{"r":5},"h":6}},"e":[{"g":{"e":5},"n":0,"p":5,"v":15,"i":{"c":{"e":{"s":170}}}},9],"i":{"g":[{"a":5},1],"n":9,"o":3,"t":1}},"m":{"a":{"g":{"a":16},"l":{"o":5},"n":{"a":5},"r":{"t":{"i":5}}},"e":[{"r":{"c":11},"t":{"e":{"r":4},"a":{"l":{"a":0}}},"g":{"a":{"l":171}}},9],"i":{"s":[{"t":{"i":6},"e":{"r":{"s":173}}},15],"m":{"i":{"c":172}}},"o":{"n":{"e":11},"r":{"o":3}},"u":{"t":{"a":[{"b":6},4]}}},"n":{"i":{"c":1},"e":{"o":{"f":174}},"o":{"e":{"t":{"h":15}},"n":{"e":{"m":175}}}},"o":{"d":[{"d":5},9],"f":{"t":{"e":4}},"r":{"a":{"t":{"o":4}},"c":3,"d":2,"t":3},"s":[{"t":{"l":1}},3],"t":{"h":11},"u":{"t":11}},"p":{"e":{"d":{"a":{"l":5}},"t":{"e":4,"i":{"t":4}}},"i":{"e":1,"o":{"n":5},"t":9},"r":{"e":{"m":11,"a":{"m":15}}},"o":{"l":{"y":{"s":137}},"s":{"t":{"a":{"m":137}}}}},"r":{"a":{"c":1,"n":{"t":0},"t":{"i":{"o":{"n":{"a":7}}}},"v":{"e":{"n":{"o":176}}}},"e":{"e":[{"c":173},8],"m":{"i":{"t":4}},"s":[{"t":{"a":{"t":4}}},8]},"i":{"g":1,"t":{"u":5}},"o":{"q":1,"s":{"t":5},"w":{"d":5}},"u":{"d":1}},"s":{"c":{"i":{"e":11}},"e":{"l":{"f":6,"l":6},"n":9,"r":{"i":{"e":4}},"m":{"i":[{"c":0,"d":177,"p":36,"r":36,"s":178,"v":36},6]}},"h":9,"i":[{"n":{"g":17}},9],"t":[{"a":{"b":{"l":5}}},1],"y":9,"p":{"h":{"i":{"n":179}},"i":{"n":{"o":137}}}},"t":{"a":[{"p":{"e":{"s":{"t":{"r":180}}}}},1],"e":[{"n":{"a":{"n":5}},"l":{"e":{"g":{"r":3}}}},1],"h":9,"i":[{"l":0,"m":{"o":16},"n":{"g":17,"k":5}},9],"o":{"n":{"a":0},"p":[{"i":5,"o":{"g":170}},1],"u":{"s":5},"q":9},"r":{"i":{"b":{"u":{"t":6}}}}},"u":{"n":{"a":[{"t":{"t":144}},2],"c":{"e":3},"d":{"e":{"r":7}},"e":[{"r":{"r":181}},2],"k":4,"o":4,"u":3},"p":3,"r":{"e":11},"s":{"a":4}},"v":{"e":{"n":{"d":{"e":0}},"r":{"a":4}},"i":{"c":{"a":{"r":151}}}},"w":{"i":{"l":{"i":5}},"e":{"b":{"l":131}}},"y":{"e":1},"k":{"i":{"l":{"n":{"i":168}}},"o":{"r":{"t":{"e":169}}}}},"a":{"b":{".":18,"a":{"l":19,"n":19},"e":[{"r":{"d":4}},8],"i":{"a":5,"t":{"a":{"b":13}}},"l":{"a":{"t":4}},"o":{"l":{"i":{"z":20,"c":19}}},"r":[{"o":{"g":4}},18],"u":{"l":3}},"c":{"a":{"r":[{"d":4,"o":4},21],"b":{"l":24}},"e":{"o":{"u":19},"r":2},"h":{"e":{"t":19}},"i":[{"e":23,"n":2,"o":23},22],"r":{"o":{"b":4}},"t":{"i":{"f":5}},"u":{"l":3,"m":1}},"d":[{"d":{"i":{"n":1}},"e":{"r":{".":4}},"i":[{"a":23,"c":{"a":3},"e":{"r":0},"o":23,"t":23,"u":19},25],"l":{"e":1},"o":{"w":3},"r":{"a":{"n":4}},"s":{"u":1},"u":[{"c":23,"m":4},18]},24],"e":{"r":[{"i":{"e":17}},1]},"f":[{"f":[{"i":{"s":{"h":170}}},0]},24],"g":{"a":{"b":21,"n":0},"e":{"l":{"l":4},"o":0,"u":18},"i":2,"l":26,"n":2,"o":[{"g":27,"n":{"i":3}},24],"u":{"e":{"r":19},"l":4},"y":21},"h":{"a":23,"e":23,"l":1,"o":23},"i":[{"a":19,"c":{".":23},"l":{"y":4},"n":[{"i":{"n":5},"o":5},28],"t":{"e":{"n":5}}},9],"j":29,"k":{"e":{"n":2}},"l":{"a":{"b":4,"d":3,"r":21},"d":{"i":18},"e":[{"n":{"d":3,"t":{"i":21}},"o":30},25],"i":[{"a":{".":1},"e":0},2],"l":{"e":{"v":4},"i":{"c":18}},"m":18,"o":{"g":{".":19}},"y":{".":21,"s":[{"t":31},18],"t":32,"z":27}},"m":{"a":[{"b":4,"g":3,"r":{"a":5},"s":{"c":4},"t":{"i":{"s":21},"o":33}},18],"e":{"r":{"a":4},"n":{"t":{"a":{"b":182}}}},"i":{"c":3,"f":4,"l":{"y":4},"n":[{"o":0},2]},"o":[{"n":19,"r":{"i":6}},24],"p":{"e":{"n":5}}},"n":[{"a":{"g":{"e":3},"l":{"y":[{"s":183},27]},"r":[{"c":3,"i":17},23],"t":{"i":23}},"d":[{"e":{"s":17},"i":{"s":3},"l":2,"o":{"w":1}},18],"e":{"e":19,"n":23,"s":{"t":{".":4}},"u":23},"g":[{"i":{"e":5},"l":2},25],"i":{"c":34,"e":{"s":23},"f":35,"m":{"e":1,"i":19},"n":{"e":19},"o":3,"p":23,"s":{"h":3},"t":3,"u":23},"k":{"l":{"i":1}},"n":{"i":{"z":32}},"o":[{"t":[{"h":7},4],"a":{"c":148}},0],"s":{"a":9,"c":{"o":1},"n":1,"p":[{"o":11},9],"t":1,"u":{"r":1},"g":{"r":5},"v":11},"t":{"a":{"l":36},"i":{"e":1,"d":137,"n":184,"r":{"e":137}},"o":18,"r":9,"w":1},"u":{"a":3,"l":3,"r":19}},24],"o":18,"p":{"a":{"r":17,"t":4},"e":{"r":{"o":4},"a":{"b":{"l":{"e":132}}}},"h":{"e":{"r":23},"i":18},"i":{"l":{"l":{"a":[{"r":4},21]}},"n":3,"t":{"a":3,"u":23}},"l":24,"o":{"c":6,"l":{"a":4},"r":{"i":6},"s":{"t":12}},"s":{"e":{"s":5}},"u":23},"q":{"u":{"e":6}},"r":[{"a":{"c":{"t":3},"d":{"e":19,"i":{"s":4}},"l":3,"m":{"e":{"t":{"e":19}}},"n":{"g":17},"p":11,"t":[{"i":{"o":19,"v":4}},1],"u":19,"v":38,"w":17},"b":{"a":{"l":36}},"c":{"h":{"a":{"n":1},"e":{"t":185}}},"d":{"i":{"n":{"e":4}},"r":1},"e":{"a":{"s":4},"e":23,"n":{"t":3},"s":{"s":19}},"f":{"i":1,"l":1},"i":[{"a":{"l":4,"n":3},"e":{"t":23},"m":1,"n":{"a":{"t":4}},"o":3,"z":9},2],"m":{"i":9},"o":{"d":20,"n":{"i":19},"o":23},"p":9,"q":3,"r":{"e":17,"a":{"n":{"g":{"e":9}}}},"s":{"a":1,"h":9}},37],"s":{".":18,"a":{"b":1,"n":{"t":3}},"h":{"i":17},"i":{"a":{".":19},"b":23,"c":23,"t":39},"k":{"i":11},"l":1,"o":{"c":21},"p":{"h":4},"s":{"h":1},"t":{"e":{"n":3},"r":2},"u":{"r":{"a":6}},"y":{"m":{"p":{"t":{"o":{"t":4}}}}}},"t":{"a":[{"b":{"l":3},"c":4,"l":{"o":3},"p":4},24],"e":{"c":[{"h":4},5],"g":{"o":3},"n":{".":3},"r":{"a":3,"n":[{"a":19},6]},"s":{"t":3},"v":4},"h":[{"e":{"m":5,"n":19,"r":{"o":{"s":186}}},"o":[{"m":5},1]},18],"i":{".":18,"a":19,"b":20,"c":2,"f":3,"o":{"n":{"a":{"r":7}}},"t":{"u":3}},"o":{"g":21,"m":[{"i":{"z":4}},24],"p":21,"s":21},"r":[{"o":{"p":4}},29],"s":{"k":1},"t":{"a":{"g":1},"e":[{"s":{".":170}},4],"h":1},"u":[{"a":4,"e":4,"l":3,"r":{"a":3}},24],"y":24},"u":{"b":1,"g":{"h":[{"t":{"l":17}},12],"u":3},"l":[{"i":{"f":13}},40],"n":{"d":5},"r":3,"s":{"i":{"b":4}},"t":{"e":{"n":5},"h":2}},"v":{"a":[{"g":3,"n":19},24],"e":{"n":{"o":0},"r":{"a":3,"n":4,"y":4}},"i":[{"e":{"r":0},"g":3,"o":{"u":3}},2],"o":{"c":4,"r":29}},"w":{"a":{"y":27},"i":3,"l":{"y":1},"s":0},"x":{"i":{"c":1,"d":1}},"y":{"a":{"l":4},"e":0,"s":0},"z":{"i":{"e":{"r":0}},"z":{"i":5}}},"b":{"a":{".":32,"d":{"g":{"e":{"r":5}}},"g":{"e":1},"l":{"a":15},"n":{"d":{"a":{"g":5}},"e":0,"i":11},"r":{"b":{"i":7},"i":{"a":17},"o":{"n":{"i":{"e":187}}}},"s":{"s":{"i":0}},"t":[{"h":{"y":2}},41],"z":1,"c":{"k":{"e":{"r":{".":84}}}}},"b":[{"e":[{"r":23},24],"i":{"n":{"a":0},"t":0}},42],"d":43,"e":{".":18,"a":{"k":17,"t":12},"d":[{"a":3,"e":3,"i":3},44],"g":{"i":3,"u":4},"l":[{"i":2,"o":3},41],"m":45,"n":{"i":{"g":4},"u":4},"s":[{"p":3,"t":{"r":4}},46],"t":[{"i":{"z":5},"r":4,"w":3},27],"w":3,"y":{"o":4},"v":{"i":{"e":9}}},"f":25,"h":47,"i":{"b":9,"d":[{"i":{"f":167}},1],"e":[{"n":4,"r":1},27],"f":48,"l":[{"i":{"z":3},"l":{"a":{"b":8}}},41],"n":{"a":{"r":49},"d":0,"e":{"t":4}},"o":{"g":{"r":3},"u":4,"m":5,"r":{"b":2,"h":15}},"t":[{"i":{"o":50,"v":{"e":188}},"r":3,"u":{"a":51},"z":19},9]},"j":29,"k":1,"l":[{"a":{"t":{"h":7},"n":{"d":189}},"e":{".":21,"n":17,"s":{"p":32}},"i":{"s":23,"n":{"d":189}},"o":[{"n":{"d":190}},21],"u":{"n":{"t":17}}},52],"m":43,"n":[{"e":{"g":5}},47],"o":{"d":[{"i":11},27],"e":1,"l":{"i":{"c":11}},"m":{"b":{"i":0}},"n":{"a":[{"t":5},0]},"o":27,"r":{".":32,"a":43,"d":5,"e":32,"i":32,"n":{"o":191}},"s":53,"t":{"a":19,"h":6,"o":1,"u":{"l":192}},"u":{"n":{"d":54}}},"p":18,"r":{"i":{"t":18},"o":{"t":{"h":54}},"u":{"s":{"q":17}}},"s":[{"o":{"r":17}},55],"t":[{"l":1,"o":21,"r":23},25],"u":{"f":{"f":{"e":{"r":0}}},"g":{"a":1},"l":{"i":3},"m":{"i":17},"n":[{"t":{"i":17}},1],"r":{"e":3},"s":{"i":{"e":[{"r":193,"s":193},5]},"s":{"e":17,"i":{"n":{"g":17}}},"t":32},"t":{"a":18,"i":{"o":27},"o":19,"e":{"d":{".":8}},"t":{"e":{"d":0}}}},"v":29,"w":56,"y":{".":32,"s":0}},"c":{"a":[{"b":{"i":{"n":11},"l":2},"c":{"h":17},"d":{"e":{"n":4,"m":194}},"g":46,"h":57,"l":{"a":{"t":3},"l":{"a":0,"i":{"n":6}},"o":18},"n":{"d":5,"e":0,"i":{"c":0,"s":5,"z":11},"t":{"y":0},"y":17},"p":{"e":{"r":4}},"r":{"o":{"m":5}},"s":{"t":{"e":{"r":6},"i":{"g":5}},"y":18},"t":{"h":1,"i":{"v":18},"a":{"s":195}},"v":{"a":{"l":5}}},41],"c":[{"h":{"a":6},"i":{"a":0},"o":{"m":{"p":{"a":10}},"n":17,"u":{"t":12}}},23],"e":{".":25,"d":{".":18,"e":{"n":18}},"i":27,"l":{".":32,"l":27},"n":[{"c":27,"e":58,"i":18,"t":27},41],"p":27,"r":{"a":{"m":4}},"s":{"a":18,"s":{"i":[{"b":59},27]},"t":5},"t":[{"a":60},0],"w":0},"h":[{".":18,"a":{"b":61,"n":{"i":{"c":32,"s":20}}},"e":[{"a":{"p":54},"d":18,"l":{"o":5},"m":{"i":27},"n":{"e":4},"r":{".":3,"s":3}},8],"i":{"n":[{"e":{".":32,"s":{"s":4}},"i":32},62],"o":32,"t":27,"z":8,"e":{"v":{"o":6}}},"o":63,"t":{"i":1},"s":{".":18,"h":{"u":11}}},25],"i":[{"a":[{"b":64,"r":5},27],"c":4,"e":{"r":18},"f":{"i":{"c":{".":32}}},"i":18,"l":{"a":1,"i":27},"m":25,"n":[{"a":[{"t":27},21],"e":{"m":11},"g":[{".":19},29],"o":32,"q":8},25],"o":{"n":17},"p":{"e":18,"h":3,"i":{"c":18}},"s":{"t":{"a":18,"i":18}},"t":[{"i":{"z":11}},42],"z":32,"g":{"a":{"r":152}}},41],"k":[{"i":3},2],"l":[{"a":{"r":[{"a":{"t":{"i":{"o":19}}},"e":32},18]},"e":{"m":0,"a":{"r":0}},"i":{"c":18,"m":17},"y":0},65],"n":19,"o":[{"a":{"g":4},"e":8,"g":[{"r":1},25],"i":[{"n":{"c":3}},0],"l":{"i":5,"o":[{"r":11},32]},"m":{"e":{"r":5}},"n":{"a":0,"e":21,"g":11,"t":5},"p":{"a":3,"i":{"c":11},"l":1,"h":{"o":{"n":196}}},"r":{"b":18,"o":{"n":12}},"s":{"e":0},"v":[{"e":17},15],"w":{"a":5},"z":{"e":5,"i":4},"u":{"s":{"t":{"i":84}}}},41],"q":29,"r":{"a":{"s":{"t":6},"t":{".":32,"i":{"c":32}}},"e":{"a":{"t":11},"d":32,"t":{"a":47},"v":0},"i":[{"f":5,"n":21,"s":17,"t":{"i":[{"e":11},32]}},8],"o":{"p":{"l":0,"o":6},"s":{"e":17},"c":{"o":{"d":197}},"e":{"c":{"o":148}}},"u":{"d":0}},"s":66,"t":[{"a":{"b":0,"n":{"g":4,"t":19}},"e":[{"r":23},24],"i":{"c":{"u":21},"m":{"i":12}},"u":{"r":0},"w":21,"r":{"o":{"m":{"e":{"c":198}}}}},42],"u":{"d":5,"f":21,"i":[{"t":{"y":4}},21],"l":{"i":32,"t":{"i":{"s":0},"u":27}},"m":{"a":9,"e":23,"i":1},"n":27,"p":{"i":3,"y":4},"r":{"a":{"b":67,"n":{"c":{"e":199}}},"i":{"a":4}},"s":[{"s":{"i":17}},41],"t":[{"i":{"e":1,"v":56},"r":18},68]},"y":41,"z":{"e":0}},"d":{"a":[{".":32,"b":70,"c":{"h":17},"f":18,"g":25,"m":71,"n":{"g":11},"r":{"d":6,"k":6,"y":18},"t":[{"i":{"v":18},"o":18,"a":{"b":137}},27],"v":[{"e":5},53],"y":32,"l":{"o":{"n":{"e":48}}}},69],"b":29,"c":19,"d":[{"a":{"b":20},"i":{"b":94}},72],"e":{".":25,"a":{"f":6,"l":{"s":{".":1}}},"b":{"i":{"t":5},"o":{"n":1}},"c":{"a":{"n":36},"i":{"l":1},"o":{"m":4},"l":{"a":{"r":200},"i":{"n":{"a":64}}}},"d":42,"e":{".":18},"i":{"f":4},"l":{"i":{"e":17,"q":16},"o":4},"m":[{".":32,"i":{"c":[{".":5},27],"l":4},"o":{"n":{"s":1},"r":7,"s":9}},21],"n":[{"a":{"r":1},"o":3,"t":{"i":{"f":7}},"u":3},41],"p":[{"a":3,"i":17,"u":9},2],"q":23,"r":{"h":21,"m":32,"n":{"i":{"z":6}},"s":5},"s":[{".":24,"c":2,"o":64,"t":{"i":11,"r":3},"u":1,"i":{"c":11}},8],"t":[{"o":9,"i":{"c":9}},2],"v":[{"i":{"l":11}},2],"y":18,"f":{"i":{"n":{"i":{"t":{"i":201}}}}}},"f":43,"g":{"a":21,"e":{"t":73},"i":2,"y":24},"h":74,"i":{".":32,"a":[{"b":5},75],"c":{"a":{"m":1,"i":{"d":15}},"e":21,"t":27},"d":27,"e":{"n":76},"f":[{"f":{"r":{"a":5}}},29],"g":{"e":3},"l":{"a":{"t":{"o":1}}},"n":[{"a":41,"e":{".":27},"i":[{"z":4},32]},29],"o":[{"g":5},41],"p":{"l":1},"r":[{"e":[{"n":9,"r":9},2],"t":{"i":6}},8],"s":[{"i":32,"t":77},15],"t":{"i":24},"v":78,"m":{"e":{"t":{"h":{"y":141}}}}},"j":29,"k":79,"l":{"a":56,"e":{".":27,"d":27,"s":{".":27,"s":18},"a":{"d":42}},"o":48,"u":56,"y":25,"i":{"e":202}},"m":29,"n":80,"o":[{".":27,"d":{"e":4},"e":32,"f":57,"g":21,"l":{"a":1,"i":17,"o":{"r":4}},"m":{"i":{"z":5}},"n":{"a":{"t":3},"i":17},"o":{"d":11},"p":{"p":0},"r":21,"s":27,"u":{"t":56},"v":1,"x":27,"w":{"o":{"r":{"d":203}}}},41],"p":29,"r":[{"a":{"g":{"o":{"n":6}},"i":18},"e":[{"a":{"r":6},"n":[{"a":{"l":204}},32]},0],"i":{"b":0,"l":17,"f":{"t":{"a":189}},"p":{"l":{"e":{"g":205}}}},"o":{"p":0,"w":18,"m":{"e":{"d":206}}},"u":{"p":{"l":{"i":32}}},"y":18},41],"s":[{"p":1,"w":21,"y":21},81],"t":{"h":24,"a":{"b":23}},"u":[{"a":[{"l":{".":9}},82],"c":[{"a":29,"e":{"r":5},"t":{".":18,"s":18}},9],"e":{"l":4},"g":1,"l":{"e":23},"m":{"b":{"e":0}},"n":1,"p":[{"e":1},18],"o":{"p":{"o":{"l":207}}}},41],"v":29,"w":29,"y":[{"n":32,"s":{"e":1,"p":5}},24]},"e":{"a":{"b":72,"c":{"t":23},"d":[{"i":{"e":5}},15],"g":{"e":[{"r":4},1]},"l":[{"e":{"r":5},"o":{"u":11}},1],"m":{"e":{"r":11}},"n":{"d":19,"i":{"e":{"s":111}}},"r":{"a":11,"c":0,"e":{"s":5},"i":{"c":0,"l":0},"k":5,"t":[{"e":12},8]},"s":{"p":4,"s":23,"t":12},"t":[{"e":{"n":5},"h":{"i":12},"i":{"f":19},"u":83},9],"v":[{"e":{"n":11},"i":5,"o":5},9]},"b":[{"e":{"l":{".":21,"s":21},"n":21},"i":{"t":21},"r":23},42],"c":{"a":{"d":21,"n":{"c":6}},"c":{"a":6},"e":[{"s":{"s":{"a":4}}},29],"i":[{"b":21,"f":{"i":{"c":{"a":{"t":4}},"e":4},"y":4},"m":3,"t":[{"e":19},0]},9],"l":{"a":{"m":21},"u":{"s":21}},"o":{"l":24,"m":{"m":21,"p":{"e":21}},"n":{"c":21},"r":[{"a":3,"o":5},24]},"r":[{"e":{"m":21}},29],"t":{"a":{"n":1},"e":1},"u":[{"l":[{"a":3},21]},29],"h":{"a":{"s":23}}},"d":{"a":37,"d":61,"e":{"r":34,"s":0},"i":[{"a":23,"b":3,"c":{"a":3},"m":3,"t":2,"z":5},18],"o":[{"l":21,"n":84},18],"r":{"i":21},"u":{"l":[{"o":4,"i":{"n":{"g":2}}},21]},"g":{"l":15}},"e":{"c":9,"d":{"i":11},"f":9,"l":{"i":11,"y":1},"m":9,"n":{"a":1},"p":85,"s":[{"t":17},86],"t":{"y":1},"x":19},"f":[{"e":{"r":{"e":83}},"f":41,"i":{"c":[{"i":32},21],"l":17,"n":{"e":23,"i":{"t":{"e":20}}},"t":27},"o":{"r":{"e":{"s":6}}},"u":{"s":{"e":{".":21}}}},29],"g":{"a":{"l":18},"e":{"r":17},"i":{"b":4,"c":1,"n":{"g":4},"t":87},"n":4,"o":{".":21,"s":21},"u":{"l":2,"r":19},"y":32},"h":[{"e":{"r":17}},72],"i":[{"c":19,"d":4,"g":[{"l":4},8],"m":{"b":23},"n":{"f":23,"g":29,"s":{"t":19}},"r":{"d":0},"t":{"e":11,"h":3,"y":19}},9],"j":[{"u":{"d":[{"i":4},21]}},29],"k":{"i":{"n":0},"l":{"a":1}},"l":{"a":[{".":21,"c":21,"n":{"d":17},"t":{"i":{"v":4}},"w":21,"x":{"a":36}},29],"e":{"a":23,"b":{"r":{"a":4}},"c":32,"d":21,"g":{"a":3},"n":19,"r":34,"s":29},"f":9,"i":[{"b":{"e":23},"c":{".":33,"a":3},"e":{"r":23},"g":{"i":{"b":4}},"m":19,"n":{"g":83},"o":23,"s":[{"h":4},24],"v":88,"t":{"i":{"s":208}}},9],"l":{"a":[{"b":1},18],"o":17},"o":{"c":19,"g":4,"p":{".":3},"a":29},"s":{"h":9},"t":{"a":1},"u":{"d":19,"g":4}},"m":{"a":{"c":21,"g":21,"n":[{"a":4},19]},"b":4,"e":[{"l":24,"t":21},29],"i":{"c":{"a":3},"e":0,"g":{"r":{"a":4}},"n":[{"e":4,"i":35},89],"s":[{"h":4,"s":19},21],"z":3},"n":{"i":{"z":32}},"o":{"g":0,"n":{"i":{"o":7}}},"p":{"i":3},"u":{"l":[{"a":4},21],"n":11},"y":23},"n":{"a":{"m":{"o":4},"n":{"t":21}},"c":{"h":{"e":{"r":17}}},"d":{"i":{"c":3,"x":2}},"e":{"a":19,"e":19,"m":3,"r":{"o":4},"s":{"i":4,"t":4},"t":{"r":3},"w":23},"i":{"c":{"s":4},"e":19,"l":19,"o":23,"s":{"h":3},"t":3,"u":19,"z":32},"n":18,"o":[{"g":0,"s":21,"v":3},18],"s":{"w":1},"t":{"a":{"g":{"e":5}},"h":{"e":{"s":18}}},"u":{"a":3,"f":4},"y":{".":23},"z":61},"o":{"f":19,"g":[{"r":{"a":{"p":3}}},9],"i":90,"l":23,"p":{"a":{"r":11}},"r":[{"e":3,"o":{"l":4}},29],"s":0,"t":[{"o":1},21],"u":{"t":19},"w":19},"p":{"a":[{"i":23,"n":{"c":4}},24],"e":{"l":19,"n":{"t":23},"t":{"i":{"t":{"i":{"o":4}}}}},"h":{"e":17},"l":{"i":21},"o":29,"r":{"e":{"c":[{"a":4},21],"d":21,"h":3},"o":[{"b":21},23]},"s":{"h":1},"t":{"i":{"b":13}},"u":{"t":[{"a":4},21]},"i":{"n":{"e":{"p":{"h":209}}}}},"q":[{"u":{"i":{"l":12,"s":91}}},29],"r":{"a":[{"b":0,"n":{"d":18},"r":3,"t":{"i":{".":18}}},2],"b":[{"l":1},25],"c":{"h":[{"e":1},3]},"e":{".":25,"a":{"l":23},"c":{"o":5},"i":{"n":11},"l":{".":4},"m":{"o":3},"n":{"a":4,"c":{"e":4},"e":18,"t":3},"q":0,"s":{"s":4,"t":3},"t":17},"h":2,"i":[{"a":[{"n":{".":210}},92],"c":{"k":32},"e":{"n":23,"r":0},"n":{"e":3},"o":29,"t":18,"u":1,"v":[{"a":21},0]},2],"m":93,"n":{"i":{"s":1,"t":18,"z":32},"o":3},"o":[{"b":4,"c":19,"r":0,"u":2},25],"s":[{"e":{"t":3}},2],"t":{"e":{"r":11},"l":18,"w":3},"u":[{"t":0},18],"w":{"a":{"u":32}}},"s":{"a":[{"g":{"e":{".":21,"s":21}}},72],"c":[{"a":[{"n":4},24],"r":23,"u":4},9],"e":[{"c":[{"r":4},24],"n":{"c":4},"r":{"t":{".":21,"s":21},"v":{"a":21}}},74],"h":[{"a":23,"e":{"n":5}},18],"i":[{"c":24,"d":[{"e":{"n":4}},24],"g":{"n":{"a":4}},"m":94,"n":95,"s":{"t":{"e":17}},"u":0},29],"k":{"i":{"n":19}},"m":{"i":1},"o":{"l":[{"u":3},24],"n":[{"a":4},24]},"p":[{"e":{"r":3},"i":{"r":{"a":4}},"r":{"e":1},"a":{"c":{"i":211}}},29],"s":[{"i":{"b":96}},25],"t":{"a":{"n":36},"i":{"g":3,"m":4},"o":[{"n":23},44],"r":[{"o":19,"u":{"c":10}},25]},"u":{"r":[{"r":4},24]},"w":1},"t":{"a":{"b":0},"e":{"n":{"d":17},"o":23},"h":{"o":{"d":54},"y":{"l":{"e":{"n":{"e":162}}}}},"i":{"c":2,"d":{"e":19},"n":[{"o":0},17],"r":19,"t":{"i":{"o":19,"v":4}}},"n":18,"o":{"n":{"a":4}},"r":{"a":23,"e":23,"i":{"c":3,"f":4},"o":{"g":3,"s":4}},"u":{"a":3},"y":{"m":4},"z":4},"u":[{"n":19,"p":23,"r":{"o":3},"s":0,"t":{"e":17,"i":{"l":6},"r":4},"c":{"l":{"i":{"d":212}}}},18],"v":{"a":{"p":97,"s":[{"t":4},24]},"e":{"a":19,"l":{"l":3,"o":12},"n":{"g":19,"i":17},"r":[{"b":19},2]},"i":[{"d":3,"l":0,"n":21,"v":0},29],"o":{"c":19},"u":19},"w":{"a":[{"g":21},29],"e":{"e":19},"h":23,"i":{"l":6,"n":{"g":3},"t":23}},"x":{"p":41},"y":{"c":32,"e":{".":32},"s":0}},"f":{"a":[{"b":{"l":3,"r":11},"c":{"e":1},"g":18,"i":{"n":17},"l":{"l":{"e":6}},"m":{"a":26,"i":{"s":5}},"r":[{"t":{"h":5}},32],"t":{"a":3,"h":{"e":3},"o":18},"u":{"l":{"t":7}}},41],"b":56,"d":18,"e":{".":18,"a":{"s":17,"t":{"h":54}},"b":[{"r":{"u":{"a":15}}},1],"c":{"a":18,"t":32},"d":25,"l":{"i":3},"m":{"o":1},"n":{"d":[{"e":6},8]},"r":[{"r":32,"m":{"i":{"o":213}}},15],"v":0},"f":[{"e":{"s":21},"i":{"e":21,"n":{".":19},"s":94},"l":{"y":21},"y":24},43],"h":18,"i":[{"a":3,"c":{".":48,"a":{"l":47,"n":23,"t":{"e":18}},"e":{"n":23,"r":3},"i":[{"a":32,"e":32},0],"s":18,"u":3,"h":27},"d":{"e":{"l":4}},"g":{"h":{"t":7}},"l":{"i":5,"l":{"i":{"n":6}},"y":18},"n":[{"a":32,"d":97,"e":9,"g":98,"n":0},25],"s":{"t":{"i":0}},"t":{"t":{"e":{"d":{".":5}}}}},41],"l":[{"e":{"s":{"s":19}},"i":{"n":17},"o":{"r":{"e":11},"w":{"e":{"r":{".":84}}}},"y":100,"a":{"g":{"e":{"l":214}}},"u":{"o":{"r":27}}},99],"m":18,"n":18,"o":[{"n":[{"d":{"e":0},"t":0},32],"r":[{"a":{"t":4,"y":5},"e":{"t":6},"i":0,"t":{"a":6}},9],"s":5},41],"p":56,"r":{"a":{"t":0},"e":{"a":19,"s":{"c":6}},"i":[{"l":17},8],"o":{"l":6}},"s":48,"t":[{"o":21,"y":24},25],"u":[{"e":{"l":4},"g":18,"m":{"i":{"n":1}},"n":{"e":4},"r":{"i":3},"s":{"i":17,"s":0},"t":{"a":18}},27],"y":41},"g":{"a":[{"f":0,"l":{".":32,"i":27,"o":3},"m":[{"e":{"t":4},"o":19},25],"n":{"i":{"s":5,"z":[{"a":6},3]},"o":18},"r":{"n":67},"s":{"s":17},"t":{"h":12,"i":{"v":18}},"z":18},41],"b":23,"d":1,"e":{".":25,"d":25,"e":{"z":17},"l":{"i":{"n":0,"s":4,"z":4},"y":18},"n":[{"a":{"t":1},"i":{"z":4},"o":18,"y":18,"c":{"y":{".":8}}},41],"o":[{"m":3,"d":215},41],"r":{"y":21},"s":{"i":32},"t":{"h":6,"o":18,"y":1,"i":{"c":{".":8}}},"v":1},"g":[{"e":[{"r":23},24],"l":{"u":6},"o":0},101],"h":{"i":{"n":3},"o":{"u":{"t":4}},"t":{"o":1,"w":{"e":15}}},"i":{".":32,"a":[{"r":5},102],"c":[{"i":{"a":32},"o":21},29],"e":{"n":6,"s":{".":32}},"l":0,"m":{"e":{"n":23}},"n":{".":68,"g":{"e":5},"s":103},"o":32,"r":[{"l":0},27],"s":{"l":23},"u":1,"v":32,"z":27},"l":[{"a":[{"d":{"i":6},"s":32},0],"e":[{"a":{"d":29}},41],"i":{"b":0,"g":23,"s":{"h":43}},"o":[{"r":11,"b":{"i":{"n":106}}},27]},9],"m":[{"y":21},29],"n":{"a":[{".":21,"c":69},1],"e":{"t":{"t":17,"i":{"s":{"m":137}}}},"i":[{"n":24,"o":21},29],"o":[{"n":21,"m":{"o":5},"r":{".":216,"e":{"s":{"p":24}}}},29]},"o":[{".":27,"b":5,"e":32,"g":104,"i":{"s":3},"n":[{"a":105,"d":{"o":7},"i":[{"z":{"a":217}},3]},8],"o":32,"r":{"i":{"z":4},"o":{"u":5}},"s":{".":32},"v":15},41],"p":23,"r":[{"a":{"d":{"a":18},"i":21,"n":84,"p":{"h":{".":32,"e":{"r":[{".":7},19]},"i":{"c":32},"y":18}},"y":18},"e":{"n":0,"s":{"s":{".":18}}},"i":{"t":18,"e":{"v":213}},"o":21,"u":{"f":17}},41],"s":[{"t":{"e":19}},9],"t":{"h":11},"u":{"a":[{"r":{"d":27}},1],"e":25,"i":{"t":106},"n":27,"s":27,"t":[{"a":{"n":29}},26]},"w":23,"y":[{"n":107,"r":{"a":4}},41]},"h":{"a":{"b":{"l":73},"c":{"h":17},"e":{"m":0,"t":0},"g":{"u":19},"l":{"a":[{"m":12},3]},"m":1,"n":{"c":{"i":0,"y":0},"d":{".":32},"g":[{"e":{"r":6},"o":6},0],"i":{"z":108},"k":0,"t":{"e":0}},"p":{"l":11,"t":5,"a":{"r":{"r":218}}},"r":{"a":{"n":3,"s":4},"d":[{"e":12},8],"l":{"e":0},"p":{"e":{"n":6}},"t":{"e":{"r":5}}},"s":{"s":5},"u":{"n":17},"z":[{"a":11},32],"i":{"r":{"s":137}},"t":{"c":{"h":213}}},"b":29,"e":{"a":{"d":41,"r":27},"c":{"a":{"n":1,"t":19}},"d":[{"o":13},21],"l":{"i":93,"l":{"i":{"s":0},"y":0},"o":19},"m":{"p":0},"n":[{"a":[{"t":5},17]},9],"o":{"r":5},"p":5,"r":{"a":[{"p":12},21],"b":{"a":0},"e":{"a":6},"n":23,"o":{"u":19},"y":23},"s":[{"p":64},29],"t":[{"e":{"d":0}},1],"u":0,"x":{"a":168}},"f":29,"h":29,"i":{"a":{"n":4},"c":{"o":1},"g":{"h":6},"l":109,"m":{"e":{"r":36}},"n":{"a":21},"o":{"n":{"e":17}},"p":[{"e":{"l":{"a":219}}},1],"r":{"l":0,"o":3,"p":0,"r":0},"s":{"e":{"l":11},"s":0},"t":{"h":{"e":{"r":6}},"e":{"s":{"i":{"d":12}}}},"v":9},"k":18,"l":[{"a":{"n":17},"o":[{"r":{"i":11}},24]},80],"m":[{"e":{"t":17}},43],"n":[{"a":{"u":{"z":12}}},42],"o":{"d":{"i":{"z":19},"s":19},"g":[{"e":17},1],"l":{"a":{"r":5},"e":110},"m":{"a":1,"e":12},"n":{"a":0,"y":4},"o":{"d":27,"n":17},"r":{"a":{"t":5},"i":{"s":4,"c":{".":187}},"t":{"e":12},"u":4},"s":{"e":[{"n":4},0],"p":15},"u":{"s":[{"e":54},41]},"v":{"e":{"l":5}}},"p":56,"r":[{"e":{"e":6},"o":{"n":{"i":{"z":5}},"p":{"o":11}}},26],"s":[{"h":21},101],"t":{"a":{"r":21},"e":{"n":2,"s":4,"o":{"u":216}},"y":21},"u":{"g":1,"m":{"i":{"n":1}},"n":{"k":{"e":5},"t":0},"s":{"t":14},"t":1},"w":[{"a":{"r":{"t":21}}},29],"y":{"p":{"e":3,"h":3,"o":{"t":{"h":{"a":137}}}},"s":9}},"i":{"a":[{"l":24,"m":[{"e":{"t":{"e":5}}},0],"n":[{"c":18,"i":11,"t":46},24],"p":{"e":4},"s":{"s":17},"t":{"i":{"v":21},"r":{"i":{"c":1}},"u":21}},42],"b":{"e":[{"r":{"a":3,"t":4}},0],"i":{"a":4,"n":3,"t":{".":4,"e":4}},"l":[{"i":3},29],"o":19,"r":[{"i":94},29],"u":{"n":19}},"c":{"a":{"m":18,"p":32,"r":[{".":21,"a":21},18],"s":6,"y":21},"c":{"u":17},"e":{"o":18},"h":18,"i":[{"d":19,"n":{"a":4},"p":[{"a":3},24]},25],"l":{"y":21},"o":{"c":94},"r":[{"a":32,"y":21},43],"t":{"e":1,"u":[{"a":111},84]},"u":{"l":{"a":3},"m":1,"o":4,"r":23}},"d":[{"a":{"i":21,"n":{"c":4}},"d":4,"e":{"a":{"l":11},"s":0},"i":[{"a":{"n":4,"r":0},"e":19,"o":[{"u":5,"s":1},3],"t":2,"u":4},24],"l":{"e":23},"o":{"m":21,"w":3},"r":21,"u":[{"o":4},24]},25],"e":[{"d":{"e":0},"g":{"a":113},"l":{"d":12},"n":{"a":67,"e":0,"n":19,"t":{"i":23}},"r":{".":29},"s":{"c":23,"t":29},"t":23},112],"f":{".":18,"e":{"r":{"o":4}},"f":{"e":{"n":5},"r":1},"i":{"c":{".":18},"e":23},"l":23,"t":18,"a":{"c":{"e":{"t":137}}}},"g":[{"a":{"b":5},"e":{"r":{"a":3}},"h":{"t":{"i":12}},"i":[{"b":23,"l":3,"n":3,"t":3},18],"l":28,"o":[{"r":3,"t":4},24],"r":{"e":19},"u":{"i":5,"r":2},"n":{"i":{"t":[{"e":{"r":213}},0]}}},25],"h":23,"i":114,"j":[{"k":21},23],"k":18,"l":{"a":[{"b":93,"d":{"e":21},"m":94,"r":{"a":5}},29],"e":{"g":23,"r":2,"v":17},"f":4,"i":[{"a":3,"b":9,"o":3,"s":{"t":1},"t":25,"z":9},2],"l":{"a":{"b":5}},"n":18,"o":{"q":3},"t":{"y":1},"u":{"r":4},"v":3},"m":{"a":{"g":[{"e":3},21],"r":{"y":5}},"e":{"n":{"t":{"a":{"r":10}}},"t":18},"i":[{"d":{"a":4},"l":{"e":5},"n":{"i":19},"t":18},2],"n":{"i":1},"o":{"n":23},"u":[{"l":{"a":3}},24],"p":{"e":{"d":{"a":201}}}},"n":{".":25,"a":{"u":83,"v":18},"c":{"e":{"l":36,"r":3}},"d":[{"l":{"i":{"n":{"g":4}}}},18],"e":[{"e":23,"r":{"a":{"r":17}},"s":{"s":19}},25],"g":{"a":18,"e":[{"n":4},18],"i":18,"l":{"i":{"n":{"g":4}}},"o":18,"u":18},"i":[{".":19,"a":21,"o":3,"s":2,"t":{"e":{".":19,"l":{"y":{".":19}}},"i":{"o":32},"y":3}},25],"k":18,"l":18,"n":25,"o":[{"c":90,"s":0,"t":21},42],"s":[{"e":3,"u":{"r":{"a":7}}},25],"t":{".":25,"h":112},"u":[{"s":19},2],"y":18,"f":{"r":{"a":{"s":220}}}},"o":[{".":18,"g":{"e":17,"r":9},"l":29,"m":1,"n":{"a":{"t":11},"e":{"r":{"y":0}},"i":11},"p":{"h":4},"r":{"i":11},"s":21,"t":{"h":4,"i":19,"o":1},"u":{"r":21}},25],"p":[{"e":0,"h":{"r":{"a":{"s":115}}},"i":[{"c":1},3],"r":{"e":96},"u":{"l":3}},25],"q":{"u":{"a":23,"e":{"f":4},"i":{"d":3,"t":116}}},"r":[{"a":[{"b":0,"c":21},29],"d":{"e":5},"e":{"d":{"e":0},"f":21,"l":117,"s":21},"g":{"i":4},"i":[{"d":{"e":5},"s":1,"t":{"u":11},"z":118},2],"m":{"i":{"n":1}},"o":{"g":0,"n":{".":32}},"u":{"l":4},"r":{"e":{"v":{"o":{"c":221}}}}},18],"s":{".":25,"a":{"g":4,"r":3,"s":6},"c":[{"h":3},119],"e":[{"r":3},18],"f":27,"h":{"a":{"n":4},"o":{"n":3,"p":5}},"i":{"b":3,"d":0,"s":19,"t":{"i":{"v":4}}},"k":26,"l":{"a":{"n":36}},"m":{"s":18},"o":[{"m":{"e":{"r":5}}},24],"p":[{"i":9,"y":1},2],"s":[{"a":{"l":1},"e":{"n":36,"s":1}},62],"t":{"a":{".":1},"e":2,"i":2,"l":{"y":0},"r":{"a":{"l":18}}},"u":[{"s":4},24]},"t":{"a":{".":18,"b":{"i":0},"g":21,"m":120,"n":23,"t":23},"e":[{"r":{"a":3,"i":19},"s":[{"i":{"m":{"a":29}}},1]},25],"h":[{"i":{"l":148}},25],"i":[{"a":18,"c":[{"a":3,"k":31},22],"g":3,"l":{"l":4},"m":24,"o":25,"s":[{"m":21},18],"n":{"e":{"r":{"a":{"r":158}}}}},29],"o":{"m":121,"n":18},"r":{"a":{"m":21},"y":4},"t":18,"u":{"a":{"t":3},"d":19,"l":3},"z":{".":18}},"u":29,"v":[{"e":{"l":{"l":3},"n":{".":3},"r":{".":83,"s":{".":21}}},"i":{"l":{".":4},"o":4,"t":2},"o":{"r":{"e":19,"o":35},"t":83}},25],"w":56,"x":{"o":1},"y":18,"z":{"a":{"r":18},"i":0,"o":{"n":{"t":32}}}},"j":{"a":[{"c":{"q":0},"p":[{"a":{"n":{"e":{"s":220}}}},1],"n":{"u":{"a":12}}},32],"e":[{"r":{"s":5,"e":{"m":222}},"s":{"t":{"i":{"e":18},"y":18}},"w":11},41],"o":{"p":1},"u":{"d":{"g":32}}},"k":{"a":{".":27,"b":23,"g":19,"i":{"s":17},"l":0},"b":29,"e":{"d":24,"e":41,"g":1,"l":{"i":[{"n":{"g":223}},4]},"n":{"d":73},"r":29,"s":[{"t":{".":23}},0],"t":{"y":1}},"f":23,"h":1,"i":[{".":32,"c":122,"l":{"l":21,"o":6},"m":21,"n":{".":21,"d":{"e":0},"e":{"s":{"s":19},"t":{"i":{"c":224}}},"g":0},"p":1,"s":[{"h":19},0]},29],"k":1,"l":[{"e":{"y":18},"y":18},29],"m":29,"n":{"e":{"s":19},"o":69},"o":{"r":4,"s":{"h":17},"u":23,"v":{"i":{"a":{"n":41}}}},"r":{"o":{"n":5}},"s":[{"c":21,"l":1,"y":21,"h":{"a":23}},101],"t":19,"w":29},"l":{"a":{"b":{"i":{"c":11},"o":21},"c":{"i":[{"e":225},17]},"d":{"e":21,"y":3},"g":{"n":0},"m":{"o":11},"n":{"d":[{"l":0},27],"e":{"t":5},"t":{"e":0}},"r":{"g":0,"i":11,"c":{"e":{"n":176}}},"s":{"e":0},"t":{"a":{"n":4},"e":{"l":{"i":18}},"i":{"v":18}},"v":[{"a":95},18],"i":{"n":{"e":{"s":{"s":226}}}}},"b":[{"i":{"n":17}},42],"c":[{"e":0,"i":23,"h":{"a":{"i":23},"i":{"l":{"d":227}}}},101],"d":[{"e":[{"r":{"e":1,"i":1}},24],"i":[{"s":4},0],"r":[{"i":21},23]},25],"e":{"a":[{"d":{"e":{"r":{".":183}}},"s":{"a":228}},9],"b":{"i":1},"f":{"t":6},"g":{".":32,"g":32,"e":{"n":{"d":{"r":{"e":230}}}}},"m":{"a":{"t":[{"i":{"c":5}},1]}},"n":{".":18,"c":27,"e":{".":32},"t":41,"o":{"i":{"d":78}}},"p":{"h":3,"r":1},"r":{"a":{"b":6},"e":0,"g":27,"i":68,"o":21},"s":[{"c":{"o":4},"q":32,"s":[{".":32},27]},8],"v":{"a":23,"e":{"r":{".":0,"a":0,"s":0}}},"y":[{"e":18},27],"c":{"t":{"a":{"b":229}}}},"f":[{"r":19},25],"g":[{"a":[{"r":12},19],"e":{"s":21},"o":11},80],"h":48,"i":{"a":{"g":1,"m":9,"r":{"i":{"z":6}},"s":1,"t":{"o":1}},"b":{"i":4},"c":{"i":{"o":32},"o":{"r":1},"s":18,"t":{".":18},"u":21,"y":23},"d":{"a":23,"e":{"r":5},"i":27},"f":{"e":{"r":11},"f":21,"l":1},"g":{"a":{"t":{"e":32}},"h":27,"r":{"a":1}},"k":27,"l":123,"m":{"b":{"l":0},"i":11,"o":1,"p":90},"n":{"a":21,"e":[{"a":11},124],"i":11,"k":{"e":{"r":6}}},"o":{"g":4},"q":125,"s":{"p":0},"t":[{".":24,"i":{"c":{"a":32,"s":108}},"h":{"o":{"g":204}}},29],"v":{"e":{"r":11}},"z":29},"j":18,"k":{"a":[{"l":23,"t":0},11]},"l":[{"a":{"w":21},"e":[{"a":19,"c":23,"g":23,"l":23,"n":73,"t":73},24],"i":[{"n":[{"a":19},126],"s":{"h":231}},9],"o":[{"q":{"u":{"i":10}},"u":{"t":4},"w":19},1],"f":{"l":2}},29],"m":[{"e":{"t":19},"i":{"n":{"g":3}},"o":{"d":21,"n":[{"e":{"l":{"l":232}}},17]}},25],"n":81,"o":{".":27,"b":{"a":{"l":5},"o":{"t":{"o":233}}},"c":{"i":1},"f":18,"g":{"i":{"c":27},"o":19,"u":27,"e":{"s":{".":9}}},"m":{"e":{"r":11}},"n":{"g":32,"i":[{"z":127},0]},"o":{"d":6},"p":{"e":{".":32},"i":11,"m":23},"r":{"a":[{"t":{"o":1}},17],"i":{"e":4},"o":{"u":5}},"s":{".":32,"e":{"t":5},"o":{"p":{"h":{"i":{"z":32},"y":32}}},"t":0},"t":{"a":1},"u":{"n":{"d":6},"t":25},"v":18,"a":{"d":{"e":{"d":{".":17},"r":{".":183}}}}},"p":[{"a":{"b":5},"h":{"a":23,"i":19},"i":{"n":{"g":4},"t":23},"l":21,"r":19},25],"r":43,"s":[{"c":21,"e":24,"i":{"e":21}},81],"t":[{"a":{"g":4,"n":{"e":7}},"e":[{"n":17,"r":{"a":36},"a":23},29],"h":{"i":[{"l":{"y":148}},11]},"i":{"e":{"s":{".":19}},"s":17},"r":29,"u":[{"r":{"a":12}},8]},18],"u":{"a":4,"b":{"r":3},"c":{"h":17,"i":3},"e":{"n":3,"p":15},"f":0,"i":{"d":4},"m":{"a":1,"i":32,"n":{".":19,"i":{"a":32}},"b":{"i":{"a":{".":235}}}},"o":[{"r":11},3],"p":18,"s":{"s":17,"t":{"e":11}},"t":41,"n":{"k":{"e":{"r":234}}}},"v":{"e":{"n":19,"t":128}},"w":42,"y":[{"a":18,"b":18,"m":{"e":4},"n":{"o":3},"s":[{"e":19,"t":{"y":{"r":4}}},58],"g":{"a":{"m":{"i":236}}}},41]},"m":{"a":[{"b":25,"c":{"a":9,"h":{"i":{"n":{"e":4}}},"l":1},"g":{"i":{"n":5},"n":32},"h":25,"i":{"d":6},"l":{"d":18,"i":{"g":3,"n":4},"l":{"i":0},"t":{"y":0},"a":{"p":222}},"n":{"i":{"a":32,"s":5,"z":11},".":24,"u":{"s":{"c":237}}},"p":[{"h":{"r":{"o":244}}},18],"r":{"i":{"n":{"e":{".":4}},"z":4},"l":{"y":0},"v":11,"g":{"i":{"n":238}}},"s":{"c":{"e":4},"e":0,"t":15},"t":{"e":32,"h":12,"i":{"s":3,"z":{"a":18}}}},41],"b":[{"a":{"t":129},"i":{"l":19,"n":{"g":83},"v":0}},43],"c":56,"e":{".":18,"d":[{".":18,"i":{"a":32,"e":3,"c":[{"i":{"n":152}},84],"o":{"c":239}},"y":108},25],"g":[{"r":{"a":{"n":240}}},9],"l":{"o":{"n":5},"t":0},"m":[{"o":130},9],"n":[{"a":[{"c":5},0],"d":{"e":0},"e":18,"i":0,"s":[{"u":7},17],"t":[{"e":0},27],".":24},41],"o":{"n":4},"r":{"s":{"a":19}},"s":[{"t":{"i":27}},25],"t":{"a":[{"l":11},1],"e":2,"h":{"i":4},"r":[{"i":{"c":32,"e":4},"y":3},21]},"v":1},"f":43,"h":25,"i":{".":32,"a":3,"d":{"a":[{"b":241},0],"g":0},"g":0,"l":{"i":{"a":27,"e":108,"t":{"a":27}},"l":[{"a":{"g":208},"i":{"l":{"i":59}}},21]},"n":{"a":0,"d":27,"e":{"e":19},"g":{"l":[{"i":5,"y":19},21]},"t":0,"u":[{"t":{"e":{"r":242,"s":{"t":242}}}},21],"i":{"s":{".":174}}},"o":{"t":17},"s":[{"e":{"r":{".":0}},"l":5,"t":{"i":0,"r":{"y":19}}},24],"t":{"h":18},"z":24},"k":18,"l":43,"m":[{"a":{"r":{"y":5},"b":243}},29],"n":[{"a":1,"i":{"n":21},"o":1},43],"o":[{"c":{"r":[{"a":{"t":[{"i":{"z":32}},245]}},18]},"d":131,"g":{"o":1},"i":{"s":[{"e":5},84]},"k":18,"l":{"e":{"s":{"t":4},"c":246}},"m":{"e":3},"n":{"e":{"t":5,"y":{"l":247}},"g":{"e":5},"i":{"a":12,"s":{"m":0,"t":0},"z":3},"o":{"l":36,"c":{"h":12},"e":{"n":171},"s":249},"y":{".":3}},"r":[{"a":{".":18},"o":{"n":{"i":{"s":248}}}},9],"s":[{"e":{"y":4},"p":3},8],"t":{"h":[{"e":{"t":250}},12]},"u":{"f":19,"s":[{"i":{"n":98}},27]},"v":9,"e":{"l":{"a":{"s":167}}}},41],"p":[{"a":{"r":{"a":[{"b":5},7],"i":6}},"e":{"t":23},"h":{"a":{"s":36}},"i":[{"a":0,"e":{"s":4},"n":34,"r":19,"s":4},24],"o":{"r":{"i":11},"s":{"i":{"t":{"e":6}}},"u":{"s":21},"v":6},"t":{"r":1},"y":24},43],"r":47,"s":[{"h":[{"a":{"c":{"k":251}}},21],"i":19},101],"t":18,"u":[{"l":{"a":{"r":49},"t":[{"i":[{"u":252},54]},32]},"m":27,"n":8,"p":18,"u":1,"d":{"r":{"o":9}}},41],"w":18},"n":{"a":[{"b":[{"u":21},81],"c":{".":18,"a":1,"t":19},"g":{"e":{"r":{".":5}}},"k":0,"l":{"i":[{"a":4},1],"t":18},"m":{"i":{"t":4}},"n":[{"c":{"i":36},"i":{"t":0},"k":17},24],"r":{"c":[{"h":{"s":{".":73}}},11],"e":18,"i":11,"l":0,"m":19},"s":[{"c":0,"t":{"i":5}},21],"t":[{"a":{"l":3},"o":{"m":{"i":{"z":6}}}},24],"u":[{"s":{"e":11},"t":27},24],"v":{"e":0}},41],"b":80,"c":{"a":{"r":6},"e":{"s":{".":21}},"h":{"a":23,"e":{"o":19,"s":{"t":253}},"i":{"l":19,"s":23}},"i":{"n":2,"t":1},"o":{"u":{"r":{"a":7}}},"r":29,"u":29},"d":{"a":{"i":21,"n":19},"e":[{"s":{"t":{".":4}}},29],"i":{"b":0,"f":79,"t":29,"z":23,"e":{"c":{"k":29}}},"u":{"c":19,"r":0},"w":{"e":9},"t":{"h":{"r":3}}},"e":{".":25,"a":{"r":23},"b":[{"u":11,"a":{"c":{"k":3}}},9],"c":[{"k":32},9],"d":25,"g":{"a":{"t":[{"i":{"v":5}},1]},"e":32},"l":{"a":1,"i":{"z":5}},"m":{"i":4,"o":1},"n":[{"e":18},41],"o":27,"p":{"o":1},"q":9,"r":[{"a":{"b":6,"r":21},"e":24,"i":132,"r":0},29],"s":[{".":25,"p":18,"t":25,"w":18,"k":{"i":119}},41],"t":{"i":{"c":27}},"v":[{"e":19},1],"w":1},"f":[{"i":{"n":{"i":{"t":{"e":{"s":226}}}}}},23],"g":{"a":{"b":21},"e":{"l":23,"n":{"e":[{"s":5},133]},"r":{"e":19,"i":23}},"h":{"a":4,"o":2},"i":{"b":23,"n":2,"t":19},"l":{"a":21},"o":{"v":17},"s":{"h":4,"p":{"r":2}},"u":[{"m":21},29],"y":24},"h":[{"a":[{"b":12},0],"e":0},80],"i":{"a":[{"n":[{".":114},3],"p":1},68],"b":{"a":3,"l":1},"d":[{"i":4},1],"e":{"r":1},"f":{"i":[{"c":{"a":{"t":4}}},9]},"g":{"r":19},"k":0,"m":[{"i":{"z":3}},29],"n":[{"e":{".":32},"g":0},29],"o":1,"s":{".":32,"t":{"a":0}},"t":[{"h":21,"i":{"o":27},"o":{"r":23},"r":3},24]},"j":29,"k":[{"e":{"r":{"o":19},"t":23},"i":{"n":3},"l":29,"r":{"u":{"p":3}}},44],"l":[{"e":{"s":{"s":19}}},43],"m":[{"e":[{"t":17},0]},19],"n":[{"e":0,"i":{"a":{"l":11},"v":0}},101],"o":{"b":{"l":[{"e":3},0]},"c":{"l":19,"e":{"r":{"o":{"s":254}}}},"d":66,"e":27,"g":[{"e":17},18],"i":{"s":{"i":6}},"l":{"i":134,"o":{"g":{"i":{"s":32}}}},"m":{"i":{"c":27,"z":108,"s":{"t":82}},"o":1,"y":3,"a":{"l":214},"e":{"n":{"o":194}}},"n":[{"a":{"g":0},"i":[{"z":19,"s":{"o":255}},5],"e":{"q":15}},1],"p":[{"o":{"l":{"i":135,"y":{".":256}}}},18],"r":{"a":{"b":5,"r":{"y":1}}},"s":{"c":18,"e":0,"t":5},"t":{"a":4},"u":[{"n":27},41],"v":{"e":{"l":136,"m":{"b":2}}},"w":{"l":12}},"p":[{"i":0,"r":{"e":{"c":17}}},72],"q":29,"r":[{"u":0},29],"s":[{"a":{"b":4,"t":{"i":36}},"c":[{"e":{"i":{"v":4}}},1],"e":[{"s":83},24],"i":{"d":137,"g":17},"l":24,"m":[{"o":{"o":1}},3],"o":{"c":21},"p":{"e":1,"i":19},"t":{"a":{"b":{"l":6}}}},81],"t":[{"a":{"b":0},"e":{"r":{"s":12}},"i":[{"b":19,"e":{"r":0},"f":8,"n":{"e":23,"g":83},"p":0},9],"r":{"o":{"l":{"l":{"i":7}}},"e":{"p":137}},"s":1,"u":{"m":{"e":11}}},29],"u":{"a":2,"d":1,"e":{"n":4},"f":{"f":{"e":0}},"i":{"n":23,"t":50},"m":[{"e":2,"i":19},21],"n":138,"o":23,"t":{"r":3}},"v":74,"w":72,"y":{"m":0,"p":0},"z":[{"a":23},18]},"o":{"a":[{"d":11,"l":{"e":{"s":108}},"r":{"d":12},"s":{"e":0,"t":{"e":6}},"t":{"i":5}},18],"b":{"a":{"b":35,"r":19},"e":{"l":0},"i":[{"n":[{"g":4},24]},29],"r":23,"u":{"l":3},"l":{"i":{"g":189}}},"c":{"e":29,"h":[{"e":{"t":23},"a":{"s":23}},0],"i":{"f":12,"l":21},"l":{"a":{"m":21}},"o":{"d":21},"r":{"a":{"c":3,"t":{"i":{"z":4}}},"e":12,"i":{"t":32}},"t":{"o":{"r":{"a":7}}},"u":{"l":{"a":3},"r":{"e":19}}},"d":{"d":{"e":{"d":4}},"i":{"c":3,"o":11,"t":{"i":{"c":137}}},"o":[{"r":12},139],"u":{"c":{"t":{".":4,"s":4}}},"e":{"l":{"l":{"i":12}}}},"e":{"l":21,"n":{"g":19},"r":[{"s":{"t":257}},23],"t":{"a":1},"v":23},"f":{"i":[{"t":{"e":4,"t":17}},24]},"g":{"a":{"r":121,"t":{"i":{"v":4},"o":21}},"e":[{"n":{"e":19},"o":19,"r":21},29],"i":{"e":23,"s":140,"t":3},"l":[{"y":79},21],"n":{"i":{"z":27}},"r":{"o":21},"u":{"i":5},"y":[{"n":25},41]},"h":[{"a":{"b":6}},74],"i":[{"c":{"e":{"s":11}},"d":{"e":{"r":3}},"f":{"f":17},"g":0,"l":{"e":{"t":4}},"n":{"g":23,"t":{"e":{"r":6}}},"s":{"m":19,"o":{"n":4},"t":{"e":{"n":6}}},"t":{"e":{"r":3}}},9],"j":19,"k":[{"e":{"n":23,"s":{"t":15}},"i":{"e":4}},25],"l":{"a":[{"n":21,"s":{"s":36}},29],"d":[{"e":15},9],"e":{"r":3,"s":{"c":23,"t":{"e":{"r":88}}},"t":23},"f":{"i":1},"i":[{"a":23,"c":{"e":23},"d":{".":4},"f":73,"l":19,"n":{"g":3},"o":19,"s":{".":19,"h":3},"t":{"e":19,"i":{"o":19}},"v":19,"g":{"o":{"p":{"o":258}}}},9],"l":{"i":{"e":17}},"o":{"g":{"i":{"z":4}},"r":0,"n":{"o":{"m":259}}},"p":{"l":4},"t":9,"u":{"b":3,"m":{"e":3},"n":3,"s":19},"v":9,"y":24},"m":{"a":{"h":4,"l":5,"t":{"i":{"z":4}}},"b":{"e":9,"l":1},"e":[{"n":{"a":3},"r":{"s":{"e":4}},"t":[{"r":{"y":4}},21],"c":{"h":{"a":260}}},24],"i":{"a":23,"c":{".":3,"a":3},"d":19,"n":[{"i":19},2]},"m":{"e":{"n":{"d":32}}},"o":{"g":{"e":0},"n":21},"p":{"i":3,"r":{"o":7}}},"n":[{"a":[{"c":1,"n":23},2],"c":[{"i":{"l":27}},2],"d":[{"o":4},25],"e":{"n":23,"s":{"t":4}},"g":{"u":1},"i":{"c":2,"o":23,"s":2,"u":19},"k":{"e":{"y":3}},"o":{"d":{"i":1},"m":{"y":3,"i":{"c":137}},"r":{"m":{"a":23}},"t":{"o":{"n":261}},"u":23},"s":[{"p":{"i":[{"r":{"a":10}},36]},"u":17},3],"t":{"e":{"n":36},"i":[{"f":7},93]},"u":{"m":4},"v":{"a":6}},24],"o":[{"d":{"e":5,"i":5},"k":1,"p":{"i":11},"r":{"d":23},"s":{"t":6}},9],"p":{"a":24,"e":{"d":5,"r":[{"a":[{"g":18},27]},2]},"h":[{"a":{"n":19},"e":{"r":19}},25],"i":{"n":{"g":3},"t":23,"s":{"m":{".":2}}},"o":{"n":19,"s":{"i":21}},"r":29,"u":2,"y":5},"q":29,"r":{"a":[{".":19,"g":83,"l":{"i":{"z":4}},"n":{"g":{"e":4}}},29],"e":{"a":[{"l":19},5],"i":3,"s":{"h":5,"t":{".":4}},"w":17},"g":{"u":1},"i":{"a":56,"c":{"a":3},"l":19,"n":2,"o":29,"t":{"y":3},"u":23},"m":{"i":9},"n":{"e":8},"o":{"f":19,"u":{"g":3}},"p":{"e":4},"r":{"h":27},"s":{"e":[{"n":5},1],"t":17},"t":{"h":{"i":3,"y":3,"o":{"n":{"i":{"t":262}}},"r":{"i":137}},"y":1,"i":{"v":{"e":{"l":{"y":4}}}}},"u":{"m":19},"y":29},"s":{"a":{"l":3},"c":[{"e":1,"o":{"p":[{"i":18},23]},"r":19},9],"i":{"e":95,"t":{"i":{"v":4},"o":3,"y":3},"u":0},"l":1,"o":24,"p":{"a":1,"o":1,"h":{"e":{"r":83}}},"t":{"a":[{"t":{"i":19}},9],"i":{"l":4,"t":4}}},"t":{"a":{"n":21},"e":{"l":{"e":{"g":36}},"r":{".":3,"s":4},"s":[{"t":{"e":{"r":263},"o":{"r":264}}},21]},"h":[{"e":{"s":{"i":5},"o":{"s":265}},"i":14},18],"i":{"c":{".":3,"a":4,"e":23},"f":23,"s":23},"o":{"s":5}},"u":[{"b":{"l":3,"a":{"d":{"o":116}}},"c":{"h":{"i":6}},"e":{"t":4},"l":1,"n":{"c":{"e":{"r":6}},"d":8},"v":4},9],"v":{"e":{"n":1,"r":{"n":{"e":17},"s":12,"t":1}},"i":{"s":23,"t":{"i":36},"a":{"n":{".":266}}},"o":{"l":60}},"w":{"d":{"e":{"r":3}},"e":{"l":3,"s":{"t":4}},"i":2,"n":{"i":5},"o":21},"y":{"a":2},"x":{"i":{"d":{"i":{"c":267}}}}},"p":{"a":[{"c":{"a":1,"e":1,"t":0},"d":21,"g":{"a":{"n":32,"t":23}},"i":[{"n":17},21],"l":[{"m":{"a":{"t":268}}},21],"n":{"a":0,"e":{"l":11},"t":{"y":0},"y":3},"p":[{"u":1},2],"r":{"a":{"b":{"l":6},"g":{"e":5,"r":{"a":269}},"l":{"e":228},"m":[{"e":12},36]},"d":{"i":5},"e":[{"l":5},27],"i":[{"s":0},28]},"t":{"e":[{"r":4},9],"h":{"i":{"c":32},"y":4},"r":{"i":{"c":1}}},"v":0,"y":27},41],"b":43,"d":1,"e":{".":18,"a":[{"r":{"l":17}},138],"c":9,"d":[{"e":27,"i":[{"a":36,"c":0},27]},37],"e":[{"d":0,"v":208},21],"k":0,"l":{"a":1,"i":{"e":17}},"n":{"a":{"n":1},"c":21,"t":{"h":0}},"o":{"n":4},"r":{"a":{".":21,"b":{"l":6},"g":21},"i":[{"s":{"t":6}},21],"m":{"a":{"l":0},"e":7},"n":21,"o":11,"t":{"i":11},"u":4,"v":15},"t":[{"e":{"n":4},"i":{"z":4}},9]},"f":18,"g":18,"h":{".":18,"a":{"r":{"i":6}},"e":{"n":{"o":11},"r":1,"s":{".":1}},"i":{"c":2,"e":32,"n":{"g":4},"s":{"t":{"i":32}},"z":27,"l":{"a":{"n":{"t":168},"t":{"e":{"l":270}}}}},"l":9,"o":{"b":27,"n":{"e":27,"i":32},"r":0},"s":18,"t":3,"u":32,"y":41},"i":{"a":[{"n":17},3],"c":{"i":{"e":1},"y":1,"a":{"d":271}},"d":[{"a":19,"e":3,"i":32},21],"e":{"c":27,"n":3},"g":{"r":{"a":{"p":1}}},"l":{"o":3},"n":[{".":21,"d":17,"o":21},9],"o":[{"n":17},141],"t":{"h":[{"a":4},23],"u":9}},"k":142,"l":[{"a":{"n":27,"s":{"t":6}},"i":{"a":11,"e":{"r":5},"g":18,"n":[{"a":{"r":5}},0],"c":{"a":{"b":208}}},"o":{"i":17},"u":{"m":[{"b":17},0]}},143],"m":43,"n":48,"o":{"c":1,"d":{".":32},"e":{"m":4,"t":144},"g":145,"i":{"n":[{"t":32,"c":{"a":12}},84]},"l":{"y":{"t":6,"e":137,"p":{"h":{"o":{"n":{"o":272}}}}},"e":{".":41}},"n":{"i":1},"p":1,"r":[{"y":1},124],"s":[{"s":15},41],"t":[{"a":1},21],"u":{"n":32}},"p":[{"a":{"r":{"a":5}},"e":[{"d":21,"l":19,"n":23,"r":23,"t":23},24],"o":{"s":{"i":{"t":{"e":5}}}}},43],"r":[{"a":{"y":{"e":17}},"e":{"c":{"i":32,"o":5},"e":{"m":11},"f":{"a":{"c":6}},"l":{"a":0},"r":11,"s":{"e":23,"s":27,"p":{"l":{"i":84}}},"t":{"e":{"n":5}},"v":11,"m":{"a":{"c":273}},"n":{"e":{"u":15}}},"i":{"e":53,"n":{"t":146},"s":[{"o":12},0]},"o":{"c":{"a":23,"e":{"s":{"s":8}},"i":{"t":{"y":{".":274}}}},"f":{"i":{"t":6}},"l":11,"s":{"e":12},"t":15,"g":{"e":208}}},9],"s":[{"e":[{"u":{"d":[{"o":{"d":276,"f":276}},275]}},24],"h":1,"i":{"b":21}},81],"t":[{"a":{"b":134},"e":24,"h":24,"i":{"m":11},"u":{"r":0},"w":21,"o":{"m":{"a":{"t":277}}},"r":{"o":{"l":278}}},42],"u":{"b":[{"e":{"s":{"c":181}}},11],"e":0,"f":0,"l":{"c":11},"m":1,"n":9,"r":{"r":0},"s":32,"t":[{"e":[{"r":11},32],"r":3,"t":{"e":{"d":0},"i":{"n":0}}},9]},"w":23},"q":{"u":[{"a":{"v":5,"i":{"n":{"t":{"e":279}}},"s":{"i":[{"r":281,"s":281},280]}},"e":{".":25,"r":27,"t":27},"i":{"n":{"t":{"e":{"s":{"s":282}}}},"v":{"a":{"r":14}}}},9]},"r":{"a":{"b":[{"i":3,"o":{"l":{"i":{"c":29},"o":{"i":236}}}},25],"c":{"h":{"e":17,"u":3},"l":19},"f":{"f":{"i":5},"t":0},"i":24,"l":{"o":1},"m":{"e":{"t":[{"r":{"i":{"z":283}}},11],"n":24},"i":24,"o":{"u":3}},"n":{"e":{"o":6},"g":{"e":0},"i":21,"o":4,"h":{"a":{"s":167}}},"p":{"e":{"r":11},"h":{"y":27}},"r":{"c":5,"e":[{"f":5},17],"i":{"l":18}},"s":24,"t":{"i":{"o":{"n":115}}},"u":{"t":0},"v":{"a":{"i":4},"e":{"l":11}},"z":{"i":{"e":4}},"d":{"i":{"g":127,"o":{"g":249}}},"o":{"r":2}},"b":[{"a":{"b":21,"g":21},"i":[{"f":0,"n":[{"e":19,"g":{".":4,"e":284}},24]},8],"o":1},29],"c":[{"e":[{"n":17},24],"h":{"a":23,"e":{"r":0}},"i":{"b":90,"t":1},"u":{"m":12}},29],"d":{"a":{"l":21},"i":[{"a":0,"e":{"r":0},"n":[{"g":3},17]},9]},"e":{".":25,"a":{"l":2,"n":3,"r":{"r":4},"v":32,"w":1},"b":{"r":{"a":{"t":19}}},"c":{"o":{"l":{"l":5},"m":{"p":{"e":5}}},"r":{"e":1},"i":{"p":{"r":285}},"t":{"a":{"n":{"g":286}}}},"d":[{"e":2,"i":{"s":3,"t":5}},37],"f":{"a":{"c":1},"e":[{"r":{".":4}},9],"i":3,"y":1},"g":{"i":{"s":11}},"i":{"t":4},"l":{"i":2,"u":4},"n":{"t":{"a":90,"e":0}},"o":2,"p":{"i":{"n":4},"o":{"s":{"i":1}},"u":2},"r":[{"i":21,"o":17,"u":4},147],"s":{".":21,"p":{"i":1},"s":{"i":{"b":6}},"t":[{"a":{"l":4},"r":3},8]},"t":{"e":{"r":1},"i":{"z":96},"r":{"i":[{"b":{"u":85}},3]}},"u":[{"t":{"i":4}},8],"v":[{"a":{"l":1},"e":{"l":11,"r":{".":30,"s":4,"t":4}},"i":{"l":4},"o":{"l":{"u":5}}},8],"w":{"h":1}},"f":[{"u":0,"y":21},29],"g":[{"e":{"r":3,"t":23},"i":{"c":23,"n":[{"g":3},0],"s":19,"t":19},"l":29,"o":{"n":0},"u":23},9],"h":[{".":18,"a":{"l":18}},1],"i":{"a":[{"b":0,"g":1,"l":{".":23}},3],"b":[{"a":11},21],"c":{"a":{"s":5},"e":21,"i":[{"d":32,"e":1},18],"o":21},"d":{"e":{"r":5}},"e":{"n":{"c":3,"t":3},"r":2,"t":4},"g":{"a":{"n":5},"i":32},"l":{"i":{"z":11}},"m":{"a":{"n":32},"i":5,"o":27,"p":{"e":0}},"n":{"a":[{".":32},24],"d":0,"e":0,"g":0},"o":2,"p":{"h":[{"e":6},32],"l":[{"i":{"c":5}},9]},"q":21,"s":[{".":21,"c":0,"h":23,"p":0},24],"t":{"a":{"b":116},"e":{"d":{".":19},"r":{".":5,"s":5}},"i":{"c":11},"u":[{"r":5},9]},"v":{"e":{"l":5,"t":11},"i":11,"o":{"l":287}}},"j":23,"k":{"e":{"t":23},"l":{"e":1,"i":{"n":1}},".":288,"h":{"o":2},"r":{"a":{"u":29}},"s":{".":288}},"l":[{"e":[{"d":24,"q":{"u":30}},0],"i":{"g":21,"s":[{"h":4},21]},"o":73},29],"m":[{"a":{"c":5},"e":[{"n":23,"r":{"s":4}},24],"i":{"n":{"g":[{".":21},3]},"o":21,"t":23},"y":21},29],"n":{"a":{"r":21},"e":{"l":23,"r":21,"t":19,"y":23},"i":{"c":19,"s":92,"t":23,"v":23},"o":[{"u":21},0],"u":23},"o":{"b":{"l":11,"o":{"t":289}},"c":[{"r":3},24],"e":[{"l":{"a":{"s":167}},"p":{"i":{"d":{"e":290}}}},1],"f":{"e":2,"i":{"l":4}},"k":[{"e":{"r":4}},8],"l":{"e":{".":32}},"m":{"e":{"t":{"e":5},"s":{"h":3}},"i":0,"p":0},"n":{"a":{"l":0},"e":0,"i":{"s":134},"t":{"a":0}},"o":{"m":41,"t":32},"p":{"e":{"l":3},"i":{"c":11}},"r":{"i":11,"o":4},"s":{"p":{"e":{"r":5}},"s":0},"t":{"h":{"e":1},"y":1,"r":{"o":{"n":2}}},"v":{"a":1,"e":{"l":5}},"x":5},"p":[{"e":{"a":21,"n":{"t":19},"r":{".":4},"t":23},"h":95,"i":{"n":{"g":3}},"o":23,"a":{"u":{"l":{"i":291}}}},29],"r":[{"e":{"c":0,"f":0,"o":21,"s":{"t":0}},"i":{"o":0,"v":0},"o":{"n":17,"s":17},"y":{"s":17}},72],"s":[{"a":[{"t":{"i":5}},29],"c":1,"e":[{"c":[{"r":0},23],"r":{".":4,"a":{"d":{"i":238}}},"s":3,"v":148},24],"h":[{"a":19},29],"i":[{"b":90},29],"o":{"n":12},"p":29,"w":19},44],"t":{"a":{"c":{"h":36},"g":21},"e":{"b":23,"n":{"d":17},"o":5},"i":[{"b":4,"d":0,"e":{"r":21},"g":23,"l":{"i":12,"l":17,"y":21},"s":{"t":21},"v":21},29],"r":{"i":23,"o":{"p":{"h":115}},"e":{"u":29}},"s":{"h":1},"h":{"o":{"u":29}}},"u":{"a":3,"e":{"l":93,"n":3},"g":{"l":1},"i":{"n":3},"m":{"p":{"l":11}},"n":[{"k":6,"t":{"y":0}},9],"s":{"c":19},"t":{"i":{"n":6}}},"v":{"e":[{"l":{"i":17},"n":23,"r":{".":4},"s":{"t":19},"y":23,"i":{"l":29}},1],"i":{"c":23,"v":0},"o":23},"w":29,"y":{"c":1,"n":{"g":{"e":32}},"t":3},"z":{"s":{"c":2}}},"s":{"a":[{"b":42,"c":{"k":32,"r":{"i":11},"t":23},"i":32,"l":{"a":{"r":36},"m":0,"o":4,"t":0,"e":{"s":{"c":54,"w":7}}},"n":{"c":27,"d":{"e":0}},"p":[{"a":{"r":{"i":{"l":292}}}},29],"t":{"a":4,"i":{"o":76},"u":11},"u":0,"v":{"o":{"r":4}},"w":32},9],"b":56,"c":{"a":{"n":{"t":149},"p":[{"e":{"r":267}},0],"v":6,"t":{"o":{"l":208}}},"e":{"d":21,"i":18,"s":21},"h":[{"o":21,"i":{"t":{"z":21}},"r":{"o":{"d":{"i":{"n":{"g":293}}}}}},8],"i":{"e":68,"n":{"d":150},"u":{"t":{"t":294}}},"l":{"e":6,"i":21},"o":{"f":17,"p":{"y":18},"u":{"r":{"a":7}}},"u":29,"r":{"a":{"p":{"e":{"r":{".":36}}}}},"y":{"t":{"h":247}}},"d":56,"e":{".":18,"a":[{"s":17,"w":5},1],"c":{"o":151,"t":27},"d":[{"e":95,"l":19},125],"g":[{"r":11},9],"i":32,"l":{"e":2,"f":32,"v":32},"m":{"e":[{"s":{"t":295}},18],"o":{"l":1},"a":{"p":{"h":287}},"i":{"t":{"i":{"c":296}}}},"n":{"a":{"t":5},"c":18,"d":0,"e":{"d":19},"g":5,"i":{"n":19},"t":{"d":18,"l":18}},"p":{"a":152,"t":{"e":{"m":{"b":11}}}},"r":{".":43,"l":21,"o":0,"v":{"o":18}},"s":[{"h":4,"t":5},72],"u":{"m":113},"v":[{"e":{"n":11}},32],"w":{"i":0},"x":32},"f":47,"g":48,"h":[{".":25,"e":{"r":2,"v":32},"i":{"n":2,"o":3,"p":27,"v":6},"o":[{"l":{"d":4},"n":12,"r":[{"t":7},17],"e":{"s":{"t":137}}},0],"w":18},24],"i":{"b":2,"c":{"c":19},"d":{"e":{".":27,"s":[{"t":6,"w":6},32],"d":{".":8}},"i":[{"z":4},32]},"g":{"n":{"a":18}},"l":{"e":0,"y":18},"n":[{"a":24,"e":{".":32},"g":23},42],"o":[{"n":[{"a":6},32]},41],"r":[{"a":5,"e":{"s":{"i":{"d":4}}}},9],"s":41,"t":{"i":{"o":27}},"u":32,"v":41,"z":32},"k":[{"e":[{"t":23},18],"i":{"n":{"e":4,"g":4}},"y":{"s":{"c":15}}},9],"l":[{"a":{"t":23},"e":24,"i":{"t":{"h":7}},"o":{"v":{"a":{"k":{"i":{"a":297}}}}}},74],"m":[{"a":[{"l":{"l":54},"n":12},23],"e":{"l":17,"n":19},"i":{"t":{"h":32}},"o":{"l":{"d":49}}},42],"n":72,"o":[{"c":{"e":1},"f":{"t":12},"l":{"a":{"b":1},"d":153,"i":{"c":3},"v":32,"u":{"t":{"e":9}}},"m":27,"n":{".":68,"a":17,"g":0},"p":[{"h":{"i":{"c":32,"z":19},"y":19}},21],"r":{"c":5,"d":5},"v":[{"i":4},18],"g":{"a":{"m":{"y":298}}}},41],"p":{"a":[{"i":32,"n":0,"c":{"e":299,"i":{"n":69}}},25],"e":{"n":{"d":17},"o":57,"r":25,"c":{"i":{"o":11}}},"h":{"e":[{"r":[{"o":213},27]},24],"o":6},"i":{"l":17,"n":{"g":4},"o":18,"c":{"i":{"l":208}}},"l":{"y":21},"o":{"n":21,"r":[{"t":{"s":{"c":300,"w":300}}},17],"t":18,"k":{"e":{"s":{"w":10}}}}},"q":{"u":{"a":{"l":{"l":36}},"i":{"t":{"o":88}}}},"r":29,"s":[{"a":[{"s":12,"c":{"h":{"u":301}}},29],"c":94,"e":{"l":23,"n":{"g":19},"s":{".":21},"t":19},"i":[{"e":[{"r":0},21],"l":{"y":4},"a":{"n":{".":210}},"g":{"n":{"a":{"b":302}}}},29],"l":[{"i":1},21],"n":21,"p":{"e":{"n":{"d":115}}},"t":9,"u":{"r":{"a":6}},"w":4,"h":{"a":{"t":3}}},25],"t":{".":25,"a":{"g":24,"l":24,"m":{"i":17,"p":69},"n":{"d":32,"t":{"s":{"h":{"i":303}}}},"p":90,"t":{".":32,"i":15},"r":{"t":{"l":{"i":12}}}},"e":{"d":21,"r":{"n":{"i":7},"o":19},"w":[{"a":6},8]},"h":{"e":23},"i":[{".":21,"a":19,"c":[{"k":32},29],"e":21,"f":23,"n":{"g":3},"r":32},9],"l":{"e":29},"o":{"c":{"k":32},"m":{"a":12},"n":{"e":32},"p":21,"r":{"e":27,"a":{"b":304}}},"r":[{"a":{"d":21,"t":{"u":32,"a":{"g":305}},"y":21},"i":{"d":21,"b":{"u":{"t":7}}},"y":18},1],"w":61,"y":[{"l":{"i":{"s":137}}},24],"b":4,"s":{"c":{"r":4}},"u":{"p":{"i":{"d":306}}}},"u":[{"a":{"l":2},"b":111,"g":151,"i":{"s":4,"t":12},"l":21,"m":[{"i":11},9],"n":9,"r":9,"p":{"e":{"r":{"e":307}}}},41],"v":18,"w":[{"o":18,"i":{"m":{"m":177}}},9],"y":[{"c":18,"l":27,"n":{"o":5,"c":41},"r":{"i":{"n":4}},"t":{"h":{"i":308}}},21]},"t":{"a":[{".":27,"b":[{"l":{"e":{"s":4}},"o":{"l":{"i":{"z":32,"s":{"m":309}}}}},25],"c":{"i":18},"d":{"o":4},"f":46,"i":{"l":{"o":5}},"l":[{"a":4,"e":{"n":5},"i":11,"k":[{"a":204},18],"l":{"i":{"s":0}},"o":{"g":4}},9],"m":{"o":4,"i":{"n":82}},"n":{"d":{"e":0},"t":{"a":54}},"p":{"e":{"r":4},"l":4,"a":{"t":{"h":310}}},"r":{"a":0,"c":18,"e":18,"i":{"z":3},"r":{"h":311}},"s":{"e":0,"y":4},"t":{"i":{"c":18},"u":{"r":1}},"u":{"n":17},"v":0,"w":25,"x":{"i":{"s":0}},"g":{"o":{"n":{".":3}}}},41],"b":42,"c":[{"h":[{"e":{"t":5},"c":15,"i":{"e":{"r":237}}},21],"r":29},18],"d":43,"e":{".":18,"a":{"d":{"i":17},"t":18,"c":{"h":{"e":{"r":{".":36}}}}},"c":{"e":17,"t":32},"d":[{"i":4},42],"e":41,"g":[{"e":{"r":4},"i":4},0],"l":{".":27,"i":17,"s":32,"e":{"g":84,"r":{"o":249}}},"m":{"a":[{"t":11},154]},"n":{"a":{"n":27},"c":27,"d":27,"e":{"s":18},"t":[{"a":{"g":0}},41]},"o":41,"p":[{"e":4},1],"r":{"c":11,"d":155,"i":[{"e":{"s":5},"s":11,"z":{"a":6},"c":{".":8}},41],"n":{"i":{"t":32}},"v":5,"g":{"e":{"i":312}}},"s":{".":18,"s":[{".":23,"e":{"s":313}},18]},"t":{"h":{"e":6}},"u":27,"x":27,"y":18},"f":42,"g":43,"h":{".":25,"a":{"n":17,"l":{"a":{"m":228}}},"e":[{"a":[{"s":3,"t":5},18],"i":{"s":11},"t":27},9],"i":{"c":{".":4,"a":4},"l":18,"n":{"k":32}},"l":18,"o":{"d":{"e":4,"i":{"c":32},"o":{"n":11}},"o":18,"r":{"i":{"t":6,"z":5}},"g":{"e":{"n":{"i":314}}},"k":{"e":{"r":175}}},"s":25,"y":{"l":{"a":{"n":228}},"s":{"c":11}}},"i":{"a":[{"b":1,"t":{"o":1},"n":{".":70}},41],"b":156,"c":{"k":18,"o":21,"u":157},"d":{"i":32},"e":{"n":27},"f":[{"y":4},8],"g":[{"u":32},25],"l":{"l":{"i":{"n":6}}},"m":[{"p":18,"u":{"l":5}},41],"n":[{"a":24,"e":{".":27},"i":27,"o":{"m":285}},42],"o":[{"c":4,"n":{"e":{"e":6}}},41],"q":32,"s":{"a":3,"e":27,"m":0,"o":4,"p":0,"t":{"i":{"c":{"a":32}}}},"t":{"l":3},"u":1,"v":[{"a":0},41],"z":[{"a":3,"e":{"n":3}},41]},"l":[{"a":[{"n":17},19],"e":{".":27,"d":27,"s":{".":27},"t":{".":19}},"o":19,"i":{"e":{"r":315}}},25],"m":[{"e":0},43],"n":81,"o":[{"b":3,"c":{"r":{"a":{"t":4}}},"d":{"o":18},"f":25,"g":{"r":9},"i":{"c":4},"m":{"a":9,"b":0,"y":3},"n":{"a":{"l":{"i":0},"t":3},"o":18,"y":18},"r":{"a":9,"i":{"e":3,"z":5}},"s":8,"u":{"r":32,"t":18},"w":{"a":{"r":3}},"l":{"o":{"g":{"y":84}}},"t":{"i":{"c":11}}},41],"p":43,"r":{"a":[{"b":11,"c":{"h":5,"i":[{"t":17},36],"t":{"e":17}},"s":17,"v":{"e":{"n":5,"s":158,"r":{"s":[{"a":{"b":317}},15]}}},"i":{"t":{"o":{"r":316}}}},41],"e":{"f":5,"m":[{"i":6},0],"a":{"c":{"h":{"e":318}}}},"i":{"a":[{"l":{".":1}},32],"c":{"e":{"s":5},"i":{"a":32},"s":18},"m":25,"v":0},"o":{"m":{"i":5},"n":{"i":6,"y":18},"p":{"h":{"e":5},"i":{"s":175},"o":{"l":{"e":{"s":320},"i":{"s":320,"t":321}}}},"s":{"p":11},"v":11,"l":{"e":{"u":{"m":319}}},"f":{"i":{"c":{".":17},"t":11}}},"u":{"i":5,"s":17}},"s":[{"c":[{"h":{"i":{"e":12}}},21],"h":0,"w":21},101],"t":[{"e":{"s":21},"o":19,"u":0,"r":{"i":{"b":{"u":{"t":322}}}}},66],"u":[{"a":[{"r":3},2],"b":{"i":1},"d":8,"e":18,"f":46,"i":76,"m":27,"n":{"i":{"s":1}},"p":{".":48},"r":{"e":27,"i":[{"s":11},32],"o":5,"y":4,"n":{"a":{"r":12}}},"s":27},41],"v":18,"w":[{"a":43,"i":{"s":17},"o":18,"h":29},1],"y":[{"a":18,"l":25,"p":{"e":12,"h":4,"a":{"l":64}}},41],"z":[{"e":1},18]},"u":{"a":{"b":18,"c":0,"n":{"a":4,"i":0},"r":{"a":{"n":{"t":5}},"d":8,"i":11,"t":11},"t":29,"v":0,"d":{"r":{"a":{"t":{"i":3,"u":15}}}}},"b":{"e":[{"l":21,"r":[{"o":21},23]},1],"i":[{"n":{"g":33}},72],"l":{"e":{".":23}}},"c":{"a":23,"i":{"b":0,"t":1},"l":{"e":12},"r":23,"u":23,"y":21},"d":{"d":4,"e":{"r":3,"s":{"t":4},"v":17},"i":{"c":29,"e":{"d":3,"s":3},"s":4,"t":19},"o":{"n":[{"y":232},21]},"s":{"i":1},"u":21},"e":{"n":{"e":21,"s":17,"t":{"e":0}},"r":{"i":{"l":0}},"a":{"m":15}},"f":{"a":27,"l":23},"g":{"h":{"e":{"n":11}},"i":{"n":4}},"i":[{"l":{"i":{"z":5}},"n":[{"g":29},1],"r":{"m":0},"t":{"a":17},"v":[{"e":{"r":{".":0}}},11]},156],"j":19,"k":18,"l":{"a":[{"b":5,"t":{"i":19}},29],"c":{"h":[{"e":32},17]},"d":{"e":{"r":3}},"e":[{"n":29},1],"g":{"i":1},"i":[{"a":19,"n":{"g":3},"s":{"h":4}},9],"l":{"a":{"r":1},"i":{"b":96,"s":1}},"m":61,"o":72,"s":[{"e":{"s":5}},18],"t":{"i":2,"r":{"a":54},"u":18},"u":[{"l":4},23],"v":4},"m":{"a":{"b":4},"b":{"i":1,"l":{"y":1}},"i":[{"n":{"g":83}},29],"o":{"r":{"o":6}},"p":9},"n":{"a":{"t":17},"e":[{"r":1},24],"i":[{"m":1,"n":24,"s":{"h":4},"v":11},29],"s":[{"w":1},93],"t":{"a":{"b":11},"e":{"r":{".":1},"s":1}},"u":0,"y":4,"z":4},"o":{"r":{"s":21},"s":19,"u":29},"p":{"e":[{"r":{"s":6}},29],"i":{"a":19,"n":{"g":3}},"l":23,"p":[{"o":{"r":{"t":10}}},3],"t":{"i":{"b":5},"u":17}},"r":{"a":[{".":18,"g":21,"s":21,"l":{".":216}},29],"b":{"e":1},"c":0,"d":2,"e":{"a":{"t":5}},"f":{"e":{"r":1},"r":1},"i":{"f":[{"i":{"c":0}},23],"n":2,"o":23,"t":29,"z":3,"a":{"l":{".":0}}},"l":[{"i":{"n":{"g":{".":5}}}},9],"n":{"o":1},"o":{"s":17},"p":{"e":1,"i":1},"s":{"e":{"r":5}},"t":{"e":{"s":4},"h":{"e":3},"i":[{"e":1},17]},"u":23},"s":[{"a":{"d":19,"n":19,"p":1},"c":[{"i":3},8],"e":{"a":5,"r":{".":9}},"i":{"a":19,"c":23},"l":{"i":{"n":1}},"p":2,"s":{"l":4},"t":{"e":{"r":{"e":4}},"r":2},"u":[{"r":17},24]},25],"t":{"a":{"b":0,"t":23},"e":{".":18,"l":18,"n":[{"i":17},18]},"i":[{"l":{"i":{"z":5}},"n":{"e":23,"g":3},"o":{"n":{"a":7}},"s":21,"z":31},101],"l":34,"o":{"f":4,"g":5,"m":{"a":{"t":{"i":{"c":5}}}},"n":19,"u":21},"s":0},"u":[{"m":1},23],"v":74,"x":{"u":11},"z":{"e":1}},"v":{"a":[{".":32,"b":159,"c":{"i":{"l":5},"u":11},"g":[{"e":1,"u":{"e":{"r":170}}},0],"l":{"i":{"e":4},"o":5,"u":15},"m":{"o":4},"n":{"i":{"z":4}},"p":{"i":4},"r":{"i":{"e":{"d":5}}},"t":[{"i":{"v":29}},27],"u":{"d":{"e":{"v":54}}}},41],"e":{".":18,"d":18,"g":11,"l":{".":23,"l":{"i":11},"o":1,"y":21},"n":{"o":{"m":11},"u":{"e":19}},"r":{"d":21,"e":{".":32,"l":[{"y":{".":41}},21],"n":[{"c":5},23],"s":21,"i":{"g":324}},"i":{"e":11},"m":{"i":{"n":36}},"s":{"e":27},"t":{"h":11}},"s":[{".":18,"t":{"e":0,"i":{"t":{"e":15}}}},99],"t":{"e":[{"r":11},1],"y":1}},"i":{"a":{"l":{"i":4},"n":32},"d":{"e":{".":32,"d":32,"n":47,"s":32},"i":32},"f":23,"g":{"n":4},"k":0,"l":[{"i":{"t":32,"z":127}},25],"n":[{"a":26,"c":24,"d":5,"g":18},29],"o":{"l":11,"r":73,"u":2},"p":1,"r":{"o":4},"s":{"i":{"t":11},"o":3,"u":3},"t":{"i":18,"r":11,"y":18},"v":[{"i":{"p":{"a":{"r":325}}}},27]},"o":{".":32,"i":[{"r":{"d":{"u":323}},"c":{"e":{"p":213}}},0],"k":27,"l":{"a":1,"e":19,"t":32,"v":27},"m":{"i":5},"r":{"a":{"b":5},"i":17,"y":1},"t":{"a":1,"e":{"e":18}}},"v":26,"y":21},"w":{"a":{"b":{"l":19},"c":25,"g":{"e":{"r":4},"o":5},"i":{"t":6},"l":{".":19},"m":0,"r":{"t":0},"s":{"t":[{"e":{"w":{"a":326}}},0]},"t":{"e":2},"v":{"e":{"r":4,"g":327}}},"b":29,"e":{"a":{"r":{"i":{"e":5}},"t":{"h":54}},"d":{"n":0},"e":{"t":12,"v":5,"k":{"n":137}},"l":{"l":0},"r":29,"s":{"t":12},"v":23},"h":{"i":0},"i":[{"l":[{"l":{"i":{"n":6}}},8],"n":{"d":{"e":0},"g":0},"r":0,"s":{"e":27},"t":{"h":12},"z":5,"d":{"e":{"s":{"p":6}}}},9],"k":21,"l":{"e":{"s":1},"i":{"n":3}},"n":{"o":21},"o":[{"m":15,"v":{"e":{"n":4}},"k":{"e":{"n":85}}},160],"p":19,"r":{"a":[{"p":{"a":{"r":{"o":12}}}},0],"i":[{"t":{"a":36,"e":{"r":{".":183}}}},0]},"s":{"h":23,"l":1,"p":{"e":1},"t":60},"t":18,"y":1,"c":23},"x":{"a":[{"c":{"e":5},"g":{"o":21},"m":11,"p":21,"s":5},29],"c":161,"e":[{"c":{"u":{"t":{"o":1}}},"d":24,"r":{"i":0,"o":4}},29],"h":[{"i":[{"l":6},8],"u":0},29],"i":[{"a":4,"c":4,"d":{"i":4},"m":{"e":21,"i":{"z":4}}},23],"o":[{"b":21},23],"p":[{"a":{"n":{"d":17}},"e":{"c":{"t":{"o":10}},"d":11}},23],"t":[{"i":23},74],"u":[{"a":3},29],"x":1,"q":[{"u":{"i":{"s":54}}},29]},"y":{"a":{"c":19,"r":110,"t":19},"b":29,"c":[{"e":[{"r":4},24],"h":[{"e":[{"d":264},0]},23],"o":{"m":17,"t":17}},29],"d":29,"e":{"e":19,"r":[{"f":21},29],"s":[{"t":{"e":{"r":{"y":328}}}},0],"t":1},"g":{"i":19},"h":47,"i":29,"l":{"a":23,"l":{"a":{"b":{"l":6}}},"o":23,"u":19},"m":{"b":{"o":{"l":7}},"e":[{"t":{"r":{"y":20}}},0],"p":{"a":12}},"n":{"c":{"h":{"r":3}},"d":4,"g":4,"i":{"c":4},"x":32},"o":[{"d":4,"g":33,"m":0,"n":{"e":{"t":4},"s":21},"s":21},72],"p":{"e":{"d":21,"r":6},"i":3,"o":[{"c":21},23],"t":{"a":9},"u":19},"r":{"a":{"m":5},"i":{"a":4},"o":23,"r":1},"s":{"c":1,"e":161,"i":{"c":{"a":3},"o":3,"s":27},"o":21,"s":0,"t":[{"a":3,"r":{"o":29}},2],"u":{"r":17}},"t":{"h":{"i":{"n":23}},"i":{"c":3}},"w":29},"z":{"a":[{"b":79,"r":8},2],"b":18,"e":[{"n":1,"p":1,"r":[{"o":3},29],"t":0},25],"i":[{"l":21,"s":21,"a":{"n":{".":23}}},42],"l":32,"m":18,"o":[{"m":1,"o":{"l":4},"p":{"h":{"r":329}}},41],"t":{"e":0},"z":[{"y":21,"w":231},101]}}',
        [
          "as-so-ciate",
          "as-so-ciates",
          "dec-li-na-tion",
          "oblig-a-tory",
          "phil-an-thropic",
          "present",
          "presents",
          "project",
          "projects",
          "reci-procity",
          "re-cog-ni-zance",
          "ref-or-ma-tion",
          "ret-ri-bu-tion",
          "ta-ble"
        ]
      ];
    });
  }
});

// node_modules/@react-pdf/reconciler/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/@react-pdf/reconciler/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    (function() {
      function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime3 = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      function push(heap, node) {
        var index2 = heap.length;
        heap.push(node);
        a: for (; 0 < index2; ) {
          var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare9(parent, node))
            heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last2 = heap.pop();
        if (last2 !== first) {
          heap[0] = last2;
          a: for (var index2 = 0, length2 = heap.length, halfLength = length2 >>> 1; index2 < halfLength; ) {
            var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare9(left, last2))
              rightIndex < length2 && 0 > compare9(right, left) ? (heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last2, index2 = leftIndex);
            else if (rightIndex < length2 && 0 > compare9(right, last2))
              heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare9(a4, b3) {
        var diff = a4.sortIndex - b3.sortIndex;
        return 0 !== diff ? diff : a4.id - b3.id;
      }
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, requestHostCallback();
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
          }
      }
      function shouldYieldToHost() {
        return exports.unstable_now() - startTime3 < frameInterval ? false : true;
      }
      function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime3 = -1;
      if ("function" === typeof localSetImmediate)
        var schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return peek(taskQueue);
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/@react-pdf/reconciler/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/@react-pdf/reconciler/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/@react-pdf/primitives/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  Canvas: () => Canvas,
  Checkbox: () => Checkbox,
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Document: () => Document,
  Ellipse: () => Ellipse,
  FieldSet: () => FieldSet,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Link: () => Link,
  List: () => List,
  Note: () => Note,
  Page: () => Page,
  Path: () => Path,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Select: () => Select,
  Stop: () => Stop,
  Svg: () => Svg,
  Text: () => Text,
  TextInput: () => TextInput,
  TextInstance: () => TextInstance,
  Tspan: () => Tspan,
  View: () => View
});
var G = "G";
var Svg = "SVG";
var View = "VIEW";
var Text = "TEXT";
var Link = "LINK";
var Page = "PAGE";
var Note = "NOTE";
var Path = "PATH";
var Rect = "RECT";
var Line = "LINE";
var FieldSet = "FIELD_SET";
var TextInput = "TEXT_INPUT";
var Select = "SELECT";
var Checkbox = "CHECKBOX";
var List = "LIST";
var Stop = "STOP";
var Defs = "DEFS";
var Image = "IMAGE";
var Tspan = "TSPAN";
var Canvas = "CANVAS";
var Circle = "CIRCLE";
var Ellipse = "ELLIPSE";
var Polygon = "POLYGON";
var Document = "DOCUMENT";
var Polyline = "POLYLINE";
var ClipPath = "CLIP_PATH";
var TextInstance = "TEXT_INSTANCE";
var LinearGradient = "LINEAR_GRADIENT";
var RadialGradient = "RADIAL_GRADIENT";

// node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_queue = __toESM(require_queue());
var import_react5 = __toESM(require_react());

// node_modules/@react-pdf/font/lib/index.browser.js
var import_is_url = __toESM(require_is_url());

// node_modules/restructure/src/DecodeStream.js
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length2, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length2);
    try {
      let decoder2 = new TextDecoder(encoding);
      return decoder2.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length2) {
    return this.buffer.slice(this.pos, this.pos += length2);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    DecodeStream.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length2) {
    if (length2 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length2);
      this.pos += length2;
    } else {
      const buf = new Uint8Array(length2);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap4) {
  let buf = new Uint16Array(string.length);
  for (let i4 = 0; i4 < string.length; i4++) {
    let code = string.charCodeAt(i4);
    if (swap4) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i4] = code;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i4 = 0; i4 < string.length; i4++) {
    buf[i4] = string.charCodeAt(i4);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}

// node_modules/restructure/src/Base.js
var Base = class {
  fromBuffer(buffer) {
    let stream2 = new DecodeStream(buffer);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer);
    this.encode(stream2, value2);
    return buffer;
  }
};

// node_modules/restructure/src/Number.js
var NumberT = class extends Base {
  constructor(type, endian = "BE") {
    super();
    this.type = type;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// node_modules/restructure/src/utils.js
function resolveLength(length2, stream2, parent) {
  let res;
  if (typeof length2 === "number") {
    res = length2;
  } else if (typeof length2 === "function") {
    res = length2.call(parent, parent);
  } else if (parent && typeof length2 === "string") {
    res = parent[length2];
  } else if (stream2 && length2 instanceof NumberT) {
    res = length2.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
var PropertyDescriptor = class {
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
};

// node_modules/restructure/src/Array.js
var ArrayT = class extends Base {
  constructor(type, length2, lengthType = "count") {
    super();
    this.type = type;
    this.length = length2;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length2;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length2 }
      });
      ctx = res;
    }
    if (length2 == null || this.lengthType === "bytes") {
      const target = length2 != null ? stream2.pos + length2 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i4 = 0, end2 = length2; i4 < end2; i4++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i4 = 0;
      while (i4 < ctx.pointers.length) {
        const ptr = ctx.pointers[i4++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
};

// node_modules/restructure/src/LazyArray.js
var LazyArray = class extends ArrayT {
  decode(stream2, parent) {
    const { pos } = stream2;
    const length2 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length2
      };
    }
    const res = new LazyArrayValue(this.type, length2, stream2, parent);
    stream2.pos += length2 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
};
var LazyArrayValue = class {
  constructor(type, length2, stream2, ctx) {
    this.type = type;
    this.length = length2;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.length) {
      return void 0;
    }
    if (this.items[index2] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index2;
      this.items[index2] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index2];
  }
  toArray() {
    const result = [];
    for (let i4 = 0, end2 = this.length; i4 < end2; i4++) {
      result.push(this.get(i4));
    }
    return result;
  }
};

// node_modules/restructure/src/Bitfield.js
var Bitfield = class extends Base {
  constructor(type, flags = []) {
    super();
    this.type = type;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i4 = 0; i4 < this.flags.length; i4++) {
      const flag = this.flags[i4];
      if (flag != null) {
        res[flag] = !!(val & 1 << i4);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys2) {
    let val = 0;
    for (let i4 = 0; i4 < this.flags.length; i4++) {
      const flag = this.flags[i4];
      if (flag != null) {
        if (keys2[flag]) {
          val |= 1 << i4;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
};

// node_modules/restructure/src/Buffer.js
var BufferT = class extends Base {
  constructor(length2) {
    super();
    this.length = length2;
  }
  decode(stream2, parent) {
    const length2 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length2);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
};

// node_modules/restructure/src/Optional.js
var Optional = class extends Base {
  constructor(type, condition = true) {
    super();
    this.type = type;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
};

// node_modules/restructure/src/Reserved.js
var Reserved = class extends Base {
  constructor(type, count = 1) {
    super();
    this.type = type;
    this.count = count;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
};

// node_modules/restructure/src/String.js
var StringT = class extends Base {
  constructor(length2, encoding = "ascii") {
    super();
    this.length = length2;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length2, pos;
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    let width = encodingWidth(encoding);
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer;
      ({ buffer, length: length2, pos } = stream2);
      while (pos < length2 - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) {
        pos += width;
      }
      length2 = pos - stream2.pos;
    }
    const string = stream2.readString(length2, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos += width;
    }
    return string;
  }
  size(val, parent) {
    if (val === void 0 || val === null) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size += encodingWidth(encoding);
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return encodingWidth(encoding) == 2 ? stream2.writeUInt16LE(0) : stream2.writeUInt8(0);
    }
  }
};
function encodingWidth(encoding) {
  switch (encoding) {
    case "ascii":
    case "utf8":
      return 1;
    case "utf16le":
    case "utf16-le":
    case "utf-16be":
    case "utf-16le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return 2;
    default:
      return 1;
  }
}
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i4 = 0; i4 < string.length; i4++) {
        let c4 = string.charCodeAt(i4);
        if (c4 >= 55296 && c4 <= 56319 && i4 < string.length - 1) {
          let c22 = string.charCodeAt(++i4);
          if ((c22 & 64512) === 56320) {
            c4 = ((c4 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i4--;
          }
        }
        if ((c4 & 4294967168) === 0) {
          len++;
        } else if ((c4 & 4294965248) === 0) {
          len += 2;
        } else if ((c4 & 4294901760) === 0) {
          len += 3;
        } else if ((c4 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}

// node_modules/restructure/src/Struct.js
var Struct = class extends Base {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length2) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length2 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type = fields[key];
      if (typeof type === "function") {
        val = type.call(res, res);
      } else {
        val = type.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type = this.fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type = this.fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i4 = 0;
    while (i4 < ctx.pointers.length) {
      const ptr = ctx.pointers[i4++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// node_modules/restructure/src/VersionedStruct.js
var getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
var VersionedStruct = class _VersionedStruct extends Struct {
  constructor(type, versions3 = {}) {
    super();
    this.type = type;
    this.versions = versions3;
    if (typeof type === "string") {
      this.versionPath = type.split(".");
    }
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type = fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type = fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i4 = 0;
    while (i4 < ctx.pointers.length) {
      const ptr = ctx.pointers[i4++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// node_modules/restructure/src/Pointer.js
var Pointer = class extends Base {
  constructor(offsetType, type, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset2 = this.offsetType.decode(stream2, ctx);
    if (offset2 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c4 = ctx;
        while (c4.parent) {
          c4 = c4.parent;
        }
        relative = c4._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset2 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type,
      val,
      parent
    });
    return ctx.pointerOffset += type.size(val, parent);
  }
};
var VoidPointer = class {
  constructor(type, value2) {
    this.type = type;
    this.value = value2;
  }
};

// node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value2;
  return obj;
}

// node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// node_modules/unicode-properties/dist/module.mjs
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a4) {
  return a4 && a4.__esModule ? a4.default : a4;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("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"));
var $747425b437e121da$var$log2 = Math.log2 || ((n5) => Math.log(n5) / Math.LN2);
var $747425b437e121da$var$bits = (n5) => $747425b437e121da$var$log2(n5) + 1 | 0;
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0) return null;
  else if (num <= 50) return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};

// node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e4, n5, v3, s2) {
  Object.defineProperty(e4, n5, { get: v3, set: s2, enumerable: true, configurable: true });
}
function $parcel$interopDefault2(a4) {
  return a4 && a4.__esModule ? a4.default : a4;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format3) {
  $d636bc798e7178db$var$formats.push(format3);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i4 = 0; i4 < $d636bc798e7178db$var$formats.length; i4++) {
    let format3 = $d636bc798e7178db$var$formats[i4];
    if (format3.probe(buffer)) {
      let font = new format3(new (0, DecodeStream)(buffer));
      if (postscriptName) return font.getFont(postscriptName);
      return font;
    }
  }
  throw new Error("Unknown font format");
}
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key, descriptor) {
  if (descriptor.get) {
    let get14 = descriptor.get;
    descriptor.get = function() {
      let value2 = get14.call(this);
      Object.defineProperty(this, key, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache2 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key2 = args.length > 0 ? args[0] : "value";
          if (cache2.has(key2)) return cache2.get(key2);
          let result = fn.apply(this, args);
          cache2.set(key2, result);
          return result;
        }
        Object.defineProperty(this, key, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t4) => Math.max.apply(Math, t4.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t4) => t4.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t4) => (t4.length - t4._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t4) => t4.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t4) => t4.parent.maxp.numGlyphs - t4.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": " ",
  "x-mac-gaelic": " ",
  "x-mac-greek": " ",
  "x-mac-icelandic": " ",
  "x-mac-inuit": " ",
  "x-mac-ce": " ",
  "x-mac-romanian": " ",
  "x-mac-turkish": " "
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached) return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i4 = 0; i4 < mapping.length; i4++) res.set(mapping.charCodeAt(i4), 128 + i4);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder2 = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i4 = 0; i4 < 128; i4++) mapping2[i4] = 128 + i4;
    let res = /* @__PURE__ */ new Map();
    let s2 = decoder2.decode(mapping2);
    for (let i4 = 0; i4 < 128; i4++) res.set(s2.charCodeAt(i4), 128 + i4);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "gbk",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii",
    null,
    "iso-8859-1"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf-16be",
    "shift-jis",
    "gb18030",
    "big5",
    "euc-kr",
    "johab",
    null,
    null,
    null,
    "utf-16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t4) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t4.platformID, t4.encodingID, t4.languageID)), {
    type: "parent",
    relativeTo: (ctx) => ctx.parent.stringOffset,
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx) => ctx.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
    if (language == null) language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null) records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName") records.push({
      platformID: 1,
      encodingID: 0,
      languageID: 0,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length,
      string: val.en
    });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t4) => t4.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i4 = 0; i4 < this.offsets.length; i4++) this.offsets[i4] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i4 = 0; i4 < this.offsets.length; i4++) this.offsets[i4] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version4 = this.getCFFVersion(parent);
    let count = version4 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0) return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1) offsetType = uint8;
    else if (offSize === 2) offsetType = uint16;
    else if (offSize === 3) offsetType = uint24;
    else if (offSize === 4) offsetType = uint32;
    else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count + 1) * offSize - 1;
    let start2 = offsetType.decode(stream2);
    for (let i4 = 0; i4 < count; i4++) {
      let end2 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start2;
        parent.length = end2 - start2;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else ret.push({
        offset: startPos + start2,
        length: end2 - start2
      });
      start2 = end2;
    }
    stream2.pos = startPos + start2;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0) return size;
    let type = this.type || new BufferT();
    let offset2 = 1;
    for (let i4 = 0; i4 < arr.length; i4++) {
      let item = arr[i4];
      offset2 += type.size(item, parent);
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset2 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) return;
    let type = this.type || new BufferT();
    let sizes = [];
    let offset2 = 1;
    for (let item of arr) {
      let s2 = type.size(item, parent);
      sizes.push(s2);
      offset2 += s2;
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset2 = 1;
    offsetType.encode(stream2, offset2);
    for (let size of sizes) {
      offset2 += size;
      offsetType.encode(stream2, offset2);
    }
    for (let item of arr) type.encode(stream2, item, parent);
    return;
  }
  constructor(type) {
    this.type = type;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246) return value2 - 139;
    if (247 <= value2 && value2 <= 250) return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254) return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28) return stream2.readInt16BE();
    if (value2 === 29) return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b3 = stream2.readUInt8();
        let n1 = b3 >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n22 = b3 & 15;
        if (n22 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n22];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge) value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107) return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108) return 2;
    else if (-32768 <= value2 && value2 <= 32767) return 3;
    else return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i4 = 0; i4 < str.length; i4 += 2) {
        let c1 = str[i4];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i4 === str.length - 1) var n22 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c22 = str[i4 + 1];
          var n22 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c22] || +c22;
        }
        stream2.writeUInt8(n1 << 4 | n22 & 15);
      }
      if (n22 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107) return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  decodeOperands(type, stream2, ret, operands) {
    if (Array.isArray(type)) return operands.map((op, i4) => this.decodeOperands(type[i4], stream2, ret, [
      op
    ]));
    else if (type.decode != null) return type.decode(stream2, ret, operands);
    else switch (type) {
      case "number":
      case "offset":
      case "sid":
        return operands[0];
      case "boolean":
        return !!operands[0];
      default:
        return operands;
    }
  }
  encodeOperands(type, stream2, ctx, operands) {
    if (Array.isArray(type)) return operands.map((op, i4) => this.encodeOperands(type[i4], stream2, ctx, op)[0]);
    else if (type.encode != null) return type.encode(stream2, operands, ctx);
    else if (typeof operands === "number") return [
      operands
    ];
    else if (typeof operands === "boolean") return [
      +operands
    ];
    else if (Array.isArray(operands)) return operands;
    else return [
      operands
    ];
  }
  decode(stream2, parent) {
    let end2 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end2) {
      let b3 = stream2.readUInt8();
      if (b3 < 28) {
        if (b3 === 12) b3 = b3 << 8 | stream2.readUInt8();
        let field = this.fields[b3];
        if (!field) throw new Error(`Unknown operator ${b3}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor)) Object.defineProperty(ret, field[1], val);
          else ret[field[1]] = val;
        }
        operands = [];
      } else operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b3));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k3 in this.fields) {
      let field = this.fields[k3];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands) len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers) len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands) (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op of key) stream2.writeUInt8(op);
    }
    let i4 = 0;
    while (i4 < ctx.pointers.length) {
      let ptr = ctx.pointers[i4++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream3, val) => ptr = val
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type, options = {}) {
    if (options.type == null) options.type = "global";
    super(null, type, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends) operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t4) => t4.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t4) => t4.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t4) => t4.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t4) => t4.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t4) => t4.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t4) => t4.parent.regionIndexCount - t4.parent.shortDeltaCount),
  deltas: (t4) => t4.shortDeltas.concat(t4.regionDeltas)
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index2 = this.predefinedOps.indexOf(value2);
    if (index2 !== -1) return index2;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  decode(stream2, parent) {
    let length2 = (0, resolveLength)(this.length, stream2, parent);
    let count = 0;
    let res = [];
    while (count < length2) {
      let range2 = this.type.decode(stream2, parent);
      range2.offset = count;
      count += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t4) => t4.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t4) => t4.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t4) => t4.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t4) => t4.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static decode(stream2) {
    return new _$822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    let start2 = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2) return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length) return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2) return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2) return null;
    if (this.isCIDFont) return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset)) return charset[gid];
    if (gid === 0) return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i4 = 0; i4 < charset.ranges.length; i4++) {
          let range2 = charset.ranges[i4];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) return this.string(range2.first + (gid - range2.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect) return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first) high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
          else return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2) return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
};
var $0941618dc22a946d$var$BitAligned = class {
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t4) => t4.parent.lastGlyphIndex - t4.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t4) => t4.parent.lastGlyphIndex - t4.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t4) => t4.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t4) => t4.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent) struct = struct.parent;
    if (!struct[this.key]) return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format3 = struct[this.key];
    for (let key in format3) if (format3[key]) fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t4) => t4.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t4) => t4.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t4) => t4.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t4) => ((t4.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t4) => t4.entry >> (t4.parent.entryFormat & 15) + 1,
  innerIndex: (t4) => t4.entry & (1 << (t4.parent.entryFormat & 15) + 1) - 1
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t4) => t4.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t4) => t4.offsets.length && Math.max.apply(Math, t4.offsets)
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t4) => t4._startOffset - t4.parent.parent._startOffset,
  len: (t4) => ((t4.parent.leftTable.max - t4.off) / t4.parent.rowWidth + 1) * (t4.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t4) => t4.leftClassCount * t4.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t4) => t4.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t4) => t4.parent.maxp.numGlyphs - t4.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  getItem(index2) {
    if (this._items[index2] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index2;
      this._items[index2] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index2];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type, stream2, parent) {
    this.type = type;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type) {
    super(type, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow {
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type) {
      this.type = type;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t4) => t4.lastGlyph - t4.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t4) => t4.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t4) => t4.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t4) => t4.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t4) => t4.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t4) => (t4.newStateOffset - (t4.parent.stateArray.base - t4.parent._startOffset)) / t4.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t4) => t4.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t4) => t4.parent.parent.parent.name.records.fontFeatures[t4.nameIndex]
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t4) => t4.parent.parent.name.records.fontFeatures[t4.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t4) => t4.parent.parent.name.records.fontFeatures[t4.nameID]
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t4) => t4.parent.parent.name.records.fontFeatures[t4.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t4) => t4.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t4) => t4.parent.instanceSize - t4._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx) => ctx.offsetToData,
    allowNull: false
  }), (t4) => t4.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t4) => t4.actionLength - t4._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx) => ctx.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t4) => t4.length - t4._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table = this.tables[tag];
      if (table) tables.push({
        tag,
        checkSum: 0,
        offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),
        length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)
      });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min2 = 0;
  let max2 = arr.length - 1;
  while (min2 <= max2) {
    let mid = min2 + max2 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0) max2 = mid - 1;
    else if (res > 0) min2 = mid + 1;
    else return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index2, end2) {
  let range2 = [];
  while (index2 < end2) range2.push(index2++);
  return range2;
}
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i4 = 0; i4 < $12727730ddfc8bfe$var$CHARS.length; i4++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i4)] = i4;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p3 = 0;
  for (let i4 = 0, len = base64.length; i4 < len; i4 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i4)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i4 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i4 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i4 + 3)];
    bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  findSubtable(cmapTable, pairs2) {
    for (let [platformID, encodingID] of pairs2) for (let cmap of cmapTable.tables) {
      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
    }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min2 = 0;
        let max2 = cmap.segCount - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          if (codepoint < cmap.startCode.get(mid)) max2 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid)) min2 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index2 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index2) || 0;
              if (gid !== 0) gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min2 = 0;
        let max2 = cmap.nGroups - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode) max2 = mid - 1;
          else if (codepoint > group.endCharCode) min2 = mid + 1;
          else {
            if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);
            else return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i4 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i4];
    if (i4 !== -1 && sel.defaultUVS) i4 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i4 !== -1 && sel.nonDefaultUVS) {
      i4 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i4 !== -1) return sel.nonDefaultUVS[i4].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i4 = 0; i4 < endCodes.length; i4++) {
          let tail = endCodes[i4] + 1;
          let start2 = cmap.startCode.get(i4);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start2, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i4 = 0; i4 < 256; i4++) if (cmap.codeMap.get(i4) === gid) res.push(i4);
        return res;
      }
      case 4: {
        let res = [];
        for (let i4 = 0; i4 < cmap.segCount; i4++) {
          let end2 = cmap.endCode.get(i4);
          let start2 = cmap.startCode.get(i4);
          let rangeOffset = cmap.idRangeOffset.get(i4);
          let delta = cmap.idDelta.get(i4);
          for (var c4 = start2; c4 <= end2; c4++) {
            let g3 = 0;
            if (rangeOffset === 0) g3 = c4 + delta;
            else {
              let index2 = rangeOffset / 2 + (c4 - start2) - (cmap.segCount - i4);
              g3 = cmap.glyphIndexArray.get(index2) || 0;
              if (g3 !== 0) g3 += delta;
            }
            if (g3 === gid) res.push(c4);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap) for (let cmap of cmapTable.tables) {
      let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
      let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
      if (mapping) {
        this.cmap = cmap.table;
        this.encoding = mapping;
      }
    }
    if (!this.cmap) throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14) this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream) continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal) continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation) continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s2 = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s2.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) val = s2.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s2.leftTable.firstGlyph && left < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs) leftOffset = s2.leftTable.offsets[left - s2.leftTable.firstGlyph];
          else leftOffset = s2.array.off;
          if (right >= s2.rightTable.firstGlyph && right < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs) rightOffset = s2.rightTable.offsets[right - s2.rightTable.firstGlyph];
          let index2 = (leftOffset + rightOffset - s2.array.off) / 2;
          val = s2.array.values.get(index2);
          break;
        case 3:
          if (left >= s2.glyphCount || right >= s2.glyphCount) return 0;
          val = s2.kernValue[s2.kernIndex[s2.leftClass[left] * s2.rightClassCount + s2.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override) res = val;
      else res += val;
    }
    return res;
  }
  constructor(font) {
    this.kern = font.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.isMark) clusterEnd = index2;
      else {
        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index2;
      }
    }
    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index2 = clusterStart + 1; index2 <= clusterEnd; index2++) {
      let mark = glyphs[index2];
      let markBox = mark.cbox;
      let position = positions[index2];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") switch (codePoint) {
        case 3633:
        case 3636:
        case 3637:
        case 3638:
        case 3639:
        case 3655:
        case 3660:
        case 3645:
        case 3662:
          return "Above_Right";
        case 3761:
        case 3764:
        case 3765:
        case 3766:
        case 3767:
        case 3771:
        case 3788:
        case 3789:
          return "Above";
        case 3772:
          return "Below";
      }
      else if (codePoint === 3642) return "Below_Right";
    }
    switch (combiningClass) {
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font) {
    this.font = font;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y3) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) this.minX = x;
      if (x > this.maxX) this.maxX = x;
    }
    if (Math.abs(y3) !== Infinity) {
      if (y3 < this.minY) this.minY = y3;
      if (y3 > this.maxY) this.maxY = y3;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag)) for (let t4 of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t4] = script;
  else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script = (0, $747425b437e121da$export$941569448d136665)(code);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i4 = 0; i4 < codePoints.length; i4++) {
    let codePoint = codePoints[i4];
    let script = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script) {
  if ($130d1a642ebcd2b7$var$RTL[script]) return "rtl";
  return "ltr";
}
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions) width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height2 = 0;
    for (let position of this.positions) height2 += position.yAdvance;
    return height2;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x = 0;
    let y3 = 0;
    for (let index2 = 0; index2 < this.glyphs.length; index2++) {
      let glyph = this.glyphs[index2];
      let p3 = this.positions[index2];
      let b3 = glyph.bbox;
      bbox.addPoint(b3.minX + x + p3.xOffset, b3.minY + y3 + p3.yOffset);
      bbox.addPoint(b3.maxX + x + p3.xOffset, b3.maxY + y3 + p3.yOffset);
      x += p3.xAdvance;
      y3 += p3.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;
    else if (typeof features === "object") this.features = features;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = (name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
];
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i4 = 1; i4 <= 99; i4++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i4}`.slice(-2)}`] = [
  $3b6302b64eccc32c$var$features.characterAlternatives.code,
  i4
];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features) {
  let res = {};
  for (let k3 in features) {
    let r5;
    if (r5 = $3b6302b64eccc32c$var$OTMapping[k3]) {
      if (res[r5[0]] == null) res[r5[0]] = {};
      res[r5[0]][r5[1]] = features[k3];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f3) {
  let [type, setting] = f3;
  if (isNaN(type)) var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
  else var typeCode = type;
  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
  else var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features) {
  let res = {};
  if (Array.isArray(features)) for (let k3 = 0; k3 < features.length; k3++) {
    let r5;
    let f3 = $3b6302b64eccc32c$var$mapFeatureStrings(features[k3]);
    if (r5 = $3b6302b64eccc32c$var$AATMapping[f3[0]] && $3b6302b64eccc32c$var$AATMapping[f3[0]][f3[1]]) res[r5] = true;
  }
  else if (typeof features === "object") for (let type in features) {
    let feature = features[type];
    for (let setting in feature) {
      let r5;
      let f3 = $3b6302b64eccc32c$var$mapFeatureStrings([
        type,
        setting
      ]);
      if (feature[setting] && (r5 = $3b6302b64eccc32c$var$AATMapping[f3[0]] && $3b6302b64eccc32c$var$AATMapping[f3[0]][f3[1]])) res[r5] = true;
    }
  }
  return Object.keys(res);
}
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) return null;
          if (glyph < seg.firstGlyph) max2 = mid - 1;
          else if (glyph > seg.lastGlyph) min2 = mid + 1;
          else {
            if (this.table.version === 2) return seg.value;
            else return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) return null;
          if (glyph < seg.glyph) max2 = mid - 1;
          else if (glyph > seg.glyph) min2 = mid + 1;
          else return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
        else {
          for (let index2 = 0; index2 < segment.values.length; index2++) if (segment.values[index2] === classValue) res.push(segment.firstGlyph + index2);
        }
        break;
      case 6:
        for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);
        break;
      case 8:
        for (let i4 = 0; i4 < this.table.values.length; i4++) if (this.table.values[i4] === classValue) res.push(this.table.firstGlyph + i4);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  process(glyphs, reverse2, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index2 = reverse2 ? glyphs.length - 1 : 0;
    let dir = reverse2 ? -1 : 1;
    while (dir === 1 && index2 <= glyphs.length || dir === -1 && index2 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index2 === glyphs.length || index2 === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index2];
        if (glyph.id === 65535) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index2);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) index2 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2)) return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter) opts2.enter(glyph, entry);
        if (entry.newState !== 0) this.traverse(opts2, entry.newState, visited);
        if (opts2.exit) opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f3;
        if (f3 = features[feature.featureType]) {
          if (f3[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f3[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
    }
    let index2 = glyphs.length - 1;
    while (index2 >= 0) {
      if (glyphs[index2].id === 65535) glyphs.splice(index2, 1);
      index2--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let reverse2 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse2, process2);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index2;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index2;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index2) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[index2];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index2;
  }
  processLigature(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index2);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last2 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last2) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last2 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset2 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset2 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset2);
        ligatureIndex += component;
        if (last2 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index2) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid) glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index2;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index2, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains) for (let feature of chain.features) features.push([
      feature.featureType,
      feature.featureSetting
    ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache) this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2) return;
    let reverse2 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse2) throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g3 = this.font.getGlyph(glyph);
        input.push(g3);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i4 = 0; i4 < glyphs.length && count <= 1; i4++) if (glyphs[i4].id !== 65535) {
          count++;
          found = glyphs[i4].id;
        }
        if (count === 1) {
          let result = input.map((g4) => g4.id);
          let cache2 = this.inputCache[found];
          if (cache2) cache2.push(result);
          else this.inputCache[found] = [
            result
          ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end2 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) end2.reverse();
  let start2 = glyphs.splice(rangeA[0], rangeA[1], ...end2);
  if (reverseA) start2.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start2);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length2 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index2, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index2]);
    for (let codePoint of codePoints) {
      let s2 = string + String.fromCodePoint(codePoint);
      if (index2 < glyphs.length - 1) this._addStrings(glyphs, index2 + 1, strings, s2);
      else strings.add(s2);
    }
  }
  constructor(font) {
    this.font = font;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features) if (this.allFeatures[feature] == null) {
      stage.push(feature);
      this.allFeatures[feature] = stageIndex;
      if (global2) this.globalFeatures[feature] = true;
    }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0) this.stages.push([]);
    if (typeof arg === "string") arg = [
      arg
    ];
    if (Array.isArray(arg)) this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function") this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features)) this.add(features);
    else if (typeof features === "object") for (let tag in features) {
      if (features[tag]) this.add(tag);
      else if (this.allFeatures[tag] != null) {
        let stage = this.stages[this.allFeatures[tag]];
        stage.splice(stage.indexOf(tag), 1);
        delete this.allFeatures[tag];
        delete this.globalFeatures[tag];
      }
    }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions) stage(this.font, glyphs, this);
      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font, script, direction) {
    this.font = font;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i4 = 0; i4 < glyphs.length; i4++) {
      let glyph = glyphs[i4];
      if (glyph.codePoints[0] === 8260) {
        let start2 = i4;
        let end2 = i4 + 1;
        while (start2 > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start2 - 1].codePoints[0])) {
          glyphs[start2 - 1].features.numr = true;
          glyphs[start2 - 1].features.frac = true;
          start2--;
        }
        while (end2 < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end2].codePoints[0])) {
          glyphs[end2].features.dnom = true;
          glyphs[end2].features.frac = true;
          end2++;
        }
        glyph.features.frac = true;
        i4 = end2 - 1;
      }
    }
  }
};
(0, _define_property)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ=="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i4 = 0; i4 < $764eb544bbe1ccf0$var$FEATURES.length; i4++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i4];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i4 = 0; i4 < glyphs.length; i4++) {
      let curAction, prevAction;
      var glyph = glyphs[i4];
      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i4] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;
      actions[i4] = curAction;
      prev = i4;
    }
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let feature;
      var glyph = glyphs[index2];
      if (feature = actions[index2]) glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res) return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  reset(options = {}, index2 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index2;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length) return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--) this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  findScript(script) {
    if (this.table.scriptList == null) return null;
    if (!Array.isArray(script)) script = [
      script
    ];
    for (let s2 of script) for (let entry of this.table.scriptList) {
      if (entry.tag === s2) return entry;
    }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry) return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4) language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords) if (lang.tag === language) {
        this.language = lang.langSys;
        this.languageTag = lang.tag;
        break;
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) for (let featureIndex of this.language.featureIndexes) {
        let record = this.table.featureList[featureIndex];
        let substituteFeature = this.substituteFeatureForVariations(featureIndex);
        this.features[record.tag] = substituteFeature || record.feature;
      }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature) continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a4, b3) => a4.index - b3.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations) return -1;
    let records = variations.featureVariationRecords;
    for (let i4 = 0; i4 < records.length; i4++) {
      let conditions = records[i4].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) return i4;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup: lookup4 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup4.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup4.subTables) {
          let res = this.applyLookup(lookup4.lookupType, table);
          if (res) break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup4, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
      for (let table of lookup4.subTables) {
        if (this.applyLookup(lookup4.lookupType, table)) break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null) glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range2 of coverage.rangeRecords) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.startCoverageIndex + glyph - range2.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched) matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features)) return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i4 = glyph - classDef.startGlyph;
        if (i4 >= 0 && i4 < classDef.classValueArray.length) return classDef.classValueArray[i4];
        break;
      case 2:
        for (let range2 of classDef.classRangeRecord) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index2, set5;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        set5 = table.ruleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index2 === -1) return false;
        set5 = table.classSet[index2];
        for (let rule of set5) {
          if (this.classSequenceMatches(1, rule.classes, table.classDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index2;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let set5 = table.chainRuleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index2];
        if (!rules) return false;
        for (let rule of rules) {
          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font, table) {
    this.font = font;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font, id, codePoints = [], features) {
    this._font = font;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features)) for (let i4 = 0; i4 < features.length; i4++) {
      let feature = features[i4];
      this.features[feature] = true;
    }
    else if (typeof features === "object") Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i4 = 0;
    while (i4 < glyphs.length) {
      let action;
      let glyph = glyphs[i4];
      let code = glyph.codePoints[0];
      let type = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code)) i4 = $e1c6bbc8cb416f8c$var$decompose(glyphs, i4, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i4 = $e1c6bbc8cb416f8c$var$compose(glyphs, i4, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i4, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i4 = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i4, plan.font);
          break;
      }
      i4++;
    }
  }
};
(0, _define_property)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
var $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
var $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
var $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
var $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
var $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
var $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
var $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
var $e1c6bbc8cb416f8c$var$isCombiningT = (code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
    code
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i4, font) {
  let glyph = glyphs[i4];
  let code = glyph.codePoints[0];
  let s2 = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t4 = $e1c6bbc8cb416f8c$var$T_BASE + s2 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s2 = s2 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l2 = $e1c6bbc8cb416f8c$var$L_BASE + s2 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v3 = $e1c6bbc8cb416f8c$var$V_BASE + s2 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font.hasGlyphForCodePoint(l2) || !font.hasGlyphForCodePoint(v3) || t4 !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t4)) return i4;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l2, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v3, glyph.features);
  vjmo.features.vjmo = true;
  let insert2 = [
    ljmo,
    vjmo
  ];
  if (t4 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t4, glyph.features);
    tjmo.features.tjmo = true;
    insert2.push(tjmo);
  }
  glyphs.splice(i4, 1, ...insert2);
  return i4 + insert2.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i4, font) {
  let glyph = glyphs[i4];
  let code = glyphs[i4].codePoints[0];
  let type = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i4 - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i4 - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i4 - 2];
      vjmo = glyphs[i4 - 1];
      tjmo = glyph;
    }
    let l2 = ljmo.codePoints[0];
    let v3 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l2) && $e1c6bbc8cb416f8c$var$isCombiningV(v3)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l2 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v3 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t4 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t4 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t4))) {
    let s2 = lv + (t4 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font.hasGlyphForCodePoint(s2)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i4 - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s2, glyph.features));
      return i4 - del + 1;
    }
  }
  if (ljmo) ljmo.features.ljmo = true;
  if (vjmo) vjmo.features.vjmo = true;
  if (tjmo) tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i4 - 1, font);
    return i4 + 1;
  }
  return i4;
}
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i4, font) {
  let glyph = glyphs[i4];
  let code = glyphs[i4].codePoints[0];
  if (font.glyphForCodePoint(code).advanceWidth === 0) return;
  let prev = glyphs[i4 - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i4, 1);
  return glyphs.splice(i4 - len, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i4, font) {
  let glyph = glyphs[i4];
  let code = glyphs[i4].codePoints[0];
  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i4 : i4 + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i4++;
  }
  return i4;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","null","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","M","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i4 = glyphs.length - 1; i4 >= 0; i4--) {
      let codepoint = glyphs[i4].codePoints[0];
      let d2 = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d2) {
        let decomposed = d2.map((c4) => {
          let g3 = plan.font.glyphForCodePoint(c4);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g3.id, [
            c4
          ], glyphs[i4].features);
        });
        glyphs.splice(i4, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
var $7826f90f6f0cecc9$var$IndicInfo = class {
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  let last2 = 0;
  for (let [start2, end2, tags2] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start2 > last2) {
      ++syllable;
      for (let i4 = last2; i4 < start2; i4++) glyphs[i4].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i4 = start2; i4 <= end2; i4++) glyphs[i4].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i4]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i4]), tags2[0], syllable);
    last2 = end2 + 1;
  }
  if (last2 < glyphs.length) {
    ++syllable;
    for (let i4 = last2; i4 < glyphs.length; i4++) glyphs[i4].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs) glyph.features = {
    [feature]: true
  };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font.glyphForCodePoint(9676).id;
  let virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [
      indicConfig.virama
    ]);
    for (let i4 = 0; i4 < glyphs.length; i4++) if (glyphs[i4].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) glyphs[i4].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i4].copy(), info);
  }
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let { category, syllableType } = glyphs[start2].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g3 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g3.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g3), $7826f90f6f0cecc9$var$indicPosition(g3), glyphs[start2].shaperInfo.syllableType, glyphs[start2].shaperInfo.syllable);
      let i4 = start2;
      while (i4 < end2 && glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) i4++;
      glyphs.splice(i4++, 0, g3);
      end2++;
    }
    let base = end2;
    let limit = start2;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start2 + 3 <= end2 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start2 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start2 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g3 = [
        glyphs[start2].copy(),
        glyphs[start2 + 1].copy(),
        glyphs[start2 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g3.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g3, "rphf")) {
        limit += 2;
        while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
        base = start2;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
      base = start2;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i4 = end2;
        let seenBelow = false;
        do {
          let info = glyphs[--i4].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
            if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i4;
              break;
            }
            if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;
            base = i4;
          } else if (start2 < i4 && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i4 - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        } while (i4 > limit);
        break;
      }
      case "First":
        base = start2;
        for (let i4 = base + 1; i4 < end2; i4++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) glyphs[i4].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start2 && limit - base <= 2) hasReph = false;
    for (let i4 = start2; i4 < base; i4++) {
      let info = glyphs[i4].shaperInfo;
      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
    }
    if (base < end2) glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i4 = base + 1; i4 < end2; i4++) if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
      for (let j = i4 + 1; j < end2; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
        glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
        break;
      }
      break;
    }
    if (hasReph) glyphs[start2].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i4 = base + 1; i4 < end2; i4++) if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
        let j;
        for (j = end2 - 1; j > i4; j--) {
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        }
        if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i4) {
          let t4 = glyphs[i4];
          glyphs.splice(i4, 0, ...glyphs.splice(i4 + 1, j - i4));
          glyphs[j] = t4;
        }
        break;
      }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i4 = start2; i4 < end2; i4++) {
      let info = glyphs[i4].shaperInfo;
      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
        info.position = lastPos;
        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i4; j > start2; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            info.position = glyphs[j - 1].shaperInfo.position;
            break;
          }
        }
      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) lastPos = info.position;
    }
    let last2 = base;
    for (let i4 = base + 1; i4 < end2; i4++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
        for (let j = last2 + 1; j < i4; j++) if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i4].shaperInfo.position;
        last2 = i4;
      } else if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) last2 = i4;
    }
    let arr = glyphs.slice(start2, end2);
    arr.sort((a4, b3) => a4.shaperInfo.position - b3.shaperInfo.position);
    glyphs.splice(start2, arr.length, ...arr);
    for (let i4 = start2; i4 < end2; i4++) if (glyphs[i4].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      base = i4;
      break;
    }
    for (let i4 = start2; i4 < end2 && glyphs[i4].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i4++) glyphs[i4].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i4 = start2; i4 < base; i4++) {
      glyphs[i4].features.half = true;
      if (blwf) glyphs[i4].features.blwf = true;
    }
    for (let i4 = base + 1; i4 < end2; i4++) {
      glyphs[i4].features.abvf = true;
      glyphs[i4].features.pstf = true;
      glyphs[i4].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i4 = start2; i4 + 1 < base; i4++) if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i4 + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i4 + 1 === base || glyphs[i4 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
        glyphs[i4].features.blwf = true;
        glyphs[i4 + 1].features.blwf = true;
      }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end2)
      for (let i4 = base + 1; i4 + prefLen - 1 < end2; i4++) {
        let g3 = [
          glyphs[i4].copy(),
          glyphs[i4 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g3, "pref")) {
          for (let j = 0; j < prefLen; j++) glyphs[i4++].features.pref = true;
          if (features.cfar) for (; i4 < end2; i4++) glyphs[i4].features.cfar = true;
          break;
        }
      }
    for (let i4 = start2 + 1; i4 < end2; i4++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i4])) {
      let nonJoiner = glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
      let j = i4;
      do {
        j--;
        if (nonJoiner) delete glyphs[j].features.half;
      } while (j > start2 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
    }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let tryPref = !!features.pref;
    let base = start2;
    for (; base < end2; base++) if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      if (tryPref && base + 1 < end2) {
        for (let i4 = base + 1; i4 < end2; i4++) if (glyphs[i4].features.pref) {
          if (!(glyphs[i4].substituted && glyphs[i4].isLigated && !glyphs[i4].isMultiplied)) {
            base = i4;
            while (base < end2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;
            glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
            tryPref = false;
          }
          break;
        }
      }
      if (plan.unicodeScript === "Malayalam") for (let i4 = base + 1; i4 < end2; i4++) {
        while (i4 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i4])) i4++;
        if (i4 === end2 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i4])) break;
        i4++;
        while (i4 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i4])) i4++;
        if (i4 < end2 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i4]) && glyphs[i4].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
          base = i4;
          glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
        }
      }
      if (start2 < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) base--;
      break;
    }
    if (base === end2 && start2 < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ) base--;
    if (base < end2) while (start2 < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))) base--;
    if (start2 + 1 < end2 && start2 < base) {
      let newPos = base === end2 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start2 && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;
        } else newPos = start2;
      }
      if (start2 < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i4 = newPos; i4 > start2; i4--) if (glyphs[i4 - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          let oldPos = i4 - 1;
          if (oldPos < base && base <= newPos) base--;
          let tmp = glyphs[oldPos];
          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
          glyphs[newPos] = tmp;
          newPos--;
        }
      }
    }
    if (start2 + 1 < end2 && glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start2].isLigated && !glyphs[start2].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;
          found = newRephPos < end2;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;
          found = newRephPos < end2;
        }
      }
      if (!found) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end2 - 1;
        while (newRephPos > start2 && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i4 = base + 1; i4 < newRephPos; i4++) if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) newRephPos--;
        }
      }
      let reph = glyphs[start2];
      glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, newRephPos - start2));
      glyphs[newRephPos] = reph;
      if (start2 < base && base <= newRephPos) base--;
    }
    if (tryPref && base + 1 < end2) {
      for (let i4 = base + 1; i4 < end2; i4++) if (glyphs[i4].features.pref) {
        if (glyphs[i4].isLigated && !glyphs[i4].isMultiplied) {
          let newPos = base;
          if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
            while (newPos > start2 && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
            if (newPos > start2 && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
              let oldPos2 = i4;
              for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                newPos--;
                break;
              }
            }
          }
          if (newPos > start2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
            if (newPos < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;
          }
          let oldPos = i4;
          let tmp = glyphs[oldPos];
          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
          glyphs[newPos] = tmp;
          if (newPos <= base && base < oldPos) base++;
        }
        break;
      }
    }
    if (glyphs[start2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start2 || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start2 - 1].codePoints[0])))) glyphs[start2].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i4 = glyphs.length - 1; i4 >= 0; i4--) {
      let codepoint = glyphs[i4].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c4) => {
          let g3 = plan.font.glyphForCodePoint(c4);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g3.id, [
            c4
          ], glyphs[i4].features);
        });
        glyphs.splice(i4, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
var $7ab494fe977143c6$var$USEInfo = class {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  for (let [start2, end2, tags2] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i4 = start2; i4 <= end2; i4++) glyphs[i4].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i4])], tags2[0], syllable);
    let limit = glyphs[start2].shaperInfo.category === "R" ? 1 : Math.min(3, end2 - start2);
    for (let i4 = start2; i4 < start2 + limit; i4++) glyphs[i4].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
  for (let glyph of glyphs) glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
    glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted)
    glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font, glyphs) {
  let dottedCircle = font.glyphForCodePoint(9676).id;
  for (let start2 = 0, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, start2)) {
    let i4, j;
    let info = glyphs[start2].shaperInfo;
    let type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") continue;
    if (type === "broken_cluster" && dottedCircle) {
      let g3 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g3.shaperInfo = info;
      for (i4 = start2; i4 < end2 && glyphs[i4].shaperInfo.category === "R"; i4++) ;
      glyphs.splice(++i4, 0, g3);
      end2++;
    }
    if (info.category === "R" && end2 - start2 > 1)
      for (i4 = start2 + 1; i4 < end2; i4++) {
        info = glyphs[i4].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i4])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i4])) i4--;
          glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, i4 - start2), glyphs[i4]);
          break;
        }
      }
    for (i4 = start2, j = end2; i4 < end2; i4++) {
      info = glyphs[i4].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i4]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i4]) ? i4 + 1 : i4;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i4) glyphs.splice(j, 1, glyphs[i4], ...glyphs.splice(j, i4 - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script)) script = [
    script
  ];
  for (let s2 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s2];
    if (shaper) return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index2);
            break;
        }
        return true;
      }
      case 2: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let sequence = table.sequences.get(index2);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i4) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i4 + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        for (let ligature of table.ligatureSets.get(index2)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index3 of matched) characters2.push(...this.glyphs[index3].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i4 = 0; i4 < matched.length && isMarkLigature; i4++) isMarkLigature = this.glyphs[matched[i4]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature) idx = matchIndex;
            else while (idx < matchIndex) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
              this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
              this.glyphs[idx].ligatureComponent = ligatureComponent;
              idx++;
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) for (let i4 = idx; i4 < this.glyphs.length; i4++) {
            if (this.glyphs[i4].ligatureID === lastLigID) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i4].ligatureComponent || 1, lastNumComps);
              this.glyphs[i4].ligatureComponent = ligatureComponent;
            } else break;
          }
          for (let i4 = matched.length - 1; i4 >= 0; i4--) this.glyphs.splice(matched[i4], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null) position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null) position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null) position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null) position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index2));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) return false;
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            let set5 = table.pairSets.get(index2);
            for (let pair2 of set5) if (pair2.secondGlyph === nextGlyph.id) {
              this.applyPositionValue(0, pair2.value1);
              this.applyPositionValue(1, pair2.value2);
              return true;
            }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1) return false;
            var pair = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair.value1);
            this.applyPositionValue(1, pair.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph) return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor) return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d2;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d2 = entry.x + next.xOffset;
            next.xAdvance -= d2;
            next.xOffset -= d2;
            break;
          case "rtl":
            d2 = exit.x + cur.xOffset;
            cur.xAdvance -= d2;
            cur.xOffset -= d2;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
        if (baseGlyphIndex < 0) return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
        if (baseGlyphIndex < 0) return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1) return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1) return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID) good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
        if (!good) return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1) return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y3 = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable) y3 += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y: y3
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i4 = 0; i4 < this.glyphs.length; i4++) this.fixCursiveAttachment(i4);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i4) {
    let glyph = this.glyphs[i4];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i4].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i4 = 0; i4 < this.glyphs.length; i4++) {
      let glyph = this.glyphs[i4];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i4].xOffset += this.positions[j].xOffset;
        this.positions[i4].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") for (let k3 = j; k3 < i4; k3++) {
          this.positions[i4].xOffset -= this.positions[k3].xAdvance;
          this.positions[i4].yOffset -= this.positions[k3].yAdvance;
        }
        else for (let k3 = j + 1; k3 < i4 + 1; k3++) {
          this.positions[i4].xOffset += this.positions[k3].xAdvance;
          this.positions[i4].yOffset += this.positions[k3].yAdvance;
        }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i4 = 0; i4 < this.glyphInfos.length; i4++) if (this.glyphInfos[i4].isMark) {
      positions[i4].xAdvance = 0;
      positions[i4].yAdvance = 0;
    }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB) this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);
    if (font.GPOS) this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  layout(string, features, script, language, direction) {
    if (typeof features === "string") {
      direction = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string) codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i4 = 0; i4 < glyphs.length; i4++) if (this.isDefaultIgnorable(glyphs[i4].codePoints[0])) {
      glyphs[i4] = space;
      positions[i4].xAdvance = 0;
      positions[i4].yAdvance = 0;
    }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1) features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
    return Array.from(result);
  }
  constructor(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c4) => {
        return ctx[c4.command].apply(ctx, c4.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c4) => {
      let args = c4.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c4.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command of this.commands) for (let i4 = 0; i4 < command.args.length; i4 += 2) cbox.addPoint(command.args[i4], command.args[i4 + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox) return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx2 = 0, cy2 = 0;
    let f3 = (t4) => Math.pow(1 - t4, 3) * p0[i4] + 3 * Math.pow(1 - t4, 2) * t4 * p1[i4] + 3 * (1 - t4) * Math.pow(t4, 2) * p22[i4] + Math.pow(t4, 3) * p3[i4];
    for (let c4 of this.commands) switch (c4.command) {
      case "moveTo":
      case "lineTo":
        let [x, y3] = c4.args;
        bbox.addPoint(x, y3);
        cx2 = x;
        cy2 = y3;
        break;
      case "quadraticCurveTo":
      case "bezierCurveTo":
        if (c4.command === "quadraticCurveTo") {
          var [qp1x, qp1y, p3x, p3y] = c4.args;
          var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
          var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
          var cp2x = p3x + 2 / 3 * (qp1x - p3x);
          var cp2y = p3y + 2 / 3 * (qp1y - p3y);
        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c4.args;
        bbox.addPoint(p3x, p3y);
        var p0 = [
          cx2,
          cy2
        ];
        var p1 = [
          cp1x,
          cp1y
        ];
        var p22 = [
          cp2x,
          cp2y
        ];
        var p3 = [
          p3x,
          p3y
        ];
        for (var i4 = 0; i4 <= 1; i4++) {
          let b3 = 6 * p0[i4] - 12 * p1[i4] + 6 * p22[i4];
          let a4 = -3 * p0[i4] + 9 * p1[i4] - 9 * p22[i4] + 3 * p3[i4];
          c4 = 3 * p1[i4] - 3 * p0[i4];
          if (a4 === 0) {
            if (b3 === 0) continue;
            let t4 = -c4 / b3;
            if (0 < t4 && t4 < 1) {
              if (i4 === 0) bbox.addPoint(f3(t4), bbox.maxY);
              else if (i4 === 1) bbox.addPoint(bbox.maxX, f3(t4));
            }
            continue;
          }
          let b2ac = Math.pow(b3, 2) - 4 * c4 * a4;
          if (b2ac < 0) continue;
          let t1 = (-b3 + Math.sqrt(b2ac)) / (2 * a4);
          if (0 < t1 && t1 < 1) {
            if (i4 === 0) bbox.addPoint(f3(t1), bbox.maxY);
            else if (i4 === 1) bbox.addPoint(bbox.maxX, f3(t1));
          }
          let t22 = (-b3 - Math.sqrt(b2ac)) / (2 * a4);
          if (0 < t22 && t22 < 1) {
            if (i4 === 0) bbox.addPoint(f3(t22), bbox.maxY);
            else if (i4 === 1) bbox.addPoint(bbox.maxX, f3(t22));
          }
        }
        cx2 = p3x;
        cy2 = p3y;
        break;
    }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c4 of this.commands) {
      let args = [];
      for (let i4 = 0; i4 < c4.args.length; i4 += 2) {
        let [x, y3] = fn(c4.args[i4], c4.args[i4 + 1]);
        args.push(x, y3);
      }
      path[c4.command](...args);
    }
    return path;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x, y3) => {
      const tx = m0 * x + m2 * y3 + m4;
      const ty = m1 * x + m3 * y3 + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y3) {
    return this.transform(1, 0, 0, 1, x, y3);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
]) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
  this._bbox = this._cbox = null;
  this.commands.push({
    command,
    args
  });
  return this;
};
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length) return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics) return this._metrics;
    let { advance: advanceWidth2, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) advanceWidth2 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth2,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyphs control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyphs bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale2 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale2);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post) return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length) return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale2 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale2, scale2);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y3 = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y3;
  }
};
var $69aac16029968692$var$Component = class {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal) return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same) val = -val;
      val += prev;
    } else if (same) var val = prev;
    else var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream2.readUInt8();
        for (let j = 0; j < count; j++) flags.push(flag);
      }
    }
    for (var i4 = 0; i4 < flags.length; i4++) {
      var flag = flags[i4];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i4) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i4 = 0; i4 < flags.length; i4++) {
      var flag = flags[i4];
      glyph.points[i4].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i4 = 0; i4 < flags.length; i4++) {
      var flag = flags[i4];
      glyph.points[i4].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset2 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset2;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i4 = 0; i4 < points.length; i4++) {
        let point = points[i4];
        glyph.components[i4].dx = point.x;
        glyph.components[i4].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null) this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth2, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth2, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph) return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i4 = 0; i4 < contours2.length; i4++) {
          let contour = contours2[i4];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y3 = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y3));
          }
        }
      }
    else points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k3 = 0; k3 < points.length; k3++) {
      var point = points[k3];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics) return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i4 = 0; i4 < contours.length; i4++) {
      let contour = contours[i4];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start2 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start2 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path.moveTo(firstPt.x, firstPt.y);
      for (let j = start2; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else throw new Error("Unknown TTF path state");
      }
      if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path.closePath();
    }
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getName() {
    if (this._font.CFF2) return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s2) {
    if (s2.length < 1240) return 107;
    else if (s2.length < 33900) return 1131;
    else return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end2 = str.offset + str.length;
    stream2.pos = str.offset;
    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x = 0, y3 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) width = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0) checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo(x2, y4) {
      if (open) path.closePath();
      path.moveTo(x2, y4);
      open = true;
    }
    let parse3 = function() {
      while (stream2.pos < end2) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index2, subr, phase;
          let c1x, c1y, c2x, c2y, c3x, c3y;
          let c4x, c4y, c5x, c5y, c6x, c6y;
          let pts;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) checkWidth();
              y3 += stack.shift();
              moveTo(x, y3);
              break;
            case 5:
              while (stack.length >= 2) {
                x += stack.shift();
                y3 += stack.shift();
                path.lineTo(x, y3);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase) x += stack.shift();
                else y3 += stack.shift();
                path.lineTo(x, y3);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 10:
              index2 = stack.pop() + subrsBias;
              subr = subrs[index2];
              if (subr) {
                usedSubrs[index2] = true;
                let p3 = stream2.pos;
                let e4 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p3;
                end2 = e4;
              }
              break;
            case 11:
              if (cff.version >= 2) break;
              return;
            case 14:
              if (cff.version >= 2) break;
              if (stack.length > 0) checkWidth();
              if (open) {
                path.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor) throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i4 = 0; i4 < numBlends; i4++) {
                let sum = stack[base + i4];
                for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                stack[base + i4] = sum;
              }
              while (numOperands--) stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) checkWidth();
              x += stack.shift();
              y3 += stack.shift();
              moveTo(x, y3);
              break;
            case 22:
              if (stack.length > 1) checkWidth();
              x += stack.shift();
              moveTo(x, y3);
              break;
            case 24:
              while (stack.length >= 8) {
                c1x = x + stack.shift();
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              x += stack.shift();
              y3 += stack.shift();
              path.lineTo(x, y3);
              break;
            case 25:
              while (stack.length >= 8) {
                x += stack.shift();
                y3 += stack.shift();
                path.lineTo(x, y3);
              }
              c1x = x + stack.shift();
              c1y = y3 + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y3 = c2y + stack.shift();
              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              break;
            case 26:
              if (stack.length % 2) x += stack.shift();
              while (stack.length >= 4) {
                c1x = x;
                c1y = y3 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y3 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 27:
              if (stack.length % 2) y3 += stack.shift();
              while (stack.length >= 4) {
                c1x = x + stack.shift();
                c1y = y3;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y3 = c2y;
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index2 = stack.pop() + gsubrsBias;
              subr = gsubrs[index2];
              if (subr) {
                usedGsubrs[index2] = true;
                let p3 = stream2.pos;
                let e4 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse3();
                stream2.pos = p3;
                end2 = e4;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x + stack.shift();
                  c1y = y3;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y3 = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x;
                  c1y = y3 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y3 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y3);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a4 = stack.pop();
                  let b3 = stack.pop();
                  stack.push(a4 && b3 ? 1 : 0);
                  break;
                case 4:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 || b3 ? 1 : 0);
                  break;
                case 5:
                  a4 = stack.pop();
                  stack.push(a4 ? 0 : 1);
                  break;
                case 9:
                  a4 = stack.pop();
                  stack.push(Math.abs(a4));
                  break;
                case 10:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 + b3);
                  break;
                case 11:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 - b3);
                  break;
                case 12:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 / b3);
                  break;
                case 14:
                  a4 = stack.pop();
                  stack.push(-a4);
                  break;
                case 15:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 === b3 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v22 = stack.pop();
                  stack.push(v1 <= v22 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(a4 * b3);
                  break;
                case 26:
                  a4 = stack.pop();
                  stack.push(Math.sqrt(a4));
                  break;
                case 27:
                  a4 = stack.pop();
                  stack.push(a4, a4);
                  break;
                case 28:
                  a4 = stack.pop();
                  b3 = stack.pop();
                  stack.push(b3, a4);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) idx = 0;
                  else if (idx > stack.length - 1) idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n5 = stack.pop();
                  let j = stack.pop();
                  if (j >= 0) while (j > 0) {
                    var t4 = stack[n5 - 1];
                    for (let i4 = n5 - 2; i4 >= 0; i4--) stack[i4 + 1] = stack[i4];
                    stack[0] = t4;
                    j--;
                  }
                  else while (j < 0) {
                    var t4 = stack[0];
                    for (let i4 = 0; i4 <= n5; i4++) stack[i4] = stack[i4 + 1];
                    stack[n5 - 1] = t4;
                    j++;
                  }
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y3;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y;
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y3 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  pts = [];
                  for (let i4 = 0; i4 <= 5; i4++) {
                    x += stack.shift();
                    y3 += stack.shift();
                    pts.push(x, y3);
                  }
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y3 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y3 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x;
                  let starty = y3;
                  pts = [];
                  for (let i4 = 0; i4 <= 4; i4++) {
                    x += stack.shift();
                    y3 += stack.shift();
                    pts.push(x, y3);
                  }
                  if (Math.abs(x - startx) > Math.abs(y3 - starty)) {
                    x += stack.shift();
                    y3 = starty;
                  } else {
                    x = startx;
                    y3 += stack.shift();
                  }
                  pts.push(x, y3);
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247) stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else stack.push(stream2.readInt32BE() / 65536);
      }
    };
    parse3();
    if (open) path.closePath();
    return path;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t4) => t4.parent.buflen - t4._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i4 = 0; i4 < this._font.sbix.imageTables.length; i4++) {
      var table = this._font.sbix.imageTables[i4];
      if (table.ppem >= size) break;
    }
    let offsets = table.imageOffsets;
    let start2 = offsets[this.id];
    let end2 = offsets[this.id + 1];
    if (start2 === end2) return null;
    this._font.stream.pos = start2;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end2 - start2
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale2 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale2
      });
    }
    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i4 = 0; i4 < this.layers.length; i4++) {
      let layer = this.layers[i4];
      let b3 = layer.glyph.bbox;
      bbox.addPoint(b3.minX, b3.minY);
      bbox.addPoint(b3.maxX, b3.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid) high = mid - 1;
      else if (this.id > rec.gid) low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g3 = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g3, color)
      ];
    }
    let layers = [];
    for (let i4 = baseLayer.firstLayerIndex; i4 < baseLayer.firstLayerIndex + baseLayer.numLayers; i4++) {
      var rec = colr.layerRecords[i4];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g3 = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g3, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i4 = 0; i4 < this.font.fvar.axis.length; i4++) {
      let axis = this.font.fvar.axis[i4];
      if (coords[i4] < axis.defaultValue) normalized.push((coords[i4] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else normalized.push((coords[i4] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar) for (var i4 = 0; i4 < this.font.avar.segment.length; i4++) {
      let segment = this.font.avar.segment[i4];
      for (let j = 0; j < segment.correspondence.length; j++) {
        let pair = segment.correspondence[j];
        if (j >= 1 && normalized[i4] < pair.fromCoord) {
          let prev = segment.correspondence[j - 1];
          normalized[i4] = ((normalized[i4] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
          break;
        }
      }
    }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount) return;
    let offset2 = gvar.offsets[gid];
    if (offset2 === gvar.offsets[gid + 1]) return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset2;
    if (stream2.pos >= stream2.length) return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset2 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i4 = 0; i4 < tupleCount; i4++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a4 = 0; a4 < gvar.axisCount; a4++) endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor2 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor2 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
      else var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) for (let i5 = 0; i5 < glyphPoints.length; i5++) {
        var point = glyphPoints[i5];
        point.x += Math.round(xDeltas[i5] * factor2);
        point.y += Math.round(yDeltas[i5] * factor2);
      }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i5 = 0; i5 < points.length; i5++) {
          let idx = points[i5];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += xDeltas[i5] * factor2;
            point2.y += yDeltas[i5] * factor2;
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i5 = 0; i5 < glyphPoints.length; i5++) {
          let deltaX = outPoints[i5].x - origPoints[i5].x;
          let deltaY = outPoints[i5].y - origPoints[i5].y;
          glyphPoints[i5].x = Math.round(glyphPoints[i5].x + deltaX);
          glyphPoints[i5].y = Math.round(glyphPoints[i5].y + deltaY);
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count = stream2.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count);
    let i4 = 0;
    let point = 0;
    while (i4 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i4 < count; j++) {
        point += fn.call(stream2);
        points[i4++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream2 = this.font.stream;
    let i4 = 0;
    let deltas = new Int16Array(count);
    while (i4 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i4 += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i4 < count; j++) deltas[i4++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor2 = 1;
    for (let i4 = 0; i4 < gvar.axisCount; i4++) {
      if (tupleCoords[i4] === 0) continue;
      if (normalized[i4] === 0) return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i4] < Math.min(0, tupleCoords[i4]) || normalized[i4] > Math.max(0, tupleCoords[i4])) return 0;
        factor2 = (factor2 * normalized[i4] + Number.EPSILON) / (tupleCoords[i4] + Number.EPSILON);
      } else {
        if (normalized[i4] < startCoords[i4] || normalized[i4] > endCoords[i4]) return 0;
        else if (normalized[i4] < tupleCoords[i4]) factor2 = factor2 * (normalized[i4] - startCoords[i4] + Number.EPSILON) / (tupleCoords[i4] - startCoords[i4] + Number.EPSILON);
        else factor2 = factor2 * (endCoords[i4] - normalized[i4] + Number.EPSILON) / (endCoords[i4] - tupleCoords[i4] + Number.EPSILON);
      }
    }
    return factor2;
  }
  // Interpolates points without delta values.
  // Needed for the  and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour) pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point]) point++;
      if (point > endPoint) continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p22, ref1, ref2, inPoints, outPoints) {
    if (p1 > p22) return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i4 = 0; i4 < iterable.length; i4++) {
      let k3 = iterable[i4];
      if (inPoints[ref1][k3] > inPoints[ref2][k3]) {
        var p3 = ref1;
        ref1 = ref2;
        ref2 = p3;
      }
      let in1 = inPoints[ref1][k3];
      let in2 = inPoints[ref2][k3];
      let out1 = outPoints[ref1][k3];
      let out2 = outPoints[ref2][k3];
      if (in1 !== in2 || out1 === out2) {
        let scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p4 = p1; p4 <= p22; p4++) {
          let out = inPoints[p4][k3];
          if (out <= in1) out += out1 - in1;
          else if (out >= in2) out += out2 - in2;
          else out = out1 + (out - in1) * scale2;
          outPoints[p4][k3] = out;
        }
      }
    }
  }
  deltaShift(p1, p22, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0) return;
    for (let p3 = p1; p3 <= p22; p3++) if (p3 !== ref) {
      outPoints[p3].x += deltaX;
      outPoints[p3].y += deltaY;
    }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;
      let entryFormat = table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length) return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length) return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
        else if (axis.peakCoord === 0) axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  includeGlyph(glyph) {
    if (typeof glyph === "object") glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255) stream2.writeUInt8(value2);
    else stream2.writeInt16BE(value2);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  encodeSimple(path, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i4 = 0; i4 < path.commands.length; i4++) {
      let c4 = path.commands[i4];
      for (let j = 0; j < c4.args.length; j += 2) {
        let x = c4.args[j];
        let y3 = c4.args[j + 1];
        let flag = 0;
        if (c4.command === "quadraticCurveTo" && j === 2) {
          let next = path.commands[i4 + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x === midX && y3 === midY) continue;
          }
        }
        if (!(c4.command === "quadraticCurveTo" && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y3, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y3;
        pointCount++;
      }
      if (c4.command === "closePath") endPtsOfContours.push(pointCount - 1);
    }
    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
    let bbox = path.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0) stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last2, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last2;
    if (value2 === last2) flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0) diff = -diff;
        else flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i4 = 0;
    while (i4 < this.glyphs.length) this._addGlyph(this.glyphs[i4++]);
    let maxp = (0, import_clone.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = (0, import_clone.default)(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font) {
    super(font);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i4 = 0; i4 < subrs.length; i4++) {
      let subr = subrs[i4];
      if (used[i4]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else res.push(new Uint8Array([
        11
      ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null) continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i4 = 0; i4 < topDict.FDArray.length; i4++) {
      let dict = topDict.FDArray[i4];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i4]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string) return null;
    if (!this.strings) this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) this.subsetFontdict(topDict);
    else this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font) {
    super(font);
    this.cff = this.font["CFF "];
    if (!this.cff) throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let format3 = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
    return format3 === "true" || format3 === "OTTO" || format3 === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables)) try {
      this._tables[table.tag] = this._decodeTable(table);
    } catch (e4) {
      if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
        console.error(`Error decoding table ${table.tag}`);
        console.error(e4.stack);
      }
    }
    return this._tables[table.tag];
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream2, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the fonts internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last2 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code = 0;
      let nextState = 0;
      if (idx < len) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code), [
          last2,
          code
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last2));
      last2 = code;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters2, this);
      else this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "]) return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar) return res;
    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
      name: axis.name.en,
      min: axis.minValue,
      default: axis.defaultValue,
      max: axis.maxValue
    };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar) return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i4 = 0; i4 < this.fvar.axis.length; i4++) {
        let axis = this.fvar.axis[i4];
        settings[axis.axisTag.trim()] = instance.coord[i4];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string") settings = this.namedVariations[settings];
    if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i4) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font._tables = this._tables;
    return font;
  }
  get _variationProcessor() {
    if (!this.fvar) return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2) return null;
    if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream2, variationCoords = null) {
    (0, _define_property)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table = this.directory.tables[tag];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0) Object.defineProperty(this, tag, {
        get: this._getTable.bind(this, table)
      });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i4 = iterable[j];
      let code = stream2.readUInt8();
      if (result & 3758096384) throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0) return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t4) => (t4.flags & 63) === 63),
  tag: (t4) => t4.customTag || $c28ec7bbb3b8de3a$var$knownTags[t4.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t4) => t4.flags >>> 6 & 3,
  transformed: (t4) => t4.tag === "glyf" || t4.tag === "loca" ? t4.transformVersion === 0 : t4.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t4) => t4.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i4 = 0; i4 < this.tables.length; i4++) {
    let table = this.tables[i4];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
      if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters2, this);
      } else return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index2 = 0; index2 < table.numGlyphs; index2++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i4 = 0; i4 < nContours; i4++) {
          let r5 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r5;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i4 = 0; i4 < nContours; i4++) glyph.points[nPoints[i4] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length2) {
    this.length = length2;
    this._buf = new BufferT(length2);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code = stream2.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream2.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y3;
  let x = y3 = 0;
  let res = [];
  for (let i4 = 0; i4 < nPoints; i4++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b22 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b22 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b22 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y3 += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y3));
  }
  return res;
}
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v3, i4) => name[i4] === v3)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t4) => t4.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t4) => t4.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    let stream2 = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e4) {
      return false;
    }
    for (let type of header.map.typeList.types) {
      if (type.name === "sfnt") return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt) return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v3, i4) => name[i4] === v3)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type of this.header.map.typeList.types) {
      for (let ref of type.refList) if (ref.nameOffset >= 0) {
        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
        ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
      } else ref.name = null;
      if (type.name === "sfnt") this.sfnt = type;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_zstream = __toESM(require_zstream());
var import_deflate = __toESM(require_deflate());
var import_inflate = __toESM(require_inflate());
var import_constants = __toESM(require_constants());
var import_md5 = __toESM(require_md5());

// node_modules/linebreak/dist/module.mjs
var import_unicode_trie3 = __toESM(require_unicode_trie(), 1);
var import_base64_js2 = __toESM(require_b64(), 1);
var $557adaaeb0c7885f$exports = {};
var $1627905f8be2ef3f$export$fb4028874a74450 = 5;
var $1627905f8be2ef3f$export$1bb1140fe1358b00 = 12;
var $1627905f8be2ef3f$export$f3e416a182673355 = 13;
var $1627905f8be2ef3f$export$24aa617c849a894a = 16;
var $1627905f8be2ef3f$export$a73c4d14459b698d = 17;
var $1627905f8be2ef3f$export$9e5d732f3676a9ba = 22;
var $1627905f8be2ef3f$export$1dff41d5c0caca01 = 28;
var $1627905f8be2ef3f$export$30a74a373318dec6 = 31;
var $1627905f8be2ef3f$export$d710c5f50fc7496a = 33;
var $1627905f8be2ef3f$export$66498d28055820a9 = 34;
var $1627905f8be2ef3f$export$eb6c6d0b7c8826f2 = 35;
var $1627905f8be2ef3f$export$de92be486109a1df = 36;
var $1627905f8be2ef3f$export$606cfc2a8896c91f = 37;
var $1627905f8be2ef3f$export$e51d3c675bb0140d = 38;
var $1627905f8be2ef3f$export$da51c6332ad11d7b = 39;
var $1627905f8be2ef3f$export$bea437c40441867d = 40;
var $1627905f8be2ef3f$export$c4c7eecbfed13dc9 = 41;
var $1627905f8be2ef3f$export$98e1f8a379849661 = 42;
var $32627af916ac1b00$export$98f50d781a474745 = 0;
var $32627af916ac1b00$export$12ee1f8f5315ca7e = 1;
var $32627af916ac1b00$export$e4965ce242860454 = 2;
var $32627af916ac1b00$export$8f14048969dcd45e = 3;
var $32627af916ac1b00$export$133eb141bf58aff4 = 4;
var $32627af916ac1b00$export$5bdb8ccbf5c57afc = [
  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$8f14048969dcd45e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ]
  // CB
];
var $557adaaeb0c7885f$var$data = import_base64_js2.default.toByteArray("AAgOAAAAAAAQ4QAAAQ0P8vDtnQuMXUUZx+eyu7d7797d9m5bHoWltKVUlsjLWE0VJNigQoMVqkStEoNQQUl5GIo1KKmogEgqkKbBRki72lYabZMGKoGAjQRtJJDaCCIRiiigREBQS3z+xzOTnZ3O+3HOhd5NfpkzZx7fN9988zivu2M9hGwB28F94DnwEngd/Asc1EtIs9c/bIPDwCxwLDgezHcodyo4w5C+CCwBS8FnwSXgCnA1uFbI93XwbXAbWAfWgx+CzWAb+An4KfgFeAzsYWWfYuFz4CXwGvgb+Dfo6yNkEEwGh4CZYB44FpwI3g1OY+kfBItZOo2fB84Hy8DF4HJwNbiWpV8PVoO1LH4n2NRXyN+KcAd4kNVP9XsY4aPgcfAbsBfs6SniL4K/sPjfEf6HlanXCRkCw2BGvUh/keWfXS/CY+pFXs7x9XHmM94LTmWIeU2cgbxnS/k/B3kf86jDhU8L9V2E40vAFWAlWFUfb++NOL4F3C7JX4/4GiE+hvgWsF0oS7mXldspnN+F493gyXrh9xTav0cg3EvzgVfBG6wsmVSEkxBOBgdPGpd7JI6PnqRvJ68/xlbHof53gPeA94OzwLngk+ACsAwsByvASrAK3MB0Ws3CtQjvBJvAVrADPMDSHkb4CNijaccTwvnf4fiPEs8Lxy+D18A/QU8/xjgYBjPAbDAKTgYLwOngTHAO+EQ/8wuEF4EvsPiVCFf2+9tsFStzA8LVHuXXBsi6QyqzUYiPMR/7Mc7dAx7oL8bzw/3u/Bw8Bp4Az4AXwCtgHzsmDXP5fiF9iiVvly5d0sHngar16NKlS5cuXbp06fLmYlqHXrcd3ph4P0THUY3iXh49novju4S0tzfs5d+JPKewfAsRntZb3K9ZhOMlrO6lCC8An28U9+OuovcPcPxlVu5rCL/VmHh/iHIrzn3fIPu7SN8Axmg+8AOwEWwCm7tp3bRuWjetm5Y8bSu4B9zbKO6ZVsnORrVU3f4uXTqZ2H3sLoyx3eDXjfDndE9qyj6L838CfwVvgFpzYnof4oNgOhgBc8Fos9DrZIQLmtXPP1MmF6wGj4H+KXoWguvADkXaPil+YpuQy8Am8Ey7ODdtmJDF4HowBp4De6HDTNjhfHAHeBr0DBBy0kDxfPbcgSIusgrcWhtnJ8vL+TPix7UIOQtcBq4C28Cr4KRBnANbwSuDE+s50JgyNNFuXbp06XIgsXjIvPafjvXozKY+fVFz/z0LT1uCtKVSWbrOLWPnztG8e0Xfy7ol8XtZJi7WtG+5od2UFXQ/A12vUeS7jp27yVKHjdsU9lXB869TyNvAzt0lpP2oWbwLdjiO78bx/Sz+EMJHwK9Y/LcIfw+eZ3F67/Hl5vh9xX80J+rwX8SvRDhpgL17iPAQMHNArfPrqHPewLheI+AERV6efwV418B4nOZ/H+IfYHV8GOF5LJ3eAz0fx8sM9S0fUNud39O9CulfGZhY5huI3wzWgNvBelbHZoTbNPVpfYjKQpkHwUNgl0LWblbnk0LbbDxr0OMFpL3iqWdu9nWYPlVAWkXY39LnGdCkDbeqv1YNbfcMQ3t9oe8lzm6NH9N1ZB6Ln4BwfkJZJk7RyFnYKt6b/JDQXx9p5X+eFdqOjzM9P9MB/lUlFzr20aXIdzlY4dmn9F3YqtvoO76/2hp/D/xA5Zue88nNyL8GbFbs075X0tyUig3Qd2MCnf//HjnzpbsR3g9+1kHzzVjdnE71/qVBX9rGPUh/ysNWe1neFzvIDi5zAufV1sT0N0poR22wkFUfTOPfA4N2mbZ5fSrqOHSw+IbkSBbOGSzSRgf91/GTUWYBOB2cIZQ/G8cfBZ8CFwrnL8XxF8FKcA24jqXdiPA7Qr61OF7H4mMItwzuv2/YLth1ISt3Hzu3k4W7EH5JqPdRHD/O4k+z8A8IX5Lq3y7Z4nXE9xn6kX6vQ4bKfy+ok+hH+xf3hq9dnTTHhjKd2GmDuWA242iHMq4cC7A8kJ7i8o1+skSa7Jieo38HCWnoNjKFhdSFBxzpZ7QE6lI8N4S14aASZcryaV/WWHw66f6NHuCoxuQxmvM56GX9QMd8Q4D65ywGP+ZzRJuM+zQvx/MOS2VFeqQ4IXnH26zM9Xe6/E6D+4foAzzuajPZp8Qyw5ayZVDWuH0z0BtYRkeIDqH9KO9VbH1btd/lhNqCzvl8zeLnG0S/hnU6baHfpiuO6yy0rd+DHURo/zYF5H26j03rQsip2ndzz82u1z9N4VjWKWeb68Tedpt95HRVXp7H1R6p+/Wt4FPy/PpWwscOLRJ+PVWF/+W0iVyGzs18TIvXkOJ1Wxm66vSXz+vylenrZcj1ub439W+K8RNCGTJi2p/TJ1K23VaXr35tRpnzmjxequgfcfyk6B/TGBVlyedsNgpdd/h+W1U3P99QyFPNo1X3TwpM/WLTIWYfoBqXrv6iskHZ/RFr79R6hIyHBrH3f1nrUVnjP8SnZZ+rYtzr9Exld5MNbPNErusAPg+77u/eDOPftU9yj39TH7rezxd1LvsZQJlzkWlOirG/79zjMj/mtHUKu7vKy+3/LnXr9okyKedjX5/0He9iP/j63LwOQdarEVlfy8OO/Lqw023j6xcqmwxLiOd6heM2i9cV9LJy8jMJ23yQ+rpbfu7EQ/pXE8KYvUSqvVnb4XzZa6LrHMXHR+zcLvqWbm/Bn0/HzIs6fWPHoat8XfnDKmZGxRxeMbn2UqZ5Q94nmcZRbqqUXbZ8+lcjE+cPX11t814orvvAXNcG8vqj2vvk1MGn3anlj0bIT72v47bvE+Lc98T9b6r7AKn6j+8Duf7D0nnZx/j7Zjn0j9nbpSTndaLr9WNLivP+iN23xF7L+fqv6ZouFyb78jxVXvv5jJ9YUs9/sddO8h7KNg5jrhfaJGztT6G7KF+1d6yCmD5Kdb2fan60rSc552fZr3zeQ9DpnPp+Si5cx5Ktv2QfSzF/mMbWdOm46rFI4XstnU9xeqX4NKb7TKEdcr6pZOK3ID1k/LvFHkVczEuZLEDr499YqvqBym1aEHWgcvoYOtv0M91qQl5TfpO/in6rWx8OVpT1Wedkv3f5xom3T/xeR/6Gx6V86PWAOB4bBpqWdN+yTcVxjIyGRz/FrDGu6w/3d7kPm8StX8RyPu+uuvpNju/vTLJV37GpvoM0oZPnW87VLnL/5pDno1NoW1R6yedU6TyUv3u19a3KFnIbTLYz+ZCLP4T0tU1uivFgso0pnsJ/UtXvarNY28Xq5cvkBDrQP/E5ZaiuQwwfmTlsOiQRU1fMuqrDd/3ISSuwjOwXOfTyGUMpZIXq4GpLn3pUcdfzch2x7XO1u2uZHOPb1G6b3Xg9PH1IIWeEpJlPQtqos2EKW8b0u8rnuP1UeVLoXJb9be0uG9nnbchjU+XTszT5VeNBThPHnc5OKj1U9aj0GTHIVaGy1YhEWT4ixns00DT+XEzWn/7VAsIc63Cov3OdyhwjrnaqQqZvWKXdypRdlq+k8msZ031U+Rm4fA+3TtyeR9hwfW9G9yxDN0fZMN33F+9TE6md4hwoxumfaUzI9fN3PFT3xVV2msrQ3UsnChm6Nulk8TndpS28D3zX9tTIPsF/z7Am5OkTjm1tI1JZW74+4VgsZ0N3L1yXV3WeP5uR7TGHHdvC3JQlxybfpd22tDlk/2eofRK8TzrN/qnar/K/OUTth6I/+jAnEptNbPvFHP2gs40N3+dfMWtwqvVct7/wfd8gtQ7imifial9ZJ9/3IHLYU6eDj3+4PhsNhX+vwvcWLnu6kGfEMe8DuciPfUfGZB8X/7HJy/Gefe5n+VRGFd/wyP2ta7/LO4yh/sbLV/k9lev6kfO9Dt/5U67b1/6u/epqB1U9Me23jfHY9sscAg4tkbLl+e4/U36rJ9ddxfd6sg5vq5ice42Wpk/pb9FOJ36/W9tpv4kbC79nUbZceX8Zu6/qJ+P3WvhvA8v3reh7Jbn2d6rrNC7XNZTLma4Ba0JI9efX2uLzF5scG/w9UNU1ZxW+ymUfzELeTllXlQ1rUuhzjS5fp9c964iFBOqeSz63bU065nZKdU+mDEz3qHIjjifquw0pnb/raRtvrnsYcb46ihT3taoYz6brdNW9l6rWRnE/navdPn1XlR1km7hcz1WlH/elKuSOSvLLuE8U6m8uzwRdfcGl73VyTHuyMvzJ1Sa2cWDTP/Z63Kc94n2B1PYr24dz1JlyHLlcP+S4B6vD1c9EW4q2LWstCvUjeVy63k/LMYdUNd5D1xQfvVTzX1VjkMsUv88N8VH5fReVn/Fjn++/h6X6Q8a6b1/q3g/i/ewi0/Scs8zxXeV6mWIOUPlPzBgdFerW+bZrm2P18dnjuK6HunEp+rHvPMXbr+sHVb/lnL+pTP57jPw9Cvk3PW178JD9qChfzuvTf7Htl38L1QUf/VKu9SFjwWbTWPvFEvu7Uq76y7+31g6QlYPc669pbsm9Xur2LWI9Pu8ypfDXqm3A2z8s1FWGn4ntL9NfQu2oSlftX9uetvTtv7J8Ql4zxfXGZ3zk8PeQ9w59x2uMfqI8/q5eKh/l9cb2rwsu9rSNl06ZP2Pmxtz+rNMx93yno0n2/82rVH7rQ+y9P15H6FyRun9ViH81ATmffI7nJ5r8uXXW6enbP6b/B8/l5OifVHYLnb9S39s2zcc+Ph+rh8+eQgVPS72elzGWY/tUtbbabBpDiI7yN1q6/4th2y+ErAc5+9BVvu/7KamJbWNZeuqI/R4tRf+YyD1HmOZM1bMV3/14Sn10c0Xu+Sj1nOXb5jL73ncdy02uvlXZNde65dOHYl7Vs4KYuS6FzWLn2zJlpZqPXPVPOa5yzKOyn1VhT9lmMfdbfH7D11Wf2PXN5h9y+dD287+qxgSnaYmnIrRtIb8pJe6/Uv9OVer6Whn0zfGO/BEloZI9ojmfAlUflClDd178bTmVHVTpZXOkAlk/lb42UujmI89HH5V+cl7XtowY6vTxLVWok6UrGzoGTHN+bB+6ri05687VNpvfuvRfaP2uMlNQth1D5JjGelm/8yn+9p3p/7qk9gnfeddXZmq/Sm333PJT659Kv1zjNbZ9uv2Oi//67CV8/N1nj1DmviyXDNVeJkaeaX8UsyesYg8cu2+NvdaPfb+lLDu5tvt/");
var $557adaaeb0c7885f$var$classTrie = new import_unicode_trie3.default($557adaaeb0c7885f$var$data);
var $557adaaeb0c7885f$var$mapClass = function(c4) {
  switch (c4) {
    case $1627905f8be2ef3f$export$d710c5f50fc7496a:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$da51c6332ad11d7b:
    case $1627905f8be2ef3f$export$bea437c40441867d:
    case $1627905f8be2ef3f$export$98e1f8a379849661:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$eb6c6d0b7c8826f2:
      return $1627905f8be2ef3f$export$fb4028874a74450;
    default:
      return c4;
  }
};
var $557adaaeb0c7885f$var$mapFirst = function(c4) {
  switch (c4) {
    case $1627905f8be2ef3f$export$606cfc2a8896c91f:
    case $1627905f8be2ef3f$export$e51d3c675bb0140d:
      return $1627905f8be2ef3f$export$66498d28055820a9;
    case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
      return $1627905f8be2ef3f$export$9e5d732f3676a9ba;
    default:
      return c4;
  }
};
var $557adaaeb0c7885f$var$Break = class {
  constructor(position, required = false) {
    this.position = position;
    this.required = required;
  }
};
var $557adaaeb0c7885f$var$LineBreaker = class {
  nextCodePoint() {
    const code = this.string.charCodeAt(this.pos++);
    const next = this.string.charCodeAt(this.pos);
    if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
      this.pos++;
      return (code - 55296) * 1024 + (next - 56320) + 65536;
    }
    return code;
  }
  nextCharClass() {
    return $557adaaeb0c7885f$var$mapClass($557adaaeb0c7885f$var$classTrie.get(this.nextCodePoint()));
  }
  getSimpleBreak() {
    switch (this.nextClass) {
      case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
        return false;
      case $1627905f8be2ef3f$export$66498d28055820a9:
      case $1627905f8be2ef3f$export$606cfc2a8896c91f:
      case $1627905f8be2ef3f$export$e51d3c675bb0140d:
        this.curClass = $1627905f8be2ef3f$export$66498d28055820a9;
        return false;
      case $1627905f8be2ef3f$export$de92be486109a1df:
        this.curClass = $1627905f8be2ef3f$export$de92be486109a1df;
        return false;
    }
    return null;
  }
  getPairTableBreak(lastClass) {
    let shouldBreak2 = false;
    switch ($32627af916ac1b00$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
      case $32627af916ac1b00$export$98f50d781a474745:
        shouldBreak2 = true;
        break;
      case $32627af916ac1b00$export$12ee1f8f5315ca7e:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        break;
      case $32627af916ac1b00$export$e4965ce242860454:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        if (!shouldBreak2) {
          shouldBreak2 = false;
          return shouldBreak2;
        }
        break;
      case $32627af916ac1b00$export$8f14048969dcd45e:
        if (lastClass !== $1627905f8be2ef3f$export$c4c7eecbfed13dc9) return shouldBreak2;
        break;
      case $32627af916ac1b00$export$133eb141bf58aff4:
        break;
    }
    if (this.LB8a) shouldBreak2 = false;
    if (this.LB21a && (this.curClass === $1627905f8be2ef3f$export$24aa617c849a894a || this.curClass === $1627905f8be2ef3f$export$a73c4d14459b698d)) {
      shouldBreak2 = false;
      this.LB21a = false;
    } else this.LB21a = this.curClass === $1627905f8be2ef3f$export$f3e416a182673355;
    if (this.curClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
      this.LB30a++;
      if (this.LB30a == 2 && this.nextClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
        shouldBreak2 = true;
        this.LB30a = 0;
      }
    } else this.LB30a = 0;
    this.curClass = this.nextClass;
    return shouldBreak2;
  }
  nextBreak() {
    if (this.curClass == null) {
      let firstClass = this.nextCharClass();
      this.curClass = $557adaaeb0c7885f$var$mapFirst(firstClass);
      this.nextClass = firstClass;
      this.LB8a = firstClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      this.LB30a = 0;
    }
    while (this.pos < this.string.length) {
      this.lastPos = this.pos;
      const lastClass = this.nextClass;
      this.nextClass = this.nextCharClass();
      if (this.curClass === $1627905f8be2ef3f$export$66498d28055820a9 || this.curClass === $1627905f8be2ef3f$export$de92be486109a1df && this.nextClass !== $1627905f8be2ef3f$export$606cfc2a8896c91f) {
        this.curClass = $557adaaeb0c7885f$var$mapFirst($557adaaeb0c7885f$var$mapClass(this.nextClass));
        return new $557adaaeb0c7885f$var$Break(this.lastPos, true);
      }
      let shouldBreak2 = this.getSimpleBreak();
      if (shouldBreak2 === null) shouldBreak2 = this.getPairTableBreak(lastClass);
      this.LB8a = this.nextClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      if (shouldBreak2) return new $557adaaeb0c7885f$var$Break(this.lastPos);
    }
    if (this.lastPos < this.string.length) {
      this.lastPos = this.string.length;
      return new $557adaaeb0c7885f$var$Break(this.string.length);
    }
    return null;
  }
  constructor(string) {
    this.string = string;
    this.pos = 0;
    this.lastPos = 0;
    this.curClass = null;
    this.nextClass = null;
    this.LB8a = false;
    this.LB21a = false;
    this.LB30a = 0;
  }
};
$557adaaeb0c7885f$exports = $557adaaeb0c7885f$var$LineBreaker;

// node_modules/jay-peg/src/markers/dac.js
var DACTable = new Struct({
  identifier: new BufferT(1),
  value: new BufferT(1)
});
var DACMarker = {
  name: () => "DAC",
  length: uint16be,
  tables: new ArrayT(DACTable, (parent) => parent.length / 2)
};
var dac_default = DACMarker;

// node_modules/jay-peg/src/markers/utils.js
var readUInt8 = (array, offset2) => {
  return array[offset2];
};
var readUInt16BE = (array, offset2) => {
  return array[offset2] << 8 | array[offset2 + 1];
};
var readUInt16LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8;
};
var readUInt32BE = (array, offset2) => {
  return readInt32BE(array, offset2) >>> 0;
};
var readUInt32LE = (array, offset2) => {
  return readInt32LE(array, offset2) >>> 0;
};
var uint8ArrayToHexString = (uint8Array) => {
  return Array.from(
    uint8Array,
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
};
var decoder = new TextDecoder("utf-8");
var uint8ArrayToString = (uint8Array) => {
  return decoder.decode(uint8Array);
};
var concatenateUint8Arrays = (arrays) => {
  const totalLength = arrays.reduce((length2, arr) => length2 + arr.length, 0);
  const concatenatedArray = new Uint8Array(totalLength);
  let offset2 = 0;
  arrays.forEach((arr) => {
    concatenatedArray.set(arr, offset2);
    offset2 += arr.length;
  });
  return concatenatedArray;
};
var readInt32BE = (array, offset2) => {
  return array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3];
};
var readInt32LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8 | array[offset2 + 2] << 16 | array[offset2 + 3] << 24;
};

// node_modules/jay-peg/src/markers/dht.js
var HuffmanTableElements = class {
  decode(stream2, parent) {
    const tables = {};
    let buffer = stream2.buffer.slice(
      stream2.pos,
      stream2.pos + parent.length - 2
    );
    while (buffer.length > 0) {
      let offset2 = 1;
      const elements = [];
      const identifier = readUInt8(buffer, 0);
      const lengths = buffer.slice(offset2, offset2 + 16);
      offset2 += 16;
      for (const length2 of lengths) {
        elements.push(buffer.slice(offset2, offset2 + length2));
        offset2 += length2;
      }
      buffer = buffer.slice(offset2);
      tables[identifier] = concatenateUint8Arrays(elements);
    }
    stream2.pos += parent.length - 2;
    return tables;
  }
};
var DefineHuffmanTableMarker = {
  name: () => "DHT",
  length: uint16be,
  tables: new HuffmanTableElements()
};
var dht_default = DefineHuffmanTableMarker;

// node_modules/jay-peg/src/markers/dqt.js
var DQTMarker = {
  name: () => "DQT",
  length: uint16be,
  tables: new ArrayT(
    new Struct({
      identifier: new BufferT(1),
      data: new BufferT(64)
    }),
    (parent) => (parent.length - 2) / 65
  )
};
var dqt_default = DQTMarker;

// node_modules/jay-peg/src/markers/dri.js
var DRIMarker = {
  name: () => "DRI",
  length: uint16be,
  restartInterval: uint16be
};
var dri_default = DRIMarker;

// node_modules/jay-peg/src/markers/eoi.js
var EndOfImageMarker = {
  name: () => "EOI",
  afterEOI: new Reserved(uint8, Infinity)
};
var eoi_default = EndOfImageMarker;

// node_modules/jay-peg/src/markers/exif.js
var tags = {
  ifd: {
    "010e": "imageDescription",
    "010f": "make",
    "011a": "xResolution",
    "011b": "yResolution",
    "011c": "planarConfiguration",
    "012d": "transferFunction",
    "013b": "artist",
    "013e": "whitePoint",
    "013f": "primaryChromaticities",
    "0100": "imageWidth",
    "0101": "imageHeight",
    "0102": "bitsPerSample",
    "0103": "compression",
    "0106": "photometricInterpretation",
    "0110": "model",
    "0111": "stripOffsets",
    "0112": "orientation",
    "0115": "samplesPerPixel",
    "0116": "rowsPerStrip",
    "0117": "stripByteCounts",
    "0128": "resolutionUnit",
    "0131": "software",
    "0132": "dateTime",
    "0201": "jpegInterchangeFormat",
    "0202": "jpegInterchangeFormatLength",
    "0211": "ycbCrCoefficients",
    "0212": "ycbCrSubSampling",
    "0213": "ycbCrPositioning",
    "0214": "referenceBlackWhite",
    "829a": "exposureTime",
    "829d": "fNumber",
    "920a": "focalLength",
    "927c": "makerNote",
    8298: "copyright",
    8769: "exifIFDPointer",
    8822: "exposureProgram",
    8824: "spectralSensitivity",
    8825: "gpsInfoIFDPointer",
    8827: "photographicSensitivity",
    8828: "oecf",
    8830: "sensitivityType",
    8831: "standardOutputSensitivity",
    8832: "recommendedExposureIndex",
    8833: "isoSpeed",
    8834: "isoSpeedLatitudeyyy",
    8835: "isoSpeedLatitudezzz",
    9e3: "exifVersion",
    9003: "dateTimeOriginal",
    9004: "dateTimeDigitized",
    9101: "componentsConfiguration",
    9102: "compressedBitsPerPixel",
    9201: "shutterSpeedValue",
    9202: "apertureValue",
    9203: "brightnessValue",
    9204: "exposureBiasValue",
    9205: "maxApertureValue",
    9206: "subjectDistance",
    9207: "meteringMode",
    9208: "lightSource",
    9209: "flash",
    9214: "subjectArea",
    9286: "userComment",
    9290: "subSecTime",
    9291: "subSecTimeOriginal",
    9292: "subSecTimeDigitized",
    a000: "flashpixVersion",
    a001: "colorSpace",
    a002: "pixelXDimension",
    a003: "pixelYDimension",
    a004: "relatedSoundFile",
    a005: "interoperabilityIFDPointer",
    a20b: "flashEnergy",
    a20c: "spatialFrequencyResponse",
    a20e: "focalPlaneXResolution",
    a20f: "focalPlaneYResolution",
    a40a: "sharpness",
    a40b: "deviceSettingDescription",
    a40c: "subjectDistanceRange",
    a210: "focalPlaneResolutionUnit",
    a214: "subjectLocation",
    a215: "exposureIndex",
    a217: "sensingMethod",
    a300: "fileSource",
    a301: "sceneType",
    a302: "cfaPattern",
    a401: "customRendered",
    a402: "exposureMode",
    a403: "whiteBalance",
    a404: "digitalZoomRatio",
    a405: "focalLengthIn35mmFilm",
    a406: "sceneCaptureType",
    a407: "gainControl",
    a408: "contrast",
    a409: "saturation",
    a420: "imageUniqueID",
    a430: "cameraOwnerName",
    a431: "bodySerialNumber",
    a432: "lensSpecification",
    a433: "lensMake",
    a434: "lensModel",
    a435: "lensSerialNumber",
    a500: "gamma"
  },
  gps: {
    "0000": "gpsVersionID",
    "0001": "gpsLatitudeRef",
    "0002": "gpsLatitude",
    "0003": "gpsLongitudeRef",
    "0004": "gpsLongitude",
    "0005": "gpsAltitudeRef",
    "0006": "gpsAltitude",
    "0007": "gpsTimeStamp",
    "0008": "gpsSatellites",
    "0009": "gpsStatus",
    "000a": "gpsMeasureMode",
    "000b": "gpsDOP",
    "000c": "gpsSpeedRef",
    "000d": "gpsSpeed",
    "000e": "gpsTrackRef",
    "000f": "gpsTrack",
    "0010": "gpsImgDirectionRef",
    "0011": "gpsImgDirection",
    "0012": "gpsMapDatum",
    "0013": "gpsDestLatitudeRef",
    "0014": "gpsDestLatitude",
    "0015": "gpsDestLongitudeRef",
    "0016": "gpsDestLongitude",
    "0017": "gpsDestBearingRef",
    "0018": "gpsDestBearing",
    "0019": "gpsDestDistanceRef",
    "001a": "gpsDestDistance",
    "001b": "gpsProcessingMethod",
    "001c": "gpsAreaInformation",
    "001d": "gpsDateStamp",
    "001e": "gpsDifferential",
    "001f": "gpsHPositioningError"
  }
};
var IDFEntries = class {
  constructor(bigEndian) {
    this.bigEndian = bigEndian;
    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
  }
  _getTagValue(dataValue, dataFormat, componentsNumber) {
    switch (dataFormat) {
      case 2:
        return dataValue.toString("ascii").replace(/\0+$/, "");
      case 129:
        return dataValue.toString("utf8").replace(/\0+$/, "");
      case 7:
        return "0x" + dataValue.toString("hex");
      default:
        return this._getTagValueForNumericalData(dataValue, dataFormat, componentsNumber);
    }
  }
  _getTagValueForNumericalData(dataValue, dataFormat, componentsNumber) {
    const tagValue = [];
    const componentsBytes = this.bytes[dataFormat];
    for (let i4 = 0; i4 < componentsNumber; i4 += 1) {
      tagValue.push(this._getSingleTagValueForNumericalData(dataValue, dataFormat, i4 * componentsBytes));
    }
    return tagValue.length === 1 ? tagValue[0] : tagValue;
  }
  _getSingleTagValueForNumericalData(dataValue, dataFormat, pos) {
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(dataValue, pos2) : readUInt16LE(dataValue, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(dataValue, pos2) : readUInt32LE(dataValue, pos2);
    const int322 = (pos2) => this.bigEndian ? readInt32BE(dataValue, pos2) : readInt32LE(dataValue, pos2);
    switch (dataFormat) {
      case 1:
        return readUInt8(dataValue, pos);
      case 3:
        return uint162(pos);
      case 4:
        return uint322(pos);
      case 5:
        return uint322(pos) / uint322(pos + 4);
      case 9:
        return int322(pos);
      case 10: {
        return int322(pos) / int322(pos + 4);
      }
    }
  }
  _decodeIDFEntries(buffer, tags2, offset2, log3 = false) {
    let pos = 2 + offset2;
    const entries = {};
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(buffer, pos2) : readUInt16LE(buffer, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(buffer, pos2) : readUInt32LE(buffer, pos2);
    const numberOfEntries = uint162(offset2);
    for (let i4 = 0; i4 < numberOfEntries; i4++) {
      const tagAddress = buffer.slice(pos, pos + 2);
      const dataFormat = uint162(pos + 2);
      const componentsNumber = uint322(pos + 4);
      const componentsBytes = this.bytes[dataFormat];
      const dataLength = componentsNumber * componentsBytes;
      let dataValue = buffer.slice(pos + 8, pos + 12);
      if (dataLength > 4) {
        const dataOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);
        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
      }
      const tagValue = this._getTagValue(dataValue, dataFormat, componentsNumber);
      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());
      const tagName = tags2[tagNumber];
      entries[tagName] = tagValue;
      pos += 12;
    }
    return entries;
  }
  decode(stream2, parent) {
    const buffer = stream2.buffer.slice(stream2.pos - 8);
    const offsetToFirstIFD = parent.offsetToFirstIFD;
    if (offsetToFirstIFD > buffer.length) {
      stream2.pos += parent.parent.length - 16;
      return {};
    }
    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);
    const { exifIFDPointer, gpsInfoIFDPointer } = entries;
    if (exifIFDPointer) {
      entries.subExif = this._decodeIDFEntries(
        buffer,
        tags.ifd,
        exifIFDPointer
      );
    }
    if (gpsInfoIFDPointer) {
      const gps = gpsInfoIFDPointer;
      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);
    }
    stream2.pos += parent.parent.length - 16;
    return entries;
  }
};
var IFDData = (bigEndian) => {
  const uint162 = bigEndian ? uint16be : uint16le;
  const uint322 = bigEndian ? uint32be : uint32le;
  return new Struct({
    fortyTwo: uint162,
    offsetToFirstIFD: uint322,
    entries: new IDFEntries(bigEndian)
  });
};
var TIFFHeader = class {
  decode(stream2, parent) {
    const byteOrder = uint8ArrayToString(
      stream2.buffer.slice(stream2.pos, stream2.pos + 2)
    );
    const bigEndian = byteOrder === "MM";
    stream2.pos += 2;
    const data2 = IFDData(bigEndian).decode(stream2, parent);
    return data2.entries;
  }
};
var EXIFMarker = {
  name: () => "EXIF",
  length: uint16be,
  identifier: new StringT(6),
  entries: new TIFFHeader()
};
var exif_default = EXIFMarker;

// node_modules/jay-peg/src/markers/jfif.js
var JFIFMarker = {
  name: () => "JFIF",
  length: uint16be,
  identifier: new StringT(5),
  version: uint16be,
  units: uint8,
  xDensity: uint16be,
  yDensity: uint16be,
  thumbnailWidth: uint8,
  thumbnailHeight: uint8
};
var jfif_default = JFIFMarker;

// node_modules/jay-peg/src/markers/sos.js
var ImageData = class {
  decode(stream2) {
    const buffer = stream2.buffer.slice(stream2.pos);
    let length2 = 0;
    let i4 = buffer.indexOf(255);
    while (i4 !== -1) {
      length2 = i4;
      const nextByte = buffer[length2 + 1];
      const comesRestart = nextByte >= 208 && nextByte <= 215;
      if (nextByte !== 0 && !comesRestart) break;
      i4 = buffer.indexOf(255, i4 + 1);
    }
    stream2.pos += length2;
    return buffer.slice(0, length2);
  }
};
var SOSComponentSpecification = new Struct({
  scanComponentSelector: uint8,
  entropyCodingTable: new BufferT(1)
});
var SOSMarker = {
  name: () => "SOS",
  length: uint16be,
  numberOfImageComponents: uint8,
  componentSpecifications: new ArrayT(
    SOSComponentSpecification,
    (parent) => parent.numberOfImageComponents
  ),
  startOfSpectral: uint8,
  endOfSpectral: uint8,
  successiveApproximationBit: new BufferT(1),
  data: new ImageData()
};
var sos_default = SOSMarker;

// node_modules/jay-peg/src/markers/sof.js
var FrameColorComponent = new Struct({
  id: uint8,
  samplingFactors: uint8,
  quantizationTableId: uint8
});
var StartOfFrameMarker = {
  name: () => "SOF",
  length: uint16be,
  precision: uint8,
  height: uint16be,
  width: uint16be,
  numberOfComponents: uint8,
  components: new ArrayT(
    FrameColorComponent,
    (parent) => parent.numberOfComponents
  )
};
var sof_default = StartOfFrameMarker;

// node_modules/jay-peg/src/markers/soi.js
var StartOfImageMarker = {
  name: () => "SOI"
};
var soi_default = StartOfImageMarker;

// node_modules/jay-peg/src/index.js
var UnknownMarker = {
  length: uint16be,
  buf: new BufferT((parent) => parent.length - 2)
};
var unknownMarkers = Array(63).fill(0).reduce((acc, v3, i4) => ({ ...acc, [i4 + 65472]: UnknownMarker }), {});
var Marker = new VersionedStruct(uint16be, {
  ...unknownMarkers,
  65472: sof_default,
  65473: sof_default,
  65474: sof_default,
  65475: sof_default,
  65476: dht_default,
  65477: sof_default,
  65478: sof_default,
  65479: sof_default,
  65481: sof_default,
  65482: sof_default,
  65483: sof_default,
  65484: dac_default,
  65485: sof_default,
  65486: sof_default,
  65487: sof_default,
  65496: soi_default,
  65497: eoi_default,
  65498: sos_default,
  65499: dqt_default,
  65501: dri_default,
  65504: jfif_default,
  65505: exif_default
});
var JPEG = new ArrayT(Marker);
var decode = (buffer) => {
  const markers = JPEG.fromBuffer(buffer);
  return markers.map(({ version: version4, ...rest }) => ({ type: version4, ...rest }));
};
var src_default = { decode };

// node_modules/@react-pdf/png-js/lib/png-js.browser.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup[i4] = code[i4];
    revLookup[code.charCodeAt(i4)] = i4;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i4, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i4 = 0, j = 0; i4 < l2; i4 += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i4 = start2; i4 < end2; i4 += 3) {
    tmp = (uint82[i4] << 16) + (uint82[i4 + 1] << 8) + uint82[i4 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len2 = len - extraBytes; i4 < len2; i4 += maxChunkLength) {
    parts.push(encodeChunk(uint82, i4, i4 + maxChunkLength > len2 ? len2 : i4 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i4];
  i4 += d2;
  e4 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  m = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e4 - mLen);
}
function write(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m, c4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c4 = Math.pow(2, -e4)) < 1) {
      e4--;
      c4 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c4;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c4 >= 2) {
      e4++;
      c4 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m = (value2 * c4 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i4] = m & 255, i4 += d2, m /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i4] = e4 & 255, i4 += d2, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i4 - d2] |= s2 * 128;
}
var toString = {}.toString;
var isArray$1 = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length2) {
  if (kMaxLength() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length2) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length2);
}
Buffer2.poolSize = 8192;
Buffer2._augment = function(arr) {
  arr.__proto__ = Buffer2.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer2.from = function(value2, encodingOrOffset, length2) {
  return from(null, value2, encodingOrOffset, length2);
};
if (Buffer2.TYPED_ARRAY_SUPPORT) {
  Buffer2.prototype.__proto__ = Uint8Array.prototype;
  Buffer2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill4, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill4, encoding) : createBuffer(that, size).fill(fill4);
  }
  return createBuffer(that, size);
}
Buffer2.alloc = function(size, fill4, encoding) {
  return alloc(null, size, fill4, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i4 = 0; i4 < size; ++i4) {
      that[i4] = 0;
    }
  }
  return that;
}
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength2(string, encoding) | 0;
  that = createBuffer(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length2);
  for (var i4 = 0; i4 < length2; i4 += 1) {
    that[i4] = array[i4] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length2) {
  if (length2 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer2.alloc(+length2);
}
Buffer2.isBuffer = isBuffer$1;
function internalIsBuffer(b3) {
  return !!(b3 != null && b3._isBuffer);
}
Buffer2.compare = function compare(a4, b3) {
  if (!internalIsBuffer(a4) || !internalIsBuffer(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i4 = 0, len = Math.min(x, y3); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x = a4[i4];
      y3 = b3[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat(list, length2) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i4;
  if (length2 === void 0) {
    length2 = 0;
    for (i4 = 0; i4 < list.length; ++i4) {
      length2 += list[i4].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length2);
  var pos = 0;
  for (i4 = 0; i4 < list.length; ++i4) {
    var buf = list[i4];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength2(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.byteLength = byteLength2;
function slowToString(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start2, end2);
      case "ascii":
        return asciiSlice(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice(this, start2, end2);
      case "base64":
        return base64Slice(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.prototype._isBuffer = true;
function swap(b3, n5, m) {
  var i4 = b3[n5];
  b3[n5] = b3[m];
  b3[m] = i4;
}
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 2) {
    swap(this, i4, i4 + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 4) {
    swap(this, i4, i4 + 3);
    swap(this, i4 + 1, i4 + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 8) {
    swap(this, i4, i4 + 7);
    swap(this, i4 + 1, i4 + 6);
    swap(this, i4 + 2, i4 + 5);
    swap(this, i4 + 3, i4 + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString2() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice(this, 0, length2);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.equals = function equals(b3) {
  if (!internalIsBuffer(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer2.compare(this, b3) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer2.prototype.compare = function compare2(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i4 = 0; i4 < len; ++i4) {
    if (thisCopy[i4] !== targetCopy[i4]) {
      x = thisCopy[i4];
      y3 = targetCopy[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i5) {
    if (indexSize === 1) {
      return buf[i5];
    } else {
      return buf.readUInt16BE(i5 * indexSize);
    }
  }
  var i4;
  if (dir) {
    var foundIndex = -1;
    for (i4 = byteOffset; i4 < arrLength; i4++) {
      if (read4(arr, i4) === read4(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i4 = byteOffset; i4 >= 0; i4--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i4 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i4;
    }
  }
  return -1;
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i4 = 0; i4 < length2; ++i4) {
    var parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (isNaN(parsed)) return i4;
    buf[offset2 + i4] = parsed;
  }
  return i4;
}
function utf8Write(buf, string, offset2, length2) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite(buf, string, offset2, length2) {
  return blitBuffer(asciiToBytes(string), buf, offset2, length2);
}
function latin1Write(buf, string, offset2, length2) {
  return asciiWrite(buf, string, offset2, length2);
}
function base64Write(buf, string, offset2, length2) {
  return blitBuffer(base64ToBytes(string), buf, offset2, length2);
}
function ucs2Write(buf, string, offset2, length2) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
}
Buffer2.prototype.write = function write2(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset2, length2);
      case "ascii":
        return asciiWrite(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset2, length2);
      case "base64":
        return base64Write(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start2, end2));
  }
}
function utf8Slice(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i4 = start2;
  while (i4 < end2) {
    var firstByte = buf[i4];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i4 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          fourthByte = buf[i4 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i4 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i4 = 0;
  while (i4 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4] & 127);
  }
  return ret;
}
function latin1Slice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4]);
  }
  return ret;
}
function hexSlice(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i4 = start2; i4 < end2; ++i4) {
    out += toHex(buf[i4]);
  }
  return out;
}
function utf16leSlice(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i4 = 0; i4 < bytes.length; i4 += 2) {
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  }
  return res;
}
Buffer2.prototype.slice = function slice(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer2(sliceLen, void 0);
    for (var i4 = 0; i4 < sliceLen; ++i4) {
      newBuf[i4] = this[i4 + start2];
    }
  }
  return newBuf;
};
function checkOffset(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  return val;
};
Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer2.prototype.readUInt8 = function readUInt82(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  return this[offset2];
};
Buffer2.prototype.readUInt16LE = function readUInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer2.prototype.readUInt16BE = function readUInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer2.prototype.readUInt32BE = function readUInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset2, byteLength5, this.length);
  var i4 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i4];
  while (i4 > 0 && (mul *= 256)) {
    val += this[offset2 + --i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, false, 52, 8);
};
function checkInt(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i4 = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt16(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 2); i4 < j; ++i4) {
    buf[offset2 + i4] = (value2 & 255 << 8 * (littleEndian ? i4 : 1 - i4)) >>> (littleEndian ? i4 : 1 - i4) * 8;
  }
}
Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 4); i4 < j; ++i4) {
    buf[offset2 + i4] = value2 >>> (littleEndian ? i4 : 3 - i4) * 8 & 255;
  }
}
Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 4);
  }
  write(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, false, noAssert);
};
function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 8);
  }
  write(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i4;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i4 = len - 1; i4 >= 0; --i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
    for (i4 = 0; i4 < len; ++i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i4;
  if (typeof val === "number") {
    for (i4 = start2; i4 < end2; ++i4) {
      this[i4] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
    var len = bytes.length;
    for (i4 = 0; i4 < end2 - start2; ++i4) {
      this[i4 + start2] = bytes[i4 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i4 = 0; i4 < length2; ++i4) {
    codePoint = string.charCodeAt(i4);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    byteArray.push(str.charCodeAt(i4) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c4, hi, lo;
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    if ((units -= 2) < 0) break;
    c4 = str.charCodeAt(i4);
    hi = c4 >> 8;
    lo = c4 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset2, length2) {
  for (var i4 = 0; i4 < length2; ++i4) {
    if (i4 + offset2 >= dst.length || i4 >= src.length) break;
    dst[i4 + offset2] = src[i4];
  }
  return i4;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var _polyfillNode_buffer = Object.freeze({
  __proto__: null,
  Buffer: Buffer2,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  isBuffer: isBuffer$1,
  kMaxLength: _kMaxLength
});
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e4) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e5) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e4) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e5) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      args[i4 - 1] = arguments[i4];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding$1(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance2 = global$1.performance || {};
var performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding: binding$1,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n5) {
  if (n5.__esModule) return n5;
  var f3 = n5.default;
  if (typeof f3 == "function") {
    var a4 = function a5() {
      if (this instanceof a5) {
        return Reflect.construct(f3, arguments, this.constructor);
      }
      return f3.apply(this, arguments);
    };
    a4.prototype = f3.prototype;
  } else a4 = {};
  Object.defineProperty(a4, "__esModule", { value: true });
  Object.keys(n5).forEach(function(k3) {
    var d2 = Object.getOwnPropertyDescriptor(n5, k3);
    Object.defineProperty(a4, k3, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n5[k3];
      }
    });
  });
  return a4;
}
var lib = {};
var require$$0 = getAugmentedNamespace(_polyfillNode_buffer);
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n5) {
  if (typeof n5 !== "number" || n5 < 0 || isNaN(n5))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n5;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].apply(self2, args);
  }
}
EventEmitter.prototype.emit = function emit2(type) {
  var er, handler, len, args, i4, events2, domain3;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i4 = 1; i4 < len; i4++)
        args[i4 - 1] = arguments[i4];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e4) {
  typeof console.warn === "function" ? console.warn(e4) : console.log(e4);
}
EventEmitter.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g3() {
    target.removeListener(type, g3);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g3.listener = listener;
  return g3;
}
EventEmitter.prototype.once = function once2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
  var list, events2, position, i4, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i4 = list.length; i4-- > 0; ) {
      if (list[i4] === listener || list[i4].listener && list[i4].listener === listener) {
        originalListener = list[i4].listener;
        position = i4;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i4 = 0, key; i4 < keys2.length; ++i4) {
      key = keys2[i4];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index2) {
  for (var i4 = index2, k3 = i4 + 1, n5 = list.length; k3 < n5; i4 += 1, k3 += 1)
    list[i4] = list[k3];
  list.pop();
}
function arrayClone(arr, i4) {
  var copy5 = new Array(i4);
  while (i4--)
    copy5[i4] = arr[i4];
  return copy5;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i4 = 0; i4 < ret.length; ++i4) {
    ret[i4] = arr[i4].listener || arr[i4];
  }
  return ret;
}
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i4 = 0; i4 < keys2.length; i4++) {
    descriptors[keys2[i4]] = Object.getOwnPropertyDescriptor(obj, keys2[i4]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
function format(f3) {
  if (!isString(f3)) {
    var objects = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      objects.push(inspect$1(arguments[i4]));
    }
    return objects.join(" ");
  }
  var i4 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f3).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i4 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i4++]);
      case "%d":
        return Number(args[i4++]);
      case "%j":
        try {
          return JSON.stringify(args[i4++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i4]; i4 < len; x = args[++i4]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1(x);
    }
  }
  return str;
}
function deprecate(fn, msg2) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set5) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set5] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs[set5] = function() {
      };
    }
  }
  return debugs[set5];
}
function inspect$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend(ctx, opts2);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys2.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value2)) {
    var n5 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n5 + "]";
  }
  if (isRegExp(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base = " " + formatError(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i4 = 0, l2 = value2.length; i4 < l2; ++i4) {
    if (hasOwnProperty(value2, String(i4))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i4),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject(d2) && objectToString(d2) === "[object Date]";
}
function isError(e4) {
  return isObject(e4) && (objectToString(e4) === "[object Error]" || e4 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o2) {
  return Object.prototype.toString.call(o2);
}
function pad(n5) {
  return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad(d2.getHours()),
    pad(d2.getMinutes()),
    pad(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months[d2.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add2) {
  if (!add2 || !isObject(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i4 = keys2.length;
  while (i4--) {
    origin[keys2[i4]] = add2[keys2[i4]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      args.push(arguments[i4]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      args.push(arguments[i4]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
var _polyfillNode_util = {
  inherits: inherits$1,
  _extend,
  log,
  isBuffer,
  isPrimitive,
  isFunction,
  isError,
  isDate,
  isObject,
  isRegExp,
  isUndefined,
  isSymbol,
  isString,
  isNumber,
  isNullOrUndefined,
  isNull,
  isBoolean,
  isArray,
  inspect: inspect$1,
  deprecate,
  format,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate,
  format,
  inherits: inherits$1,
  inspect: inspect$1,
  isArray,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  log,
  promisify
});
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v3) {
  var entry = { data: v3, next: null };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v3) {
  var entry = { data: v3, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0) return "";
  var p3 = this.head;
  var ret = "" + p3.data;
  while (p3 = p3.next) {
    ret += s2 + p3.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n5) {
  if (this.length === 0) return Buffer2.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer2.allocUnsafe(n5 >>> 0);
  var p3 = this.head;
  var i4 = 0;
  while (p3) {
    p3.data.copy(ret, i4);
    i4 += p3.data.length;
    p3 = p3.next;
  }
  return ret;
};
var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var i4 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i4 > 0; i4--) {
    var c4 = buffer[buffer.length - i4];
    if (i4 == 1 && c4 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i4 <= 2 && c4 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i4 <= 3 && c4 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i4;
};
StringDecoder.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$1(Readable, EventEmitter);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function") this._read = options.read;
  EventEmitter.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state2, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk(this, state2, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
  var er = chunkInvalid(state2, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e4 = new Error("stream.push() after EOF");
      stream2.emit("error", e4);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront) state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront) state2.buffer.unshift(chunk);
          else state2.buffer.push(chunk);
          if (state2.needReadable) emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n5) {
  if (n5 >= MAX_HWM) {
    n5 = MAX_HWM;
  } else {
    n5--;
    n5 |= n5 >>> 1;
    n5 |= n5 >>> 2;
    n5 |= n5 >>> 4;
    n5 |= n5 >>> 8;
    n5 |= n5 >>> 16;
    n5++;
  }
  return n5;
}
function howMuchToRead(n5, state2) {
  if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n5 !== n5) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n5);
  if (n5 <= state2.length) return n5;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n5) {
  debug("read", n5);
  n5 = parseInt(n5, 10);
  var state2 = this._readableState;
  var nOrig = n5;
  if (n5 !== 0) state2.emittedReadable = false;
  if (n5 === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n5 = howMuchToRead(n5, state2);
  if (n5 === 0 && state2.ended) {
    if (state2.length === 0) endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n5 = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n5 > 0) ret = fromList(n5, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n5 = 0;
  } else {
    state2.length -= n5;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n5 && state2.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid(state2, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state2) {
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync) nextTick(emitReadable_, stream2);
    else emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    nextTick(maybeReadMore_, stream2, state2);
  }
}
function maybeReadMore_(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else len = state2.length;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n5) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend3 : cleanup;
  if (state2.endEmitted) nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  function onend3() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0) dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state2 = src._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src.listeners("data").length) {
      state2.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i4 = indexOf2(state2.pipes, dest);
  if (i4 === -1) return this;
  state2.pipes.splice(i4, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state2.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = true;
    resume(this, state2);
  }
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    nextTick(resume_, stream2, state2);
  }
}
function resume_(stream2, state2) {
  if (!state2.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i4 in stream2) {
    if (this[i4] === void 0 && typeof stream2[i4] === "function") {
      this[i4] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i4);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n5) {
    debug("wrapped _read", n5);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n5, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n5 || n5 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n5, state2.buffer, state2.decoder);
  }
  return ret;
}
function fromListPartial(n5, list, hasStrings) {
  var ret;
  if (n5 < list.head.data.length) {
    ret = list.head.data.slice(0, n5);
    list.head.data = list.head.data.slice(n5);
  } else if (n5 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n5, list) : copyFromBuffer(n5, list);
  }
  return ret;
}
function copyFromBufferString(n5, list) {
  var p3 = list.head;
  var c4 = 1;
  var ret = p3.data;
  n5 -= ret.length;
  while (p3 = p3.next) {
    var str = p3.data;
    var nb = n5 > str.length ? str.length : n5;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n5);
    n5 -= nb;
    if (n5 === 0) {
      if (nb === str.length) {
        ++c4;
        if (p3.next) list.head = p3.next;
        else list.head = list.tail = null;
      } else {
        list.head = p3;
        p3.data = str.slice(nb);
      }
      break;
    }
    ++c4;
  }
  list.length -= c4;
  return ret;
}
function copyFromBuffer(n5, list) {
  var ret = Buffer2.allocUnsafe(n5);
  var p3 = list.head;
  var c4 = 1;
  p3.data.copy(ret);
  n5 -= p3.data.length;
  while (p3 = p3.next) {
    var buf = p3.data;
    var nb = n5 > buf.length ? buf.length : n5;
    buf.copy(ret, ret.length - n5, 0, nb);
    n5 -= nb;
    if (n5 === 0) {
      if (nb === buf.length) {
        ++c4;
        if (p3.next) list.head = p3.next;
        else list.head = list.tail = null;
      } else {
        list.head = p3;
        p3.data = buf.slice(nb);
      }
      break;
    }
    ++c4;
  }
  list.length -= c4;
  return ret;
}
function endReadable(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    nextTick(endReadableNT, state2, stream2);
  }
}
function endReadableNT(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f3) {
  for (var i4 = 0, l2 = xs.length; i4 < l2; i4++) {
    f3(xs[i4], i4);
  }
}
function indexOf2(xs, x) {
  for (var i4 = 0, l2 = xs.length; i4 < l2; i4++) {
    if (xs[i4] === x) return i4;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
  }
  EventEmitter.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream2, state2, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state2.ended) writeAfterEnd(this, cb);
  else if (validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk(state2, chunk, encoding);
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) nextTick(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate(state2);
  if (er) onwriteError(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish(state2);
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      nextTick(afterWrite, stream2, state2, finished, cb);
    } else {
      afterWrite(stream2, state2, finished, cb);
    }
  }
}
function afterWrite(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished) endWritable(this, state2, cb);
};
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function prefinish(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state2);
    }
  }
  return need;
}
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished) nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (v3 = 0; v3 < keys.length; v3++) {
  method = keys[v3];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
var method;
var v3;
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$1(Transform2, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform2(options) {
  if (!(this instanceof Transform2)) return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done(stream2, er);
    });
    else done(stream2);
  });
}
Transform2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform2.prototype._read = function(n5) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1(PassThrough, Transform2);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform2;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend3);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend3() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend3);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = Object.freeze({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform2,
  Writable,
  default: Stream
});
var require$$1 = getAugmentedNamespace(_polyfillNode_stream);
var binding = {};
function compare3(a4, b3) {
  if (a4 === b3) {
    return 0;
  }
  var x = a4.length;
  var y3 = b3.length;
  for (var i4 = 0, len = Math.min(x, y3); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x = a4[i4];
      y3 = b3[i4];
      break;
    }
  }
  if (x < y3) {
    return -1;
  }
  if (y3 < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$1(AssertionError, Error);
function truncate(s2, n5) {
  if (typeof s2 === "string") {
    return s2.length < n5 ? s2 : s2.slice(0, n5);
  } else {
    return s2;
  }
}
function inspect2(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect2(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect2(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert.fail = fail;
function ok(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
assert.ok = ok;
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, "==", equal);
}
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare3(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare3(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a4, b3, strict, actualVisitedObjects) {
  if (a4 === null || a4 === void 0 || b3 === null || b3 === void 0)
    return false;
  if (isPrimitive(a4) || isPrimitive(b3))
    return a4 === b3;
  if (strict && Object.getPrototypeOf(a4) !== Object.getPrototypeOf(b3))
    return false;
  var aIsArgs = isArguments(a4);
  var bIsArgs = isArguments(b3);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a4 = pSlice.call(a4);
    b3 = pSlice.call(b3);
    return _deepEqual(a4, b3, strict);
  }
  var ka = objectKeys(a4);
  var kb = objectKeys(b3);
  var key, i4;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    if (ka[i4] !== kb[i4])
      return false;
  }
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    key = ka[i4];
    if (!_deepEqual(a4[key], b3[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e4) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e4) {
    error = e4;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert.throws = throws;
function throws(block, error, message) {
  _throws(true, block, error, message);
}
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert = Object.freeze({
  __proto__: null,
  AssertionError,
  assert: ok,
  deepEqual,
  deepStrictEqual,
  default: assert,
  doesNotThrow,
  equal,
  fail,
  ifError,
  notDeepEqual,
  notDeepStrictEqual,
  notEqual,
  notStrictEqual,
  ok,
  strictEqual,
  throws
});
var require$$4 = getAugmentedNamespace(_polyfillNode_assert);
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p3 in source) {
        if (_has(source, p3)) {
          obj[p3] = source[p3];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i4 = 0; i4 < len; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i4, l2, len, pos, chunk, result;
      len = 0;
      for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
        len += chunks[i4].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
        chunk = chunks[i4];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i4 = 0; i4 < len; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on3) {
    if (on3) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s2, w) {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
}
function send_bits(s2, value2, length2) {
  if (s2.bi_valid > Buf_size - length2) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length2 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length2;
  }
}
function send_code(s2, c4, tree) {
  send_bits(
    s2,
    tree[c4 * 2],
    tree[c4 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s2) {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
}
function gen_bitlen(s2, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h3;
  var n5, m;
  var bits;
  var xbits;
  var f3;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h3 = s2.heap_max + 1; h3 < HEAP_SIZE$1; h3++) {
    n5 = s2.heap[h3];
    bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n5 * 2 + 1] = bits;
    if (n5 > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n5 >= base) {
      xbits = extra[n5 - base];
    }
    f3 = tree[n5 * 2];
    s2.opt_len += f3 * (bits + xbits);
    if (has_stree) {
      s2.static_len += f3 * (stree[n5 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n5 = s2.bl_count[bits];
    while (n5 !== 0) {
      m = s2.heap[--h3];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n5--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n5;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    var len = tree[n5 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n5 * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n5;
  var bits;
  var length2;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length2;
    for (n5 = 0; n5 < 1 << extra_lbits[code]; n5++) {
      _length_code[length2++] = code;
    }
  }
  _length_code[length2 - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n5 = 0; n5 < 1 << extra_dbits[code]; n5++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n5 = 0; n5 < 1 << extra_dbits[code] - 7; n5++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n5 = 0;
  while (n5 <= 143) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  while (n5 <= 255) {
    static_ltree[n5 * 2 + 1] = 9;
    n5++;
    bl_count[9]++;
  }
  while (n5 <= 279) {
    static_ltree[n5 * 2 + 1] = 7;
    n5++;
    bl_count[7]++;
  }
  while (n5 <= 287) {
    static_ltree[n5 * 2 + 1] = 8;
    n5++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    static_dtree[n5 * 2 + 1] = 5;
    static_dtree[n5 * 2] = bi_reverse(n5, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s2) {
  var n5;
  for (n5 = 0; n5 < L_CODES$1; n5++) {
    s2.dyn_ltree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < D_CODES$1; n5++) {
    s2.dyn_dtree[n5 * 2] = 0;
  }
  for (n5 = 0; n5 < BL_CODES$1; n5++) {
    s2.bl_tree[n5 * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
}
function bi_windup(s2) {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
}
function copy_block(s2, buf, len, header) {
  bi_windup(s2);
  if (header) {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  utils$3.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
  s2.pending += len;
}
function smaller(tree, n5, m, depth) {
  var _n2 = n5 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m];
}
function pqdownheap(s2, tree, k3) {
  var v3 = s2.heap[k3];
  var j = k3 << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v3, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k3] = s2.heap[j];
    k3 = j;
    j <<= 1;
  }
  s2.heap[k3] = v3;
}
function compress_block(s2, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s2, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s2, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s2, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
}
function build_tree(s2, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n5, m;
  var max_code = -1;
  var node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n5 = 0; n5 < elems; n5++) {
    if (tree[n5 * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n5;
      s2.depth[n5] = 0;
    } else {
      tree[n5 * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n5 = s2.heap_len >> 1; n5 >= 1; n5--) {
    pqdownheap(s2, tree, n5);
  }
  node = elems;
  do {
    n5 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n5;
    s2.heap[--s2.heap_max] = m;
    tree[node * 2] = tree[n5 * 2] + tree[m * 2];
    s2.depth[node] = (s2.depth[n5] >= s2.depth[m] ? s2.depth[n5] : s2.depth[m]) + 1;
    tree[n5 * 2 + 1] = tree[m * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
}
function scan_tree(s2, tree, max_code) {
  var n5;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s2, tree, max_code) {
  var n5;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n5 = 0; n5 <= max_code; n5++) {
    curlen = nextlen;
    nextlen = tree[(n5 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s2) {
  var max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s2, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
}
function detect_data_type(s2) {
  var black_mask = 4093624447;
  var n5;
  for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n5 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n5 = 32; n5 < LITERALS$1; n5++) {
    if (s2.dyn_ltree[n5 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s2) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
}
function _tr_stored_block(s2, buf, stored_len, last2) {
  send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s2, buf, stored_len, true);
}
function _tr_align(s2) {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
}
function _tr_flush_block(s2, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s2, buf, stored_len, last2);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last2) {
    bi_windup(s2);
  }
}
function _tr_tally(s2, dist, lc) {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n5 = 0;
  while (len !== 0) {
    n5 = len > 2e3 ? 2e3 : len;
    len -= n5;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n5);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c4, table = [];
  for (var n5 = 0; n5 < 256; n5++) {
    c4 = n5;
    for (var k3 = 0; k3 < 8; k3++) {
      c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
    }
    table[n5] = c4;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t4 = crcTable, end2 = pos + len;
  crc ^= -1;
  for (var i4 = pos; i4 < end2; i4++) {
    crc = crc >>> 8 ^ t4[(crc ^ buf[i4]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f3) {
  return (f3 << 1) - (f3 > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s2 = strm.state;
  var len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
}
function flush_block_only(s2, last2) {
  trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
}
function put_byte(s2, b3) {
  s2.pending_buf[s2.pending++] = b3;
}
function putShortMSB(s2, b3) {
  s2.pending_buf[s2.pending++] = b3 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b3 & 255;
}
function read_buf(strm, buf, start2, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start2);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start2);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start2);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s2, cur_match) {
  var chain_length = s2.max_chain_length;
  var scan = s2.strstart;
  var match;
  var len;
  var best_len = s2.prev_length;
  var nice_match = s2.nice_match;
  var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s2.window;
  var wmask = s2.w_mask;
  var prev = s2.prev;
  var strend = s2.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
}
function fill_window(s2) {
  var _w_size = s2.w_size;
  var p3, n5, m, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n5 = s2.hash_size;
      p3 = n5;
      do {
        m = s2.head[--p3];
        s2.head[p3] = m >= _w_size ? m - _w_size : 0;
      } while (--n5);
      n5 = _w_size;
      p3 = n5;
      do {
        m = s2.prev[--p3];
        s2.prev[p3] = m >= _w_size ? m - _w_size : 0;
      } while (--n5);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n5 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n5;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
      while (s2.insert) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
}
function deflate_stored(s2, flush) {
  var max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    var max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s2, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s2, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s2, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s2, flush) {
  var bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s2) {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s2;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH;
  trees._tr_init(s2);
  return Z_OK$1;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new utils$2.Buf8(s2.w_size * 2);
  s2.head = new utils$2.Buf16(s2.hash_size);
  s2.prev = new utils$2.Buf16(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new utils$2.Buf8(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
  var old_flush, s2;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s2.strm = strm;
  old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s2.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
    var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s2;
  var str, n5;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s2.w_size);
    utils$2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    str = s2.strstart;
    n5 = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n5);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$1;
}
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start2) {
  var state2;
  var _in;
  var last2;
  var _out;
  var beg;
  var end2;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from4;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD$1;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD$1;
                  break top;
                }
              }
              from4 = 0;
              from_source = s_window;
              if (wnext === 0) {
                from4 += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from4 += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from4++];
                    } while (--op);
                    from4 = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from4 += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from4++];
                if (len > 1) {
                  output[_out++] = from_source[from4++];
                }
              }
            } else {
              from4 = _out - dist;
              do {
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from4++];
                if (len > 1) {
                  output[_out++] = output[from4++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE$1;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD$1;
        break top;
      }
      break;
    }
  } while (_in < last2 && _out < end2);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min2 = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill4;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end2;
  var count = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end2 = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end2 = 256;
  } else {
    base = dbase;
    extra = dext;
    end2 = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end2) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill4 = 1 << curr;
    min2 = fill4;
    do {
      fill4 -= incr;
      table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill4 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
};
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src, end2, copy5) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy5 >= state2.wsize) {
    utils.arraySet(state2.window, src, end2 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy5) {
      dist = copy5;
    }
    utils.arraySet(state2.window, src, end2 - copy5, dist, state2.wnext);
    copy5 -= dist;
    if (copy5) {
      utils.arraySet(state2.window, src, end2 - copy5, copy5, 0);
      state2.wnext = copy5;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy5;
  var from4;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n5;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy5 = state2.length;
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy5,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              state2.length -= copy5;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy5 = state2.length;
          if (copy5) {
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5 > left) {
              copy5 = left;
            }
            if (copy5 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next, copy5, put);
            have -= copy5;
            next += copy5;
            left -= copy5;
            put += copy5;
            state2.length -= copy5;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n5 = here_bits + 2;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy5 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n5 = here_bits + 3;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n5 = here_bits + 7;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy5 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy5--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n5 = state2.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n5 = state2.extra;
            while (bits < n5) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy5 = _out - left;
          if (state2.offset > copy5) {
            copy5 = state2.offset - copy5;
            if (copy5 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy5 > state2.wnext) {
              copy5 -= state2.wnext;
              from4 = state2.wsize - copy5;
            } else {
              from4 = state2.wnext - copy5;
            }
            if (copy5 > state2.length) {
              copy5 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from4 = put - state2.offset;
            copy5 = state2.length;
          }
          if (copy5 > left) {
            copy5 = left;
          }
          left -= copy5;
          state2.length -= copy5;
          do {
            output[put++] = from_source[from4++];
          } while (--copy5);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports) {
  var assert3 = require$$4;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1 = constants;
  for (var key in constants$1) {
    exports[key] = constants$1[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding);
var require$$3 = getAugmentedNamespace(_polyfillNode_util$1);
(function(exports) {
  var Buffer5 = require$$0.Buffer;
  var Transform3 = require$$1.Transform;
  var binding$13 = binding;
  var util = require$$3;
  var assert3 = require$$4.ok;
  var kMaxLength4 = require$$0.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib);
var zlib = getDefaultExportFromCjs(lib);
var PNG = class {
  static decode(path, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  }
  static load(path) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  }
  constructor(data2) {
    let i4;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      const chunkSize = this.readUInt32();
      let section = "";
      for (i4 = 0; i4 < 4; i4++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i4 = 0; i4 < chunkSize; i4++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i4 = 0; i4 < short; i4++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text = this.read(chunkSize);
          var index2 = text.indexOf(0);
          var key = String.fromCharCode.apply(String, text.slice(0, index2));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index2 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer2.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  read(bytes) {
    const result = new Array(bytes);
    for (let i4 = 0; i4 < bytes; i4++) {
      result[i4] = this.data[this.pos++];
    }
    return result;
  }
  readUInt32() {
    const b1 = this.data[this.pos++] << 24;
    const b22 = this.data[this.pos++] << 16;
    const b3 = this.data[this.pos++] << 8;
    const b4 = this.data[this.pos++];
    return b1 | b22 | b3 | b4;
  }
  readUInt16() {
    const b1 = this.data[this.pos++] << 8;
    const b22 = this.data[this.pos++];
    return b1 | b22;
  }
  decodePixels(fn) {
    return zlib.inflate(this.imgData, (err2, data2) => {
      if (err2) throw err2;
      var pos = 0;
      const {
        width,
        height: height2
      } = this;
      var pixelBytes = this.pixelBitlength / 8;
      const pixels = Buffer2.alloc(width * height2 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        const w = Math.ceil((width - x0) / dx);
        const h3 = Math.ceil((height2 - y0) / dy);
        const scanlineLength = pixelBytes * w;
        const buffer = singlePass ? pixels : Buffer2.alloc(scanlineLength * h3);
        let row = 0;
        let c4 = 0;
        while (row < h3 && pos < data2.length) {
          var byte;
          var col;
          var i4;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i4 = 0; i4 < scanlineLength; i4++) {
                buffer[c4++] = data2[pos++];
              }
              break;
            case 1:
              for (i4 = 0; i4 < scanlineLength; i4++) {
                byte = data2[pos++];
                left = i4 < pixelBytes ? 0 : buffer[c4 - pixelBytes];
                buffer[c4++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i4 = 0; i4 < scanlineLength; i4++) {
                byte = data2[pos++];
                col = (i4 - i4 % pixelBytes) / pixelBytes;
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i4 % pixelBytes];
                buffer[c4++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i4 = 0; i4 < scanlineLength; i4++) {
                byte = data2[pos++];
                col = (i4 - i4 % pixelBytes) / pixelBytes;
                left = i4 < pixelBytes ? 0 : buffer[c4 - pixelBytes];
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i4 % pixelBytes];
                buffer[c4++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i4 = 0; i4 < scanlineLength; i4++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i4 - i4 % pixelBytes) / pixelBytes;
                left = i4 < pixelBytes ? 0 : buffer[c4 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i4 % pixelBytes];
                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i4 % pixelBytes];
                }
                const p3 = left + upper - upperLeft;
                const pa = Math.abs(p3 - left);
                const pb = Math.abs(p3 - upper);
                const pc = Math.abs(p3 - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer[c4++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error(`Invalid filter algorithm: ${data2[pos - 1]}`);
          }
          if (!singlePass) {
            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            let bufferPos = row * scanlineLength;
            for (i4 = 0; i4 < w; i4++) {
              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      if (this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  }
  decodePalette() {
    const {
      palette
    } = this;
    const {
      length: length2
    } = palette;
    const transparency = this.transparency.indexed || [];
    const ret = Buffer2.alloc(transparency.length + length2);
    let pos = 0;
    let c4 = 0;
    for (let i4 = 0; i4 < length2; i4 += 3) {
      var left;
      ret[pos++] = palette[i4];
      ret[pos++] = palette[i4 + 1];
      ret[pos++] = palette[i4 + 2];
      ret[pos++] = (left = transparency[c4++]) != null ? left : 255;
    }
    return ret;
  }
  copyToImageData(imageData, pixels) {
    let j;
    var k3;
    let {
      colors
    } = this;
    let palette = null;
    let alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    const data2 = imageData.data || imageData;
    const {
      length: length2
    } = data2;
    const input = palette || pixels;
    let i4 = j = 0;
    if (colors === 1) {
      while (i4 < length2) {
        k3 = palette ? pixels[i4 / 4] * 4 : j;
        const v3 = input[k3++];
        data2[i4++] = v3;
        data2[i4++] = v3;
        data2[i4++] = v3;
        data2[i4++] = alpha ? input[k3++] : 255;
        j = k3;
      }
    } else {
      while (i4 < length2) {
        k3 = palette ? pixels[i4 / 4] * 4 : j;
        data2[i4++] = input[k3++];
        data2[i4++] = input[k3++];
        data2[i4++] = input[k3++];
        data2[i4++] = alpha ? input[k3++] : 255;
        j = k3;
      }
    }
  }
  decode(fn) {
    const ret = Buffer2.alloc(this.width * this.height * 4);
    return this.decodePixels((pixels) => {
      this.copyToImageData(ret, pixels);
      return fn(ret);
    });
  }
};

// node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_crypto_js = __toESM(require_crypto_js());
var global$12 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup2 = [];
var revLookup2 = [];
var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited2 = false;
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup2[i4] = code[i4];
    revLookup2[code.charCodeAt(i4)] = i4;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray2(b64) {
  if (!inited2) {
    init2();
  }
  var i4, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i4 = 0, j = 0; i4 < l2; i4 += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 18 | revLookup2[b64.charCodeAt(i4 + 1)] << 12 | revLookup2[b64.charCodeAt(i4 + 2)] << 6 | revLookup2[b64.charCodeAt(i4 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 2 | revLookup2[b64.charCodeAt(i4 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 10 | revLookup2[b64.charCodeAt(i4 + 1)] << 4 | revLookup2[b64.charCodeAt(i4 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i4 = start2; i4 < end2; i4 += 3) {
    tmp = (uint82[i4] << 16) + (uint82[i4 + 1] << 8) + uint82[i4 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray2(uint82) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len2 = len - extraBytes; i4 < len2; i4 += maxChunkLength) {
    parts.push(encodeChunk2(uint82, i4, i4 + maxChunkLength > len2 ? len2 : i4 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read2(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i4];
  i4 += d2;
  e4 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  m = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e4 - mLen);
}
function write3(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m, c4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c4 = Math.pow(2, -e4)) < 1) {
      e4--;
      c4 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c4;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c4 >= 2) {
      e4++;
      c4 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m = (value2 * c4 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i4] = m & 255, i4 += d2, m /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i4] = e4 & 255, i4 += d2, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i4 - d2] |= s2 * 128;
}
var toString3 = {}.toString;
var isArray$12 = Array.isArray || function(arr) {
  return toString3.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES2 = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$12.TYPED_ARRAY_SUPPORT !== void 0 ? global$12.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength2 = kMaxLength2();
function kMaxLength2() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length2) {
  if (kMaxLength2() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length2) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length2);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString2(that, value2, encodingOrOffset);
  }
  return fromObject2(that, value2);
}
Buffer$2.from = function(value2, encodingOrOffset, length2) {
  return from$1(null, value2, encodingOrOffset, length2);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2) ;
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill4, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill4, encoding) : createBuffer2(that, size).fill(fill4);
  }
  return createBuffer2(that, size);
}
Buffer$2.alloc = function(size, fill4, encoding) {
  return alloc2(null, size, fill4, encoding);
};
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i4 = 0; i4 < size; ++i4) {
      that[i4] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size) {
  return allocUnsafe2(null, size);
};
Buffer$2.allocUnsafeSlow = function(size) {
  return allocUnsafe2(null, size);
};
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength3(string, encoding) | 0;
  that = createBuffer2(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length2 = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length2);
  for (var i4 = 0; i4 < length2; i4 += 1) {
    that[i4] = array[i4] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray$12(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length2) {
  if (length2 >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer2(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer$2.alloc(+length2);
}
Buffer$2.isBuffer = isBuffer$12;
function internalIsBuffer2(b3) {
  return !!(b3 != null && b3._isBuffer);
}
Buffer$2.compare = function compare4(a4, b3) {
  if (!internalIsBuffer2(a4) || !internalIsBuffer2(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i4 = 0, len = Math.min(x, y3); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x = a4[i4];
      y3 = b3[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding2(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat2(list, length2) {
  if (!isArray$12(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i4;
  if (length2 === void 0) {
    length2 = 0;
    for (i4 = 0; i4 < list.length; ++i4) {
      length2 += list[i4].length;
    }
  }
  var buffer = Buffer$2.allocUnsafe(length2);
  var pos = 0;
  for (i4 = 0; i4 < list.length; ++i4) {
    var buf = list[i4];
    if (!internalIsBuffer2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength3(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase) return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength3;
function slowToString2(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start2, end2);
      case "ascii":
        return asciiSlice2(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start2, end2);
      case "base64":
        return base64Slice2(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap2(b3, n5, m) {
  var i4 = b3[n5];
  b3[n5] = b3[m];
  b3[m] = i4;
}
Buffer$2.prototype.swap16 = function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 2) {
    swap2(this, i4, i4 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 4) {
    swap2(this, i4, i4 + 3);
    swap2(this, i4 + 1, i4 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 8) {
    swap2(this, i4, i4 + 7);
    swap2(this, i4 + 1, i4 + 6);
    swap2(this, i4 + 2, i4 + 5);
    swap2(this, i4 + 3, i4 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString4() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice2(this, 0, length2);
  return slowToString2.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals2(b3) {
  if (!internalIsBuffer2(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer$2.compare(this, b3) === 0;
};
Buffer$2.prototype.inspect = function inspect3() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$2.prototype.compare = function compare5(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i4 = 0; i4 < len; ++i4) {
    if (thisCopy[i4] !== targetCopy[i4]) {
      x = thisCopy[i4];
      y3 = targetCopy[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i5) {
    if (indexSize === 1) {
      return buf[i5];
    } else {
      return buf.readUInt16BE(i5 * indexSize);
    }
  }
  var i4;
  if (dir) {
    var foundIndex = -1;
    for (i4 = byteOffset; i4 < arrLength; i4++) {
      if (read4(arr, i4) === read4(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i4 = byteOffset; i4 >= 0; i4--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i4 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i4;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
function hexWrite2(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i4 = 0; i4 < length2; ++i4) {
    var parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (isNaN(parsed)) return i4;
    buf[offset2 + i4] = parsed;
  }
  return i4;
}
function utf8Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite2(buf, string, offset2, length2) {
  return blitBuffer2(asciiToBytes2(string), buf, offset2, length2);
}
function latin1Write2(buf, string, offset2, length2) {
  return asciiWrite2(buf, string, offset2, length2);
}
function base64Write2(buf, string, offset2, length2) {
  return blitBuffer2(base64ToBytes2(string), buf, offset2, length2);
}
function ucs2Write2(buf, string, offset2, length2) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset2), buf, offset2, length2);
}
Buffer$2.prototype.write = function write4(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite2(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write2(this, string, offset2, length2);
      case "ascii":
        return asciiWrite2(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write2(this, string, offset2, length2);
      case "base64":
        return base64Write2(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write2(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice2(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray2(buf);
  } else {
    return fromByteArray2(buf.slice(start2, end2));
  }
}
function utf8Slice2(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i4 = start2;
  while (i4 < end2) {
    var firstByte = buf[i4];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i4 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          fourthByte = buf[i4 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i4 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i4 = 0;
  while (i4 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4]);
  }
  return ret;
}
function hexSlice2(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i4 = start2; i4 < end2; ++i4) {
    out += toHex$1(buf[i4]);
  }
  return out;
}
function utf16leSlice2(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i4 = 0; i4 < bytes.length; i4 += 2) {
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice2(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i4 = 0; i4 < sliceLen; ++i4) {
      newBuf[i4] = this[i4 + start2];
    }
  }
  return newBuf;
};
function checkOffset2(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset2(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt83(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  return this[offset2];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE2(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset2, byteLength5, this.length);
  var i4 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i4];
  while (i4 > 0 && (mul *= 256)) {
    val += this[offset2 + --i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt82(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 4, this.length);
  return read2(this, offset2, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE2(offset2, noAssert) {
  if (!noAssert) checkOffset2(offset2, 8, this.length);
  return read2(this, offset2, false, 52, 8);
};
function checkInt2(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i4 = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeUInt8 = function writeUInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt162(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 2); i4 < j; ++i4) {
    buf[offset2 + i4] = (value2 & 255 << 8 * (littleEndian ? i4 : 1 - i4)) >>> (littleEndian ? i4 : 1 - i4) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt322(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 4); i4 < j; ++i4) {
    buf[offset2 + i4] = value2 >>> (littleEndian ? i4 : 3 - i4) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeIntBE = function writeIntBE2(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer$2.prototype.writeInt8 = function writeInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt322(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE7542(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 4);
  }
  write3(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE2(value2, offset2, noAssert) {
  return writeFloat2(this, value2, offset2, false, noAssert);
};
function writeDouble2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset2, 8);
  }
  write3(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE2(value2, offset2, noAssert) {
  return writeDouble2(this, value2, offset2, false, noAssert);
};
Buffer$2.prototype.copy = function copy2(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i4;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i4 = len - 1; i4 >= 0; --i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i4 = 0; i4 < len; ++i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill2(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i4;
  if (typeof val === "number") {
    for (i4 = start2; i4 < end2; ++i4) {
      this[i4] = val;
    }
  } else {
    var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i4 = 0; i4 < end2 - start2; ++i4) {
      this[i4 + start2] = bytes[i4 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$1(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i4 = 0; i4 < length2; ++i4) {
    codePoint = string.charCodeAt(i4);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    byteArray.push(str.charCodeAt(i4) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c4, hi, lo;
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    if ((units -= 2) < 0) break;
    c4 = str.charCodeAt(i4);
    hi = c4 >> 8;
    lo = c4 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray2(base64clean2(str));
}
function blitBuffer2(src, dst, offset2, length2) {
  for (var i4 = 0; i4 < length2; ++i4) {
    if (i4 + offset2 >= dst.length || i4 >= src.length) break;
    dst[i4 + offset2] = src[i4];
  }
  return i4;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer$12(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var _polyfillNode_buffer2 = Object.freeze({
  __proto__: null,
  Buffer: Buffer$2,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES2,
  SlowBuffer: SlowBuffer2,
  isBuffer: isBuffer$12,
  kMaxLength: _kMaxLength2
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace2(n5) {
  if (n5.__esModule) return n5;
  var f3 = n5.default;
  if (typeof f3 == "function") {
    var a4 = function a5() {
      if (this instanceof a5) {
        return Reflect.construct(f3, arguments, this.constructor);
      }
      return f3.apply(this, arguments);
    };
    a4.prototype = f3.prototype;
  } else a4 = {};
  Object.defineProperty(a4, "__esModule", { value: true });
  Object.keys(n5).forEach(function(k3) {
    var d2 = Object.getOwnPropertyDescriptor(n5, k3);
    Object.defineProperty(a4, k3, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n5[k3];
      }
    });
  });
  return a4;
}
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout2 = defaultSetTimout2;
var cachedClearTimeout2 = defaultClearTimeout2;
if (typeof global$12.setTimeout === "function") {
  cachedSetTimeout2 = setTimeout;
}
if (typeof global$12.clearTimeout === "function") {
  cachedClearTimeout2 = clearTimeout;
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e4) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e5) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e4) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e5) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      args[i4 - 1] = arguments[i4];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform2 = "browser";
var browser$12 = true;
var env2 = {};
var argv2 = [];
var version2 = "";
var versions2 = {};
var release2 = {};
var config$1 = {};
function noop$2() {
}
var on2 = noop$2;
var addListener3 = noop$2;
var once$2 = noop$2;
var off2 = noop$2;
var removeListener3 = noop$2;
var removeAllListeners3 = noop$2;
var emit3 = noop$2;
function binding$12(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
var performance3 = global$12.performance || {};
var performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance3) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime2 = /* @__PURE__ */ new Date();
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick2,
  title: title2,
  browser: browser$12,
  env: env2,
  argv: argv2,
  version: version2,
  versions: versions2,
  on: on2,
  addListener: addListener3,
  once: once$2,
  off: off2,
  removeListener: removeListener3,
  removeAllListeners: removeAllListeners3,
  emit: emit3,
  binding: binding$12,
  cwd: cwd2,
  chdir: chdir2,
  umask: umask2,
  hrtime: hrtime2,
  platform: platform2,
  release: release2,
  config: config$1,
  uptime: uptime2
};
var domain2;
function EventHandlers2() {
}
EventHandlers2.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter2() {
  EventEmitter2.init.call(this);
}
EventEmitter2.EventEmitter = EventEmitter2;
EventEmitter2.usingDomains = false;
EventEmitter2.prototype.domain = void 0;
EventEmitter2.prototype._events = void 0;
EventEmitter2.prototype._maxListeners = void 0;
EventEmitter2.defaultMaxListeners = 10;
EventEmitter2.init = function() {
  this.domain = null;
  if (EventEmitter2.usingDomains) {
    if (domain2.active && !(this instanceof domain2.Domain)) {
      this.domain = domain2.active;
    }
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers2();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter2.prototype.setMaxListeners = function setMaxListeners2(n5) {
  if (typeof n5 !== "number" || n5 < 0 || isNaN(n5))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n5;
  return this;
};
function $getMaxListeners2(that) {
  if (that._maxListeners === void 0)
    return EventEmitter2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter2.prototype.getMaxListeners = function getMaxListeners2() {
  return $getMaxListeners2(this);
};
function emitNone2(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2);
  }
}
function emitOne2(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1);
  }
}
function emitTwo2(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2);
  }
}
function emitThree2(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2, arg3);
  }
}
function emitMany2(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].apply(self2, args);
  }
}
EventEmitter2.prototype.emit = function emit4(type) {
  var er, handler, len, args, i4, events2, domain3;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone2(handler, isFn, this);
      break;
    case 2:
      emitOne2(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo2(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree2(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i4 = 1; i4 < len; i4++)
        args[i4 - 1] = arguments[i4];
      emitMany2(handler, isFn, this, args);
  }
  return true;
};
function _addListener2(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers2();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners2(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning2(w);
      }
    }
  }
  return target;
}
function emitWarning2(e4) {
  typeof console.warn === "function" ? console.warn(e4) : console.log(e4);
}
EventEmitter2.prototype.addListener = function addListener4(type, listener) {
  return _addListener2(this, type, listener, false);
};
EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
EventEmitter2.prototype.prependListener = function prependListener3(type, listener) {
  return _addListener2(this, type, listener, true);
};
function _onceWrap2(target, type, listener) {
  var fired = false;
  function g3() {
    target.removeListener(type, g3);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g3.listener = listener;
  return g3;
}
EventEmitter2.prototype.once = function once3(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.removeListener = function removeListener4(type, listener) {
  var list, events2, position, i4, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers2();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i4 = list.length; i4-- > 0; ) {
      if (list[i4] === listener || list[i4].listener && list[i4].listener === listener) {
        originalListener = list[i4].listener;
        position = i4;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers2();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne2(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter2.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers2();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers2();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i4 = 0, key; i4 < keys2.length; ++i4) {
      key = keys2[i4];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers2();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter2.prototype.listeners = function listeners2(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners2(evlistener);
  }
  return ret;
};
EventEmitter2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount2.call(emitter, type);
  }
};
EventEmitter2.prototype.listenerCount = listenerCount2;
function listenerCount2(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter2.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne2(list, index2) {
  for (var i4 = index2, k3 = i4 + 1, n5 = list.length; k3 < n5; i4 += 1, k3 += 1)
    list[i4] = list[k3];
  list.pop();
}
function arrayClone2(arr, i4) {
  var copy5 = new Array(i4);
  while (i4--)
    copy5[i4] = arr[i4];
  return copy5;
}
function unwrapListeners2(arr) {
  var ret = new Array(arr.length);
  for (var i4 = 0; i4 < ret.length; ++i4) {
    ret[i4] = arr[i4].listener || arr[i4];
  }
  return ret;
}
var _polyfillNode_events = Object.freeze({
  __proto__: null,
  EventEmitter: EventEmitter2,
  default: EventEmitter2
});
var require$$1$1 = getAugmentedNamespace2(_polyfillNode_events);
var streamBrowser = require$$1$1.EventEmitter;
var require$$02 = getAugmentedNamespace2(_polyfillNode_buffer2);
var inherits$2;
if (typeof Object.create === "function") {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var getOwnPropertyDescriptors3 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors4(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i4 = 0; i4 < keys2.length; i4++) {
    descriptors[keys2[i4]] = Object.getOwnPropertyDescriptor(obj, keys2[i4]);
  }
  return descriptors;
};
var formatRegExp2 = /%[sdj%]/g;
function format2(f3) {
  if (!isString2(f3)) {
    var objects = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      objects.push(inspect$12(arguments[i4]));
    }
    return objects.join(" ");
  }
  var i4 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f3).replace(formatRegExp2, function(x2) {
    if (x2 === "%%") return "%";
    if (i4 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i4++]);
      case "%d":
        return Number(args[i4++]);
      case "%j":
        try {
          return JSON.stringify(args[i4++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i4]; i4 < len; x = args[++i4]) {
    if (isNull2(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$12(x);
    }
  }
  return str;
}
function deprecate$1(fn, msg2) {
  if (isUndefined2(global$12.process)) {
    return function() {
      return deprecate$1(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs2 = {};
var debugEnviron2;
function debuglog2(set5) {
  if (isUndefined2(debugEnviron2))
    debugEnviron2 = browser$1$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs2[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron2)) {
      var pid = 0;
      debugs2[set5] = function() {
        var msg2 = format2.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs2[set5] = function() {
      };
    }
  }
  return debugs2[set5];
}
function inspect$12(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor2
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean2(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend2(ctx, opts2);
  }
  if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined2(ctx.depth)) ctx.depth = 2;
  if (isUndefined2(ctx.colors)) ctx.colors = false;
  if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor2;
  return formatValue2(ctx, obj, ctx.depth);
}
inspect$12.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$12.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor2(str, styleType) {
  var style = inspect$12.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$12.colors[style][0] + "m" + str + "\x1B[" + inspect$12.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor2(str, styleType) {
  return str;
}
function arrayToHash2(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue2(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$12 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive2(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash2(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError2(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError2(value2);
  }
  if (keys2.length === 0) {
    if (isFunction2(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate2(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError2(value2)) {
      return formatError2(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value2)) {
    var n5 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n5 + "]";
  }
  if (isRegExp2(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate2(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError2(value2)) {
    base = " " + formatError2(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString2(output, base, braces);
}
function formatPrimitive2(ctx, value2) {
  if (isUndefined2(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull2(value2))
    return ctx.stylize("null", "null");
}
function formatError2(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i4 = 0, l2 = value2.length; i4 < l2; ++i4) {
    if (hasOwnProperty2(value2, String(i4))) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i4),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull2(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined2(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString2(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean2(arg) {
  return typeof arg === "boolean";
}
function isNull2(arg) {
  return arg === null;
}
function isNullOrUndefined2(arg) {
  return arg == null;
}
function isNumber2(arg) {
  return typeof arg === "number";
}
function isString2(arg) {
  return typeof arg === "string";
}
function isSymbol2(arg) {
  return typeof arg === "symbol";
}
function isUndefined2(arg) {
  return arg === void 0;
}
function isRegExp2(re) {
  return isObject2(re) && objectToString2(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate2(d2) {
  return isObject2(d2) && objectToString2(d2) === "[object Date]";
}
function isError2(e4) {
  return isObject2(e4) && (objectToString2(e4) === "[object Error]" || e4 instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function isPrimitive2(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer2(maybeBuf) {
  return Buffer$2.isBuffer(maybeBuf);
}
function objectToString2(o2) {
  return Object.prototype.toString.call(o2);
}
function pad$1(n5) {
  return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
}
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad$1(d2.getHours()),
    pad$1(d2.getMinutes()),
    pad$1(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months2[d2.getMonth()], time].join(" ");
}
function log2() {
  console.log("%s - %s", timestamp2(), format2.apply(null, arguments));
}
function _extend2(origin, add2) {
  if (!add2 || !isObject2(add2)) return origin;
  var keys2 = Object.keys(add2);
  var i4 = keys2.length;
  while (i4--) {
    origin[keys2[i4]] = add2[keys2[i4]];
  }
  return origin;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol2 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify2(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol2 && original[kCustomPromisifiedSymbol2]) {
    var fn = original[kCustomPromisifiedSymbol2];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      args.push(arguments[i4]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol2) Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors3(original)
  );
}
promisify2.custom = kCustomPromisifiedSymbol2;
function callbackifyOnRejected2(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      args.push(arguments[i4]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected2.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors3(original));
  return callbackified;
}
var _polyfillNode_util2 = {
  inherits: inherits$2,
  _extend: _extend2,
  log: log2,
  isBuffer: isBuffer2,
  isPrimitive: isPrimitive2,
  isFunction: isFunction2,
  isError: isError2,
  isDate: isDate2,
  isObject: isObject2,
  isRegExp: isRegExp2,
  isUndefined: isUndefined2,
  isSymbol: isSymbol2,
  isString: isString2,
  isNumber: isNumber2,
  isNullOrUndefined: isNullOrUndefined2,
  isNull: isNull2,
  isBoolean: isBoolean2,
  isArray: isArray2,
  inspect: inspect$12,
  deprecate: deprecate$1,
  format: format2,
  debuglog: debuglog2,
  promisify: promisify2,
  callbackify: callbackify2
};
var _polyfillNode_util$12 = Object.freeze({
  __proto__: null,
  _extend: _extend2,
  callbackify: callbackify2,
  debuglog: debuglog2,
  default: _polyfillNode_util2,
  deprecate: deprecate$1,
  format: format2,
  inherits: inherits$2,
  inspect: inspect$12,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isBuffer: isBuffer2,
  isDate: isDate2,
  isError: isError2,
  isFunction: isFunction2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber2,
  isObject: isObject2,
  isPrimitive: isPrimitive2,
  isRegExp: isRegExp2,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  log: log2,
  promisify: promisify2
});
var require$$32 = getAugmentedNamespace2(_polyfillNode_util$12);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4] != null ? arguments[i4] : {};
      if (i4 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i4 = 0; i4 < props.length; i4++) {
      var descriptor = props[i4];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require2 = require$$02, Buffer5 = _require2.Buffer;
  var _require22 = require$$32, inspect6 = _require22.inspect;
  var custom = inspect6 && inspect6.custom || "inspect";
  function copyBuffer(src, target, offset2) {
    Buffer5.prototype.copy.call(src, target, offset2);
  }
  buffer_list = function() {
    function BufferList3() {
      _classCallCheck(this, BufferList3);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList3, [{
      key: "push",
      value: function push(v3) {
        var entry = {
          data: v3,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v3) {
        var entry = {
          data: v3,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next) {
          ret += s2 + p3.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat5(n5) {
        if (this.length === 0) return Buffer5.alloc(0);
        var ret = Buffer5.allocUnsafe(n5 >>> 0);
        var p3 = this.head;
        var i4 = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i4);
          i4 += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n5, hasStrings) {
        var ret;
        if (n5 < this.head.data.length) {
          ret = this.head.data.slice(0, n5);
          this.head.data = this.head.data.slice(n5);
        } else if (n5 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n5) {
        var p3 = this.head;
        var c4 = 1;
        var ret = p3.data;
        n5 -= ret.length;
        while (p3 = p3.next) {
          var str = p3.data;
          var nb = n5 > str.length ? str.length : n5;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n5);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === str.length) {
              ++c4;
              if (p3.next) this.head = p3.next;
              else this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = str.slice(nb);
            }
            break;
          }
          ++c4;
        }
        this.length -= c4;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n5) {
        var ret = Buffer5.allocUnsafe(n5);
        var p3 = this.head;
        var c4 = 1;
        p3.data.copy(ret);
        n5 -= p3.data.length;
        while (p3 = p3.next) {
          var buf = p3.data;
          var nb = n5 > buf.length ? buf.length : n5;
          buf.copy(ret, ret.length - n5, 0, nb);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === buf.length) {
              ++c4;
              if (p3.next) this.head = p3.next;
              else this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = buf.slice(nb);
            }
            break;
          }
          ++c4;
        }
        this.length -= c4;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value2(_, options) {
        return inspect6(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList3;
  }();
  return buffer_list;
}
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$1.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$1.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$1.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose) return;
  if (self2._readableState && !self2._readableState.emitClose) return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
  else stream2.emit("error", err2);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage3(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage3(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i4) {
      return String(i4);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(0, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes3(str, search, start2) {
  if (typeof start2 !== "number") {
    start2 = 0;
  }
  if (start2 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start2) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes3(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits2;
if (typeof Object.create === "function") {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$12 = inherits2;
var _polyfillNode_inherits = Object.freeze({
  __proto__: null,
  default: inherits$12
});
var require$$12 = getAugmentedNamespace2(_polyfillNode_inherits);
var isBufferEncoding2 = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding2(encoding) {
  if (encoding && !isBufferEncoding2(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder$1(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding2(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar2;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar2;
      break;
    default:
      this.write = passThroughWrite2;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder$1.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder$1.prototype.detectIncompleteChar = function(buffer) {
  var i4 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i4 > 0; i4--) {
    var c4 = buffer[buffer.length - i4];
    if (i4 == 1 && c4 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i4 <= 2 && c4 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i4 <= 3 && c4 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i4;
};
StringDecoder$1.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite2(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var _polyfillNode_string_decoder = Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});
var require$$10 = getAugmentedNamespace2(_polyfillNode_string_decoder);
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function") return eos$1(stream2, null, opts2);
  if (!opts2) opts2 = {};
  callback = once$1(callback || noop$1);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable) onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend3 = function onend4() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream2);
  };
  var onerror = function onerror2(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend3);
  stream2.on("finish", onfinish);
  if (opts2.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend3);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value2, done3) {
    return {
      value: value2,
      done: done3
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    browser$1$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          browser$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve3(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator2 = function createReadableStreamAsyncIterator3(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value2(resolve3, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator2;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var Registry$4 = _registry;
Registry$4.Readable = Readable2;
Readable2.ReadableState = ReadableState2;
require$$1$1.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream$1 = streamBrowser;
var Buffer$1 = require$$02.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$1.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var debugUtil = require$$32;
var debug2;
if (debugUtil && debugUtil.debuglog) {
  debug2 = debugUtil.debuglog("stream");
} else {
  debug2 = function debug3() {
  };
}
var BufferList2 = requireBuffer_list();
var destroyImpl$1 = destroy_1;
var _require$1 = state;
var getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE;
var ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF;
var ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder2;
var createReadableStreamAsyncIterator;
var from2;
require$$12(Readable2, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener4(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
  else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList2();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
    this.decoder = new StringDecoder2(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable2(options) {
  if (!(this instanceof Readable2)) return new Readable2(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState2(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function") this._read = options.read;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
Object.defineProperty(Readable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable2.prototype.destroy = destroyImpl$1.destroy;
Readable2.prototype._undestroy = destroyImpl$1.undestroy;
Readable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable2.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$1.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
};
Readable2.prototype.unshift = function(chunk) {
  return readableAddChunk2(this, chunk, null, true, false);
};
function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug2("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk2(stream2, state2);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid2(state2, chunk);
    if (er) {
      errorOrDestroy$1(stream2, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted) errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore2(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore2(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront) state2.buffer.unshift(chunk);
    else state2.buffer.push(chunk);
    if (state2.needReadable) emitReadable2(stream2);
  }
  maybeReadMore2(stream2, state2);
}
function chunkInvalid2(state2, chunk) {
  var er;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
Readable2.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable2.prototype.setEncoding = function(enc) {
  if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
  var decoder2 = new StringDecoder2(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p3 = this._readableState.buffer.head;
  var content = "";
  while (p3 !== null) {
    content += decoder2.write(p3.data);
    p3 = p3.next;
  }
  this._readableState.buffer.clear();
  if (content !== "") this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM2 = 1073741824;
function computeNewHighWaterMark2(n5) {
  if (n5 >= MAX_HWM2) {
    n5 = MAX_HWM2;
  } else {
    n5--;
    n5 |= n5 >>> 1;
    n5 |= n5 >>> 2;
    n5 |= n5 >>> 4;
    n5 |= n5 >>> 8;
    n5 |= n5 >>> 16;
    n5++;
  }
  return n5;
}
function howMuchToRead2(n5, state2) {
  if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n5 !== n5) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark2(n5);
  if (n5 <= state2.length) return n5;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable2.prototype.read = function(n5) {
  debug2("read", n5);
  n5 = parseInt(n5, 10);
  var state2 = this._readableState;
  var nOrig = n5;
  if (n5 !== 0) state2.emittedReadable = false;
  if (n5 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug2("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable2(this);
    else emitReadable2(this);
    return null;
  }
  n5 = howMuchToRead2(n5, state2);
  if (n5 === 0 && state2.ended) {
    if (state2.length === 0) endReadable2(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug2("need readable", doRead);
  if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
    doRead = true;
    debug2("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug2("reading or ended", doRead);
  } else if (doRead) {
    debug2("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n5 = howMuchToRead2(nOrig, state2);
  }
  var ret;
  if (n5 > 0) ret = fromList2(n5, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n5 = 0;
  } else {
    state2.length -= n5;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n5 && state2.ended) endReadable2(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function onEofChunk2(stream2, state2) {
  debug2("onEofChunk");
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable2(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_2(stream2);
    }
  }
}
function emitReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug2("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$1.nextTick(emitReadable_2, stream2);
  }
}
function emitReadable_2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow2(stream2);
}
function maybeReadMore2(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$1.nextTick(maybeReadMore_2, stream2, state2);
  }
}
function maybeReadMore_2(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug2("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable2.prototype._read = function(n5) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable2.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
  var endFn = doEnd ? onend3 : unpipe;
  if (state2.endEmitted) browser$1$1.nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug2("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend3() {
    debug2("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain2(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug2("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug2("ondata");
    var ret = dest.write(chunk);
    debug2("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf4(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug2("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug2("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0) errorOrDestroy$1(dest, er);
  }
  prependListener4(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug2("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug2("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug2("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain2(src) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src._readableState;
    debug2("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
      state2.flowing = true;
      flow2(src);
    }
  };
}
Readable2.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i4 = 0; i4 < len; i4++) {
      dests[i4].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index2 = indexOf4(state2.pipes, dest);
  if (index2 === -1) return this;
  state2.pipes.splice(index2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable2.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false) this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug2("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable2(this);
      } else if (!state2.reading) {
        browser$1$1.nextTick(nReadingNextTick2, this);
      }
    }
  }
  return res;
};
Readable2.prototype.addListener = Readable2.prototype.on;
Readable2.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable2.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick2(self2) {
  debug2("readable nexttick read 0");
  self2.read(0);
}
Readable2.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug2("resume");
    state2.flowing = !state2.readableListening;
    resume2(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume2(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$1.nextTick(resume_2, stream2, state2);
  }
}
function resume_2(stream2, state2) {
  debug2("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow2(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable2.prototype.pause = function() {
  debug2("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug2("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow2(stream2) {
  var state2 = stream2._readableState;
  debug2("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable2.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug2("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug2("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i4 in stream2) {
    if (this[i4] === void 0 && typeof stream2[i4] === "function") {
      this[i4] = /* @__PURE__ */ function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i4);
    }
  }
  for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
    stream2.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
  }
  this._read = function(n6) {
    debug2("wrapped _read", n6);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable2.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = requireAsync_iterator();
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get2() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable2.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get3() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable2.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get4() {
    return this._readableState.flowing;
  },
  set: function set2(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable2._fromList = fromList2;
Object.defineProperty(Readable2.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get5() {
    return this._readableState.length;
  }
});
function fromList2(n5, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n5 || n5 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.first();
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n5, state2.decoder);
  }
  return ret;
}
function endReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$1.nextTick(endReadableNT2, state2, stream2);
  }
}
function endReadableNT2(state2, stream2) {
  debug2("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable2.from = function(iterable, opts2) {
    if (from2 === void 0) {
      from2 = requireFromBrowser();
    }
    return from2(Readable2, iterable, opts2);
  };
}
function indexOf4(xs, x) {
  for (var i4 = 0, l2 = xs.length; i4 < l2; i4++) {
    if (xs[i4] === x) return i4;
  }
  return -1;
}
var browser2 = deprecate2;
function deprecate2(fn, msg2) {
  if (config2("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config2("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config2("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config2(name) {
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === "true";
}
var Registry$3 = _registry;
Registry$3.Writable = Writable2;
function CorkedRequest2(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
Writable2.WritableState = WritableState2;
var internalUtil = {
  deprecate: browser2
};
var Stream2 = streamBrowser;
var Buffer3 = require$$02.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = destroy_1;
var _require = state;
var getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE;
var ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK;
var ERR_STREAM_CANNOT_PIPE = _require$codes$2.ERR_STREAM_CANNOT_PIPE;
var ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
var ERR_STREAM_NULL_VALUES = _require$codes$2.ERR_STREAM_NULL_VALUES;
var ERR_STREAM_WRITE_AFTER_END = _require$codes$2.ERR_STREAM_WRITE_AFTER_END;
var ERR_UNKNOWN_ENCODING = _require$codes$2.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require$$12(Writable2, Stream2);
function nop2() {
}
function WritableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite2(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest2(this);
}
WritableState2.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState2.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable2, Symbol.hasInstance, {
    value: function value2(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable2) return false;
      return object && object._writableState instanceof WritableState2;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object) {
    return object instanceof this;
  };
}
function Writable2(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
  this._writableState = new WritableState2(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
    if (typeof options.final === "function") this._final = options.final;
  }
  Stream2.call(this);
}
Writable2.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd2(stream2, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er);
  browser$1$1.nextTick(cb, er);
}
function validChunk2(stream2, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy(stream2, er);
    browser$1$1.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable2.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop2;
  if (state2.ending) writeAfterEnd2(this, cb);
  else if (isBuf || validChunk2(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable2.prototype.cork = function() {
  this._writableState.corked++;
};
Writable2.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer2(this, state2);
  }
};
Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get6() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk2(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get7() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk2(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite2(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite2(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError2(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$1.nextTick(cb, er);
    browser$1$1.nextTick(finishMaybe2, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
  } else {
    cb(er);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
    finishMaybe2(stream2, state2);
  }
}
function onwriteStateUpdate2(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite2(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate2(state2);
  if (er) onwriteError2(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish2(state2) || stream2.destroyed;
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer2(stream2, state2);
    }
    if (sync) {
      browser$1$1.nextTick(afterWrite2, stream2, state2, finished, cb);
    } else {
      afterWrite2(stream2, state2, finished, cb);
    }
  }
}
function afterWrite2(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain2(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe2(stream2, state2);
}
function onwriteDrain2(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer2(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite2(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest2(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite2(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable2.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable2.prototype._writev = null;
Writable2.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending) endWritable2(this, state2, cb);
  return this;
};
Object.defineProperty(Writable2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get8() {
    return this._writableState.length;
  }
});
function needFinish2(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe2(stream2, state2);
  });
}
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$1.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
function finishMaybe2(stream2, state2) {
  var need = needFinish2(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable2(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe2(stream2, state2);
  if (cb) {
    if (state2.finished) browser$1$1.nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get9() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set3(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable2.prototype.destroy = destroyImpl.destroy;
Writable2.prototype._undestroy = destroyImpl.undestroy;
Writable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    keys2.push(key);
  }
  return keys2;
};
var Registry$2 = _registry;
Registry$2.Duplex = Duplex2;
require$$12(Duplex2, Registry$2.Readable);
{
  keys2 = objectKeys$1(Registry$2.Writable.prototype);
  for (v3 = 0; v3 < keys2.length; v3++) {
    method = keys2[v3];
    if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
var keys2;
var method;
var v3;
function Duplex2(options) {
  if (!(this instanceof Duplex2)) return new Duplex2(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend2);
    }
  }
}
Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get10() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get11() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get12() {
    return this._writableState.length;
  }
});
function onend2() {
  if (this._writableState.ended) return;
  browser$1$1.nextTick(onEndNT2, this);
}
function onEndNT2(self2) {
  self2.end();
}
Object.defineProperty(Duplex2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get13() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set4(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
var Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes;
var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK;
var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
require$$12(Transform$1, Registry$1.Duplex);
function afterTransform2(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform2.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.on("prefinish", prefinish2);
}
function prefinish2() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done2(_this, er, data2);
    });
  } else {
    done2(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n5) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done2(stream2, er, data2) {
  if (er) return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var Registry = _registry;
Registry.PassThrough = PassThrough2;
require$$12(PassThrough2, Registry.Transform);
function PassThrough2(options) {
  if (!(this instanceof PassThrough2)) return new PassThrough2(options);
  Transform.call(this, options);
}
PassThrough2.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once4(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes;
var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop2(err2) {
  if (err2) throw err2;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once4(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0) eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2) return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isRequest(stream2)) return stream2.abort();
    if (typeof stream2.destroy === "function") return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from4, to) {
  return from4.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop2;
  if (typeof streams[streams.length - 1] !== "function") return noop2;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream2, i4) {
    var reading = i4 < streams.length - 1;
    var writing = i4 > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error) error = err2;
      if (err2) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports) {
  const Registry2 = _registry;
  exports = module.exports = Registry2.Readable;
  exports.Stream = Registry2.Readable;
  exports.Readable = Registry2.Readable;
  exports.Writable = Registry2.Writable;
  exports.Duplex = Registry2.Duplex;
  exports.Transform = Registry2.Transform;
  exports.PassThrough = Registry2.PassThrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var stream = getDefaultExportFromCjs2(readableBrowserExports);
var lib2 = {};
var binding2 = {};
function compare6(a4, b3) {
  if (a4 === b3) {
    return 0;
  }
  var x = a4.length;
  var y3 = b3.length;
  for (var i4 = 0, len = Math.min(x, y3); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x = a4[i4];
      y3 = b3[i4];
      break;
    }
  }
  if (x < y3) {
    return -1;
  }
  if (y3 < x) {
    return 1;
  }
  return 0;
}
var hasOwn2 = Object.prototype.hasOwnProperty;
var objectKeys2 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn2.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice2 = Array.prototype.slice;
var _functionsHaveNames2;
function functionsHaveNames2() {
  if (typeof _functionsHaveNames2 !== "undefined") {
    return _functionsHaveNames2;
  }
  return _functionsHaveNames2 = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString2(obj) {
  return Object.prototype.toString.call(obj);
}
function isView2(arrbuf) {
  if (isBuffer$12(arrbuf)) {
    return false;
  }
  if (typeof global$12.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
var regex2 = /\s*function\s+([^\(\s]*)\s*/;
function getName2(func) {
  if (!isFunction2(func)) {
    return;
  }
  if (functionsHaveNames2()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex2);
  return match && match[1];
}
assert2.AssertionError = AssertionError2;
function AssertionError2(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage2(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail2;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName2(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$2(AssertionError2, Error);
function truncate2(s2, n5) {
  if (typeof s2 === "string") {
    return s2.length < n5 ? s2 : s2.slice(0, n5);
  } else {
    return s2;
  }
}
function inspect4(something) {
  if (functionsHaveNames2() || !isFunction2(something)) {
    return inspect$12(something);
  }
  var rawname = getName2(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage2(self2) {
  return truncate2(inspect4(self2.actual), 128) + " " + self2.operator + " " + truncate2(inspect4(self2.expected), 128);
}
function fail2(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError2({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert2.fail = fail2;
function ok2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
assert2.ok = ok2;
assert2.equal = equal2;
function equal2(actual, expected, message) {
  if (actual != expected) fail2(actual, expected, message, "==", equal2);
}
assert2.notEqual = notEqual2;
function notEqual2(actual, expected, message) {
  if (actual == expected) {
    fail2(actual, expected, message, "!=", notEqual2);
  }
}
assert2.deepEqual = deepEqual2;
function deepEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "deepEqual", deepEqual2);
  }
}
assert2.deepStrictEqual = deepStrictEqual2;
function deepStrictEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "deepStrictEqual", deepStrictEqual2);
  }
}
function _deepEqual2(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$12(actual) && isBuffer$12(expected)) {
    return compare6(actual, expected) === 0;
  } else if (isDate2(actual) && isDate2(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp2(actual) && isRegExp2(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView2(actual) && isView2(expected) && pToString2(actual) === pToString2(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare6(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$12(actual) !== isBuffer$12(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv2(actual, expected, strict, memos);
  }
}
function isArguments2(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv2(a4, b3, strict, actualVisitedObjects) {
  if (a4 === null || a4 === void 0 || b3 === null || b3 === void 0)
    return false;
  if (isPrimitive2(a4) || isPrimitive2(b3))
    return a4 === b3;
  if (strict && Object.getPrototypeOf(a4) !== Object.getPrototypeOf(b3))
    return false;
  var aIsArgs = isArguments2(a4);
  var bIsArgs = isArguments2(b3);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a4 = pSlice2.call(a4);
    b3 = pSlice2.call(b3);
    return _deepEqual2(a4, b3, strict);
  }
  var ka = objectKeys2(a4);
  var kb = objectKeys2(b3);
  var key, i4;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    if (ka[i4] !== kb[i4])
      return false;
  }
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    key = ka[i4];
    if (!_deepEqual2(a4[key], b3[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert2.notDeepEqual = notDeepEqual2;
function notDeepEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "notDeepEqual", notDeepEqual2);
  }
}
assert2.notDeepStrictEqual = notDeepStrictEqual2;
function notDeepStrictEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual2);
  }
}
assert2.strictEqual = strictEqual2;
function strictEqual2(actual, expected, message) {
  if (actual !== expected) {
    fail2(actual, expected, message, "===", strictEqual2);
  }
}
assert2.notStrictEqual = notStrictEqual2;
function notStrictEqual2(actual, expected, message) {
  if (actual === expected) {
    fail2(actual, expected, message, "!==", notStrictEqual2);
  }
}
function expectedException2(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e4) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock2(block) {
  var error;
  try {
    block();
  } catch (e4) {
    error = e4;
  }
  return error;
}
function _throws2(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock2(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail2(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError2(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException2(actual, expected) || isUnexpectedException) {
    fail2(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException2(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert2.throws = throws2;
function throws2(block, error, message) {
  _throws2(true, block, error, message);
}
assert2.doesNotThrow = doesNotThrow2;
function doesNotThrow2(block, error, message) {
  _throws2(false, block, error, message);
}
assert2.ifError = ifError2;
function ifError2(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert2 = Object.freeze({
  __proto__: null,
  AssertionError: AssertionError2,
  assert: ok2,
  deepEqual: deepEqual2,
  deepStrictEqual: deepStrictEqual2,
  default: assert2,
  doesNotThrow: doesNotThrow2,
  equal: equal2,
  fail: fail2,
  ifError: ifError2,
  notDeepEqual: notDeepEqual2,
  notDeepStrictEqual: notDeepStrictEqual2,
  notEqual: notEqual2,
  notStrictEqual: notStrictEqual2,
  ok: ok2,
  strictEqual: strictEqual2,
  throws: throws2
});
var require$$42 = getAugmentedNamespace2(_polyfillNode_assert2);
(function(exports) {
  var assert3 = require$$42;
  var Zstream = import_zstream.default;
  var zlib_deflate = import_deflate.default;
  var zlib_inflate = import_inflate.default;
  var constants3 = import_constants.default;
  for (var key in constants3) {
    exports[key] = constants3[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding2);
(function(exports) {
  var Buffer5 = require$$02.Buffer;
  var Transform3 = readableBrowserExports.Transform;
  var binding$13 = binding2;
  var util = require$$32;
  var assert3 = require$$42.ok;
  var kMaxLength4 = require$$02.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib2);
var zlib2 = getDefaultExportFromCjs2(lib2);
var PDFReference = class extends stream.Writable {
  constructor(document2, id, data2) {
    super({
      decodeStrings: false
    });
    this.finalize = this.finalize.bind(this);
    this.document = document2;
    this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    this.data = data2;
    this.gen = 0;
    this.deflate = null;
    this.compress = this.document.compress && !this.data.Filter;
    this.uncompressedLength = 0;
    this.chunks = [];
  }
  initDeflate() {
    this.data.Filter = "FlateDecode";
    this.deflate = zlib2.createDeflate();
    this.deflate.on("data", (chunk) => {
      this.chunks.push(chunk);
      return this.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  }
  _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$2.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  }
  end() {
    super.end(...arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  }
  finalize() {
    this.offset = this.document._offset;
    this.document._write(`${this.id} ${this.gen} obj`);
    this.document._write(PDFObject.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (let chunk of Array.from(this.chunks)) {
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  }
  toString() {
    return `${this.id} ${this.gen} R`;
  }
};
var PDFTree = class {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  add(key, val) {
    return this._items[key] = val;
  }
  get(key) {
    return this._items[key];
  }
  toString() {
    const sortedKeys = Object.keys(this._items).sort((a4, b3) => this._compareKeys(a4, b3));
    const out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      const first = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last2)])}`);
    }
    out.push(`  /${this._keysName()} [`);
    for (let key of sortedKeys) {
      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  }
  _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  }
  _keysName() {
    throw new Error("Must be implemented by subclasses");
  }
  _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  }
};
var PDFNameTree = class extends PDFTree {
  _compareKeys(a4, b3) {
    return a4.localeCompare(b3);
  }
  _keysName() {
    return "Names";
  }
  _dataForKey(k3) {
    return new String(k3);
  }
};
var pad2 = (str, length2) => (Array(length2 + 1).join("0") + str).slice(-length2);
var escapableRe = /[\n\r\t\b\f()\\]/g;
var escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
var swapBytes = function(buff) {
  const l2 = buff.length;
  if (l2 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (let i4 = 0, end2 = l2 - 1; i4 < end2; i4 += 2) {
      const a4 = buff[i4];
      buff[i4] = buff[i4 + 1];
      buff[i4 + 1] = a4;
    }
  }
  return buff;
};
var PDFObject = class _PDFObject {
  static convert(object) {
    if (typeof object === "string") {
      return `/${object}`;
    }
    if (object instanceof String) {
      let string = object;
      let isUnicode = false;
      for (let i4 = 0, end2 = string.length; i4 < end2; i4++) {
        if (string.charCodeAt(i4) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$2.from(`\uFEFF${string}`, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, (c4) => escapable[c4]);
      return `(${string})`;
    }
    if (Buffer$2.isBuffer(object)) {
      return `<${object.toString("hex")}>`;
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return `(D:${pad2(object.getUTCFullYear(), 4)}` + pad2(object.getUTCMonth() + 1, 2) + pad2(object.getUTCDate(), 2) + pad2(object.getUTCHours(), 2) + pad2(object.getUTCMinutes(), 2) + pad2(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      const items = Array.from(object).map((e4) => _PDFObject.convert(e4)).join(" ");
      return `[${items}]`;
    }
    if ({}.toString.call(object) === "[object Object]") {
      const out = ["<<"];
      for (let key in object) {
        const val = object[key];
        out.push(`/${key} ${_PDFObject.convert(val)}`);
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return _PDFObject.number(object);
    }
    return `${object}`;
  }
  static number(n5) {
    if (n5 > -1e21 && n5 < 1e21) {
      return Math.round(n5 * 1e6) / 1e6;
    }
    throw new Error(`unsupported number: ${n5}`);
  }
};
var DEFAULT_MARGINS = {
  top: 72,
  left: 72,
  bottom: 72,
  right: 72
};
var SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
var PDFPage = class {
  constructor(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this._options = options;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    if (typeof options.margin === "number") {
      this.margins = {
        top: options.margin,
        left: options.margin,
        bottom: options.margin,
        right: options.margin
      };
    } else {
      this.margins = options.margins || DEFAULT_MARGINS;
    }
    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    if (options.font) document2.font(options.font, options.fontFamily);
    if (options.fontSize) document2.fontSize(options.fontSize);
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
    this.markings = [];
  }
  // Lazily create these objects
  get fonts() {
    const data2 = this.resources.data;
    return data2.Font != null ? data2.Font : data2.Font = {};
  }
  get xobjects() {
    const data2 = this.resources.data;
    return data2.XObject != null ? data2.XObject : data2.XObject = {};
  }
  get ext_gstates() {
    const data2 = this.resources.data;
    return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
  }
  get patterns() {
    const data2 = this.resources.data;
    return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
  }
  get colorSpaces() {
    const data2 = this.resources.data;
    return data2.ColorSpace || (data2.ColorSpace = {});
  }
  get annotations() {
    const data2 = this.dictionary.data;
    return data2.Annots != null ? data2.Annots : data2.Annots = [];
  }
  get structParentTreeKey() {
    const data2 = this.dictionary.data;
    return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
  }
  maxY() {
    return this.height - this.margins.bottom;
  }
  write(chunk) {
    return this.content.write(chunk);
  }
  // Set tab order if document is tagged for accessibility.
  _setTabOrder() {
    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {
      this.dictionary.data.Tabs = "S";
    }
  }
  end() {
    this._setTabOrder();
    this.dictionary.end();
    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};
    for (let color of Object.values(this.document.spotColors)) {
      this.resources.data.ColorSpace[color.id] = color;
    }
    this.resources.end();
    return this.content.end();
  }
};
var wordArrayToBuffer = (wordArray) => {
  const byteArray = [];
  for (let i4 = 0; i4 < wordArray.sigBytes; i4++) {
    byteArray.push(wordArray.words[Math.floor(i4 / 4)] >> 8 * (3 - i4 % 4) & 255);
  }
  return Buffer$2.from(byteArray);
};
var PDFSecurity = class {
  static generateFileID(info) {
    if (info === void 0) {
      info = {};
    }
    let infoStr = `${info.CreationDate.getTime()}
`;
    for (let key in info) {
      if (!info.hasOwnProperty(key)) continue;
      infoStr += `${key}: ${info[key].valueOf()}
`;
    }
    return wordArrayToBuffer((0, import_md5.default)(infoStr));
  }
};
var {
  number: number$2
} = PDFObject;
var PDFGradient$1 = class PDFGradient {
  constructor(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  stop(pos, color, opacity) {
    if (opacity == null) {
      opacity = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity = Math.max(0, Math.min(1, opacity));
    this.stops.push([pos, color, opacity]);
    return this;
  }
  setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  }
  embed(m) {
    let fn;
    const stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m;
    const last2 = this.stops[stopsLength - 1];
    if (last2[0] < 1) {
      this.stops.push([1, last2[1], last2[2]]);
    }
    const bounds = [];
    const encode = [];
    const stops = [];
    for (let i4 = 0; i4 < stopsLength - 1; i4++) {
      encode.push(0, 1);
      if (i4 + 2 !== stopsLength) {
        bounds.push(this.stops[i4 + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i4 + 0][1],
        C1: this.stops[i4 + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = `Sh${++this.doc._gradCount}`;
    const shader = this.shader(fn);
    shader.end();
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern3.end();
    if (this.stops.some((stop) => stop[2] < 1)) {
      let grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (let stop of this.stops) {
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      const form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(`${pageBBox.join(" ")} re f`);
      const gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      const opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern3
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(`${pageBBox.join(" ")} re f`);
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern3;
    }
    return pattern3;
  }
  apply(stroke) {
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = this.transform;
    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m.join(" ") !== this.matrix.join(" ")) {
      this.embed(m);
    }
    this.doc._setColorSpace("Pattern", stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`/${this.id} ${op}`);
  }
};
var PDFLinearGradient$1 = class PDFLinearGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, x2, y22) {
    super(doc);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y22;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
  }
};
var PDFRadialGradient$1 = class PDFRadialGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, r1, x2, y22, r22) {
    super(doc);
    this.doc = doc;
    this.x1 = x1;
    this.y1 = y1;
    this.r1 = r1;
    this.x2 = x2;
    this.y2 = y22;
    this.r2 = r22;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  }
};
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
var underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
var PDFTilingPattern$1 = class PDFTilingPattern {
  constructor(doc, bBox, xStep, yStep, stream2) {
    this.doc = doc;
    this.bBox = bBox;
    this.xStep = xStep;
    this.yStep = yStep;
    this.stream = stream2;
  }
  createPattern() {
    const resources = this.doc.ref();
    resources.end();
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];
    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    const pattern3 = this.doc.ref({
      Type: "Pattern",
      PatternType: 1,
      // tiling
      PaintType: 2,
      // 1-colored, 2-uncolored
      TilingType: 2,
      // 2-no distortion
      BBox: this.bBox,
      XStep: this.xStep,
      YStep: this.yStep,
      Matrix: m.map((v3) => +v3.toFixed(5)),
      Resources: resources
    });
    pattern3.end(this.stream);
    return pattern3;
  }
  embedPatternColorSpaces() {
    underlyingColorSpaces.forEach((csName) => {
      const csId = this.getPatternColorSpaceId(csName);
      if (this.doc.page.colorSpaces[csId]) return;
      const cs = this.doc.ref(["Pattern", csName]);
      cs.end();
      this.doc.page.colorSpaces[csId] = cs;
    });
  }
  getPatternColorSpaceId(underlyingColorspace) {
    return `CsP${underlyingColorspace}`;
  }
  embed() {
    if (!this.id) {
      this.doc._patternCount = this.doc._patternCount + 1;
      this.id = "P" + this.doc._patternCount;
      this.pattern = this.createPattern();
    }
    if (!this.doc.page.patterns[this.id]) {
      this.doc.page.patterns[this.id] = this.pattern;
    }
  }
  apply(stroke, patternColor) {
    this.embedPatternColorSpaces();
    this.embed();
    const normalizedColor = this.doc._normalizeColor(patternColor);
    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);
    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
    this.doc._setColorSpace(csId, stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`${normalizedColor.join(" ")} /${this.id} ${op}`);
  }
};
var pattern = {
  PDFTilingPattern: PDFTilingPattern$1
};
var SpotColor = class {
  constructor(doc, name, C, M, Y, K) {
    this.id = "CS" + Object.keys(doc.spotColors).length;
    this.name = name;
    this.values = [C, M, Y, K];
    this.ref = doc.ref(["Separation", this.name, "DeviceCMYK", {
      Range: [0, 1, 0, 1, 0, 1, 0, 1],
      C0: [0, 0, 0, 0],
      C1: this.values.map((value2) => value2 / 100),
      FunctionType: 2,
      Domain: [0, 1],
      N: 1
    }]);
    this.ref.end();
  }
  toString() {
    return `${this.ref.id} 0 R`;
  }
};
var {
  PDFGradient: PDFGradient2,
  PDFLinearGradient: PDFLinearGradient2,
  PDFRadialGradient: PDFRadialGradient2
} = Gradient;
var {
  PDFTilingPattern: PDFTilingPattern2
} = pattern;
var ColorMixin = {
  initColor() {
    this.spotColors = {};
    this._opacityRegistry = {};
    this._opacityCount = 0;
    this._patternCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor(color) {
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        const hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      } else if (this.spotColors[color]) {
        return this.spotColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = color.map((part) => part / 255);
      } else if (color.length === 4) {
        color = color.map((part) => part / 100);
      }
      return color;
    }
    return null;
  },
  _setColor(color, stroke) {
    if (color instanceof PDFGradient2) {
      color.apply(stroke);
      return true;
    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern2) {
      color[0].apply(stroke, color[1]);
      return true;
    }
    return this._setColorCore(color, stroke);
  },
  _setColorCore(color, stroke) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    const op = stroke ? "SCN" : "scn";
    const space = this._getColorSpace(color);
    this._setColorSpace(space, stroke);
    if (color instanceof SpotColor) {
      this.page.colorSpaces[color.id] = color.ref;
      this.addContent(`1 ${op}`);
    } else {
      this.addContent(`${color.join(" ")} ${op}`);
    }
    return true;
  },
  _setColorSpace(space, stroke) {
    const op = stroke ? "CS" : "cs";
    return this.addContent(`/${space} ${op}`);
  },
  _getColorSpace(color) {
    if (color instanceof SpotColor) {
      return color.id;
    }
    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
  },
  fillColor(color, opacity) {
    const set5 = this._setColor(color, false);
    if (set5) {
      this.fillOpacity(opacity);
    }
    this._fillColor = [color, opacity];
    return this;
  },
  strokeColor(color, opacity) {
    const set5 = this._setColor(color, true);
    if (set5) {
      this.strokeOpacity(opacity);
    }
    return this;
  },
  opacity(opacity) {
    this._doOpacity(opacity, opacity);
    return this;
  },
  fillOpacity(opacity) {
    this._doOpacity(opacity, null);
    return this;
  },
  strokeOpacity(opacity) {
    this._doOpacity(null, opacity);
    return this;
  },
  _doOpacity(fillOpacity, strokeOpacity) {
    let dictionary, name;
    if (fillOpacity == null && strokeOpacity == null) {
      return;
    }
    if (fillOpacity != null) {
      fillOpacity = Math.max(0, Math.min(1, fillOpacity));
    }
    if (strokeOpacity != null) {
      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
    }
    const key = `${fillOpacity}_${strokeOpacity}`;
    if (this._opacityRegistry[key]) {
      [dictionary, name] = this._opacityRegistry[key];
    } else {
      dictionary = {
        Type: "ExtGState"
      };
      if (fillOpacity != null) {
        dictionary.ca = fillOpacity;
      }
      if (strokeOpacity != null) {
        dictionary.CA = strokeOpacity;
      }
      dictionary = this.ref(dictionary);
      dictionary.end();
      const id = ++this._opacityCount;
      name = `Gs${id}`;
      this._opacityRegistry[key] = [dictionary, name];
    }
    this.page.ext_gstates[name] = dictionary;
    return this.addContent(`/${name} gs`);
  },
  linearGradient(x1, y1, x2, y22) {
    return new PDFLinearGradient2(this, x1, y1, x2, y22);
  },
  radialGradient(x1, y1, r1, x2, y22, r22) {
    return new PDFRadialGradient2(this, x1, y1, r1, x2, y22, r22);
  },
  pattern(bbox, xStep, yStep, stream2) {
    return new PDFTilingPattern2(this, bbox, xStep, yStep, stream2);
  },
  addSpotColor(name, C, M, Y, K) {
    const color = new SpotColor(this, name, C, M, Y, K);
    this.spotColors[name] = color;
    return this;
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var cx;
var cy;
var px;
var py;
var sx;
var sy;
cx = cy = px = py = sx = sy = 0;
var argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
var isCommand = (c4) => {
  return c4 in argsCountPerCommand;
};
var isWsp = (c4) => {
  const codePoint = c4.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
};
var isDigit = (c4) => {
  const codePoint = c4.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
var readNumber = (string, cursor) => {
  let i4 = cursor;
  let value2 = "";
  let state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i4 < string.length; i4 += 1) {
    const c4 = string[i4];
    if (c4 === "+" || c4 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c4;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c4;
        continue;
      }
    }
    if (isDigit(c4)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c4;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c4;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c4;
        continue;
      }
    }
    if (c4 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c4;
        continue;
      }
    }
    if (c4 === "E" || c4 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c4;
        continue;
      }
    }
    break;
  }
  const number3 = Number.parseFloat(value2);
  if (Number.isNaN(number3)) {
    return [cursor, null];
  }
  return [i4 - 1, number3];
};
var parsePathData = (string) => {
  const pathData = [];
  let command = null;
  let args = (
    /** @type {number[]} */
    []
  );
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i4 = 0; i4 < string.length; i4 += 1) {
    const c4 = string.charAt(i4);
    if (isWsp(c4)) {
      continue;
    }
    if (canHaveComma && c4 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c4)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c4 !== "M" && c4 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c4;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    let newCursor = i4;
    let number3 = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        if (c4 !== "+" && c4 !== "-") {
          [newCursor, number3] = readNumber(string, i4);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number3] = readNumber(string, i4);
      }
      if (position === 3 || position === 4) {
        if (c4 === "0") {
          number3 = 0;
        }
        if (c4 === "1") {
          number3 = 1;
        }
      }
    } else {
      [newCursor, number3] = readNumber(string, i4);
    }
    if (number3 == null) {
      return pathData;
    }
    args.push(number3);
    canHaveComma = true;
    hadComma = false;
    i4 = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
var apply = function(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (let i4 = 0; i4 < commands.length; i4++) {
    const {
      command,
      args
    } = commands[i4];
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
};
var runners = {
  M(doc, a4) {
    cx = a4[0];
    cy = a4[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m(doc, a4) {
    cx += a4[0];
    cy += a4[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C(doc, a4) {
    cx = a4[4];
    cy = a4[5];
    px = a4[2];
    py = a4[3];
    return doc.bezierCurveTo(...a4);
  },
  c(doc, a4) {
    doc.bezierCurveTo(a4[0] + cx, a4[1] + cy, a4[2] + cx, a4[3] + cy, a4[4] + cx, a4[5] + cy);
    px = cx + a4[2];
    py = cy + a4[3];
    cx += a4[4];
    return cy += a4[5];
  },
  S(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a4[0], a4[1], a4[2], a4[3]);
    px = a4[0];
    py = a4[1];
    cx = a4[2];
    return cy = a4[3];
  },
  s(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a4[0], cy + a4[1], cx + a4[2], cy + a4[3]);
    px = cx + a4[0];
    py = cy + a4[1];
    cx += a4[2];
    return cy += a4[3];
  },
  Q(doc, a4) {
    px = a4[0];
    py = a4[1];
    cx = a4[2];
    cy = a4[3];
    return doc.quadraticCurveTo(a4[0], a4[1], cx, cy);
  },
  q(doc, a4) {
    doc.quadraticCurveTo(a4[0] + cx, a4[1] + cy, a4[2] + cx, a4[3] + cy);
    px = cx + a4[0];
    py = cy + a4[1];
    cx += a4[2];
    return cy += a4[3];
  },
  T(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a4[0], a4[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a4[0];
    return cy = a4[1];
  },
  t(doc, a4) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a4[0], cy + a4[1]);
    cx += a4[0];
    return cy += a4[1];
  },
  A(doc, a4) {
    solveArc(doc, cx, cy, a4);
    cx = a4[5];
    return cy = a4[6];
  },
  a(doc, a4) {
    a4[5] += cx;
    a4[6] += cy;
    solveArc(doc, cx, cy, a4);
    cx = a4[5];
    return cy = a4[6];
  },
  L(doc, a4) {
    cx = a4[0];
    cy = a4[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l(doc, a4) {
    cx += a4[0];
    cy += a4[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H(doc, a4) {
    cx = a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h(doc, a4) {
    cx += a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V(doc, a4) {
    cy = a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v(doc, a4) {
    cy += a4[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
var solveArc = function(doc, x, y3, coords) {
  const [rx, ry, rot, large, sweep, ex, ey] = coords;
  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y3);
  for (let seg of segs) {
    const bez = segmentToBezier(...seg);
    doc.bezierCurveTo(...bez);
  }
};
var arcToSegments = function(x, y3, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = rotateX * (Math.PI / 180);
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y3) * 0.5;
  py = cos_th * (oy - y3) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y3;
  const y1 = a10 * x + a11 * y3;
  const d2 = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d2 - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  const result = [];
  for (let i4 = 0; i4 < segments; i4++) {
    const th2 = th0 + i4 * th_arc / segments;
    const th3 = th0 + (i4 + 1) * th_arc / segments;
    result[i4] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
};
var segmentToBezier = function(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const th_half = 0.5 * (th1 - th0);
  const t4 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  const x1 = cx2 + Math.cos(th0) - t4 * Math.sin(th0);
  const y1 = cy2 + Math.sin(th0) + t4 * Math.cos(th0);
  const x3 = cx2 + Math.cos(th1);
  const y3 = cy2 + Math.sin(th1);
  const x2 = x3 + t4 * Math.sin(th1);
  const y22 = y3 - t4 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y22, a10 * x2 + a11 * y22, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
};
var SVGPath = class {
  static apply(doc, path) {
    const commands = parsePathData(path);
    apply(commands, doc);
  }
};
var {
  number: number$1
} = PDFObject;
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath() {
    return this.addContent("h");
  },
  lineWidth(w) {
    return this.addContent(`${number$1(w)} w`);
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap(c4) {
    if (typeof c4 === "string") {
      c4 = this._CAP_STYLES[c4.toUpperCase()];
    }
    return this.addContent(`${c4} J`);
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(`${j} j`);
  },
  miterLimit(m) {
    return this.addContent(`${number$1(m)} M`);
  },
  dash(length2, options) {
    if (options === void 0) {
      options = {};
    }
    const originalLength = length2;
    if (!Array.isArray(length2)) {
      length2 = [length2, options.space || length2];
    }
    const valid = length2.every((x) => Number.isFinite(x) && x > 0);
    if (!valid) {
      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);
    }
    length2 = length2.map(number$1).join(" ");
    return this.addContent(`[${length2}] ${number$1(options.phase || 0)} d`);
  },
  undash() {
    return this.addContent("[] 0 d");
  },
  moveTo(x, y3) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} m`);
  },
  lineTo(x, y3) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} l`);
  },
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y3) {
    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y3)} c`);
  },
  quadraticCurveTo(cpx, cpy, x, y3) {
    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y3)} v`);
  },
  rect(x, y3, w, h3) {
    return this.addContent(`${number$1(x)} ${number$1(y3)} ${number$1(w)} ${number$1(h3)} re`);
  },
  roundedRect(x, y3, w, h3, r5) {
    if (r5 == null) {
      r5 = 0;
    }
    r5 = Math.min(r5, 0.5 * w, 0.5 * h3);
    const c4 = r5 * (1 - KAPPA);
    this.moveTo(x + r5, y3);
    this.lineTo(x + w - r5, y3);
    this.bezierCurveTo(x + w - c4, y3, x + w, y3 + c4, x + w, y3 + r5);
    this.lineTo(x + w, y3 + h3 - r5);
    this.bezierCurveTo(x + w, y3 + h3 - c4, x + w - c4, y3 + h3, x + w - r5, y3 + h3);
    this.lineTo(x + r5, y3 + h3);
    this.bezierCurveTo(x + c4, y3 + h3, x, y3 + h3 - c4, x, y3 + h3 - r5);
    this.lineTo(x, y3 + r5);
    this.bezierCurveTo(x, y3 + c4, x + c4, y3, x + r5, y3);
    return this.closePath();
  },
  ellipse(x, y3, r1, r22) {
    if (r22 == null) {
      r22 = r1;
    }
    x -= r1;
    y3 -= r22;
    const ox = r1 * KAPPA;
    const oy = r22 * KAPPA;
    const xe = x + r1 * 2;
    const ye = y3 + r22 * 2;
    const xm = x + r1;
    const ym = y3 + r22;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y3, xm, y3);
    this.bezierCurveTo(xm + ox, y3, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle(x, y3, radius) {
    return this.ellipse(x, y3, radius);
  },
  arc(x, y3, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    const TWO_PI = 2 * Math.PI;
    const HALF_PI = 0.5 * Math.PI;
    let deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      const dir = anticlockwise ? -1 : 1;
      deltaAng = dir * TWO_PI + deltaAng;
    }
    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    const segAng = deltaAng / numSegs;
    const handleLen = segAng / HALF_PI * KAPPA * radius;
    let curAng = startAngle;
    let deltaCx = -Math.sin(curAng) * handleLen;
    let deltaCy = Math.cos(curAng) * handleLen;
    let ax = x + Math.cos(curAng) * radius;
    let ay = y3 + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (let segIdx = 0; segIdx < numSegs; segIdx++) {
      const cp1x = ax + deltaCx;
      const cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y3 + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      const cp2x = ax - deltaCx;
      const cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo(...points.shift() || []);
    for (let point of points) {
      this.lineTo(...point || []);
    }
    return this.closePath();
  },
  path(path) {
    SVGPath.apply(this, path);
    return this;
  },
  _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent(`f${this._windingRule(rule)}`);
  },
  stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke(fillColor, strokeColor, rule) {
    if (strokeColor == null) {
      strokeColor = fillColor;
    }
    const isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor)) {
      rule = fillColor;
      fillColor = null;
    }
    if (isFillRule.test(strokeColor)) {
      rule = strokeColor;
      strokeColor = fillColor;
    }
    if (fillColor) {
      this.fillColor(fillColor);
      this.strokeColor(strokeColor);
    }
    return this.addContent(`B${this._windingRule(rule)}`);
  },
  clip(rule) {
    return this.addContent(`W${this._windingRule(rule)} n`);
  },
  transform(m11, m12, m21, m22, dx, dy) {
    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
      return this;
    }
    const m = this._ctm;
    const [m0, m1, m2, m3, m4, m5] = m;
    m[0] = m0 * m11 + m2 * m12;
    m[1] = m1 * m11 + m3 * m12;
    m[2] = m0 * m21 + m2 * m22;
    m[3] = m1 * m21 + m3 * m22;
    m[4] = m0 * dx + m2 * dy + m4;
    m[5] = m1 * dx + m3 * dy + m5;
    const values = [m11, m12, m21, m22, dx, dy].map((v3) => number$1(v3)).join(" ");
    return this.addContent(`${values} cm`);
  },
  translate(x, y3) {
    return this.transform(1, 0, 0, 1, x, y3);
  },
  rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    let y3;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    let x = y3 = 0;
    if (options.origin != null) {
      [x, y3] = options.origin;
      const x1 = x * cos - y3 * sin;
      const y1 = x * sin + y3 * cos;
      x -= x1;
      y3 -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y3);
  },
  scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    let y3;
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    let x = y3 = 0;
    if (options.origin != null) {
      [x, y3] = options.origin;
      x -= xFactor * x;
      y3 -= yFactor * y3;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y3);
  }
};
var fs = {};
var range = (left, right, inclusive) => {
  let range2 = [];
  let end2 = right + 1;
  for (let i4 = left; i4 < end2; i4++) {
    range2.push(i4);
  }
  return range2;
};
var WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
var characters = `.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef

space         exclam         quotedbl       numbersign
dollar        percent        ampersand      quotesingle
parenleft     parenright     asterisk       plus
comma         hyphen         period         slash
zero          one            two            three
four          five           six            seven
eight         nine           colon          semicolon
less          equal          greater        question

at            A              B              C
D             E              F              G
H             I              J              K
L             M              N              O
P             Q              R              S
T             U              V              W
X             Y              Z              bracketleft
backslash     bracketright   asciicircum    underscore

grave         a              b              c
d             e              f              g
h             i              j              k
l             m              n              o
p             q              r              s
t             u              v              w
x             y              z              braceleft
bar           braceright     asciitilde     .notdef

Euro          .notdef        quotesinglbase florin
quotedblbase  ellipsis       dagger         daggerdbl
circumflex    perthousand    Scaron         guilsinglleft
OE            .notdef        Zcaron         .notdef
.notdef       quoteleft      quoteright     quotedblleft
quotedblright bullet         endash         emdash
tilde         trademark      scaron         guilsinglright
oe            .notdef        zcaron         ydieresis

space         exclamdown     cent           sterling
currency      yen            brokenbar      section
dieresis      copyright      ordfeminine    guillemotleft
logicalnot    softhyphen     registered     macron
degree        plusminus      twosuperior    threesuperior
acute         mu             paragraph      periodcentered
cedilla       onesuperior    ordmasculine   guillemotright
onequarter    onehalf        threequarters  questiondown

Agrave        Aacute         Acircumflex    Atilde
Adieresis     Aring          AE             Ccedilla
Egrave        Eacute         Ecircumflex    Edieresis
Igrave        Iacute         Icircumflex    Idieresis
Eth           Ntilde         Ograve         Oacute
Ocircumflex   Otilde         Odieresis      multiply
Oslash        Ugrave         Uacute         Ucircumflex
Udieresis     Yacute         Thorn          germandbls

agrave        aacute         acircumflex    atilde
adieresis     aring          ae             ccedilla
egrave        eacute         ecircumflex    edieresis
igrave        iacute         icircumflex    idieresis
eth           ntilde         ograve         oacute
ocircumflex   otilde         odieresis      divide
oslash        ugrave         uacute         ucircumflex
udieresis     yacute         thorn          ydieresis`.split(/\s+/);
function parse(contents) {
  const obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  let section = "";
  for (let line2 of contents.split("\n")) {
    var match;
    var a4;
    if (match = line2.match(/^Start(\w+)/)) {
      section = match[1];
      continue;
    } else if (match = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match = line2.match(/(^\w+)\s+(.*)/);
        var key = match[1];
        var value2 = match[2];
        if (a4 = obj.attributes[key]) {
          if (!Array.isArray(a4)) {
            a4 = obj.attributes[key] = [a4];
          }
          a4.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match) {
          obj.kernPairs[match[1] + match[2]] = parseInt(match[3]);
        }
        break;
    }
  }
  return obj;
}
var AFMFont = class _AFMFont {
  static open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  }
  static fromJson(json) {
    return new _AFMFont(json);
  }
  constructor(contents) {
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255).map((i4) => this.glyphWidths[characters[i4]]);
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map((e4) => +e4);
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  parse() {
    const parsed = parse(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  }
  encodeText(text) {
    const res = [];
    for (let i4 = 0, end2 = text.length, asc = 0 <= end2; asc ? i4 < end2 : i4 > end2; asc ? i4++ : i4--) {
      let char = text.charCodeAt(i4);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  }
  glyphsForString(string) {
    const glyphs = [];
    for (let i4 = 0, end2 = string.length, asc = 0 <= end2; asc ? i4 < end2 : i4 > end2; asc ? i4++ : i4--) {
      const charCode = string.charCodeAt(i4);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  }
  characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  }
  widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  }
  getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  }
  advancesForGlyphs(glyphs) {
    const advances = [];
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      const left = glyphs[index2];
      const right = glyphs[index2 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  }
};
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
var initFont = (font) => {
  return [font.FontName, {
    attributes: font,
    glyphWidths: {},
    kernPairs: {}
  }];
};
var expandData = (data2) => {
  const {
    attributes: attributes2,
    glyphWidths: glyphWidths2,
    kernPairs: kernPairs2
  } = data2;
  const fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach((key) => {
    glyphWidths2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach((key) => {
    kernPairs2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
};
var STANDARD_FONTS = expandData(data);
var createStandardFont = (PDFFont2) => class StandardFont extends PDFFont2 {
  constructor(document2, name, id) {
    super();
    this.document = document2;
    this.name = name;
    this.id = id;
    this.font = AFMFont.fromJson(STANDARD_FONTS[this.name]);
    this.ascender = this.font.ascender;
    this.descender = this.font.descender;
    this.bbox = this.font.bbox;
    this.lineGap = this.font.lineGap;
  }
  embed() {
    this.dictionary.data = {
      Type: "Font",
      BaseFont: this.name,
      Subtype: "Type1",
      Encoding: "WinAnsiEncoding"
    };
    return this.dictionary.end();
  }
  encode(text) {
    const encoded = this.font.encodeText(text);
    const glyphs = this.font.glyphsForString(`${text}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    const positions = [];
    for (let i4 = 0; i4 < glyphs.length; i4++) {
      const glyph = glyphs[i4];
      positions.push({
        xAdvance: advances[i4],
        yAdvance: 0,
        xOffset: 0,
        yOffset: 0,
        advanceWidth: this.font.widthOfGlyph(glyph)
      });
    }
    return [encoded, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let glyph of Array.from(glyphs)) {
      res.push(`00${glyph.id.toString(16)}`.slice(-2));
    }
    return res;
  }
  widthOfString(string, size) {
    const glyphs = this.font.glyphsForString(`${string}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    let width = 0;
    for (let advance of Array.from(advances)) {
      width += advance;
    }
    const scale2 = size / 1e3;
    return width * scale2;
  }
  static isStandardFont(name) {
    return name in STANDARD_FONTS;
  }
};
var toHex2 = function() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  const codes2 = Array.from(codePoints).map((code) => `0000${code.toString(16)}`.slice(-4));
  return codes2.join("");
};
var createEmbeddedFont = (PDFFont2) => class EmbeddedFont extends PDFFont2 {
  constructor(document2, font, id) {
    super();
    this.document = document2;
    this.font = font;
    this.id = id;
    this.subset = this.font.createSubset();
    this.unicode = [[0]];
    this.widths = [this.font.getGlyph(0).advanceWidth];
    this.name = this.font.postscriptName;
    this.scale = 1e3 / this.font.unitsPerEm;
    this.ascender = this.font.ascent * this.scale;
    this.descender = this.font.descent * this.scale;
    this.xHeight = this.font.xHeight * this.scale;
    this.capHeight = this.font.capHeight * this.scale;
    this.lineGap = this.font.lineGap * this.scale;
    this.bbox = this.font.bbox;
    this.layoutCache = /* @__PURE__ */ Object.create(null);
  }
  layoutRun(text, features) {
    const run = this.font.layout(text, features, void 0, void 0, "ltr");
    for (let i4 = 0; i4 < run.positions.length; i4++) {
      const position = run.positions[i4];
      for (let key in position) {
        position[key] *= this.scale;
      }
      position.advanceWidth = run.glyphs[i4].advanceWidth * this.scale;
    }
    return run;
  }
  layoutCached(text) {
    let cached;
    if (cached = this.layoutCache[text]) {
      return cached;
    }
    const run = this.layoutRun(text);
    this.layoutCache[text] = run;
    return run;
  }
  layout(text, features, onlyWidth) {
    if (onlyWidth == null) {
      onlyWidth = false;
    }
    if (features) {
      return this.layoutRun(text, features);
    }
    const glyphs = onlyWidth ? null : [];
    const positions = onlyWidth ? null : [];
    let advanceWidth2 = 0;
    let last2 = 0;
    let index2 = 0;
    while (index2 <= text.length) {
      let needle;
      if (index2 === text.length && last2 < index2 || (needle = text.charAt(index2), [" ", "	"].includes(needle))) {
        const run = this.layoutCached(text.slice(last2, ++index2));
        if (!onlyWidth) {
          glyphs.push(...Array.from(run.glyphs || []));
          positions.push(...Array.from(run.positions || []));
        }
        advanceWidth2 += run.advanceWidth;
        last2 = index2;
      } else {
        index2++;
      }
    }
    return {
      glyphs,
      positions,
      advanceWidth: advanceWidth2
    };
  }
  encode(text, features) {
    const {
      glyphs,
      positions
    } = this.layout(text, features);
    const res = [];
    for (let i4 = 0; i4 < glyphs.length; i4++) {
      const glyph = glyphs[i4];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return [res, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let i4 = 0; i4 < glyphs.length; i4++) {
      const glyph = glyphs[i4];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return res;
  }
  widthOfString(string, size, features) {
    const width = this.layout(string, features, true).advanceWidth;
    const scale2 = size / 1e3;
    return width * scale2;
  }
  embed() {
    const isCFF = this.subset.cff != null;
    const fontFile = this.document.ref();
    if (isCFF) {
      fontFile.data.Subtype = "CIDFontType0C";
    }
    fontFile.end(this.subset.encode());
    const familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
    let flags = 0;
    if (this.font.post.isFixedPitch) {
      flags |= 1 << 0;
    }
    if (1 <= familyClass && familyClass <= 7) {
      flags |= 1 << 1;
    }
    flags |= 1 << 2;
    if (familyClass === 10) {
      flags |= 1 << 3;
    }
    if (this.font.head.macStyle.italic) {
      flags |= 1 << 6;
    }
    const tag = [0, 1, 2, 3, 4, 5].map(() => String.fromCharCode(Math.random() * 26 + 65)).join("");
    const name = tag + "+" + this.font.postscriptName;
    const {
      bbox
    } = this.font;
    const descriptor = this.document.ref({
      Type: "FontDescriptor",
      FontName: name,
      Flags: flags,
      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
      ItalicAngle: this.font.italicAngle,
      Ascent: this.ascender,
      Descent: this.descender,
      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
      XHeight: (this.font.xHeight || 0) * this.scale,
      StemV: 0
    });
    if (isCFF) {
      descriptor.data.FontFile3 = fontFile;
    } else {
      descriptor.data.FontFile2 = fontFile;
    }
    descriptor.end();
    const descendantFontData = {
      Type: "Font",
      Subtype: "CIDFontType0",
      BaseFont: name,
      CIDSystemInfo: {
        Registry: new String("Adobe"),
        Ordering: new String("Identity"),
        Supplement: 0
      },
      FontDescriptor: descriptor,
      W: [0, this.widths]
    };
    if (!isCFF) {
      descendantFontData.Subtype = "CIDFontType2";
      descendantFontData.CIDToGIDMap = "Identity";
    }
    const descendantFont = this.document.ref(descendantFontData);
    descendantFont.end();
    this.dictionary.data = {
      Type: "Font",
      Subtype: "Type0",
      BaseFont: name,
      Encoding: "Identity-H",
      DescendantFonts: [descendantFont],
      ToUnicode: this.toUnicodeCmap()
    };
    return this.dictionary.end();
  }
  // Maps the glyph ids encoded in the PDF back to unicode strings
  // Because of ligature substitutions and the like, there may be one or more
  // unicode characters represented by each glyph.
  toUnicodeCmap() {
    const cmap = this.document.ref();
    let entries = [];
    let unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
    for (let [index2, codePoints] of this.unicode.entries()) {
      const encoded = [];
      if (entries.length >= 100) {
        unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar";
        entries = [];
      }
      for (let value2 of codePoints) {
        if (value2 > 65535) {
          value2 -= 65536;
          encoded.push(toHex2(value2 >>> 10 & 1023 | 55296));
          value2 = 56320 | value2 & 1023;
        }
        encoded.push(toHex2(value2));
      }
      entries.push("<" + toHex2(index2) + "><" + encoded.join(" ") + ">");
    }
    if (entries.length) {
      unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar\n";
    }
    unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    cmap.end(unicodeMap);
    return cmap;
  }
};
var PDFFont = class {
  static open(document2, src, family, id) {
    let font;
    if (typeof src === "string") {
      if (StandardFont.isStandardFont(src)) {
        return new StandardFont(document2, src, id);
      }
      {
        throw new Error(`Can't open ${src} in browser build`);
      }
    } else if (src instanceof Uint8Array) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(src, family);
    } else if (src instanceof ArrayBuffer) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src), family);
    } else if (typeof src === "object") {
      font = src;
    }
    if (font == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font, id);
  }
  encode() {
    throw new Error("Must be implemented by subclasses");
  }
  widthOfString() {
    throw new Error("Must be implemented by subclasses");
  }
  ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  }
  finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  }
  embed() {
    throw new Error("Must be implemented by subclasses");
  }
  lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    const gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  }
};
var StandardFont = createStandardFont(PDFFont);
var EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font(src, family, size) {
    let cacheKey;
    let font;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src === "string" && this._registeredFonts[src]) {
      cacheKey = src;
      ({
        src,
        family
      } = this._registeredFonts[src]);
    } else {
      cacheKey = family || src;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font = this._fontFamilies[cacheKey]) {
      this._font = font;
      return this;
    }
    const id = `F${++this._fontCount}`;
    this._font = PDFFont.open(this, src, family, id);
    if (font = this._fontFamilies[this._font.name]) {
      this._font = font;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont(name, src, family) {
    this._registeredFonts[name] = {
      src,
      family
    };
    return this;
  }
};
function PDFNumber(n5) {
  return Math.fround(n5);
}
var SOFT_HYPHEN = "";
var HYPHEN = "-";
var LineWrapper = class extends EventEmitter2 {
  constructor(document2, options) {
    super();
    this.document = document2;
    this.horizontalScaling = options.horizontalScaling || 100;
    this.indent = (options.indent || 0) * this.horizontalScaling / 100;
    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;
    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;
    this.columns = options.columns || 1;
    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;
    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;
    this.spaceLeft = this.lineWidth;
    this.startX = this.document.x;
    this.startY = this.document.y;
    this.column = 1;
    this.ellipsis = options.ellipsis;
    this.continuedX = 0;
    this.features = options.features;
    if (options.height != null) {
      this.height = options.height;
      this.maxY = PDFNumber(this.startY + options.height);
    } else {
      this.maxY = PDFNumber(this.document.page.maxY());
    }
    this.on("firstLine", (options2) => {
      const indent = this.continuedX || this.indent;
      this.document.x += indent;
      this.lineWidth -= indent;
      if (options2.indentAllLines) {
        return;
      }
      return this.once("line", () => {
        this.document.x -= indent;
        this.lineWidth += indent;
        if (options2.continued && !this.continuedX) {
          this.continuedX = this.indent;
        }
        if (!options2.continued) {
          return this.continuedX = 0;
        }
      });
    });
    this.on("lastLine", (options2) => {
      const {
        align
      } = options2;
      if (align === "justify") {
        options2.align = "left";
      }
      this.lastLine = true;
      return this.once("line", () => {
        this.document.y += options2.paragraphGap || 0;
        options2.align = align;
        return this.lastLine = false;
      });
    });
  }
  wordWidth(word) {
    return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
  }
  canFit(word, w) {
    if (word[word.length - 1] != SOFT_HYPHEN) {
      return w <= this.spaceLeft;
    }
    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;
  }
  eachWord(text, fn) {
    let bk;
    const breaker = new $557adaaeb0c7885f$exports(text);
    let last2 = null;
    const wordWidths = /* @__PURE__ */ Object.create(null);
    while (bk = breaker.nextBreak()) {
      var shouldContinue;
      let word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
      if (w > this.lineWidth + this.continuedX) {
        let lbk = last2;
        const fbk = {};
        while (word.length) {
          var l2, mightGrow;
          if (w > this.spaceLeft) {
            l2 = Math.ceil(this.spaceLeft / (w / word.length));
            w = this.wordWidth(word.slice(0, l2));
            mightGrow = w <= this.spaceLeft && l2 < word.length;
          } else {
            l2 = word.length;
          }
          let mustShrink = w > this.spaceLeft && l2 > 0;
          while (mustShrink || mightGrow) {
            if (mustShrink) {
              w = this.wordWidth(word.slice(0, --l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
            } else {
              w = this.wordWidth(word.slice(0, ++l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
              mightGrow = w <= this.spaceLeft && l2 < word.length;
            }
          }
          if (l2 === 0 && this.spaceLeft === this.lineWidth) {
            l2 = 1;
          }
          fbk.required = bk.required || l2 < word.length;
          shouldContinue = fn(word.slice(0, l2), w, fbk, lbk);
          lbk = {
            required: false
          };
          word = word.slice(l2);
          w = this.wordWidth(word);
          if (shouldContinue === false) {
            break;
          }
        }
      } else {
        shouldContinue = fn(word, w, bk, last2);
      }
      if (shouldContinue === false) {
        break;
      }
      last2 = bk;
    }
  }
  wrap(text, options) {
    this.horizontalScaling = options.horizontalScaling || 100;
    if (options.indent != null) {
      this.indent = options.indent * this.horizontalScaling / 100;
    }
    if (options.characterSpacing != null) {
      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;
    }
    if (options.wordSpacing != null) {
      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;
    }
    if (options.ellipsis != null) {
      this.ellipsis = options.ellipsis;
    }
    const nextY = this.document.y + this.document.currentLineHeight(true);
    if (this.document.y > this.maxY || nextY > this.maxY) {
      this.nextSection();
    }
    let buffer = "";
    let textWidth = 0;
    let wc = 0;
    let lc = 0;
    let {
      y: y3
    } = this.document;
    const emitLine = () => {
      options.textWidth = textWidth + this.wordSpacing * (wc - 1);
      options.wordCount = wc;
      options.lineWidth = this.lineWidth;
      ({
        y: y3
      } = this.document);
      this.emit("line", buffer, options, this);
      return lc++;
    };
    this.emit("sectionStart", options, this);
    this.eachWord(text, (word, w, bk, last2) => {
      if (last2 == null || last2.required) {
        this.emit("firstLine", options, this);
        this.spaceLeft = this.lineWidth;
      }
      if (this.canFit(word, w)) {
        buffer += word;
        textWidth += w;
        wc++;
      }
      if (bk.required || !this.canFit(word, w)) {
        const lh = this.document.currentLineHeight(true);
        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {
          if (this.ellipsis === true) {
            this.ellipsis = "";
          }
          buffer = buffer.replace(/\s+$/, "");
          textWidth = this.wordWidth(buffer + this.ellipsis);
          while (buffer && textWidth > this.lineWidth) {
            buffer = buffer.slice(0, -1).replace(/\s+$/, "");
            textWidth = this.wordWidth(buffer + this.ellipsis);
          }
          if (textWidth <= this.lineWidth) {
            buffer = buffer + this.ellipsis;
          }
          textWidth = this.wordWidth(buffer);
        }
        if (bk.required) {
          if (w > this.spaceLeft) {
            emitLine();
            buffer = word;
            textWidth = w;
            wc = 1;
          }
          this.emit("lastLine", options, this);
        }
        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {
          buffer = buffer.slice(0, -1) + HYPHEN;
          this.spaceLeft -= this.wordWidth(HYPHEN);
        }
        emitLine();
        if (PDFNumber(this.document.y + lh) > this.maxY) {
          const shouldContinue = this.nextSection();
          if (!shouldContinue) {
            wc = 0;
            buffer = "";
            return false;
          }
        }
        if (bk.required) {
          this.spaceLeft = this.lineWidth;
          buffer = "";
          textWidth = 0;
          return wc = 0;
        } else {
          this.spaceLeft = this.lineWidth - w;
          buffer = word;
          textWidth = w;
          return wc = 1;
        }
      } else {
        return this.spaceLeft -= w;
      }
    });
    if (wc > 0) {
      this.emit("lastLine", options, this);
      emitLine();
    }
    this.emit("sectionEnd", options, this);
    if (options.continued === true) {
      if (lc > 1) {
        this.continuedX = 0;
      }
      this.continuedX += options.textWidth || 0;
      return this.document.y = y3;
    } else {
      return this.document.x = this.startX;
    }
  }
  nextSection(options) {
    this.emit("sectionEnd", options, this);
    if (++this.column > this.columns) {
      if (this.height != null) {
        return false;
      }
      this.document.continueOnNewPage();
      this.column = 1;
      this.startY = this.document.page.margins.top;
      this.maxY = this.document.page.maxY();
      this.document.x = this.startX;
      if (this.document._fillColor) {
        this.document.fillColor(...this.document._fillColor);
      }
      this.emit("pageBreak", options, this);
    } else {
      this.document.x += this.lineWidth + this.columnGap;
      this.document.y = this.startY;
      this.emit("columnBreak", options, this);
    }
    this.emit("sectionStart", options, this);
    return true;
  }
};
var {
  number
} = PDFObject;
var TextMixin = {
  initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  lineGap(_lineGap) {
    this._lineGap = _lineGap;
    return this;
  },
  moveDown(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y += this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  moveUp(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y -= this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  _text(text, x, y3, options, lineCallback) {
    options = this._initOptions(x, y3, options);
    text = text == null ? "" : `${text}`;
    if (options.wordSpacing) {
      text = text.replace(/\s{2,}/g, " ");
    }
    const addStructure = () => {
      if (options.structParent) {
        options.structParent.add(this.struct(options.structType || "P", [this.markStructureContent(options.structType || "P")]));
      }
    };
    if (options.rotation !== 0) {
      this.save();
      this.rotate(-options.rotation, {
        origin: [this.x, this.y]
      });
    }
    if (options.width) {
      let wrapper = this._wrapper;
      if (!wrapper) {
        wrapper = new LineWrapper(this, options);
        wrapper.on("line", lineCallback);
        wrapper.on("firstLine", addStructure);
      }
      this._wrapper = options.continued ? wrapper : null;
      this._textOptions = options.continued ? options : null;
      wrapper.wrap(text, options);
    } else {
      for (let line2 of text.split("\n")) {
        addStructure();
        lineCallback(line2, options);
      }
    }
    if (options.rotation !== 0) this.restore();
    return this;
  },
  text(text, x, y3, options) {
    return this._text(text, x, y3, options, this._line);
  },
  widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    const horizontalScaling = options.horizontalScaling || 100;
    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;
  },
  /**
   * Compute the bounding box of a string
   * based on what will actually be rendered by `doc.text()`
   *
   * @param string - The string
   * @param x - X position of text (defaults to this.x)
   * @param y - Y position of text (defaults to this.y)
   * @param options - Any text options (The same you would apply to `doc.text()`)
   * @returns {{x: number, y: number, width: number, height: number}}
   */
  boundsOfString(string, x, y3, options) {
  },
  heightOfString(text, options) {
    const {
      x,
      y: y3
    } = this;
    options = this._initOptions(options);
    options.height = Infinity;
    const lineGap2 = options.lineGap || this._lineGap || 0;
    this._text(text, this.x, this.y, options, () => {
      return this.y += this.currentLineHeight(true) + lineGap2;
    });
    const height2 = this.y - y3;
    this.x = x;
    this.y = y3;
    return height2;
  },
  list(list, x, y3, options, wrapper) {
    options = this._initOptions(x, y3, options);
    const listType = options.listType || "bullet";
    const unit = Math.round(this._font.ascender / 1e3 * this._fontSize);
    const midLine = unit / 2;
    const r5 = options.bulletRadius || unit / 3;
    const indent = options.textIndent || (listType === "bullet" ? r5 * 5 : unit * 2);
    const itemIndent = options.bulletIndent || (listType === "bullet" ? r5 * 8 : unit * 2);
    let level = 1;
    const items = [];
    const levels = [];
    const numbers = [];
    var flatten3 = function(list2) {
      let n5 = 1;
      for (let i4 = 0; i4 < list2.length; i4++) {
        const item = list2[i4];
        if (Array.isArray(item)) {
          level++;
          flatten3(item);
          level--;
        } else {
          items.push(item);
          levels.push(level);
          if (listType !== "bullet") {
            numbers.push(n5++);
          }
        }
      }
    };
    flatten3(list);
    const label = function(n5) {
      switch (listType) {
        case "numbered":
          return `${n5}.`;
        case "lettered":
          var letter = String.fromCharCode((n5 - 1) % 26 + 65);
          var times = Math.floor((n5 - 1) / 26 + 1);
          var text = Array(times + 1).join(letter);
          return `${text}.`;
      }
    };
    const drawListItem = function(listItem, i4) {
      wrapper = new LineWrapper(this, options);
      wrapper.on("line", this._line);
      level = 1;
      wrapper.once("firstLine", () => {
        let item, itemType, labelType, bodyType;
        if (options.structParent) {
          if (options.structTypes) {
            [itemType, labelType, bodyType] = options.structTypes;
          } else {
            [itemType, labelType, bodyType] = ["LI", "Lbl", "LBody"];
          }
        }
        if (itemType) {
          item = this.struct(itemType);
          options.structParent.add(item);
        } else if (options.structParent) {
          item = options.structParent;
        }
        let l2;
        if ((l2 = levels[i4++]) !== level) {
          const diff = itemIndent * (l2 - level);
          this.x += diff;
          wrapper.lineWidth -= diff;
          level = l2;
        }
        if (item && (labelType || bodyType)) {
          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));
        }
        switch (listType) {
          case "bullet":
            this.circle(this.x - indent + r5, this.y + midLine, r5);
            this.fill();
            break;
          case "numbered":
          case "lettered":
            var text = label(numbers[i4 - 1]);
            this._fragment(text, this.x - indent, this.y, options);
            break;
        }
        if (item && labelType && bodyType) {
          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));
        }
        if (item && item !== options.structParent) {
          item.end();
        }
      });
      wrapper.on("sectionStart", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x += pos;
        return wrapper.lineWidth -= pos;
      });
      wrapper.on("sectionEnd", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x -= pos;
        return wrapper.lineWidth += pos;
      });
      wrapper.wrap(listItem, options);
    };
    for (let i4 = 0; i4 < items.length; i4++) {
      drawListItem.call(this, items[i4], i4);
    }
    return this;
  },
  _initOptions(x, y3, options) {
    var _options$rotation;
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const result = Object.assign({}, options);
    if (this._textOptions) {
      for (let key in this._textOptions) {
        const val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y3 != null) {
      this.y = y3;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    result.rotation = Number((_options$rotation = options.rotation) !== null && _options$rotation !== void 0 ? _options$rotation : 0) % 360;
    if (result.rotation < 0) result.rotation += 360;
    return result;
  },
  _line(text, options, wrapper) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text, this.x, this.y, options);
    const lineGap2 = options.lineGap || this._lineGap || 0;
    if (!wrapper) {
      return this.x += this.widthOfString(text, options);
    } else {
      return this.y += this.currentLineHeight(true) + lineGap2;
    }
  },
  _fragment(text, x, y3, options) {
    let dy, encoded, i4, positions, textWidth, words;
    text = `${text}`.replace(/\n/g, "");
    if (text.length === 0) {
      return;
    }
    const align = options.align || "left";
    let wordSpacing = options.wordSpacing || 0;
    const characterSpacing = options.characterSpacing || 0;
    const horizontalScaling = options.horizontalScaling || 100;
    if (options.width) {
      switch (align) {
        case "right":
          textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
          x += options.lineWidth - textWidth;
          break;
        case "center":
          x += options.lineWidth / 2 - options.textWidth / 2;
          break;
        case "justify":
          words = text.trim().split(/\s+/);
          textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
          var spaceWidth = this.widthOfString(" ") + characterSpacing;
          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
          break;
      }
    }
    if (typeof options.baseline === "number") {
      dy = -options.baseline;
    } else {
      switch (options.baseline) {
        case "svg-middle":
          dy = 0.5 * this._font.xHeight;
          break;
        case "middle":
        case "svg-central":
          dy = 0.5 * (this._font.descender + this._font.ascender);
          break;
        case "bottom":
        case "ideographic":
          dy = this._font.descender;
          break;
        case "alphabetic":
          dy = 0;
          break;
        case "mathematical":
          dy = 0.5 * this._font.ascender;
          break;
        case "hanging":
          dy = 0.8 * this._font.ascender;
          break;
        case "top":
          dy = this._font.ascender;
          break;
        default:
          dy = this._font.ascender;
      }
      dy = dy / 1e3 * this._fontSize;
    }
    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
    if (options.link != null) {
      this.link(x, y3, renderedWidth, this.currentLineHeight(), options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y3, renderedWidth, this.currentLineHeight(), options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y3, null);
    }
    if (options.underline) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y3 + this.currentLineHeight() - lineWidth;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    if (options.strike) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y3 + this.currentLineHeight() / 2;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    this.save();
    if (options.oblique) {
      let skew;
      if (typeof options.oblique === "number") {
        skew = -Math.tan(options.oblique * Math.PI / 180);
      } else {
        skew = -0.25;
      }
      this.transform(1, 0, 0, 1, x, y3);
      this.transform(1, 0, skew, 1, -skew * dy, 0);
      this.transform(1, 0, 0, 1, -x, -y3);
    }
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y3 = this.page.height - y3 - dy;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent(`1 0 0 1 ${number(x)} ${number(y3)} Tm`);
    this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);
    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(`${mode} Tr`);
    }
    if (characterSpacing) {
      this.addContent(`${number(characterSpacing)} Tc`);
    }
    if (horizontalScaling !== 100) {
      this.addContent(`${horizontalScaling} Tz`);
    }
    if (wordSpacing) {
      words = text.trim().split(/\s+/);
      wordSpacing += this.widthOfString(" ") + characterSpacing;
      wordSpacing *= 1e3 / this._fontSize;
      encoded = [];
      positions = [];
      for (let word of words) {
        const [encodedWord, positionsWord] = this._font.encode(word, options.features);
        encoded = encoded.concat(encodedWord);
        positions = positions.concat(positionsWord);
        const space = {};
        const object = positions[positions.length - 1];
        for (let key in object) {
          const val = object[key];
          space[key] = val;
        }
        space.xAdvance += wordSpacing;
        positions[positions.length - 1] = space;
      }
    } else {
      [encoded, positions] = this._font.encode(text, options.features);
    }
    const scale2 = this._fontSize / 1e3;
    const commands = [];
    let last2 = 0;
    let hadOffset = false;
    const addSegment = (cur) => {
      if (last2 < cur) {
        const hex = encoded.slice(last2, cur).join("");
        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push(`<${hex}> ${number(-advance)}`);
      }
      return last2 = cur;
    };
    const flush = (i5) => {
      addSegment(i5);
      if (commands.length > 0) {
        this.addContent(`[${commands.join(" ")}] TJ`);
        return commands.length = 0;
      }
    };
    for (i4 = 0; i4 < positions.length; i4++) {
      const pos = positions[i4];
      if (pos.xOffset || pos.yOffset) {
        flush(i4);
        this.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale2)} ${number(y3 + pos.yOffset * scale2)} Tm`);
        flush(i4 + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent(`1 0 0 1 ${number(x)} ${number(y3)} Tm`);
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i4 + 1);
        }
      }
      x += pos.xAdvance * scale2;
    }
    flush(i4);
    this.addContent("ET");
    return this.restore();
  }
};
var COLOR_SPACE_MAP = {
  1: "DeviceGray",
  3: "DeviceRGB",
  4: "DeviceCMYK"
};
var JPEG2 = class {
  constructor(data2, label) {
    this.data = data2;
    this.label = label;
    this.orientation = 1;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    const markers = src_default.decode(this.data);
    for (let i4 = 0; i4 < markers.length; i4 += 1) {
      const marker = markers[i4];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        this.orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.bits || (this.bits = marker.precision);
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
        this.colorSpace || (this.colorSpace = COLOR_SPACE_MAP[marker.numberOfComponents]);
      }
    }
    this.obj = null;
  }
  embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    return this.data = null;
  }
};
var PNGImage = class {
  constructor(data2, label) {
    this.label = label;
    this.image = new PNG(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  embed(document2) {
    let dataDecoded = false;
    this.document = document2;
    if (this.obj) {
      return;
    }
    const hasAlphaChannel = this.image.hasAlphaChannel;
    const isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      const params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data.DecodeParms = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data.ColorSpace = this.image.colorSpace;
    } else {
      const palette = this.document.ref();
      palette.end(Buffer$2.from(this.image.palette));
      this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      const val = this.image.transparency.grayscale;
      this.obj.data.Mask = [val, val];
    } else if (this.image.transparency.rgb) {
      const {
        rgb
      } = this.image.transparency;
      const mask = [];
      for (let x of rgb) {
        mask.push(x, x);
      }
      this.obj.data.Mask = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  }
  finalize() {
    if (this.alphaChannel) {
      const sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data.SMask = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    return this.imgData = null;
  }
  splitAlphaChannel() {
    return this.image.decodePixels((pixels) => {
      let a4;
      let p3;
      const colorCount = this.image.colors;
      const pixelCount = this.width * this.height;
      const imgData = Buffer$2.alloc(pixelCount * colorCount);
      const alphaChannel = Buffer$2.alloc(pixelCount);
      let i4 = p3 = a4 = 0;
      const len = pixels.length;
      const skipByteCount = this.image.bits === 16 ? 1 : 0;
      while (i4 < len) {
        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p3++] = pixels[i4++];
          i4 += skipByteCount;
        }
        alphaChannel[a4++] = pixels[i4++];
        i4 += skipByteCount;
      }
      this.imgData = zlib2.deflateSync(imgData);
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  loadIndexedAlphaChannel() {
    const transparency = this.image.transparency.indexed;
    return this.image.decodePixels((pixels) => {
      const alphaChannel = Buffer$2.alloc(this.width * this.height);
      let i4 = 0;
      for (let j = 0, end2 = pixels.length; j < end2; j++) {
        alphaChannel[i4++] = transparency[pixels[j]];
      }
      this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  decodeData() {
    this.image.decodePixels((pixels) => {
      this.imgData = zlib2.deflateSync(pixels);
      this.finalize();
    });
  }
};
var PDFImage = class {
  static open(src, label) {
    let data2;
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match;
      if (match = /^data:.+?;base64,(.*)$/.exec(src)) {
        data2 = Buffer$2.from(match[1], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          return;
        }
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG2(data2, label);
    } else if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    } else {
      throw new Error("Unknown image format.");
    }
  }
};
var ImagesMixin = {
  initImages() {
    this._imageRegistry = {};
    return this._imageCount = 0;
  },
  image(src, x, y3, options) {
    if (options === void 0) {
      options = {};
    }
    let bh, bp, bw, image, ip, left, left1, rotateAngle, originX, originY;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y3 = (left1 = y3 != null ? y3 : options.y) != null ? left1 : this.y;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      if (src.width && src.height) {
        image = src;
      } else {
        image = this.openImage(src);
      }
    }
    if (!image.obj) {
      image.embed(this);
    }
    if (this.page.xobjects[image.label] == null) {
      this.page.xobjects[image.label] = image.obj;
    }
    let {
      width,
      height: height2
    } = image;
    if (!ignoreOrientation && image.orientation > 4) {
      [width, height2] = [height2, width];
    }
    let w = options.width || width;
    let h3 = options.height || height2;
    if (options.width && !options.height) {
      const wp = w / width;
      w = width * wp;
      h3 = height2 * wp;
    } else if (options.height && !options.width) {
      const hp = h3 / height2;
      w = width * hp;
      h3 = height2 * hp;
    } else if (options.scale) {
      w = width * options.scale;
      h3 = height2 * options.scale;
    } else if (options.fit) {
      [bw, bh] = options.fit;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        w = bw;
        h3 = bw / ip;
      } else {
        h3 = bh;
        w = bh * ip;
      }
    } else if (options.cover) {
      [bw, bh] = options.cover;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        h3 = bh;
        w = bh * ip;
      } else {
        w = bw;
        h3 = bw / ip;
      }
    }
    if (options.fit || options.cover) {
      if (options.align === "center") {
        x = x + bw / 2 - w / 2;
      } else if (options.align === "right") {
        x = x + bw - w;
      }
      if (options.valign === "center") {
        y3 = y3 + bh / 2 - h3 / 2;
      } else if (options.valign === "bottom") {
        y3 = y3 + bh - h3;
      }
    }
    if (!ignoreOrientation) {
      switch (image.orientation) {
        default:
        case 1:
          h3 = -h3;
          y3 -= h3;
          rotateAngle = 0;
          break;
        case 2:
          w = -w;
          h3 = -h3;
          x -= w;
          y3 -= h3;
          rotateAngle = 0;
          break;
        case 3:
          originX = x;
          originY = y3;
          h3 = -h3;
          x -= w;
          rotateAngle = 180;
          break;
        case 4:
          break;
        case 5:
          originX = x;
          originY = y3;
          [w, h3] = [h3, w];
          y3 -= h3;
          rotateAngle = 90;
          break;
        case 6:
          originX = x;
          originY = y3;
          [w, h3] = [h3, w];
          h3 = -h3;
          rotateAngle = 90;
          break;
        case 7:
          originX = x;
          originY = y3;
          [w, h3] = [h3, w];
          h3 = -h3;
          w = -w;
          x -= w;
          rotateAngle = 90;
          break;
        case 8:
          originX = x;
          originY = y3;
          [w, h3] = [h3, w];
          h3 = -h3;
          x -= w;
          y3 -= h3;
          rotateAngle = -90;
          break;
      }
    } else {
      h3 = -h3;
      y3 -= h3;
      rotateAngle = 0;
    }
    if (options.link != null) {
      this.link(x, y3, w, h3, options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y3, w, h3, options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y3, null);
    }
    if (this.y === y3) {
      this.y += h3;
    }
    this.save();
    if (rotateAngle) {
      this.rotate(rotateAngle, {
        origin: [originX, originY]
      });
    }
    this.transform(w, 0, 0, h3, x, y3);
    this.addContent(`/${image.label} Do`);
    this.restore();
    return this;
  },
  openImage(src) {
    let image;
    if (typeof src === "string") {
      image = this._imageRegistry[src];
    }
    if (!image) {
      image = PDFImage.open(src, `I${++this._imageCount}`);
      if (typeof src === "string") {
        this._imageRegistry[src] = image;
      }
    }
    return image;
  }
};
var AnnotationsMixin = {
  annotate(x, y3, w, h3, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y3, w, h3);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (let key in options) {
      const val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    const ref = this.ref(options);
    this.page.annotations.push(ref);
    ref.end();
    return this;
  },
  note(x, y3, w, h3, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    if (options.Name == null) {
      options.Name = "Comment";
    }
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    return this.annotate(x, y3, w, h3, options);
  },
  goTo(x, y3, w, h3, name, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name)
    });
    options.A.end();
    return this.annotate(x, y3, w, h3, options);
  },
  link(x, y3, w, h3, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      const pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error(`The document has no page ${url}`);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y3, w, h3, options);
  },
  _markup(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    const [x1, y1, x2, y22] = this._convertRect(x, y3, w, h3);
    options.QuadPoints = [x1, y22, x2, y22, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y3, w, h3, options);
  },
  highlight(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y3, w, h3, options);
  },
  underline(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Underline";
    return this._markup(x, y3, w, h3, options);
  },
  strike(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "StrikeOut";
    return this._markup(x, y3, w, h3, options);
  },
  lineAnnotation(x1, y1, x2, y22, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Line";
    options.Contents = new String();
    options.L = [x1, this.page.height - y1, x2, this.page.height - y22];
    return this.annotate(x1, y1, x2, y22, options);
  },
  rectAnnotation(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Square";
    options.Contents = new String();
    return this.annotate(x, y3, w, h3, options);
  },
  ellipseAnnotation(x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Circle";
    options.Contents = new String();
    return this.annotate(x, y3, w, h3, options);
  },
  textAnnotation(x, y3, w, h3, text, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "FreeText";
    options.Contents = new String(text);
    options.DA = new String();
    return this.annotate(x, y3, w, h3, options);
  },
  fileAnnotation(x, y3, w, h3, file, options) {
    if (file === void 0) {
      file = {};
    }
    if (options === void 0) {
      options = {};
    }
    const filespec = this.file(file.src, Object.assign({
      hidden: true
    }, file));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y3, w, h3, options);
  },
  _convertRect(x1, y1, w, h3) {
    let y22 = y1;
    y1 += h3;
    let x2 = x1 + w;
    const [m0, m1, m2, m3, m4, m5] = this._ctm;
    x1 = m0 * x1 + m2 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m2 * y22 + m4;
    y22 = m1 * x2 + m3 * y22 + m5;
    return [x1, y1, x2, y22];
  }
};
var DEFAULT_OPTIONS = {
  top: 0,
  left: 0,
  zoom: 0,
  fit: false,
  pageNumber: null,
  expanded: false
};
var PDFOutline = class _PDFOutline {
  constructor(document2, parent, title3, dest, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      const destWidth = dest.data.MediaBox[2];
      const destHeight = dest.data.MediaBox[3];
      const top = destHeight - (options.top || 0);
      const left = destWidth - (options.left || 0);
      const zoom = options.zoom || 0;
      this.outlineData["Dest"] = options.fit ? [dest, "Fit"] : [dest, "XYZ", left, top, zoom];
    }
    if (parent !== null) {
      this.outlineData["Parent"] = parent;
    }
    if (title3 !== null) {
      this.outlineData["Title"] = new String(title3);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  addItem(title3, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    const pages = this.document._root.data.Pages.data.Kids;
    const dest = options.pageNumber !== null ? pages[options.pageNumber] : this.document.page.dictionary;
    const result = new _PDFOutline(this.document, this.dictionary, title3, dest, options);
    this.children.push(result);
    return result;
  }
  endOutline() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      const first = this.children[0], last2 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last2.dictionary;
      for (let i4 = 0, len = this.children.length; i4 < len; i4++) {
        const child = this.children[i4];
        if (i4 > 0) {
          child.outlineData.Prev = this.children[i4 - 1].dictionary;
        }
        if (i4 < this.children.length - 1) {
          child.outlineData.Next = this.children[i4 + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  }
};
var OutlineMixin = {
  initOutline() {
    return this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      return this._root.data.PageMode = this._root.data.PageMode || "UseOutlines";
    }
  }
};
var PDFStructureContent = class {
  constructor(pageRef, mcid) {
    this.refs = [{
      pageRef,
      mcid
    }];
  }
  push(structContent) {
    structContent.refs.forEach((ref) => this.refs.push(ref));
  }
};
var PDFStructureElement = class _PDFStructureElement {
  constructor(document2, type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    this.document = document2;
    this._attached = false;
    this._ended = false;
    this._flushed = false;
    this.dictionary = document2.ref({
      // Type: "StructElem",
      S: type
    });
    const data2 = this.dictionary.data;
    if (Array.isArray(options) || this._isValidChild(options)) {
      children = options;
      options = {};
    }
    if (typeof options.title !== "undefined") {
      data2.T = new String(options.title);
    }
    if (typeof options.lang !== "undefined") {
      data2.Lang = new String(options.lang);
    }
    if (typeof options.alt !== "undefined") {
      data2.Alt = new String(options.alt);
    }
    if (typeof options.expanded !== "undefined") {
      data2.E = new String(options.expanded);
    }
    if (typeof options.actual !== "undefined") {
      data2.ActualText = new String(options.actual);
    }
    this._children = [];
    if (children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach((child) => this.add(child));
      this.end();
    }
  }
  add(child) {
    if (this._ended) {
      throw new Error(`Cannot add child to already-ended structure element`);
    }
    if (!this._isValidChild(child)) {
      throw new Error(`Invalid structure element child`);
    }
    if (child instanceof _PDFStructureElement) {
      child.setParent(this.dictionary);
      if (this._attached) {
        child.setAttached();
      }
    }
    if (child instanceof PDFStructureContent) {
      this._addContentToParentTree(child);
    }
    if (typeof child === "function" && this._attached) {
      child = this._contentForClosure(child);
    }
    this._children.push(child);
    return this;
  }
  _addContentToParentTree(content) {
    content.refs.forEach((_ref) => {
      let {
        pageRef,
        mcid
      } = _ref;
      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);
      pageStructParents[mcid] = this.dictionary;
    });
  }
  setParent(parentRef) {
    if (this.dictionary.data.P) {
      throw new Error(`Structure element added to more than one parent`);
    }
    this.dictionary.data.P = parentRef;
    this._flush();
  }
  setAttached() {
    if (this._attached) {
      return;
    }
    this._children.forEach((child, index2) => {
      if (child instanceof _PDFStructureElement) {
        child.setAttached();
      }
      if (typeof child === "function") {
        this._children[index2] = this._contentForClosure(child);
      }
    });
    this._attached = true;
    this._flush();
  }
  end() {
    if (this._ended) {
      return;
    }
    this._children.filter((child) => child instanceof _PDFStructureElement).forEach((child) => child.end());
    this._ended = true;
    this._flush();
  }
  _isValidChild(child) {
    return child instanceof _PDFStructureElement || child instanceof PDFStructureContent || typeof child === "function";
  }
  _contentForClosure(closure) {
    const content = this.document.markStructureContent(this.dictionary.data.S);
    closure();
    this.document.endMarkedContent();
    this._addContentToParentTree(content);
    return content;
  }
  _isFlushable() {
    if (!this.dictionary.data.P || !this._ended) {
      return false;
    }
    return this._children.every((child) => {
      if (typeof child === "function") {
        return false;
      }
      if (child instanceof _PDFStructureElement) {
        return child._isFlushable();
      }
      return true;
    });
  }
  _flush() {
    if (this._flushed || !this._isFlushable()) {
      return;
    }
    this.dictionary.data.K = [];
    this._children.forEach((child) => this._flushChild(child));
    this.dictionary.end();
    this._children = [];
    this.dictionary.data.K = null;
    this._flushed = true;
  }
  _flushChild(child) {
    if (child instanceof _PDFStructureElement) {
      this.dictionary.data.K.push(child.dictionary);
    }
    if (child instanceof PDFStructureContent) {
      child.refs.forEach((_ref2) => {
        let {
          pageRef,
          mcid
        } = _ref2;
        if (!this.dictionary.data.Pg) {
          this.dictionary.data.Pg = pageRef;
        }
        if (this.dictionary.data.Pg === pageRef) {
          this.dictionary.data.K.push(mcid);
        } else {
          this.dictionary.data.K.push({
            Type: "MCR",
            Pg: pageRef,
            MCID: mcid
          });
        }
      });
    }
  }
};
var PDFNumberTree = class extends PDFTree {
  _compareKeys(a4, b3) {
    return parseInt(a4) - parseInt(b3);
  }
  _keysName() {
    return "Nums";
  }
  _dataForKey(k3) {
    return parseInt(k3);
  }
};
var MarkingsMixin = {
  initMarkings(options) {
    this.structChildren = [];
    if (options.tagged) {
      this.getMarkInfoDictionary().data.Marked = true;
      this.getStructTreeRoot();
    }
  },
  markContent(tag, options) {
    if (options === void 0) {
      options = null;
    }
    if (tag === "Artifact" || options && options.mcid) {
      let toClose = 0;
      this.page.markings.forEach((marking) => {
        if (toClose || marking.structContent || marking.tag === "Artifact") {
          toClose++;
        }
      });
      while (toClose--) {
        this.endMarkedContent();
      }
    }
    if (!options) {
      this.page.markings.push({
        tag
      });
      this.addContent(`/${tag} BMC`);
      return this;
    }
    this.page.markings.push({
      tag,
      options
    });
    const dictionary = {};
    if (typeof options.mcid !== "undefined") {
      dictionary.MCID = options.mcid;
    }
    if (tag === "Artifact") {
      if (typeof options.type === "string") {
        dictionary.Type = options.type;
      }
      if (Array.isArray(options.bbox)) {
        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
      }
      if (Array.isArray(options.attached) && options.attached.every((val) => typeof val === "string")) {
        dictionary.Attached = options.attached;
      }
    }
    if (tag === "Span") {
      if (options.lang) {
        dictionary.Lang = new String(options.lang);
      }
      if (options.alt) {
        dictionary.Alt = new String(options.alt);
      }
      if (options.expanded) {
        dictionary.E = new String(options.expanded);
      }
      if (options.actual) {
        dictionary.ActualText = new String(options.actual);
      }
    }
    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);
    return this;
  },
  markStructureContent(tag, options) {
    if (options === void 0) {
      options = {};
    }
    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
    const mcid = pageStructParents.length;
    pageStructParents.push(null);
    this.markContent(tag, {
      ...options,
      mcid
    });
    const structContent = new PDFStructureContent(this.page.dictionary, mcid);
    this.page.markings.slice(-1)[0].structContent = structContent;
    return structContent;
  },
  endMarkedContent() {
    this.page.markings.pop();
    this.addContent("EMC");
    return this;
  },
  struct(type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    return new PDFStructureElement(this, type, options, children);
  },
  addStructure(structElem) {
    const structTreeRoot = this.getStructTreeRoot();
    structElem.setParent(structTreeRoot);
    structElem.setAttached();
    this.structChildren.push(structElem);
    if (!structTreeRoot.data.K) {
      structTreeRoot.data.K = [];
    }
    structTreeRoot.data.K.push(structElem.dictionary);
    return this;
  },
  initPageMarkings(pageMarkings) {
    pageMarkings.forEach((marking) => {
      if (marking.structContent) {
        const structContent = marking.structContent;
        const newStructContent = this.markStructureContent(marking.tag, marking.options);
        structContent.push(newStructContent);
        this.page.markings.slice(-1)[0].structContent = structContent;
      } else {
        this.markContent(marking.tag, marking.options);
      }
    });
  },
  endPageMarkings(page) {
    const pageMarkings = page.markings;
    pageMarkings.forEach(() => page.write("EMC"));
    page.markings = [];
    return pageMarkings;
  },
  getMarkInfoDictionary() {
    if (!this._root.data.MarkInfo) {
      this._root.data.MarkInfo = this.ref({});
    }
    return this._root.data.MarkInfo;
  },
  hasMarkInfoDictionary() {
    return !!this._root.data.MarkInfo;
  },
  getStructTreeRoot() {
    if (!this._root.data.StructTreeRoot) {
      this._root.data.StructTreeRoot = this.ref({
        Type: "StructTreeRoot",
        ParentTree: new PDFNumberTree(),
        ParentTreeNextKey: 0
      });
    }
    return this._root.data.StructTreeRoot;
  },
  getStructParentTree() {
    return this.getStructTreeRoot().data.ParentTree;
  },
  createStructParentTreeNextKey() {
    this.getMarkInfoDictionary();
    const structTreeRoot = this.getStructTreeRoot();
    const key = structTreeRoot.data.ParentTreeNextKey++;
    structTreeRoot.data.ParentTree.add(key, []);
    return key;
  },
  endMarkings() {
    const structTreeRoot = this._root.data.StructTreeRoot;
    if (structTreeRoot) {
      structTreeRoot.end();
      this.structChildren.forEach((structElem) => structElem.end());
    }
    if (this._root.data.MarkInfo) {
      this._root.data.MarkInfo.end();
    }
  }
};
var FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
var FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
var VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
var FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
var FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    let data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String(`/${this._font.id} 0 Tf 0 g`),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    const AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm() {
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      let fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach((name) => {
        fontDict[name] = this._acroform.fonts[name];
      });
      this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {
        this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild(ref) {
    if (Array.isArray(ref.data.Kids)) {
      ref.data.Kids.forEach((childRef) => {
        this._endChild(childRef);
      });
      ref.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField(name, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, null, options);
    let fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation(name, type, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, type, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y3, w, h3, fieldDict);
    let annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "text", x, y3, w, h3, options);
  },
  formPushButton(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "pushButton", x, y3, w, h3, options);
  },
  formCombo(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "combo", x, y3, w, h3, options);
  },
  formList(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "list", x, y3, w, h3, options);
  },
  formRadioButton(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "radioButton", x, y3, w, h3, options);
  },
  formCheckbox(name, x, y3, w, h3, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "checkbox", x, y3, w, h3, options);
  },
  _addToParent(fieldRef) {
    let parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict(name, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForm() method before adding form elements to document");
    }
    let opts2 = Object.assign({}, options);
    if (type !== null) {
      opts2 = this._resolveType(type, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType(type, opts2) {
    if (type === "text") {
      opts2.FT = "Tx";
    } else if (type === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type === "checkbox") {
      opts2.FT = "Btn";
    } else if (type === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error(`Invalid form annotation type '${type}'`);
    }
    return opts2;
  },
  _resolveFormat(opts2) {
    const f3 = opts2.format;
    if (f3 && f3.type) {
      let fnKeystroke;
      let fnFormat;
      let params = "";
      if (FORMAT_SPECIAL[f3.type] !== void 0) {
        fnKeystroke = `AFSpecial_Keystroke`;
        fnFormat = `AFSpecial_Format`;
        params = FORMAT_SPECIAL[f3.type];
      } else {
        let format3 = f3.type.charAt(0).toUpperCase() + f3.type.slice(1);
        fnKeystroke = `AF${format3}_Keystroke`;
        fnFormat = `AF${format3}_Format`;
        if (f3.type === "date") {
          fnKeystroke += "Ex";
          params = String(f3.param);
        } else if (f3.type === "time") {
          params = String(f3.param);
        } else if (f3.type === "number") {
          let p3 = Object.assign({}, FORMAT_DEFAULT.number, f3);
          params = String([String(p3.nDec), p3.sepComma ? "0" : "1", '"' + p3.negStyle + '"', "null", '"' + p3.currency + '"', String(p3.currencyPrepend)].join(","));
        } else if (f3.type === "percent") {
          let p3 = Object.assign({}, FORMAT_DEFAULT.percent, f3);
          params = String([String(p3.nDec), p3.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(`${fnKeystroke}(${params});`)
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(`${fnFormat}(${params});`)
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors(opts2) {
    let color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags(options) {
    let result = 0;
    Object.keys(options).forEach((key) => {
      if (FIELD_FLAGS[key]) {
        if (options[key]) {
          result |= FIELD_FLAGS[key];
        }
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify(options) {
    let result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] == null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      const fontSize = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);
    }
    return options;
  },
  _resolveStrings(options) {
    let select = [];
    function appendChoices(a4) {
      if (Array.isArray(a4)) {
        for (let idx = 0; idx < a4.length; idx++) {
          if (typeof a4[idx] === "string") {
            select.push(new String(a4[idx]));
          } else {
            select.push(a4[idx]);
          }
        }
      }
    }
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach((key) => {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach((key) => {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.
   * @returns filespec reference
   */
  file(src, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src;
    options.relationship = options.relationship || "Unspecified";
    const refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    let data2;
    if (!src) {
      throw new Error("No src specified");
    }
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      let match;
      if (match = /^data:(.*?);base64,(.*)$/.exec(src)) {
        if (match[1]) {
          refBody.Subtype = match[1].replace("/", "#2F");
        }
        data2 = Buffer$2.from(match[2], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          throw new Error(`Could not read contents of file at filepath ${src}`);
        }
        const {
          birthtime,
          ctime
        } = fs.statSync(src);
        refBody.Params.CreationDate = birthtime;
        refBody.Params.ModDate = ctime;
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    const checksum = import_crypto_js.default.MD5(import_crypto_js.default.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    let ref;
    if (!this._fileRegistry) this._fileRegistry = {};
    let file = this._fileRegistry[options.name];
    if (file && isEqual(refBody, file)) {
      ref = file.ref;
    } else {
      ref = this.ref(refBody);
      ref.end(data2);
      this._fileRegistry[options.name] = {
        ...refBody,
        ref
      };
    }
    const fileSpecBody = {
      Type: "Filespec",
      AFRelationship: options.relationship,
      F: new String(options.name),
      EF: {
        F: ref
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    const filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    if (this._root.data.AF) {
      this._root.data.AF.push(filespec);
    } else {
      this._root.data.AF = [filespec];
    }
    return filespec;
  }
};
function isEqual(a4, b3) {
  return a4.Subtype === b3.Subtype && a4.Params.CheckSum.toString() === b3.Params.CheckSum.toString() && a4.Params.Size === b3.Params.Size && a4.Params.CreationDate.getTime() === b3.Params.CreationDate.getTime() && (a4.Params.ModDate === void 0 && b3.Params.ModDate === void 0 || a4.Params.ModDate.getTime() === b3.Params.ModDate.getTime());
}
var __dirname = "/home/runner/work/react-pdf/react-pdf/packages/pdfkit/src/mixins";
var PDFA = {
  initPDFA(pSubset) {
    if (pSubset.charAt(pSubset.length - 3) === "-") {
      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();
      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));
    } else {
      this.subset_conformance = "B";
      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));
    }
  },
  endSubset() {
    this._addPdfaMetadata();
    this._addColorOutputIntent();
  },
  _addColorOutputIntent() {
    const iccProfile = fs.readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);
    const colorProfileRef = this.ref({
      Length: iccProfile.length,
      N: 3
    });
    colorProfileRef.write(iccProfile);
    colorProfileRef.end();
    const intentRef = this.ref({
      Type: "OutputIntent",
      S: "GTS_PDFA1",
      Info: new String("sRGB IEC61966-2.1"),
      OutputConditionIdentifier: new String("sRGB IEC61966-2.1"),
      DestOutputProfile: colorProfileRef
    });
    intentRef.end();
    this._root.data.OutputIntents = [intentRef];
  },
  _getPdfaid() {
    return `
        <rdf:Description xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/" rdf:about="">
            <pdfaid:part>${this.subset}</pdfaid:part>
            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>
        </rdf:Description>
        `;
  },
  _addPdfaMetadata() {
    this.appendXML(this._getPdfaid());
  }
};
var PDFUA = {
  initPDFUA() {
    this.subset = 1;
  },
  endSubset() {
    this._addPdfuaMetadata();
  },
  _addPdfuaMetadata() {
    this.appendXML(this._getPdfuaid());
  },
  _getPdfuaid() {
    return `
        <rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
            <pdfuaid:part>${this.subset}</pdfuaid:part>
        </rdf:Description>
        `;
  }
};
var SubsetMixin = {
  _importSubset(subset) {
    Object.assign(this, subset);
  },
  initSubset(options) {
    switch (options.subset) {
      case "PDF/A-1":
      case "PDF/A-1a":
      case "PDF/A-1b":
      case "PDF/A-2":
      case "PDF/A-2a":
      case "PDF/A-2b":
      case "PDF/A-3":
      case "PDF/A-3a":
      case "PDF/A-3b":
        this._importSubset(PDFA);
        this.initPDFA(options.subset);
        break;
      case "PDF/UA":
        this._importSubset(PDFUA);
        this.initPDFUA();
        break;
    }
  }
};
var PDFMetadata = class {
  constructor() {
    this._metadata = `
        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta xmlns:x="adobe:ns:meta/">
                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        `;
  }
  _closeTags() {
    this._metadata = this._metadata.concat(`
                </rdf:RDF>
            </x:xmpmeta>
        <?xpacket end="w"?>
        `);
  }
  append(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this._metadata = this._metadata.concat(xml);
    if (newline) this._metadata = this._metadata.concat("\n");
  }
  getXML() {
    return this._metadata;
  }
  getLength() {
    return this._metadata.length;
  }
  end() {
    this._closeTags();
    this._metadata = this._metadata.trim();
  }
};
var MetadataMixin = {
  initMetadata() {
    this.metadata = new PDFMetadata();
  },
  appendXML(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this.metadata.append(xml, newline);
  },
  _addInfo() {
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
            <xmp:CreateDate>${this.info.CreationDate.toISOString().split(".")[0] + "Z"}</xmp:CreateDate>
            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>
        </rdf:Description>
        `);
    if (this.info.Title || this.info.Author || this.info.Subject) {
      this.appendXML(`
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
            `);
      if (this.info.Title) {
        this.appendXML(`
                <dc:title>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Title}</rdf:li>
                    </rdf:Alt>
                </dc:title>
                `);
      }
      if (this.info.Author) {
        this.appendXML(`
                <dc:creator>
                    <rdf:Seq>
                        <rdf:li>${this.info.Author}</rdf:li>
                    </rdf:Seq>
                </dc:creator>
                `);
      }
      if (this.info.Subject) {
        this.appendXML(`
                <dc:description>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Subject}</rdf:li>
                    </rdf:Alt>
                </dc:description>
                `);
      }
      this.appendXML(`
            </rdf:Description>
            `);
    }
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);
    if (this.info.Keywords) {
      this.appendXML(`
            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);
    }
    this.appendXML(`
        </rdf:Description>
        `);
  },
  endMetadata() {
    this._addInfo();
    this.metadata.end();
    if (this.version != 1.3) {
      this.metadataRef = this.ref({
        length: this.metadata.getLength(),
        Type: "Metadata",
        Subtype: "XML"
      });
      this.metadataRef.compress = false;
      this.metadataRef.write(Buffer$2.from(this.metadata.getXML(), "utf-8"));
      this.metadataRef.end();
      this._root.data.Metadata = this.metadataRef;
    }
  }
};
var PDFDocument = class extends stream.Readable {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super(options);
    this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        this.version = 1.4;
        break;
      case "1.5":
        this.version = 1.5;
        break;
      case "1.6":
        this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        this.version = 1.7;
        break;
      default:
        this.version = 1.3;
        break;
    }
    this.compress = this.options.compress != null ? this.options.compress : true;
    this._pageBuffer = [];
    this._pageBufferStart = 0;
    this._offsets = [];
    this._waiting = 0;
    this._ended = false;
    this._offset = 0;
    const Pages = this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    const Names = this.ref({
      Dests: new PDFNameTree()
    });
    this._root = this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (this.options.lang) {
      this._root.data.Lang = new String(this.options.lang);
    }
    this.page = null;
    this.initMetadata();
    this.initColor();
    this.initVector();
    this.initFonts(options.font);
    this.initText();
    this.initImages();
    this.initOutline();
    this.initMarkings(options);
    this.initSubset(options);
    this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (this.options.info) {
      for (let key in this.options.info) {
        const val = this.options.info[key];
        this.info[key] = val;
      }
    }
    if (this.options.displayTitle) {
      this._root.data.ViewerPreferences = this.ref({
        DisplayDocTitle: true
      });
    }
    this._id = PDFSecurity.generateFileID(this.info);
    this._write(`%PDF-${this.version}`);
    this._write("%");
    if (this.options.autoFirstPage !== false) {
      this.addPage();
    }
  }
  addPage(options) {
    if (options == null) {
      ({
        options
      } = this);
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    const pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this.x = this.page.margins.left;
    this.y = this.page.margins.top;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    this.emit("pageAdded");
    return this;
  }
  continueOnNewPage(options) {
    const pageMarkings = this.endPageMarkings(this.page);
    this.addPage(options !== null && options !== void 0 ? options : this.page._options);
    this.initPageMarkings(pageMarkings);
    return this;
  }
  bufferedPageRange() {
    return {
      start: this._pageBufferStart,
      count: this._pageBuffer.length
    };
  }
  switchToPage(n5) {
    let page;
    if (!(page = this._pageBuffer[n5 - this._pageBufferStart])) {
      throw new Error(`switchToPage(${n5}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);
    }
    return this.page = page;
  }
  flushPages() {
    const pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (let page of pages) {
      this.endPageMarkings(page);
      page.end();
    }
  }
  addNamedDestination(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name, args);
  }
  addNamedEmbeddedFile(name, ref) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name, ref);
  }
  addNamedJavaScript(name, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    let data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name, data2);
  }
  ref(data2) {
    const ref = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref;
  }
  _read() {
  }
  // do nothing, but this method is required by node
  _write(data2) {
    if (!Buffer$2.isBuffer(data2)) {
      data2 = Buffer$2.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  }
  addContent(data2) {
    this.page.write(data2);
    return this;
  }
  _refEnd(ref) {
    this._offsets[ref.id - 1] = ref.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  }
  end() {
    this.flushPages();
    this._info = this.ref();
    for (let key in this.info) {
      let val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      let entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (let name in this._fontFamilies) {
      const font = this._fontFamilies[name];
      font.finalize();
    }
    this.endOutline();
    this.endMarkings();
    if (this.subset) {
      this.endSubset();
    }
    this.endMetadata();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._security) {
      this._security.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    } else {
      return this._ended = true;
    }
  }
  _finalize() {
    const xRefOffset = this._offset;
    this._write("xref");
    this._write(`0 ${this._offsets.length + 1}`);
    this._write("0000000000 65535 f ");
    for (let offset2 of this._offsets) {
      offset2 = `0000000000${offset2}`.slice(-10);
      this._write(offset2 + " 00000 n ");
    }
    const trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    if (this._security) {
      trailer.Encrypt = this._security.dictionary;
    }
    this._write("trailer");
    this._write(PDFObject.convert(trailer));
    this._write("startxref");
    this._write(`${xRefOffset}`);
    this._write("%%EOF");
    return this.push(null);
  }
  toString() {
    return "[object PDFDocument]";
  }
};
var mixin = (methods) => {
  Object.assign(PDFDocument.prototype, methods);
};
mixin(MetadataMixin);
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(MarkingsMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);
mixin(SubsetMixin);
PDFDocument.LineWrapper = LineWrapper;

// node_modules/@react-pdf/font/lib/index.browser.js
var STANDARD_FONTS2 = [
  "Courier",
  "Courier-Bold",
  "Courier-Oblique",
  "Courier-BoldOblique",
  "Helvetica",
  "Helvetica-Bold",
  "Helvetica-Oblique",
  "Helvetica-BoldOblique",
  "Times-Roman",
  "Times-Bold",
  "Times-Italic",
  "Times-BoldItalic"
];
var StandardFont2 = class {
  constructor(src) {
    __publicField(this, "name");
    __publicField(this, "src");
    __publicField(this, "fullName");
    __publicField(this, "familyName");
    __publicField(this, "subfamilyName");
    __publicField(this, "postscriptName");
    __publicField(this, "copyright");
    __publicField(this, "version");
    __publicField(this, "underlinePosition");
    __publicField(this, "underlineThickness");
    __publicField(this, "italicAngle");
    __publicField(this, "bbox");
    __publicField(this, "OS/2");
    __publicField(this, "hhea");
    __publicField(this, "numGlyphs");
    __publicField(this, "characterSet");
    __publicField(this, "availableFeatures");
    __publicField(this, "type");
    this.name = src;
    this.fullName = src;
    this.familyName = src;
    this.subfamilyName = src;
    this.type = "STANDARD";
    this.postscriptName = src;
    this.availableFeatures = [];
    this.copyright = "";
    this.version = 1;
    this.underlinePosition = -100;
    this.underlineThickness = 50;
    this.italicAngle = 0;
    this.bbox = {};
    this["OS/2"] = {};
    this.hhea = {};
    this.numGlyphs = 0;
    this.characterSet = [];
    this.src = PDFFont.open(null, src);
  }
  encode(str) {
    return this.src.encode(str);
  }
  layout(str) {
    const [encoded, positions] = this.encode(str);
    const glyphs = encoded.map((g3, i4) => {
      const glyph = this.getGlyph(parseInt(g3, 16));
      glyph.advanceWidth = positions[i4].advanceWidth;
      return glyph;
    });
    const advanceWidth2 = positions.reduce((acc, p3) => acc + p3.advanceWidth, 0);
    return {
      positions,
      stringIndices: positions.map((_, i4) => i4),
      glyphs,
      script: "latin",
      language: "dflt",
      direction: "ltr",
      features: {},
      advanceWidth: advanceWidth2,
      advanceHeight: 0,
      bbox: void 0
    };
  }
  glyphForCodePoint(codePoint) {
    const glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  }
  getGlyph(id) {
    return {
      id,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id),
      _font: this.src,
      // @ts-expect-error assign proper value
      advanceWidth: void 0
    };
  }
  hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  }
  // Based on empirical observation
  get ascent() {
    return 900;
  }
  // Based on empirical observation
  get capHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 650;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 550;
      default:
        return 690;
    }
  }
  // Based on empirical observation
  get xHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 440;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 390;
      default:
        return 490;
    }
  }
  // Based on empirical observation
  get descent() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return -220;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return -230;
      default:
        return -200;
    }
  }
  get lineGap() {
    return 0;
  }
  get unitsPerEm() {
    return 1e3;
  }
  stringsForGlyph() {
    throw new Error("Method not implemented.");
  }
  glyphsForString() {
    throw new Error("Method not implemented.");
  }
  widthOfGlyph() {
    throw new Error("Method not implemented.");
  }
  getAvailableFeatures() {
    throw new Error("Method not implemented.");
  }
  createSubset() {
    throw new Error("Method not implemented.");
  }
  getVariation() {
    throw new Error("Method not implemented.");
  }
  getFont() {
    throw new Error("Method not implemented.");
  }
  getName() {
    throw new Error("Method not implemented.");
  }
  setDefaultLanguage() {
    throw new Error("Method not implemented.");
  }
};
var fetchFont = async (src, options) => {
  const response = await fetch(src, options);
  const data2 = await response.arrayBuffer();
  return new Uint8Array(data2);
};
var isDataUrl = (dataUrl) => {
  const header = dataUrl.split(",")[0];
  const hasDataPrefix = header.substring(0, 5) === "data:";
  const hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
};
var FontSource = class {
  constructor(src, fontFamily, fontStyle, fontWeight, options) {
    __publicField(this, "src");
    __publicField(this, "fontFamily");
    __publicField(this, "fontStyle");
    __publicField(this, "fontWeight");
    __publicField(this, "data");
    __publicField(this, "options");
    __publicField(this, "loadResultPromise");
    this.src = src;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options || {};
    this.loadResultPromise = null;
  }
  async _load() {
    const { postscriptName } = this.options;
    let data2 = null;
    if (STANDARD_FONTS2.includes(this.src)) {
      data2 = new StandardFont2(this.src);
    } else if (isDataUrl(this.src)) {
      const raw = this.src.split(",")[1];
      const uint8Array = new Uint8Array(atob(raw).split("").map((c4) => c4.charCodeAt(0)));
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
    } else {
      const { headers, body, method = "GET" } = this.options;
      const buffer = await fetchFont(this.src, { method, body, headers });
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName);
    }
    if (data2 && "fonts" in data2) {
      throw new Error("Font collection is not supported");
    }
    this.data = data2;
  }
  async load() {
    if (this.loadResultPromise === null) {
      this.loadResultPromise = this._load();
    }
    return this.loadResultPromise;
  }
};
var FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var resolveFontWeight = (value2) => {
  return typeof value2 === "string" ? FONT_WEIGHTS[value2] : value2;
};
var sortByFontWeight = (a4, b3) => a4.fontWeight - b3.fontWeight;
var FontFamily = class _FontFamily {
  constructor(family) {
    __publicField(this, "family");
    __publicField(this, "sources");
    this.family = family;
    this.sources = [];
  }
  static create(family) {
    return new _FontFamily(family);
  }
  register({ src, fontWeight, fontStyle, ...options }) {
    const numericFontWeight = fontWeight ? resolveFontWeight(fontWeight) : void 0;
    this.sources.push(new FontSource(src, this.family, fontStyle, numericFontWeight, options));
  }
  resolve(descriptor) {
    const { fontWeight = 400, fontStyle = "normal" } = descriptor;
    const styleSources = this.sources.filter((s2) => s2.fontStyle === fontStyle);
    const exactFit = styleSources.find((s2) => s2.fontWeight === fontWeight);
    if (exactFit)
      return exactFit;
    let font = null;
    const numericFontWeight = resolveFontWeight(fontWeight);
    if (numericFontWeight >= 400 && numericFontWeight <= 500) {
      const leftOffset = styleSources.filter((s2) => s2.fontWeight <= numericFontWeight);
      const rightOffset = styleSources.filter((s2) => s2.fontWeight > 500);
      const fit = styleSources.filter((s2) => s2.fontWeight >= numericFontWeight && s2.fontWeight < 500);
      font = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    const lt = styleSources.filter((s2) => s2.fontWeight < numericFontWeight).sort(sortByFontWeight);
    const gt = styleSources.filter((s2) => s2.fontWeight > numericFontWeight).sort(sortByFontWeight);
    if (numericFontWeight < 400) {
      font = lt[lt.length - 1] || gt[0];
    }
    if (numericFontWeight > 500) {
      font = gt[0] || lt[lt.length - 1];
    }
    if (!font) {
      throw new Error(`Could not resolve font for ${this.family}, fontWeight ${fontWeight}, fontStyle ${fontStyle}`);
    }
    return font;
  }
};
var FontStore = class {
  constructor() {
    __publicField(this, "fontFamilies", {});
    __publicField(this, "emojiSource", null);
    __publicField(this, "hyphenationCallback", null);
    __publicField(this, "register", (data2) => {
      const { family } = data2;
      if (!this.fontFamilies[family]) {
        this.fontFamilies[family] = FontFamily.create(family);
      }
      if ("fonts" in data2) {
        for (let i4 = 0; i4 < data2.fonts.length; i4 += 1) {
          const { src, fontStyle, fontWeight, ...options } = data2.fonts[i4];
          this.fontFamilies[family].register({
            src,
            fontStyle,
            fontWeight,
            ...options
          });
        }
      } else {
        const { src, fontStyle, fontWeight, ...options } = data2;
        this.fontFamilies[family].register({
          src,
          fontStyle,
          fontWeight,
          ...options
        });
      }
    });
    __publicField(this, "registerEmojiSource", (emojiSource) => {
      this.emojiSource = emojiSource;
    });
    __publicField(this, "registerHyphenationCallback", (callback) => {
      this.hyphenationCallback = callback;
    });
    __publicField(this, "getFont", (descriptor) => {
      const { fontFamily } = descriptor;
      if (!this.fontFamilies[fontFamily]) {
        throw new Error(`Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`);
      }
      return this.fontFamilies[fontFamily].resolve(descriptor);
    });
    __publicField(this, "load", async (descriptor) => {
      const font = this.getFont(descriptor);
      if (font)
        await font.load();
    });
    __publicField(this, "reset", () => {
      const keys2 = Object.keys(this.fontFamilies);
      for (let i4 = 0; i4 < keys2.length; i4 += 1) {
        const key = keys2[i4];
        for (let j = 0; j < this.fontFamilies[key].sources.length; j++) {
          const fontSource = this.fontFamilies[key].sources[j];
          fontSource.data = null;
        }
      }
    });
    __publicField(this, "clear", () => {
      this.fontFamilies = {};
    });
    __publicField(this, "getRegisteredFonts", () => this.fontFamilies);
    __publicField(this, "getEmojiSource", () => this.emojiSource);
    __publicField(this, "getHyphenationCallback", () => this.hyphenationCallback);
    __publicField(this, "getRegisteredFontFamilies", () => Object.keys(this.fontFamilies));
    this.register({
      family: "Helvetica",
      fonts: [
        { src: "Helvetica", fontStyle: "normal", fontWeight: 400 },
        { src: "Helvetica-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Helvetica-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Helvetica-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Courier",
      fonts: [
        { src: "Courier", fontStyle: "normal", fontWeight: 400 },
        { src: "Courier-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Courier-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Courier-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Times-Roman",
      fonts: [
        { src: "Times-Roman", fontStyle: "normal", fontWeight: 400 },
        { src: "Times-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Times-Italic", fontStyle: "italic", fontWeight: 400 },
        { src: "Times-BoldItalic", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Helvetica-Bold",
      src: "Helvetica-Bold"
    });
    this.register({
      family: "Helvetica-Oblique",
      src: "Helvetica-Oblique"
    });
    this.register({
      family: "Helvetica-BoldOblique",
      src: "Helvetica-BoldOblique"
    });
    this.register({
      family: "Courier-Bold",
      src: "Courier-Bold"
    });
    this.register({
      family: "Courier-Oblique",
      src: "Courier-Oblique"
    });
    this.register({
      family: "Courier-BoldOblique",
      src: "Courier-BoldOblique"
    });
    this.register({
      family: "Times-Bold",
      src: "Times-Bold"
    });
    this.register({
      family: "Times-Italic",
      src: "Times-Italic"
    });
    this.register({
      family: "Times-BoldItalic",
      src: "Times-BoldItalic"
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 700
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 700
    });
  }
};

// node_modules/@react-pdf/fns/lib/index.js
var adjust = (index2, fn, collection) => {
  if (index2 >= 0 && index2 >= collection.length)
    return collection;
  if (index2 < 0 && Math.abs(index2) > collection.length)
    return collection;
  const i4 = index2 < 0 ? collection.length + index2 : index2;
  return Object.assign([], collection, { [i4]: fn(collection[i4]) });
};
var asyncCompose = (...fns) => async (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i4 = 0; i4 < reversedFns.length; i4 += 1) {
    const fn = reversedFns[i4];
    result = await fn(result, ...args);
  }
  return result;
};
var capitalize = (value2) => {
  if (!value2)
    return value2;
  return value2.replace(/(^|\s)\S/g, (l2) => l2.toUpperCase());
};
var castArray = (value2) => {
  return Array.isArray(value2) ? value2 : [value2];
};
var compose = (...fns) => (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i4 = 0; i4 < reversedFns.length; i4 += 1) {
    const fn = reversedFns[i4];
    result = fn(result, ...args);
  }
  return result;
};
var dropLast = (array) => array.slice(0, array.length - 1);
function evolve(transformations, object) {
  const result = {};
  const keys2 = Object.keys(object);
  for (let i4 = 0; i4 < keys2.length; i4 += 1) {
    const key = keys2[i4];
    const transformation = transformations[key];
    if (typeof transformation === "function") {
      result[key] = transformation(object[key]);
    } else {
      result[key] = object[key];
    }
  }
  return result;
}
var isNil = (value2) => value2 === null || value2 === void 0;
function last(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
}
var mapValues = (object, fn) => {
  const entries = Object.entries(object);
  const acc = {};
  return entries.reduce((acc2, [key, value2], index2) => {
    acc2[key] = fn(value2, key, index2);
    return acc2;
  }, acc);
};
var isPercent = (value2) => /((-)?\d+\.?\d*)%/g.exec(`${value2}`);
var matchPercent = (value2) => {
  const match = isPercent(value2);
  if (match) {
    const f3 = parseFloat(match[1]);
    const percent = f3 / 100;
    return { percent, value: f3 };
  }
  return null;
};
var omit = (keys2, object) => {
  const _keys = castArray(keys2);
  const copy5 = Object.assign({}, object);
  _keys.forEach((key) => {
    delete copy5[key];
  });
  return copy5;
};
var pick = (keys2, obj) => {
  const result = {};
  for (let i4 = 0; i4 < keys2.length; i4 += 1) {
    const key = keys2[i4];
    if (key in obj)
      result[key] = obj[key];
  }
  return result;
};
var repeat = (element, length2 = 0) => {
  const result = new Array(length2);
  for (let i4 = 0; i4 < length2; i4 += 1) {
    result[i4] = element;
  }
  return result;
};
var reverse = (list) => Array.prototype.slice.call(list, 0).reverse();
var upperFirst = (value2) => {
  if (!value2)
    return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
};
var without = (keys2, array) => {
  const result = [];
  for (let i4 = 0; i4 < array.length; i4 += 1) {
    const value2 = array[i4];
    if (!keys2.includes(value2))
      result.push(value2);
  }
  return result;
};
var parseFloat$1 = (value2) => {
  return typeof value2 === "string" ? Number.parseFloat(value2) : value2;
};

// node_modules/@react-pdf/render/lib/index.js
var import_abs_svg_path = __toESM(require_abs_svg_path());
var import_parse_svg_path = __toESM(require_parse_svg_path());

// node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i4) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i4 && _arr.length === i4) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i4) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i4);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y3 = _ref.y;
  x *= rx;
  y3 *= ry;
  var xp = cosphi * x - sinphi * y3;
  var yp = sinphi * x + cosphi * y3;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a4 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y22 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a4,
    y: y1 + x1 * a4
  }, {
    x: x2 + y22 * a4,
    y: y22 - x2 * a4
  }, {
    x: x2,
    y: y22
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i4 = 0; i4 < segments; i4++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y22 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2: y22, x, y: y3 };
  });
};
var modules_default = arcToBezier;

// node_modules/normalize-svg-path/index.mjs
function normalize(path) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y3 = 0;
  for (var i4 = 0, len = path.length; i4 < len; i4++) {
    var seg = path[i4];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = modules_default({
          px: x,
          py: y3,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length) continue;
        for (var j = 0, c4; j < curves.length; j++) {
          c4 = curves[j];
          seg = ["C", c4.x1, c4.y1, c4.x2, c4.y2, c4.x, c4.y];
          if (j < curves.length - 1) result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y3;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y3 * 2 - quadY;
        } else {
          quadX = x;
          quadY = y3;
        }
        seg = quadratic(x, y3, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y3, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y3, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y3, seg[1], y3);
        break;
      case "V":
        seg = line(x, y3, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y3, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y3 = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y3;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y22) {
  return ["C", x1, y1, x2, y22, x2, y22];
}
function quadratic(x1, y1, cx2, cy2, x2, y22) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y22 / 3 + 2 / 3 * cy2,
    x2,
    y22
  ];
}

// node_modules/@react-pdf/render/lib/index.js
var import_color_string = __toESM(require_color_string());
var renderPath = (ctx, node) => {
  var _a;
  const d2 = (_a = node.props) == null ? void 0 : _a.d;
  if (d2)
    ctx.path(node.props.d);
};
var KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
var renderRect = (ctx, node) => {
  var _a, _b, _c, _d, _e, _f;
  const x = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const y3 = ((_b = node.props) == null ? void 0 : _b.y) || 0;
  const rx = ((_c = node.props) == null ? void 0 : _c.rx) || 0;
  const ry = ((_d = node.props) == null ? void 0 : _d.ry) || 0;
  const width = ((_e = node.props) == null ? void 0 : _e.width) || 0;
  const height2 = ((_f = node.props) == null ? void 0 : _f.height) || 0;
  if (!width || !height2)
    return;
  if (rx && ry) {
    const krx = rx * KAPPA$3;
    const kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y3);
    ctx.lineTo(x - rx + width, y3);
    ctx.bezierCurveTo(x - rx + width + krx, y3, x + width, y3 + ry - kry, x + width, y3 + ry);
    ctx.lineTo(x + width, y3 + height2 - ry);
    ctx.bezierCurveTo(x + width, y3 + height2 - ry + kry, x - rx + width + krx, y3 + height2, x - rx + width, y3 + height2);
    ctx.lineTo(x + rx, y3 + height2);
    ctx.bezierCurveTo(x + rx - krx, y3 + height2, x, y3 + height2 - ry + kry, x, y3 + height2 - ry);
    ctx.lineTo(x, y3 + ry);
    ctx.bezierCurveTo(x, y3 + ry - kry, x + rx - krx, y3, x + rx, y3);
  } else {
    ctx.moveTo(x, y3);
    ctx.lineTo(x + width, y3);
    ctx.lineTo(x + width, y3 + height2);
    ctx.lineTo(x, y3 + height2);
  }
  ctx.closePath();
};
var renderLine$1 = (ctx, node) => {
  const { x1, x2, y1, y2: y22 } = node.props || {};
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y22);
};
var renderGroup = () => {
};
var KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipse = (ctx, rx, ry, cx2 = 0, cy2 = 0) => {
  const x = cx2 - rx;
  const y3 = cy2 - ry;
  const ox = rx * KAPPA$2;
  const oy = ry * KAPPA$2;
  const xe = x + rx * 2;
  const ye = y3 + ry * 2;
  const xm = x + rx;
  const ym = y3 + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y3, xm, y3);
  ctx.bezierCurveTo(xm + ox, y3, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
};
var renderEllipse = (ctx, node) => {
  const { cx: cx2, cy: cy2, rx, ry } = node.props || {};
  drawEllipse(ctx, rx, ry, cx2, cy2);
};
var renderCircle = (ctx, node) => {
  var _a, _b, _c;
  const cx2 = (_a = node.props) == null ? void 0 : _a.cx;
  const cy2 = (_b = node.props) == null ? void 0 : _b.cy;
  const r5 = (_c = node.props) == null ? void 0 : _c.r;
  drawEllipse(ctx, r5, r5, cx2, cy2);
};
var number2 = (n5) => {
  if (n5 > -1e21 && n5 < 1e21) {
    return Math.round(n5 * 1e6) / 1e6;
  }
  throw new Error(`unsupported number: ${n5}`);
};
var _renderGlyphs = (ctx, encoded, positions, x, y3) => {
  const commands = [];
  const scale2 = ctx._fontSize / 1e3;
  let i4;
  let last2 = 0;
  let hadOffset = false;
  ctx.save();
  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);
  y3 = ctx.page.height - y3;
  if (ctx.page.fonts[ctx._font.id] == null) {
    ctx.page.fonts[ctx._font.id] = ctx._font.ref();
  }
  ctx.addContent("BT");
  ctx.addContent(`1 0 0 1 ${number2(x)} ${number2(y3)} Tm`);
  ctx.addContent(`/${ctx._font.id} ${number2(ctx._fontSize)} Tf`);
  const addSegment = (cur) => {
    if (last2 < cur) {
      const hex = encoded.slice(last2, cur).join("");
      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
      commands.push(`<${hex}> ${number2(-advance)}`);
    }
    return last2 = cur;
  };
  const flush = (s2) => {
    addSegment(s2);
    if (commands.length > 0) {
      ctx.addContent(`[${commands.join(" ")}] TJ`);
      return commands.length = 0;
    }
  };
  for (i4 = 0; i4 < positions.length; i4 += 1) {
    const pos = positions[i4];
    if (pos.xOffset || pos.yOffset) {
      flush(i4);
      ctx.addContent(`1 0 0 1 ${number2(x + pos.xOffset * scale2)} ${number2(y3 + pos.yOffset * scale2)} Tm`);
      flush(i4 + 1);
      hadOffset = true;
    } else {
      if (hadOffset) {
        ctx.addContent(`1 0 0 1 ${number2(x)} ${number2(y3)} Tm`);
        hadOffset = false;
      }
      if (pos.xAdvance - pos.advanceWidth !== 0) {
        addSegment(i4 + 1);
      }
    }
    x += pos.xAdvance * scale2;
  }
  flush(i4);
  ctx.addContent("ET");
  return ctx.restore();
};
var renderGlyphs = (ctx, glyphs, positions, x, y3) => {
  const scale2 = 1e3 / ctx._fontSize;
  const unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  const advanceWidthScale = 1e3 / unitsPerEm;
  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  const encodedPositions = positions.map((pos, i4) => ({
    xAdvance: pos.xAdvance * scale2,
    yAdvance: pos.yAdvance * scale2,
    xOffset: pos.xOffset,
    yOffset: pos.yOffset,
    advanceWidth: glyphs[i4].advanceWidth * advanceWidthScale
  }));
  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y3);
};
var renderRun$1 = (ctx, run) => {
  var _a;
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const runAdvanceWidth = run.xAdvance;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  const { fontSize, color, opacity } = run.attributes;
  if (color)
    ctx.fillColor(color);
  ctx.fillOpacity(opacity);
  if (font) {
    ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  }
  try {
    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
  } catch (error) {
    console.log(error);
  }
  ctx.translate(runAdvanceWidth, 0);
};
var renderSpan = (ctx, line2, textAnchor, dominantBaseline) => {
  var _a, _b, _c, _d, _e, _f;
  ctx.save();
  const x = ((_a = line2.box) == null ? void 0 : _a.x) || 0;
  const y3 = ((_b = line2.box) == null ? void 0 : _b.y) || 0;
  const font = (_d = (_c = line2.runs[0]) == null ? void 0 : _c.attributes.font) == null ? void 0 : _d[0];
  const scale2 = ((_f = (_e = line2.runs[0]) == null ? void 0 : _e.attributes) == null ? void 0 : _f.scale) || 1;
  const width = line2.xAdvance;
  if (!font)
    return;
  const ascent2 = font.ascent * scale2;
  const xHeight = font.xHeight * scale2;
  const descent2 = font.descent * scale2;
  const capHeight = font.capHeight * scale2;
  let xTranslate = x;
  let yTranslate = y3;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y3 + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y3 + capHeight;
      break;
    case "mathematical":
      yTranslate = y3 + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y3 + descent2;
      break;
    case "text-before-edge":
      yTranslate = y3 + ascent2;
      break;
    default:
      yTranslate = y3;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach((run) => renderRun$1(ctx, run));
  ctx.restore();
};
var renderSvgText = (ctx, node) => {
  const children = node.children;
  children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));
};
var pairs = (values) => {
  const result = [];
  for (let i4 = 0; i4 < values.length; i4 += 2) {
    result.push([values[i4], values[i4 + 1]]);
  }
  return result;
};
var parsePoints = (points) => {
  let values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  const mappedValues = values.map(parseFloat);
  return pairs(mappedValues);
};
var drawPolyline = (ctx, points) => {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach((p3) => ctx.lineTo(p3[0], p3[1]));
  }
};
var renderPolyline = (ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
};
var renderPolygon = (ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
  ctx.closePath();
};
var renderImage$1 = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  if (!((_a = node.image) == null ? void 0 : _a.data))
    return;
  const { x = 0, y: y3 = 0 } = node.props;
  const { width, height: height2, opacity } = node.style;
  const paddingTop = node.box.paddingLeft || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height2 === 0) {
    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);
    return;
  }
  if (typeof width === "string" || typeof height2 === "string") {
    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y3 + paddingTop, {
    width,
    height: height2
  });
  ctx.restore();
};
var KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipNode = (ctx, node) => {
  if (!node.box)
    return;
  if (!node.style)
    return;
  const { top, left, width, height: height2 } = node.box;
  const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0 } = node.style;
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - cbr, left + width - cbr, top + height2, left + width - rbr, top + height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  const cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + cbl, top + height2, left, top + height2 - cbl, left, top + height2 - rbl);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
};
var applySingleTransformation = (ctx, transform, origin) => {
  const { operation, value: value2 } = transform;
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY] = value2;
      ctx.scale(scaleX, scaleY, { origin });
      break;
    }
    case "rotate": {
      const [angle] = value2;
      ctx.rotate(angle, { origin });
      break;
    }
    case "translate": {
      const [x, y3 = 0] = value2;
      ctx.translate(x, y3, { origin });
      break;
    }
    case "skew": {
      const [xAngle = 0, yAngle = 0] = value2;
      const radx = xAngle * Math.PI / 180;
      const rady = yAngle * Math.PI / 180;
      const tanx = Math.tan(radx);
      const tany = Math.tan(rady);
      let x = 0;
      let y3 = 0;
      if (origin != null) {
        [x, y3] = Array.from(origin);
        const x1 = x + tanx * y3;
        const y1 = y3 + tany * x;
        x -= x1;
        y3 -= y1;
      }
      ctx.transform(1, tany, tanx, 1, x, y3);
      break;
    }
    case "matrix": {
      ctx.transform(...value2);
      break;
    }
    default: {
      console.error(`Transform operation: '${operation}' doesn't supported`);
    }
  }
};
var applyTransformations = (ctx, node) => {
  if (!node.origin)
    return;
  const { props, style } = node;
  const origin = [node.origin.left, node.origin.top];
  const propsTransform = "transform" in props ? props.transform : void 0;
  const operations = (style == null ? void 0 : style.transform) || propsTransform || [];
  operations.forEach((operation) => {
    applySingleTransformation(ctx, operation, origin);
  });
};
var getPathBoundingBox = (node) => {
  var _a;
  const path = normalize((0, import_abs_svg_path.default)((0, import_parse_svg_path.default)(((_a = node.props) == null ? void 0 : _a.d) || "")));
  if (!path.length)
    return [0, 0, 0, 0];
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (let i4 = 0, l2 = path.length; i4 < l2; i4 += 1) {
    const points = path[i4].slice(1);
    for (let j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0])
        bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1])
        bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2])
        bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3])
        bounds[3] = points[j + 1];
    }
  }
  return bounds;
};
var getCircleBoundingBox = (node) => {
  var _a, _b, _c;
  const r5 = ((_a = node.props) == null ? void 0 : _a.r) || 0;
  const cx2 = ((_b = node.props) == null ? void 0 : _b.cx) || 0;
  const cy2 = ((_c = node.props) == null ? void 0 : _c.cy) || 0;
  return [cx2 - r5, cy2 - r5, cx2 + r5, cy2 + r5];
};
var getEllipseBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const cx2 = ((_a = node.props) == null ? void 0 : _a.cx) || 0;
  const cy2 = ((_b = node.props) == null ? void 0 : _b.cy) || 0;
  const rx = ((_c = node.props) == null ? void 0 : _c.rx) || 0;
  const ry = ((_d = node.props) == null ? void 0 : _d.ry) || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
};
var getLineBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const x1 = ((_a = node.props) == null ? void 0 : _a.x1) || 0;
  const y1 = ((_b = node.props) == null ? void 0 : _b.y1) || 0;
  const x2 = ((_c = node.props) == null ? void 0 : _c.x2) || 0;
  const y22 = ((_d = node.props) == null ? void 0 : _d.y2) || 0;
  return [
    Math.min(x1, x2),
    Math.min(y1, y22),
    Math.max(x1, x2),
    Math.max(y1, y22)
  ];
};
var getRectBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const x = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const y3 = ((_b = node.props) == null ? void 0 : _b.y) || 0;
  const width = ((_c = node.props) == null ? void 0 : _c.width) || 0;
  const height2 = ((_d = node.props) == null ? void 0 : _d.height) || 0;
  return [x, y3, x + width, y3 + height2];
};
var max = (values) => Math.max(-Infinity, ...values);
var min = (values) => Math.min(Infinity, ...values);
var getPolylineBoundingBox = (node) => {
  var _a;
  const points = parsePoints((_a = node.props) == null ? void 0 : _a.points);
  const xValues = points.map((p3) => p3[0]);
  const yValues = points.map((p3) => p3[1]);
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
};
var boundingBoxFns = {
  [Rect]: getRectBoundingBox,
  [Line]: getLineBoundingBox,
  [Path]: getPathBoundingBox,
  [Circle]: getCircleBoundingBox,
  [Ellipse]: getEllipseBoundingBox,
  [Polygon]: getPolylineBoundingBox,
  [Polyline]: getPolylineBoundingBox
};
var getBoundingBox = (node) => {
  const boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
};
var setStrokeWidth = (ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeWidth" in node.props))
    return;
  const lineWidth = node.props.strokeWidth;
  if (lineWidth)
    ctx.lineWidth(lineWidth);
};
var setStrokeColor = (ctx, node) => {
  if (!node.props)
    return;
  if (!("stroke" in node.props))
    return;
  const strokeColor = node.props.stroke;
  if (strokeColor)
    ctx.strokeColor(strokeColor);
};
var setOpacity = (ctx, node) => {
  if (!node.props)
    return;
  if (!("opacity" in node.props))
    return;
  const opacity = node.props.opacity;
  if (!isNil(opacity))
    ctx.opacity(opacity);
};
var setFillOpacity = (ctx, node) => {
  if (!node.props)
    return;
  if (!("fillOpacity" in node.props))
    return;
  const fillOpacity = node.props.fillOpacity || null;
  if (!isNil(fillOpacity))
    ctx.fillOpacity(fillOpacity);
};
var setStrokeOpacity = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeOpacity" in node.props))
    return;
  const strokeOpacity = (_a = node.props) == null ? void 0 : _a.strokeOpacity;
  if (!isNil(strokeOpacity))
    ctx.strokeOpacity(strokeOpacity);
};
var setLineJoin = (ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeLinejoin" in node.props))
    return;
  const lineJoin = node.props.strokeLinejoin;
  if (lineJoin)
    ctx.lineJoin(lineJoin);
};
var setLineCap = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeLinecap" in node.props))
    return;
  const lineCap = (_a = node.props) == null ? void 0 : _a.strokeLinecap;
  if (lineCap)
    ctx.lineCap(lineCap);
};
var setLineDash = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeDasharray" in node.props))
    return;
  const value2 = ((_a = node.props) == null ? void 0 : _a.strokeDasharray) || null;
  if (value2)
    ctx.dash(value2.split(/[\s,]+/).map(Number));
};
var hasLinearGradientFill = (node) => {
  var _a;
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return ((_a = node.props.fill) == null ? void 0 : _a.type) === LinearGradient;
};
var hasRadialGradientFill = (node) => {
  var _a;
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return ((_a = node.props.fill) == null ? void 0 : _a.type) === RadialGradient;
};
function multiplyMatrices(m1, m2) {
  const a4 = m1[0] * m2[0] + m1[2] * m2[1];
  const b3 = m1[1] * m2[0] + m1[3] * m2[1];
  const c4 = m1[0] * m2[2] + m1[2] * m2[3];
  const d2 = m1[1] * m2[2] + m1[3] * m2[3];
  const e4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  const f3 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  return [a4, b3, c4, d2, e4, f3];
}
var transformGradient = (grad, transforms, bbox, units) => {
  const matrices = transforms.map((transform) => {
    switch (transform.operation) {
      case "scale": {
        const value2 = transform.value;
        return [value2[0], 0, 0, value2[1], 0, 0];
      }
      case "translate": {
        const value2 = transform.value;
        let x = value2[0] || 0;
        let y3 = value2[1] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y3 = (bbox[3] - bbox[1]) * y3;
        }
        return [1, 0, 0, 1, x, y3];
      }
      case "rotate": {
        const value2 = transform.value;
        const cos = Math.cos(value2[0]);
        const sin = Math.sin(value2[0]);
        return [cos, sin, -sin, cos, 0, 0];
      }
      case "skew": {
        const value2 = transform.value;
        return [1, Math.tan(value2[0]), Math.tan(value2[1]), 1, 0, 0];
      }
      case "matrix": {
        const value2 = transform.value;
        let x = value2[4] || 0;
        let y3 = value2[5] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y3 = (bbox[3] - bbox[1]) * y3;
        }
        return [value2[0], value2[1], value2[2], value2[3], x, y3];
      }
      default:
        return [1, 0, 0, 1, 0, 0];
    }
  });
  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);
  grad.setTransform(...matrix);
};
var setLinearGradientFill = (ctx, node) => {
  var _a, _b;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = (_a = node.props) == null ? void 0 : _a.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let x1 = gradient.props.x1 || 0;
  let y1 = gradient.props.y1 || 0;
  let x2 = gradient.props.x2 || 1;
  let y22 = gradient.props.y2 || 0;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    x1 = m0 * x1 + m4;
    y1 = m3 * y1 + m5;
    x2 = m0 * x2 + m4;
    y22 = m3 * y22 + m5;
  }
  const grad = ctx.linearGradient(x1, y1, x2, y22);
  transformGradient(grad, transforms, bbox, units);
  (_b = gradient.children) == null ? void 0 : _b.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setRadialGradientFill = (ctx, node) => {
  var _a, _b;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = (_a = node.props) == null ? void 0 : _a.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let r5 = gradient.props.r || 0.5;
  let cx2 = gradient.props.cx || 0.5;
  let cy2 = gradient.props.cy || 0.5;
  let fx = gradient.props.fx || cx2;
  let fy = gradient.props.fy || cy2;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    r5 = r5 * m0;
    cx2 = m0 * cx2 + m4;
    cy2 = m3 * cy2 + m5;
    fx = m0 * fx + m4;
    fy = m3 * fy + m5;
  }
  const grad = ctx.radialGradient(cx2, cy2, 0, fx, fy, r5);
  transformGradient(grad, transforms, bbox, units);
  (_b = gradient.children) == null ? void 0 : _b.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setFillColor = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const fillColor = (_a = node.props) == null ? void 0 : _a.fill;
  if (fillColor)
    ctx.fillColor(fillColor);
};
var setFill = (ctx, node) => {
  if (hasLinearGradientFill(node))
    return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node))
    return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};
var draw = (ctx, node) => {
  const props = node.props || {};
  if ("fill" in props && "stroke" in props && props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if ("fill" in props && props.fill) {
    ctx.fill(props.fillRule);
  } else if ("stroke" in props && props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};
var noop3 = () => {
};
var renderFns$1 = {
  [Tspan]: noop3,
  [TextInstance]: noop3,
  [Path]: renderPath,
  [Rect]: renderRect,
  [Line]: renderLine$1,
  [G]: renderGroup,
  [Text]: renderSvgText,
  [Circle]: renderCircle,
  [Image]: renderImage$1,
  [Ellipse]: renderEllipse,
  [Polygon]: renderPolygon,
  [Polyline]: renderPolyline
};
var renderNode$1 = (ctx, node) => {
  const renderFn = renderFns$1[node.type];
  if (renderFn) {
    renderFn(ctx, node);
  } else {
    console.warn(`SVG node of type ${node.type} is not currently supported`);
  }
};
var drawNode = (ctx, node) => {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
};
var clipPath = (ctx, node) => {
  if (!node.props)
    return;
  if (!("clipPath" in node.props))
    return;
  const value2 = node.props.clipPath;
  if (value2) {
    const children = value2.children || [];
    children.forEach((child) => renderNode$1(ctx, child));
    ctx.clip();
  }
};
var drawChildren = (ctx, node) => {
  const children = node.children || [];
  children.forEach((child) => {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren(ctx, child);
    ctx.restore();
  });
};
var resolveAspectRatio = (ctx, node) => {
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const { viewBox, preserveAspectRatio } = node.props;
  const { meetOrSlice = "meet", align = "xMidYMid" } = preserveAspectRatio || {};
  if (viewBox == null || width == null || height2 == null)
    return;
  const x = (viewBox == null ? void 0 : viewBox.minX) || 0;
  const y3 = (viewBox == null ? void 0 : viewBox.minY) || 0;
  const logicalWidth = (viewBox == null ? void 0 : viewBox.maxX) || width;
  const logicalHeight = (viewBox == null ? void 0 : viewBox.maxY) || height2;
  const logicalRatio = logicalWidth / logicalHeight;
  const physicalRatio = width / height2;
  const scaleX = width / logicalWidth;
  const scaleY = height2 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y3);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y3);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2) / 2, -y3);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2), -y3);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y3);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y3 - (logicalHeight - height2 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y3 - (logicalHeight - height2 * logicalWidth / width));
    }
  }
};
var moveToOrigin = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left } = node.box;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};
var renderSvg = (ctx, node) => {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};
var black = { value: "#000", opacity: 1 };
var parseColor = (hex) => {
  if (!hex)
    return black;
  const parsed = import_color_string.default.get(hex);
  if (!parsed)
    return black;
  const value2 = import_color_string.default.to.hex(parsed.value.slice(0, 3));
  const opacity = parsed.value[3];
  return { value: value2, opacity };
};
var DEST_REGEXP = /^#.+/;
var isSrcId$1 = (src) => src.match(DEST_REGEXP);
var renderAttachment = (ctx, attachment) => {
  const { xOffset = 0, yOffset = 0, width, height: height2, image } = attachment;
  ctx.translate(-width + xOffset, -height2 + yOffset);
  ctx.image(image, 0, 0, {
    fit: [width, height2],
    align: "center",
    valign: "bottom"
  });
};
var renderAttachments = (ctx, run, glyphs) => {
  var _a;
  if (!glyphs)
    return;
  if (!run.positions)
    return;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  if (!font)
    return;
  ctx.save();
  const space = font.glyphForCodePoint(32);
  const objectReplacement = font.glyphForCodePoint(65532);
  let attachmentAdvance = 0;
  for (let i4 = 0; i4 < glyphs.length; i4 += 1) {
    const position = run.positions[i4];
    const glyph = glyphs[i4];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      glyphs[i4] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
};
var renderRun = (ctx, run) => {
  var _a;
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  if (!font)
    return;
  const { fontSize, link } = run.attributes;
  const color = parseColor(run.attributes.color);
  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  const { height: height2 = 0, descent: descent2 = 0, xAdvance = 0 } = run;
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity);
  if (link) {
    if (isSrcId$1(link)) {
      ctx.goTo(0, -height2 - descent2, xAdvance, height2, link.slice(1));
    } else {
      ctx.link(0, -height2 - descent2, xAdvance, height2, link);
    }
  }
  const glyphs = [...run.glyphs];
  renderAttachments(ctx, run, glyphs);
  ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  try {
    renderGlyphs(ctx, glyphs, run.positions, 0, 0);
  } catch (error) {
    console.log(error);
  }
  ctx.translate(xAdvance, 0);
};
var renderBackground$1 = (ctx, rect, backgroundColor) => {
  const color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  ctx.fill(color.value);
  ctx.restore();
};
var renderDecorationLine = (ctx, decorationLine) => {
  ctx.save();
  ctx.lineWidth(decorationLine.rect.height);
  ctx.strokeOpacity(decorationLine.opacity);
  if (/dashed/.test(decorationLine.style)) {
    ctx.dash(3 * decorationLine.rect.height, {});
  } else if (/dotted/.test(decorationLine.style)) {
    ctx.dash(decorationLine.rect.height, {});
  }
  if (/wavy/.test(decorationLine.style)) {
    const dist = Math.max(2, decorationLine.rect.height);
    let step = 1.1 * dist;
    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));
    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;
    const adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    const cp1y = decorationLine.rect.y + dist;
    const cp2y = decorationLine.rect.y - dist;
    let { x } = decorationLine.rect;
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    for (let i4 = 0; i4 < stepCount; i4 += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);
    if (/double/.test(decorationLine.style)) {
      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);
      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);
    }
  }
  ctx.stroke(decorationLine.color);
  ctx.restore();
};
var renderLine = (ctx, line2) => {
  if (!line2.box)
    return;
  const lineAscent = line2.ascent || 0;
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (let i4 = 0; i4 < line2.runs.length; i4 += 1) {
    const run = line2.runs[i4];
    const isLastRun = i4 === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      const xAdvance = run.xAdvance ?? 0;
      const overflowRight = isLastRun ? line2.overflowRight ?? 0 : 0;
      const backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun(ctx, run);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  if (line2.decorationLines) {
    for (let i4 = 0; i4 < line2.decorationLines.length; i4 += 1) {
      const decorationLine = line2.decorationLines[i4];
      renderDecorationLine(ctx, decorationLine);
    }
  }
  ctx.restore();
};
var renderBlock = (ctx, block) => {
  block.forEach((line2) => {
    renderLine(ctx, line2);
  });
};
var renderText = (ctx, node) => {
  var _a, _b;
  if (!node.box)
    return;
  if (!node.lines)
    return;
  const { top, left } = node.box;
  const blocks = [node.lines];
  const paddingTop = ((_a = node.box) == null ? void 0 : _a.paddingTop) || 0;
  const paddingLeft = ((_b = node.box) == null ? void 0 : _b.paddingLeft) || 0;
  const initialY = node.lines[0] ? node.lines[0].box.y : 0;
  const offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach((block) => {
    renderBlock(ctx, block);
  });
  ctx.restore();
};
var renderPage = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const dpi = ((_a = node.props) == null ? void 0 : _a.dpi) || 72;
  const userUnit = dpi / 72;
  ctx.addPage({ size: [width, height2], margin: 0, userUnit });
};
var renderNote = (ctx, node) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left } = node.box;
  const value2 = ((_a = node == null ? void 0 : node.children) == null ? void 0 : _a[0].value) || "";
  const color = (_b = node.style) == null ? void 0 : _b.backgroundColor;
  ctx.note(left, top, 0, 0, value2, { color });
};
var embedImage = (ctx, node) => {
  const src = node.image.data;
  let image;
  if (typeof src === "string") {
    image = ctx._imageRegistry[src];
  }
  if (!image) {
    image = ctx.openImage(src);
  }
  if (!image.obj) {
    image.embed(ctx);
  }
  return image;
};
var isNumeric = (n5) => {
  return !Number.isNaN(parseFloat(n5)) && Number.isFinite(n5);
};
var applyContainObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const cr = cw / ch;
  const ir = iw / ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const height3 = ch;
    const width2 = height3 * ir;
    const yOffset2 = isNumeric(py2) ? py2 : 0;
    const xOffset2 = isNumeric(px2) ? px2 : (cw - width2) * pxv;
    return { width: width2, height: height3, xOffset: xOffset2, yOffset: yOffset2 };
  }
  const width = cw;
  const height2 = width / ir;
  const xOffset = isNumeric(px2) ? px2 : 0;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, yOffset, xOffset };
};
var applyNoneObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const width = iw;
  const height2 = ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, xOffset, yOffset };
};
var applyCoverObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const ir = iw / ih;
  const cr = cw / ch;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const width2 = cw;
    const height3 = width2 / ir;
    const xOffset2 = isNumeric(px2) ? px2 : 0;
    const yOffset2 = isNumeric(py2) ? py2 : (ch - height3) * pyv;
    return { width: width2, height: height3, yOffset: yOffset2, xOffset: xOffset2 };
  }
  const height2 = ch;
  const width = height2 * ir;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : 0;
  return { width, height: height2, xOffset, yOffset };
};
var applyScaleDownObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
};
var applyFillObjectFit = (cw, ch, px2, py2) => {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2 ?? null) ? 0 : px2 || 0,
    yOffset: matchPercent(py2 ?? null) ? 0 : py2 || 0
  };
};
var resolveObjectFit = (type = "fill", cw, ch, iw, ih, px2, py2) => {
  switch (type) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
};
var drawImage = (ctx, node, options) => {
  var _a, _b, _c, _d;
  if (!node.box)
    return;
  if (!node.image)
    return;
  const { left, top } = node.box;
  const opacity = (_a = node.style) == null ? void 0 : _a.opacity;
  const objectFit = (_b = node.style) == null ? void 0 : _b.objectFit;
  const objectPositionX = (_c = node.style) == null ? void 0 : _c.objectPositionX;
  const objectPositionY = (_d = node.style) == null ? void 0 : _d.objectPositionY;
  const paddingTop = node.box.paddingTop || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const imageCache = options.imageCache || /* @__PURE__ */ new Map();
  const { width, height: height2, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);
  if (node.image.data) {
    if (width !== 0 && height2 !== 0) {
      const cacheKey = node.image.key;
      const image = imageCache.get(cacheKey) || embedImage(ctx, node);
      if (cacheKey)
        imageCache.set(cacheKey, image);
      const imageOpacity = isNil(opacity) ? 1 : opacity;
      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height2
      });
    } else {
      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);
    }
  }
};
var renderImage = (ctx, node, options) => {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
};
var CONTENT_COLOR = "#a1c6e7";
var PADDING_COLOR = "#c4deb9";
var MARGIN_COLOR = "#f8cca1";
var debugContent = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height2 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
};
var debugPadding = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height2 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
};
var debugMargin = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height2 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height2 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height2, width, marginBottom).fill();
};
var debugText = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  const roundedWidth = Math.round(width + marginLeft + marginRight);
  const roundedHeight = Math.round(height2 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });
};
var debugOrigin = (ctx, node) => {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
};
var renderDebug = (ctx, node) => {
  if (!node.props)
    return;
  if (!("debug" in node.props) || !node.props.debug)
    return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
};
var availableMethods = [
  "dash",
  "clip",
  "save",
  "path",
  "fill",
  "font",
  "text",
  "rect",
  "scale",
  "moveTo",
  "lineTo",
  "stroke",
  "rotate",
  "circle",
  "lineCap",
  "opacity",
  "ellipse",
  "polygon",
  "restore",
  "lineJoin",
  "fontSize",
  "fillColor",
  "lineWidth",
  "translate",
  "miterLimit",
  "strokeColor",
  "fillOpacity",
  "roundedRect",
  "fillAndStroke",
  "strokeOpacity",
  "bezierCurveTo",
  "quadraticCurveTo",
  "linearGradient",
  "radialGradient"
];
var painter = (ctx) => {
  const p3 = availableMethods.reduce((acc, prop) => ({
    ...acc,
    [prop]: (...args) => {
      ctx[prop](...args);
      return p3;
    }
  }), {});
  return p3;
};
var renderCanvas = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const paddingTop = node.box.paddingTop || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const availableWidth = width - paddingLeft - paddingRight;
  const availableHeight = height2 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
};
var KAPPA2 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  const c0 = rtr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  const topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c1 = innerTopRightRadiusX * (1 - KAPPA2);
  const c22 = innerTopRightRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c22, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c32 = innerTopLeftRadiusX * (1 - KAPPA2);
  const c4 = innerTopLeftRadiusY * (1 - KAPPA2);
  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c32, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  const c5 = rtl * (1 - KAPPA2);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const { top, left, width } = layout2;
  const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth } = style;
  const c0 = rtl * (1 - KAPPA2);
  const c1 = rtr * (1 - KAPPA2);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c0 = rbr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height2);
  ctx.lineTo(topBottomXCoord, top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c1 = innerBottomRightRadiusX * (1 - KAPPA2);
  const c22 = innerBottomRightRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c22, left + width - borderRightWidth, top + height2 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c32 = innerTopRightRadiusX * (1 - KAPPA2);
  const c4 = innerTopRightRadiusY * (1 - KAPPA2);
  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c32, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  const c5 = rtr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbr * (1 - KAPPA2);
  const c1 = rtr * (1 - KAPPA2);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c0 = rbl * (1 - KAPPA2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  const bottomLeftYCoord = top + height2 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c1 = innerBottomLeftRadiusX * (1 - KAPPA2);
  const c22 = innerBottomLeftRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c22, left + borderLeftWidth + c1, top + height2 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height2 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c32 = innerBottomRightRadiusX * (1 - KAPPA2);
  const c4 = innerBottomRightRadiusY * (1 - KAPPA2);
  const bottomRightYCoord = top + height2 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c32, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c5 = rbr * (1 - KAPPA2);
  ctx.bezierCurveTo(left + width, top + height2 - c5, left + width - c5, top + height2, left + width - rbr, top + height2);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  const c0 = rbl * (1 - KAPPA2);
  const c1 = rbr * (1 - KAPPA2);
  ctx.moveTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c1, left + width - c1, top + height2, left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;
  ctx.moveTo(left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  const c0 = rtl * (1 - KAPPA2);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c1 = innerTopLeftRadiusX * (1 - KAPPA2);
  const c22 = innerTopLeftRadiusY * (1 - KAPPA2);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c22, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height2 - Math.max(rbl, borderBottomWidth));
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c32 = innerBottomLeftRadiusX * (1 - KAPPA2);
  const c4 = innerBottomLeftRadiusY * (1 - KAPPA2);
  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c4, left + borderLeftWidth + c32, top + height2 - borderBottomWidth, bottomLeftXCoord, top + height2 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c5 = rbl * (1 - KAPPA2);
  ctx.bezierCurveTo(left + c5, top + height2, left, top + height2 - c5, left, top + height2 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const { top, left, height: height2 } = layout2;
  const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbl * (1 - KAPPA2);
  const c1 = rtl * (1 - KAPPA2);
  ctx.moveTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
var shouldRenderBorders = (node) => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);
var renderBorders = (ctx, node) => {
  if (!node.box)
    return;
  if (!shouldRenderBorders(node))
    return;
  const { width, height: height2, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  const { opacity = 1, borderTopColor = "black", borderTopStyle = "solid", borderLeftColor = "black", borderLeftStyle = "solid", borderRightColor = "black", borderRightStyle = "solid", borderBottomColor = "black", borderBottomStyle = "solid" } = node.style;
  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;
  const borderTopRightRadius = node.style.borderTopRightRadius || 0;
  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;
  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;
  const style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle
  };
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  ctx.save();
  ctx.strokeOpacity(opacity);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
};
var drawBackground = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const color = parseColor(node.style.backgroundColor);
  const nodeOpacity = isNil((_a = node.style) == null ? void 0 : _a.opacity) ? 1 : node.style.opacity;
  const opacity = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height2).fill();
};
var renderBackground = (ctx, node) => {
  var _a;
  const hasBackground = !!node.box && !!((_a = node.style) == null ? void 0 : _a.backgroundColor);
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
};
var isString3 = (value2) => typeof value2 === "string";
var isSrcId = (value2) => /^#.+/.test(value2);
var renderLink = (ctx, node, src) => {
  if (!src || !node.box)
    return;
  const isId = isSrcId(src);
  const method = isId ? "goTo" : "link";
  const value2 = isId ? src.slice(1) : src;
  const { top, left, width, height: height2 } = node.box;
  ctx[method](left, top, width, height2, value2);
};
var setLink = (ctx, node) => {
  const props = node.props || {};
  if ("src" in props && isString3(props.src))
    return renderLink(ctx, node, props.src);
  if ("href" in props && isString3(props.href))
    return renderLink(ctx, node, props.href);
};
var setDestination = (ctx, node) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("id" in node.props) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
};
var clean = (options) => {
  const opt = { ...options };
  Object.entries(opt).forEach((pair) => {
    if (!pair[1]) {
      delete opt[pair[0]];
    }
  });
  return opt;
};
var parseCommonFormOptions = (node) => {
  var _a, _b, _c, _d, _e;
  return {
    required: ((_a = node.props) == null ? void 0 : _a.required) || false,
    noExport: ((_b = node.props) == null ? void 0 : _b.noExport) || false,
    readOnly: ((_c = node.props) == null ? void 0 : _c.readOnly) || false,
    value: ((_d = node.props) == null ? void 0 : _d.value) || void 0,
    defaultValue: ((_e = node.props) == null ? void 0 : _e.defaultValue) || void 0
  };
};
var parseTextInputOptions = (node, fieldSet) => {
  var _a, _b, _c, _d, _e, _f, _g;
  return clean({
    ...parseCommonFormOptions(node),
    parent: fieldSet || void 0,
    align: ((_a = node.props) == null ? void 0 : _a.align) || "left",
    multiline: ((_b = node.props) == null ? void 0 : _b.multiline) || void 0,
    password: ((_c = node.props) == null ? void 0 : _c.password) || false,
    noSpell: ((_d = node.props) == null ? void 0 : _d.noSpell) || false,
    format: ((_e = node.props) == null ? void 0 : _e.format) || void 0,
    fontSize: ((_f = node.props) == null ? void 0 : _f.fontSize) || void 0,
    MaxLen: ((_g = node.props) == null ? void 0 : _g.maxLength) || void 0
  });
};
var parseSelectAndListFieldOptions = (node) => {
  var _a, _b, _c, _d, _e;
  return clean({
    ...parseCommonFormOptions(node),
    sort: ((_a = node.props) == null ? void 0 : _a.sort) || false,
    edit: ((_b = node.props) == null ? void 0 : _b.edit) || false,
    multiSelect: ((_c = node.props) == null ? void 0 : _c.multiSelect) || false,
    noSpell: ((_d = node.props) == null ? void 0 : _d.noSpell) || false,
    select: ((_e = node.props) == null ? void 0 : _e.select) || [""]
  });
};
var getAppearance = (ctx, codepoint, width, height2) => {
  const appearance = ctx.ref({
    Type: "XObject",
    Subtype: "Form",
    BBox: [0, 0, width, height2],
    Resources: {
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
      Font: {
        ZaDi: ctx._acroform.fonts.ZaDi
      }
    }
  });
  appearance.initDeflate();
  appearance.write(`/Tx BMC
q
/ZaDi ${height2 * 0.8} Tf
BT
${width * 0.45} ${height2 / 4} Td (${codepoint}) Tj
ET
Q
EMC`);
  appearance.end(null);
  return appearance;
};
var parseCheckboxOptions = (ctx, node, fieldSet) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { width, height: height2 } = node.box || {};
  const onOption = ((_a = node.props) == null ? void 0 : _a.onState) || "Yes";
  const offOption = ((_b = node.props) == null ? void 0 : _b.offState) || "Off";
  const xMark = ((_c = node.props) == null ? void 0 : _c.xMark) || false;
  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, "ZaDi")) {
    const ref = ctx.ref({
      Type: "Font",
      Subtype: "Type1",
      BaseFont: "ZapfDingbats"
    });
    ctx._acroform.fonts.ZaDi = ref;
    ref.end(null);
  }
  const normalAppearance = {
    [onOption]: getAppearance(ctx, xMark ? "8" : "4", width, height2),
    [offOption]: getAppearance(ctx, xMark ? " " : "8", width, height2)
  };
  return clean({
    ...parseCommonFormOptions(node),
    backgroundColor: ((_d = node.props) == null ? void 0 : _d.backgroundColor) || void 0,
    borderColor: ((_e = node.props) == null ? void 0 : _e.borderColor) || void 0,
    parent: fieldSet || void 0,
    value: `/${((_f = node.props) == null ? void 0 : _f.checked) === true ? onOption : offOption}`,
    defaultValue: `/${((_g = node.props) == null ? void 0 : _g.checked) === true ? onOption : offOption}`,
    AS: ((_h = node.props) == null ? void 0 : _h.checked) === true ? onOption : offOption,
    AP: { N: normalAppearance, D: normalAppearance }
  });
};
var renderTextInput = (ctx, node, options) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  const fieldSetOptions = (_b = options.fieldSets) == null ? void 0 : _b.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formText(name, left, top, width, height2, parseTextInputOptions(node, fieldSetOptions));
};
var renderSelect = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCombo(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
var renderFieldSet = (ctx, node, options) => {
  var _a;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  const formField = ctx.formField(name);
  const option = options;
  if (!option.fieldSets) {
    option.fieldSets = [formField];
  } else {
    option.fieldSets.push(formField);
  }
};
var cleanUpFieldSet = (_ctx, _node, options) => {
  options.fieldSets.pop();
};
var renderList = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box || {};
  const name = "name" in node.props ? node.props.name || "" : "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formList(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
var renderCheckbox = (ctx, node, options) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  const fieldSetOptions = (_b = options.fieldSets) == null ? void 0 : _b.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCheckbox(name, left, top, width, height2, parseCheckboxOptions(ctx, node, fieldSetOptions));
};
var isRecursiveNode = (node) => node.type !== Text && node.type !== Svg;
var renderChildren = (ctx, node, options) => {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  const children = node.children || [];
  const renderChild = (child) => renderNode(ctx, child, options);
  children.forEach(renderChild);
  ctx.restore();
};
var renderFns = {
  [Text]: renderText,
  [Note]: renderNote,
  [Image]: renderImage,
  [FieldSet]: renderFieldSet,
  [TextInput]: renderTextInput,
  [Select]: renderSelect,
  [Checkbox]: renderCheckbox,
  [List]: renderList,
  [Canvas]: renderCanvas,
  [Svg]: renderSvg,
  [Link]: setLink
};
var cleanUpFns = {
  [FieldSet]: cleanUpFieldSet
};
var renderNode = (ctx, node, options) => {
  var _a;
  const overflowHidden = ((_a = node.style) == null ? void 0 : _a.overflow) === "hidden";
  const shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page)
    renderPage(ctx, node);
  ctx.save();
  if (overflowHidden)
    clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground(ctx, node);
  renderBorders(ctx, node);
  const renderFn = renderFns[node.type];
  if (renderFn)
    renderFn(ctx, node, options);
  if (shouldRenderChildren)
    renderChildren(ctx, node, options);
  const cleanUpFn = cleanUpFns[node.type];
  if (cleanUpFn)
    cleanUpFn(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
};
var addNodeBookmark = (ctx, node, pageNumber, registry) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("bookmark" in node.props && node.props.bookmark) {
    const bookmark = node.props.bookmark;
    const { title: title3, parent, expanded, zoom, fit } = bookmark;
    const outline = registry[parent] || ctx.outline;
    const top = bookmark.top || node.box.top;
    const left = bookmark.left || node.box.left;
    const instance = outline.addItem(title3, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children)
    return;
  node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));
};
var addBookmarks = (ctx, root) => {
  const registry = {};
  const pages = root.children || [];
  pages.forEach((page, i4) => {
    addNodeBookmark(ctx, page, i4, registry);
  });
};
var render = (ctx, doc) => {
  const pages = doc.children || [];
  const options = { imageCache: /* @__PURE__ */ new Map(), fieldSets: [] };
  pages.forEach((page) => renderNode(ctx, page, options));
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
};

// node_modules/@react-pdf/stylesheet/lib/index.js
var import_media_engine = __toESM(require_src());
var import_hsl_to_hex = __toESM(require_hsl_to_hex());
var import_color_string2 = __toESM(require_color_string());
var import_parse = __toESM(require_parse());
var import_unit = __toESM(require_unit());
var compact = (array) => array.filter(Boolean);
var mergeStyles = (styles) => styles.reduce((acc, style) => {
  const s2 = Array.isArray(style) ? flatten(style) : style;
  Object.keys(s2).forEach((key) => {
    if (s2[key] !== null && s2[key] !== void 0) {
      acc[key] = s2[key];
    }
  });
  return acc;
}, {});
var flatten = compose(mergeStyles, compact, castArray);
var resolveMediaQueries = (container, style) => {
  return Object.keys(style).reduce((acc, key) => {
    if (/@media/.test(key)) {
      return {
        ...acc,
        ...(0, import_media_engine.default)({ [key]: style[key] }, container)
      };
    }
    return { ...acc, [key]: style[key] };
  }, {});
};
var isRgb = (value2) => /rgba?/g.test(value2);
var isHsl = (value2) => /hsla?/g.test(value2);
var parseRgb = (value2) => {
  const rgb = import_color_string2.default.get.rgb(value2);
  return import_color_string2.default.to.hex(rgb);
};
var parseHsl = (value2) => {
  const hsl = import_color_string2.default.get.hsl(value2).map(Math.round);
  const hex = (0, import_hsl_to_hex.default)(...hsl);
  return hex.toUpperCase();
};
var transformColor = (value2) => {
  if (isRgb(value2))
    return parseRgb(value2);
  if (isHsl(value2))
    return parseHsl(value2);
  return value2;
};
var parseValue = (value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value2);
  return match ? { value: parseFloat(match[1]), unit: match[2] || "pt" } : { value: value2, unit: void 0 };
};
var transformUnit = (container, value2) => {
  const scalar = parseValue(value2);
  const outputDpi = 72;
  const inputDpi = container.dpi || 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value !== "number")
    return scalar.value;
  switch (scalar.unit) {
    case "rem":
      return scalar.value * (container.remBase || 18);
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
var processNumberValue = (key, value2) => ({
  [key]: parseFloat$1(value2)
});
var processUnitValue = (key, value2, container) => ({
  [key]: transformUnit(container, value2)
});
var processColorValue = (key, value2) => {
  const result = { [key]: transformColor(value2) };
  return result;
};
var processNoopValue = (key, value2) => ({
  [key]: value2
});
var BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\s(\S+)\s(.+)/;
var matchBorderShorthand = (value2) => value2.match(BORDER_SHORTHAND_REGEX) || [];
var resolveBorderShorthand = (key, value2, container) => {
  const match = matchBorderShorthand(`${value2}`);
  if (match) {
    const widthMatch = match[1] || value2;
    const styleMatch = match[4] || value2;
    const colorMatch = match[5] || value2;
    const style = styleMatch;
    const color = colorMatch ? transformColor(colorMatch) : void 0;
    const width = widthMatch ? transformUnit(container, widthMatch) : void 0;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      return {
        [`${key}Color`]: color,
        [`${key}Style`]: style,
        [`${key}Width`]: width
      };
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      if (typeof style === "number")
        throw new Error(`Invalid border style: ${style}`);
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      if (typeof width !== "number")
        throw new Error(`Invalid border width: ${width}`);
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      const radius = value2 ? transformUnit(container, value2) : void 0;
      if (typeof radius !== "number")
        throw new Error(`Invalid border radius: ${radius}`);
      return {
        borderTopLeftRadius: radius,
        borderTopRightRadius: radius,
        borderBottomRightRadius: radius,
        borderBottomLeftRadius: radius
      };
    }
    if (typeof width !== "number")
      throw new Error(`Invalid border width: ${width}`);
    if (typeof style === "number")
      throw new Error(`Invalid border style: ${style}`);
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return { [key]: value2 };
};
var handlers$b = {
  border: resolveBorderShorthand,
  borderBottom: resolveBorderShorthand,
  borderBottomColor: processColorValue,
  borderBottomLeftRadius: processUnitValue,
  borderBottomRightRadius: processUnitValue,
  borderBottomStyle: processNoopValue,
  borderBottomWidth: processUnitValue,
  borderColor: resolveBorderShorthand,
  borderLeft: resolveBorderShorthand,
  borderLeftColor: processColorValue,
  borderLeftStyle: processNoopValue,
  borderLeftWidth: processUnitValue,
  borderRadius: resolveBorderShorthand,
  borderRight: resolveBorderShorthand,
  borderRightColor: processColorValue,
  borderRightStyle: processNoopValue,
  borderRightWidth: processUnitValue,
  borderStyle: resolveBorderShorthand,
  borderTop: resolveBorderShorthand,
  borderTopColor: processColorValue,
  borderTopLeftRadius: processUnitValue,
  borderTopRightRadius: processUnitValue,
  borderTopStyle: processNoopValue,
  borderTopWidth: processUnitValue,
  borderWidth: resolveBorderShorthand
};
var handlers$a = {
  backgroundColor: processColorValue,
  color: processColorValue,
  opacity: processNumberValue
};
var handlers$9 = {
  height: processUnitValue,
  maxHeight: processUnitValue,
  maxWidth: processUnitValue,
  minHeight: processUnitValue,
  minWidth: processUnitValue,
  width: processUnitValue
};
var flexDefaults = [1, 1, 0];
var flexAuto = [1, 1, "auto"];
var processFlexShorthand = (key, value2, container) => {
  let defaults = flexDefaults;
  let matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = `${value2}`.split(" ");
  }
  const flexGrow = parseFloat$1(matches[0] || defaults[0]);
  const flexShrink = parseFloat$1(matches[1] || defaults[1]);
  const flexBasis = transformUnit(container, matches[2] || defaults[2]);
  return { flexGrow, flexShrink, flexBasis };
};
var handlers$8 = {
  alignContent: processNoopValue,
  alignItems: processNoopValue,
  alignSelf: processNoopValue,
  flex: processFlexShorthand,
  flexBasis: processUnitValue,
  flexDirection: processNoopValue,
  flexFlow: processNoopValue,
  flexGrow: processNumberValue,
  flexShrink: processNumberValue,
  flexWrap: processNoopValue,
  justifyContent: processNoopValue,
  justifySelf: processNoopValue
};
var processGapShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const rowGap = transformUnit(container, (match == null ? void 0 : match[0]) || value2);
  const columnGap = transformUnit(container, (match == null ? void 0 : match[1]) || value2);
  return { rowGap, columnGap };
};
var handlers$7 = {
  gap: processGapShorthand,
  columnGap: processUnitValue,
  rowGap: processUnitValue
};
var handlers$6 = {
  aspectRatio: processNumberValue,
  bottom: processUnitValue,
  display: processNoopValue,
  left: processUnitValue,
  position: processNoopValue,
  right: processUnitValue,
  top: processUnitValue,
  overflow: processNoopValue,
  zIndex: processNumberValue
};
var BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
var logError = (style, value2) => {
  const name = style.toString();
  console.error(`
    @react-pdf/stylesheet parsing error:
    ${name}: ${value2},
    ${" ".repeat(name.length + 2)}^
    Unsupported ${name} value format
  `);
};
var expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false } = {}) => (model, value2, container) => {
  const nodes = (0, import_parse.default)(`${value2}`);
  const parts = [];
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = nodes[i4];
    if (node.type === "function" || node.type === "string" || node.type === "div") {
      logError(model, value2);
      return {};
    }
    if (node.type === "word") {
      if (node.value === "auto" && autoSupported) {
        parts.push(node.value);
      } else {
        const result = (0, import_unit.default)(node.value);
        if (result && BOX_MODEL_UNITS.includes(result.unit)) {
          parts.push(node.value);
        } else {
          logError(model, value2);
          return {};
        }
      }
    }
  }
  if (parts.length > maxValues) {
    logError(model, value2);
    return {};
  }
  const first = transformUnit(container, parts[0]);
  if (expandsTo) {
    const second = transformUnit(container, parts[1] || parts[0]);
    const third = transformUnit(container, parts[2] || parts[0]);
    const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);
    return expandsTo({ first, second, third, fourth });
  }
  return {
    [model]: first
  };
};
var processMargin = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    marginTop: first,
    marginRight: second,
    marginBottom: third,
    marginLeft: fourth
  }),
  maxValues: 4,
  autoSupported: true
});
var processMarginVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginTop: first,
    marginBottom: second
  }),
  maxValues: 2,
  autoSupported: true
});
var processMarginHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginRight: first,
    marginLeft: second
  }),
  maxValues: 2,
  autoSupported: true
});
var processMarginSingle = expandBoxModel({
  autoSupported: true
});
var handlers$5 = {
  margin: processMargin,
  marginBottom: processMarginSingle,
  marginHorizontal: processMarginHorizontal,
  marginLeft: processMarginSingle,
  marginRight: processMarginSingle,
  marginTop: processMarginSingle,
  marginVertical: processMarginVertical
};
var processPadding = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    paddingTop: first,
    paddingRight: second,
    paddingBottom: third,
    paddingLeft: fourth
  }),
  maxValues: 4
});
var processPaddingVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingTop: first,
    paddingBottom: second
  }),
  maxValues: 2
});
var processPaddingHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingRight: first,
    paddingLeft: second
  }),
  maxValues: 2
});
var processPaddingSingle = expandBoxModel();
var handlers$4 = {
  padding: processPadding,
  paddingBottom: processPaddingSingle,
  paddingHorizontal: processPaddingHorizontal,
  paddingLeft: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingTop: processPaddingSingle,
  paddingVertical: processPaddingVertical
};
var offsetKeyword = (value2) => {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return value2;
  }
};
var processObjectPosition = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const objectPositionX = offsetKeyword(transformUnit(container, (match == null ? void 0 : match[0]) || value2));
  const objectPositionY = offsetKeyword(transformUnit(container, (match == null ? void 0 : match[1]) || value2));
  return { objectPositionX, objectPositionY };
};
var processObjectPositionValue = (key, value2, container) => ({
  [key]: offsetKeyword(transformUnit(container, value2))
});
var handlers$3 = {
  objectPosition: processObjectPosition,
  objectPositionX: processObjectPositionValue,
  objectPositionY: processObjectPositionValue,
  objectFit: processNoopValue
};
var castInt = (value2) => {
  if (typeof value2 === "number")
    return value2;
  return parseInt(value2, 10);
};
var FONT_WEIGHTS2 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var transformFontWeight = (value2) => {
  if (!value2)
    return FONT_WEIGHTS2.normal;
  if (typeof value2 === "number")
    return value2;
  const lv = value2.toLowerCase();
  if (FONT_WEIGHTS2[lv])
    return FONT_WEIGHTS2[lv];
  return castInt(value2);
};
var processFontWeight = (key, value2) => {
  return { [key]: transformFontWeight(value2) };
};
var transformLineHeight = (value2, styles, container) => {
  if (value2 === "")
    return value2;
  const fontSize = transformUnit(container, styles.fontSize || 18);
  const lineHeight = transformUnit(container, value2);
  const { percent } = matchPercent(lineHeight) || {};
  if (percent)
    return percent * fontSize;
  return isNaN(value2) ? lineHeight : lineHeight * fontSize;
};
var processLineHeight = (key, value2, container, styles) => {
  return {
    [key]: transformLineHeight(value2, styles, container)
  };
};
var handlers$2 = {
  direction: processNoopValue,
  fontFamily: processNoopValue,
  fontSize: processUnitValue,
  fontStyle: processNoopValue,
  fontWeight: processFontWeight,
  letterSpacing: processUnitValue,
  lineHeight: processLineHeight,
  maxLines: processNumberValue,
  textAlign: processNoopValue,
  textDecoration: processNoopValue,
  textDecorationColor: processColorValue,
  textDecorationStyle: processNoopValue,
  textIndent: processNoopValue,
  textOverflow: processNoopValue,
  textTransform: processNoopValue,
  verticalAlign: processNoopValue
};
var matchNumber = (value2) => typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2);
var castFloat = (value2) => {
  if (typeof value2 !== "string")
    return value2;
  if (matchNumber(value2))
    return parseFloat(value2);
  return value2;
};
var parse2 = (transformString) => {
  const transforms = transformString.trim().split(/\)[ ,]|\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  const parsed = [];
  for (let i4 = 0; i4 < transforms.length; i4 += 1) {
    const transform = transforms[i4];
    if (transform) {
      const [name, rawValue] = transform.split("(");
      const splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      const value2 = rawValue.split(splitChar).map((val) => val.trim());
      parsed.push({ operation: name.trim(), value: value2 });
    }
  }
  return parsed;
};
var parseAngle = (value2) => {
  const unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  const [, angle, unit] = unitsRegexp.exec(value2);
  const number3 = Number.parseFloat(angle);
  return unit === "rad" ? number3 * 180 / Math.PI : number3;
};
var normalizeTransformOperation = ({ operation, value: value2 }) => {
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY = scaleX] = value2.map((num) => Number.parseFloat(num));
      return { operation: "scale", value: [scaleX, scaleY] };
    }
    case "scaleX": {
      return { operation: "scale", value: [Number.parseFloat(value2), 1] };
    }
    case "scaleY": {
      return { operation: "scale", value: [1, Number.parseFloat(value2)] };
    }
    case "rotate": {
      return { operation: "rotate", value: [parseAngle(value2)] };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map((num) => Number.parseFloat(num))
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return { operation: "translate", value: [0, Number.parseFloat(value2)] };
    }
    case "skew": {
      return { operation: "skew", value: value2.map(parseAngle) };
    }
    case "skewX": {
      return { operation: "skew", value: [parseAngle(value2), 0] };
    }
    case "skewY": {
      return { operation: "skew", value: [0, parseAngle(value2)] };
    }
    default: {
      return { operation, value: value2.map((num) => Number.parseFloat(num)) };
    }
  }
};
var normalize2 = (operations) => {
  return operations.map((operation) => normalizeTransformOperation(operation));
};
var processTransform = (key, value2) => {
  if (typeof value2 !== "string")
    return { [key]: value2 };
  return { [key]: normalize2(parse2(value2)) };
};
var Y_AXIS_SHORTHANDS = { top: true, bottom: true };
var sortTransformOriginPair = (a4, b3) => {
  if (Y_AXIS_SHORTHANDS[a4])
    return 1;
  if (Y_AXIS_SHORTHANDS[b3])
    return -1;
  return 0;
};
var getTransformOriginPair = (values) => {
  if (!values || values.length === 0)
    return ["center", "center"];
  const pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
};
var processTransformOriginShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const pair = getTransformOriginPair(match);
  const transformOriginX = transformUnit(container, pair[0]);
  const transformOriginY = transformUnit(container, pair[1]);
  return {
    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),
    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)
  };
};
var processTransformOriginValue = (key, value2, container) => {
  const v3 = transformUnit(container, value2);
  return { [key]: offsetKeyword(v3) || castFloat(v3) };
};
var handlers$1 = {
  transform: processTransform,
  gradientTransform: processTransform,
  transformOrigin: processTransformOriginShorthand,
  transformOriginX: processTransformOriginValue,
  transformOriginY: processTransformOriginValue
};
var handlers = {
  fill: processColorValue,
  stroke: processColorValue,
  strokeDasharray: processNoopValue,
  strokeWidth: processUnitValue,
  fillOpacity: processNumberValue,
  strokeOpacity: processNumberValue,
  fillRule: processNoopValue,
  textAnchor: processNoopValue,
  strokeLinecap: processNoopValue,
  strokeLinejoin: processNoopValue,
  visibility: processNoopValue,
  clipPath: processNoopValue,
  dominantBaseline: processNoopValue
};
var shorthands = {
  ...handlers$b,
  ...handlers$a,
  ...handlers$9,
  ...handlers$8,
  ...handlers$7,
  ...handlers$6,
  ...handlers$5,
  ...handlers$4,
  ...handlers$3,
  ...handlers$2,
  ...handlers$1,
  ...handlers
};
var resolve = (container) => (style) => {
  const propsArray = Object.keys(style);
  const resolvedStyle = {};
  for (let i4 = 0; i4 < propsArray.length; i4 += 1) {
    const key = propsArray[i4];
    const value2 = style[key];
    if (!shorthands[key]) {
      resolvedStyle[key] = value2;
      continue;
    }
    const resolved = shorthands[key](key, value2, container, style);
    const keys2 = Object.keys(resolved);
    for (let j = 0; j < keys2.length; j += 1) {
      const propName = keys2[j];
      const propValue = resolved[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
};
var resolveStyles = (container, style) => {
  const computeMediaQueries = (value2) => resolveMediaQueries(container, value2);
  return compose(resolve(container), computeMediaQueries, flatten)(style);
};

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi2 = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i4) {
      TYPES[type] = 1 << i4 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range2) {
              var ref = range2.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i4 = 0; i4 < step; i4++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i4 = +entry; i4--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a4 = ref[0];
          var b3 = ref[1];
          a4 = String.fromCodePoint(lastCode += parseInt(a4, radix));
          b3 = String.fromCodePoint(lastCode += parseInt(b3, radix));
          map2.set(a4, b3);
          includeReverse && reverseMap.set(b3, a4);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$12() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$12();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$12();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$12();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i4 = 0; i4 < string.length; i4++) {
        charTypes[i4] = getBidiCharType(string[i4]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i5, type2) {
        var oldType = charTypes[i5];
        charTypes[i5] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n5) {
        return n5 + (n5 & 1 ? 1 : 2);
      };
      var nextOdd = function(n5) {
        return n5 + (n5 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a4, b3) {
                return a4[0] - b3[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i5 = start2; i5 < string.length; i5++) {
          var charType2 = charTypes[i5];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i5);
            i5 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i5 = isolateStart + 1; i5 < string.length; i5++) {
          var charType2 = charTypes[i5];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i5;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data2 = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse3() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data2, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value2, key) {
          map2.set(key, value2);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse3();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var map2 = /* @__PURE__ */ new Map();
      for (var i4 = start2; i4 <= end2; i4++) {
        if (embeddingLevels[i4] & 1) {
          var mirror = getMirroredCharacter(string[i4]);
          if (mirror !== null) {
            map2.set(i4, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end2, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i4 = lineEnd; i4 >= lineStart && getBidiCharType(string[i4]) & TRAILING_TYPES; i4--) {
            lineLevels[i4] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start2, end2) {
      var indices = getReorderedIndices2(string, embedLevelsResult, start2, end2);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i4) {
        chars[i4] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices2(string, embedLevelsResult, start2, end2) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end2);
      var indices = [];
      for (var i4 = 0; i4 < string.length; i4++) {
        indices[i4] = i4;
      }
      segments.forEach(function(ref) {
        var start3 = ref[0];
        var end3 = ref[1];
        var slice5 = indices.slice(start3, end3 + 1);
        for (var i5 = slice5.length; i5--; ) {
          indices[end3 - i5] = slice5[i5];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices2;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi2;
}
var bidi_default = bidiFactory;

// node_modules/@react-pdf/textkit/lib/textkit.js
var import_hyphen = __toESM(require_hyphen());
var import_en_us = __toESM(require_en_us());
var fromFragments = (fragments) => {
  let offset2 = 0;
  let string = "";
  const runs = [];
  fragments.forEach((fragment) => {
    string += fragment.string;
    runs.push({
      ...fragment,
      start: offset2,
      end: offset2 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset2 += fragment.string.length;
  });
  return { string, runs };
};
var SOFT_HYPHEN$1 = "";
var defaultHyphenate = (word) => [word];
var removeSoftHyphens = (word) => {
  return word.replaceAll(SOFT_HYPHEN$1, "");
};
var wrapWords = (engines2 = {}, options = {}) => {
  return (attributedString) => {
    var _a;
    const syllables = [];
    const fragments = [];
    const builtinHyphenate = ((_a = engines2.wordHyphenation) == null ? void 0 : _a.call(engines2)) || defaultHyphenate;
    const hyphenate = options.hyphenationCallback || builtinHyphenate;
    let offset2 = 0;
    for (let i4 = 0; i4 < attributedString.runs.length; i4 += 1) {
      let string = "";
      const run = attributedString.runs[i4];
      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (let j = 0; j < words.length; j += 1) {
        const word = words[j];
        const parts = hyphenate(word, builtinHyphenate).map(removeSoftHyphens);
        syllables.push(...parts);
        string += parts.join("");
      }
      const runOffset = run.end - run.start - string.length;
      const start2 = run.start - offset2;
      const end2 = run.end - offset2 - runOffset;
      fragments.push({ ...run, start: start2, end: end2, string });
      offset2 += runOffset;
    }
    const result = { ...fromFragments(fragments), syllables };
    return result;
  };
};
var copy3 = (rect) => {
  return Object.assign({}, rect);
};
var partition = (rect, height2) => {
  const a4 = Object.assign({}, rect, { height: height2 });
  const b3 = Object.assign({}, rect, {
    y: rect.y + height2,
    height: rect.height - height2
  });
  return [a4, b3];
};
var crop = (height2, rect) => {
  const [, result] = partition(rect, height2);
  return result;
};
var height$2 = (paragraph) => {
  return paragraph.reduce((acc, block) => acc + block.box.height, 0);
};
var calculateScale = (run) => {
  var _a;
  const attributes2 = run.attributes || {};
  const fontSize = attributes2.fontSize || 12;
  const font = attributes2.font;
  const unitsPerEm = typeof font === "string" ? null : (_a = font == null ? void 0 : font[0]) == null ? void 0 : _a.unitsPerEm;
  return unitsPerEm ? fontSize / unitsPerEm : 0;
};
var scale = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.scale) || calculateScale(run);
};
var offset = (index2, run) => {
  if (!run)
    return 0;
  const glyphIndices = run.glyphIndices || [];
  const value2 = glyphIndices[index2];
  return glyphIndices.slice(0, index2).filter((i4) => i4 === value2).length;
};
var getFont = (run) => {
  var _a, _b;
  return ((_b = (_a = run.attributes) == null ? void 0 : _a.font) == null ? void 0 : _b[0]) || null;
};
var slice$2 = (start2, end2, font, glyph) => {
  if (!glyph)
    return [];
  if (start2 === end2)
    return [];
  if (start2 === 0 && end2 === glyph.codePoints.length)
    return [glyph];
  const codePoints = glyph.codePoints.slice(start2, end2);
  const string = String.fromCodePoint(...codePoints);
  return font ? font.layout(string, void 0, void 0, void 0, "ltr").glyphs : [glyph];
};
var glyphIndexAt = (index2, run) => {
  var _a;
  const result = (_a = run == null ? void 0 : run.glyphIndices) == null ? void 0 : _a[index2];
  return isNil(result) ? index2 : result;
};
var normalize3 = (array) => {
  const head = array[0];
  return array.map((value2) => value2 - head);
};
var slice$1 = (start2, end2, run) => {
  var _a, _b;
  const runScale = scale(run);
  const font = getFont(run);
  const startIndex = glyphIndexAt(start2, run);
  const endIndex = glyphIndexAt(end2, run);
  const startGlyph = (_a = run.glyphs) == null ? void 0 : _a[startIndex];
  const endGlyph = (_b = run.glyphs) == null ? void 0 : _b[endIndex];
  const startOffset = offset(start2, run);
  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];
  const endOffset = offset(end2, run);
  const endGlyphs = slice$2(0, endOffset, font, endGlyph);
  const sliceStart = startIndex + Math.min(1, startOffset);
  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  const glyphPosition = (g3) => ({
    xAdvance: g3.advanceWidth * runScale,
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  const startPositions = startGlyphs.map(glyphPosition);
  const positions = (run.positions || []).slice(sliceStart, endIndex);
  const endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start2,
    end: Math.min(run.end, run.start + end2),
    glyphIndices: normalize3((run.glyphIndices || []).slice(start2, end2)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
};
var runIndexAt$1 = (index2, runs) => {
  if (!runs)
    return -1;
  return runs.findIndex((run) => run.start <= index2 && index2 < run.end);
};
var filter = (start2, end2, runs) => {
  const startIndex = runIndexAt$1(start2, runs);
  const endIndex = Math.max(runIndexAt$1(end2 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
};
var subtract = (index2, run) => {
  const start2 = run.start - index2;
  const end2 = run.end - index2;
  return Object.assign({}, run, { start: start2, end: end2 });
};
var sliceRuns = (start2, end2, runs) => {
  const sliceFirstRun = (a4) => slice$1(start2 - a4.start, end2 - a4.start, a4);
  const sliceLastRun = (a4) => slice$1(0, end2 - a4.start, a4);
  return runs.map((run, i4) => {
    let result = run;
    const isFirst = i4 === 0;
    const isLast = !isFirst && i4 === runs.length - 1;
    if (isFirst)
      result = sliceFirstRun(run);
    if (isLast)
      result = sliceLastRun(run);
    return subtract(start2, result);
  });
};
var slice3 = (start2, end2, attributedString) => {
  if (attributedString.string.length === 0)
    return attributedString;
  const string = attributedString.string.slice(start2, end2);
  const filteredRuns = filter(start2, end2, attributedString.runs);
  const slicedRuns = sliceRuns(start2, end2, filteredRuns);
  return Object.assign({}, attributedString, { string, runs: slicedRuns });
};
var findCharIndex = (string) => {
  return string.search(/\S/g);
};
var findLastCharIndex = (string) => {
  const match = string.match(/\S/g);
  return match ? string.lastIndexOf(match[match.length - 1]) : -1;
};
var trim = (attributedString) => {
  const start2 = findCharIndex(attributedString.string);
  const end2 = findLastCharIndex(attributedString.string);
  return slice3(start2, end2 + 1, attributedString);
};
var empty$1 = () => {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
};
var isNumber3 = (value2) => {
  return typeof value2 === "number";
};
var appendIndices = (length2, indices) => {
  const lastIndex = last(indices);
  const value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  const newIndices = Array(length2).fill(value2);
  return indices.concat(newIndices);
};
var fromCodePoint = (value2, font) => {
  if (typeof font === "string")
    return null;
  return font && value2 ? font.glyphForCodePoint(value2) : null;
};
var appendGlyph = (glyph, run) => {
  var _a;
  const glyphLength = ((_a = glyph.codePoints) == null ? void 0 : _a.length) || 0;
  const end2 = run.end + glyphLength;
  const glyphs = run.glyphs.concat(glyph);
  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions)
    return Object.assign({}, run, { end: end2, glyphs, glyphIndices });
  const positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale(run),
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  return Object.assign({}, run, { end: end2, glyphs, glyphIndices, positions });
};
var append$1 = (value2, run) => {
  if (!value2)
    return run;
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return appendGlyph(glyph, run);
};
var stringFromCodePoints = (codePoints) => {
  return String.fromCodePoint(...codePoints || []);
};
var append = (glyph, attributedString) => {
  const codePoints = typeof glyph === "number" ? [glyph] : glyph == null ? void 0 : glyph.codePoints;
  const codePointsString = stringFromCodePoints(codePoints || []);
  const string = attributedString.string + codePointsString;
  const firstRuns = attributedString.runs.slice(0, -1);
  const lastRun = last(attributedString.runs) || empty$1();
  const runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, { string, runs });
};
var ELLIPSIS_UNICODE = 8230;
var ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
var getEllipsisCodePoint = (font) => {
  if (!font.encode)
    return ELLIPSIS_UNICODE;
  const [codePoints] = font.encode(ELLIPSIS_STRING);
  return parseInt(codePoints[0], 16);
};
var truncate3 = (paragraph) => {
  var _a, _b, _c;
  const runs = ((_a = last(paragraph)) == null ? void 0 : _a.runs) || [];
  const font = (_c = (_b = last(runs)) == null ? void 0 : _b.attributes) == null ? void 0 : _c.font[0];
  if (font) {
    const index2 = paragraph.length - 1;
    const codePoint = getEllipsisCodePoint(font);
    const glyph = font.glyphForCodePoint(codePoint);
    const lastBlock = append(glyph, trim(paragraph[index2]));
    return Object.assign([], paragraph, { [index2]: lastBlock });
  }
  return paragraph;
};
var omit2 = (value2, run) => {
  const attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, { attributes: attributes2 });
};
var ascent$1 = (run) => {
  var _a;
  const { font, attachment } = run.attributes;
  const attachmentHeight = (attachment == null ? void 0 : attachment.height) || 0;
  const fontAscent = typeof font === "string" ? 0 : ((_a = font == null ? void 0 : font[0]) == null ? void 0 : _a.ascent) || 0;
  return Math.max(attachmentHeight, fontAscent * scale(run));
};
var descent = (run) => {
  var _a, _b;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const fontDescent = typeof font === "string" ? 0 : ((_b = font == null ? void 0 : font[0]) == null ? void 0 : _b.descent) || 0;
  return scale(run) * fontDescent;
};
var lineGap = (run) => {
  var _a, _b;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const lineGap2 = typeof font === "string" ? 0 : ((_b = font == null ? void 0 : font[0]) == null ? void 0 : _b.lineGap) || 0;
  return lineGap2 * scale(run);
};
var height$1 = (run) => {
  var _a;
  const lineHeight = (_a = run.attributes) == null ? void 0 : _a.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
};
var height = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, height$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
var intersects = (a4, b3) => {
  const x = Math.max(a4.x, b3.x);
  const num1 = Math.min(a4.x + a4.width, b3.x + b3.width);
  const y3 = Math.max(a4.y, b3.y);
  const num2 = Math.min(a4.y + a4.height, b3.y + b3.height);
  return num1 >= x && num2 >= y3;
};
var getLineFragment = (lineRect, excludeRect) => {
  if (!intersects(excludeRect, lineRect))
    return [lineRect];
  const eStart = excludeRect.x;
  const eEnd = excludeRect.x + excludeRect.width;
  const lStart = lineRect.x;
  const lEnd = lineRect.x + lineRect.width;
  const a4 = Object.assign({}, lineRect, { width: eStart - lStart });
  const b3 = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });
  return [a4, b3].filter((r5) => r5.width > 0);
};
var getLineFragments = (rect, excludeRects) => {
  let fragments = [rect];
  for (let i4 = 0; i4 < excludeRects.length; i4 += 1) {
    const excludeRect = excludeRects[i4];
    fragments = fragments.reduce((acc, fragment) => {
      const pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  }
  return fragments;
};
var generateLineRects = (container, height2) => {
  const { excludeRects, ...rect } = container;
  if (!excludeRects)
    return [rect];
  const lineRects = [];
  const maxY = Math.max(...excludeRects.map((r5) => r5.y + r5.height));
  let currentRect = rect;
  while (currentRect.y < maxY) {
    const [lineRect, rest] = partition(currentRect, height2);
    const lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push(...lineRectFragments);
  }
  return [...lineRects, currentRect];
};
var ATTACHMENT_CODE$1 = "";
var purgeAttachments = (line2) => {
  const shouldPurge = !line2.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge)
    return line2;
  const runs = line2.runs.map((run) => omit2("attachment", run));
  return Object.assign({}, line2, { runs });
};
var layoutLines = (rects, lines, indent) => {
  let rect = rects.shift();
  let currentY = rect.y;
  return lines.map((line2, i4) => {
    var _a, _b;
    const lineIndent = i4 === 0 ? indent : 0;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const height$12 = Math.max(height(line2), style.lineHeight);
    if (currentY + height$12 > rect.y + rect.height && rects.length > 0) {
      rect = rects.shift();
      currentY = rect.y;
    }
    const newLine = {
      string: line2.string,
      runs: line2.runs,
      box: {
        x: rect.x + lineIndent,
        y: currentY,
        width: rect.width - lineIndent,
        height: height$12
      }
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
};
var layoutParagraph = (engines2, options = {}) => {
  return (container, paragraph) => {
    var _a, _b, _c;
    const height$12 = height(paragraph);
    const indent = ((_c = (_b = (_a = paragraph.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) == null ? void 0 : _c.indent) || 0;
    const rects = generateLineRects(container, height$12);
    const availableWidths = rects.map((r5) => r5.width);
    availableWidths.unshift(availableWidths[0] - indent);
    const lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
};
var sliceAtHeight = (height2, paragraph) => {
  const newBlock = [];
  let counter = 0;
  for (let i4 = 0; i4 < paragraph.length; i4 += 1) {
    const line2 = paragraph[i4];
    counter += line2.box.height;
    if (counter < height2) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
};
var typesetter = (engines2, options, container) => {
  return (attributedStrings) => {
    const result = [];
    const paragraphs = [...attributedStrings];
    const layout2 = layoutParagraph(engines2, options);
    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    const truncateEllipsis = container.truncateMode === "ellipsis";
    let linesCount = maxLines;
    let paragraphRect = copy3(container);
    let nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      const paragraph = layout2(paragraphRect, nextParagraph);
      const slicedBlock = paragraph.slice(0, linesCount);
      const linesHeight2 = height$2(slicedBlock);
      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight2) {
        result.push(shouldTruncate ? truncate3(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight2, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        result.push(truncate3(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return result;
  };
};
var start = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : runs[0].start;
};
var end = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : last(runs).end;
};
var length$1 = (attributedString) => {
  return end(attributedString) - start(attributedString);
};
var bidi$2 = bidi_default();
var getBidiLevels$1 = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
var getReorderedIndices = (string, segments) => {
  const indices = [];
  for (let i4 = 0; i4 < string.length; i4 += 1) {
    indices[i4] = i4;
  }
  segments.forEach(([start2, end2]) => {
    const slice5 = indices.slice(start2, end2 + 1);
    for (let i4 = slice5.length - 1; i4 >= 0; i4 -= 1) {
      indices[end2 - i4] = slice5[i4];
    }
  });
  return indices;
};
var getItemAtIndex = (runs, objectName, index2) => {
  for (let i4 = 0; i4 < runs.length; i4 += 1) {
    const run = runs[i4];
    const updatedIndex = run.glyphIndices[index2 - run.start];
    if (index2 >= run.start && index2 < run.end) {
      return run[objectName][updatedIndex];
    }
  }
  throw new Error(`index ${index2} out of range`);
};
var reorderLine = (line2) => {
  var _a;
  const levels = getBidiLevels$1(line2.runs);
  const direction = (_a = line2.runs[0]) == null ? void 0 : _a.attributes.direction;
  const level = direction === "rtl" ? 1 : 0;
  const end2 = length$1(line2) - 1;
  const paragraphs = [{ start: 0, end: end2, level }];
  const embeddingLevels = { paragraphs, levels };
  const segments = bidi$2.getReorderSegments(line2.string, embeddingLevels);
  if (segments.length === 0)
    return line2;
  const indices = getReorderedIndices(line2.string, segments);
  const updatedString = bidi$2.getReorderedString(line2.string, embeddingLevels);
  const updatedRuns = line2.runs.map((run) => {
    const selectedIndices = indices.slice(run.start, run.end);
    const updatedGlyphs = [];
    const updatedPositions = [];
    const addedGlyphs = /* @__PURE__ */ new Set();
    for (let i4 = 0; i4 < selectedIndices.length; i4 += 1) {
      const index2 = selectedIndices[i4];
      const glyph = getItemAtIndex(line2.runs, "glyphs", index2);
      if (addedGlyphs.has(glyph.id))
        continue;
      updatedGlyphs.push(glyph);
      updatedPositions.push(getItemAtIndex(line2.runs, "positions", index2));
      if (glyph.isLigature) {
        addedGlyphs.add(glyph.id);
      }
    }
    return {
      ...run,
      glyphs: updatedGlyphs,
      positions: updatedPositions
    };
  });
  return {
    box: line2.box,
    runs: updatedRuns,
    string: updatedString
  };
};
var reorderParagraph = (paragraph) => paragraph.map(reorderLine);
var bidiReordering = () => {
  return (paragraphs) => paragraphs.map(reorderParagraph);
};
var DUMMY_CODEPOINT = 123;
var resolve2 = (glyphs = []) => {
  return glyphs.reduce((acc, glyph) => {
    const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];
    if (acc.length === 0)
      return codePoints.map(() => 0);
    const last2 = acc[acc.length - 1];
    const next = codePoints.map(() => last2 + 1);
    return [...acc, ...next];
  }, []);
};
var getCharacterSpacing = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.characterSpacing) || 0;
};
var scalePositions = (run, positions) => {
  const runScale = scale(run);
  const characterSpacing = getCharacterSpacing(run);
  return positions.map((position, i4) => {
    const isLast = i4 === positions.length;
    const xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
};
var layoutRun = (string) => {
  return (run) => {
    const { start: start2, end: end2, attributes: attributes2 = {} } = run;
    const { font } = attributes2;
    if (!font)
      return { ...run, glyphs: [], glyphIndices: [], positions: [] };
    const runString = string.slice(start2, end2);
    if (typeof font === "string")
      throw new Error("Invalid font");
    const glyphRun = font[0].layout(runString, void 0, void 0, void 0, "ltr");
    const positions = scalePositions(run, glyphRun.positions);
    const glyphIndices = resolve2(glyphRun.glyphs);
    const result = {
      ...run,
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    };
    return result;
  };
};
var generateGlyphs = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(layoutRun(attributedString.string));
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var resolveRunYOffset = (run) => {
  var _a, _b, _c, _d;
  if (!run.positions)
    return run;
  const unitsPerEm = ((_c = (_b = (_a = run.attributes) == null ? void 0 : _a.font) == null ? void 0 : _b[0]) == null ? void 0 : _c.unitsPerEm) || 0;
  const yOffset = (((_d = run.attributes) == null ? void 0 : _d.yOffset) || 0) * unitsPerEm;
  const positions = run.positions.map((p3) => Object.assign({}, p3, { yOffset }));
  return Object.assign({}, run, { positions });
};
var resolveYOffset = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunYOffset);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var sort = (runs) => {
  return runs.sort((a4, b3) => a4.start - b3.start || a4.end - b3.end);
};
var isEmpty = (run) => {
  return run.start === run.end;
};
var sortPoints = (a4, b3) => {
  return a4[1] - b3[1] || a4[3] - b3[3];
};
var generatePoints = (runs) => {
  const result = runs.reduce((acc, run, i4) => {
    return acc.concat([
      ["start", run.start, run.attributes, i4],
      ["end", run.end, run.attributes, i4]
    ]);
  }, []);
  return result.sort(sortPoints);
};
var mergeRuns = (runs) => {
  return runs.reduce((acc, run) => {
    const attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, { attributes: attributes2 });
  }, {});
};
var groupEmptyRuns = (runs) => {
  const groups = runs.reduce((acc, run) => {
    if (!acc[run.start])
      acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, []);
  return Object.values(groups);
};
var flattenEmptyRuns = (runs) => {
  return groupEmptyRuns(runs).map(mergeRuns);
};
var flattenRegularRuns = (runs) => {
  const res = [];
  const points = generatePoints(runs);
  let start2 = -1;
  let attrs = {};
  const stack = [];
  for (let i4 = 0; i4 < points.length; i4 += 1) {
    const [type, offset2, attributes2] = points[i4];
    if (start2 !== -1 && start2 < offset2) {
      res.push({
        start: start2,
        end: offset2,
        attributes: attrs,
        glyphIndices: [],
        glyphs: [],
        positions: []
      });
    }
    if (type === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (let j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start2 = offset2;
  }
  return res;
};
var flatten2 = (runs = []) => {
  const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));
  const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));
  return sort(emptyRuns.concat(regularRuns));
};
var empty = () => ({ string: "", runs: [] });
var omitFont = (attributedString) => {
  const runs = attributedString.runs.map((run) => omit2("font", run));
  return Object.assign({}, attributedString, { runs });
};
var preprocessRuns = (engines2) => {
  return (attributedString) => {
    if (isNil(attributedString))
      return empty();
    const { string } = attributedString;
    const { fontSubstitution: fontSubstitution2, scriptItemizer: scriptItemizer2, bidi: bidi2 } = engines2;
    const { runs: omittedFontRuns } = omitFont(attributedString);
    const { runs: itemizationRuns } = scriptItemizer2()(attributedString);
    const { runs: substitutedRuns } = fontSubstitution2()(attributedString);
    const { runs: bidiRuns } = bidi2()(attributedString);
    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);
    return { string, runs: flatten2(runs) };
  };
};
var splitParagraphs = () => {
  return (attributedString) => {
    const paragraphs = [];
    let start2 = 0;
    let breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      paragraphs.push(slice3(start2, breakPoint, attributedString));
      start2 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start2 === 0) {
      paragraphs.push(attributedString);
    } else if (start2 < attributedString.string.length) {
      paragraphs.push(slice3(start2, length$1(attributedString), attributedString));
    }
    return paragraphs;
  };
};
var advanceWidth$2 = (positions) => {
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var advanceWidth$1 = (run) => {
  return advanceWidth$2(run.positions || []);
};
var advanceWidth = (attributedString) => {
  const reducer = (acc, run) => acc + advanceWidth$1(run);
  return attributedString.runs.reduce(reducer, 0);
};
var WHITE_SPACES_CODE = 32;
var isWhiteSpace = (glyph) => {
  const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [];
  return codePoints.includes(WHITE_SPACES_CODE);
};
var leadingPositions = (run) => {
  const glyphs = run.glyphs || [];
  const positions = run.positions || [];
  const leadingWhitespaces = glyphs.findIndex((g3) => !isWhiteSpace(g3));
  return positions.slice(0, leadingWhitespaces);
};
var leadingOffset$1 = (run) => {
  const positions = leadingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var leadingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
};
var trailingPositions = (run) => {
  const glyphs = reverse(run.glyphs || []);
  const positions = reverse(run.positions || []);
  const leadingWhitespaces = glyphs.findIndex((g3) => !isWhiteSpace(g3));
  return positions.slice(0, leadingWhitespaces);
};
var trailingOffset$1 = (run) => {
  const positions = trailingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
var trailingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
};
var dropLast$1 = (run) => {
  return slice$1(0, run.end - run.start - 1, run);
};
var dropLast2 = (attributedString) => {
  const string = dropLast(attributedString.string);
  const runs = adjust(-1, dropLast$1, attributedString.runs);
  return Object.assign({}, attributedString, { string, runs });
};
var ALIGNMENT_FACTORS = { center: 0.5, right: 1 };
var removeNewLine = (line2) => {
  return last(line2.string) === "\n" ? dropLast2(line2) : line2;
};
var getOverflowLeft = (line2) => {
  return leadingOffset(line2) + (line2.overflowLeft || 0);
};
var getOverflowRight = (line2) => {
  return trailingOffset(line2) + (line2.overflowRight || 0);
};
var adjustOverflow = (line2) => {
  const overflowLeft = getOverflowLeft(line2);
  const overflowRight = getOverflowRight(line2);
  const x = line2.box.x - overflowLeft;
  const width = line2.box.width + overflowLeft + overflowRight;
  const box = Object.assign({}, line2.box, { x, width });
  return Object.assign({}, line2, { box, overflowLeft, overflowRight });
};
var justifyLine$1 = (engines2, options, align) => {
  return (line2) => {
    const lineWidth = advanceWidth(line2);
    const alignFactor = ALIGNMENT_FACTORS[align] || 0;
    const remainingWidth = Math.max(0, line2.box.width - lineWidth);
    const shouldJustify = align === "justify" || lineWidth > line2.box.width;
    const x = line2.box.x + remainingWidth * alignFactor;
    const box = Object.assign({}, line2.box, { x });
    const newLine = Object.assign({}, line2, { box });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
};
var finalizeLine = (line2) => {
  let lineAscent = 0;
  let lineDescent = 0;
  let lineHeight = 0;
  let lineXAdvance = 0;
  const runs = line2.runs.map((run) => {
    const height2 = height$1(run);
    const ascent2 = ascent$1(run);
    const descent$1 = descent(run);
    const xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height2);
    lineAscent = Math.max(lineAscent, ascent2);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, { height: height2, ascent: ascent2, descent: descent$1, xAdvance });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
};
var finalizeBlock = (engines2, options) => {
  return (line2, index2, lines) => {
    var _a, _b;
    const isLastFragment = index2 === lines.length - 1;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const align = isLastFragment ? style.alignLastLine : style.align;
    return compose(finalizeLine, engines2.textDecoration(), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
};
var finalizeFragments = (engines2, options) => {
  return (paragraphs) => {
    const blockFinalizer = finalizeBlock(engines2, options);
    return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));
  };
};
var ATTACHMENT_CODE = 65532;
var isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);
var resolveRunAttachments = (run) => {
  var _a;
  if (!run.positions)
    return run;
  const glyphs = run.glyphs || [];
  const attachment = (_a = run.attributes) == null ? void 0 : _a.attachment;
  if (!attachment)
    return run;
  const positions = run.positions.map((position, i4) => {
    const glyph = glyphs[i4];
    if (attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, { xAdvance: attachment.width });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, { positions });
};
var resolveAttachments = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunAttachments);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
var applyAttributes = (a4) => {
  return {
    align: a4.align || (a4.direction === "rtl" ? "right" : "left"),
    alignLastLine: a4.alignLastLine || (a4.align === "justify" ? "left" : a4.align || "left"),
    attachment: a4.attachment || null,
    backgroundColor: a4.backgroundColor || null,
    bullet: a4.bullet || null,
    characterSpacing: a4.characterSpacing || 0,
    color: a4.color || "black",
    direction: a4.direction || "ltr",
    features: a4.features || [],
    fill: a4.fill !== false,
    font: a4.font || [],
    fontSize: a4.fontSize || 12,
    hangingPunctuation: a4.hangingPunctuation || false,
    hyphenationFactor: a4.hyphenationFactor || 0,
    indent: a4.indent || 0,
    justificationFactor: a4.justificationFactor || 1,
    lineHeight: a4.lineHeight || null,
    lineSpacing: a4.lineSpacing || 0,
    link: a4.link || null,
    marginLeft: a4.marginLeft || a4.margin || 0,
    marginRight: a4.marginRight || a4.margin || 0,
    opacity: a4.opacity,
    paddingTop: a4.paddingTop || a4.padding || 0,
    paragraphSpacing: a4.paragraphSpacing || 0,
    script: a4.script || null,
    shrinkFactor: a4.shrinkFactor || 0,
    strike: a4.strike || false,
    strikeColor: a4.strikeColor || a4.color || "black",
    strikeStyle: a4.strikeStyle || "solid",
    stroke: a4.stroke || false,
    underline: a4.underline || false,
    underlineColor: a4.underlineColor || a4.color || "black",
    underlineStyle: a4.underlineStyle || "solid",
    verticalAlign: a4.verticalAlign || null,
    wordSpacing: a4.wordSpacing || 0,
    yOffset: a4.yOffset || 0
  };
};
var applyRunStyles = (run) => {
  const attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, { attributes: attributes2 });
};
var applyDefaultStyles = () => {
  return (attributedString) => {
    const string = attributedString.string || "";
    const runs = (attributedString.runs || []).map(applyRunStyles);
    return { string, runs };
  };
};
var verticalAlignment = () => {
  return (attributedString) => {
    attributedString.runs.forEach((run) => {
      const { attributes: attributes2 } = run;
      const { verticalAlign } = attributes2;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
};
var bidi$1 = bidi_default();
var getBidiLevels = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
var mirrorString = () => {
  return (attributedString) => {
    const levels = getBidiLevels(attributedString.runs);
    let updatedString = "";
    attributedString.string.split("").forEach((char, index2) => {
      const isRTL = levels[index2] % 2 === 1;
      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index2)) : null;
      updatedString += mirroredChar || char;
    });
    const result = {
      ...attributedString,
      string: updatedString
    };
    return result;
  };
};
var layoutEngine = (engines2) => {
  return (attributedString, container, options = {}) => {
    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), generateGlyphs(), wrapWords(engines2, options), mirrorString(), preprocessRuns(engines2));
    const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);
    return compose(finalizeFragments(engines2, options), bidiReordering(), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);
  };
};
var bidi = bidi_default();
var bidiEngine = () => {
  return (attributedString) => {
    var _a;
    const { string } = attributedString;
    const direction = (_a = attributedString.runs[0]) == null ? void 0 : _a.attributes.direction;
    const { levels } = bidi.getEmbeddingLevels(string, direction);
    let lastLevel = null;
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    for (let i4 = 0; i4 < levels.length; i4 += 1) {
      const level = levels[i4];
      if (level !== lastLevel) {
        if (lastLevel !== null) {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { bidiLevel: lastLevel }
          });
        }
        lastIndex = index2;
        lastLevel = level;
      }
      index2 += 1;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { bidiLevel: lastLevel }
      });
    }
    const result = { string, runs };
    return result;
  };
};
var INFINITY = 1e4;
var skipPastGlueAndPenalty = (nodes, start2) => {
  let j = start2 + 1;
  for (; j < nodes.length; j++) {
    if (nodes[j].type !== "glue" && nodes[j].type !== "penalty") {
      break;
    }
  }
  return nodes[j - 1];
};
var getNextBreakpoint = (subnodes, widths, lineNumber) => {
  let position = null;
  let minimumBadness = Infinity;
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  const calculateRatio = (node) => {
    const stretch = "stretch" in node ? node.stretch : null;
    if (sum.width < lineLength) {
      if (!stretch)
        return INFINITY;
      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    const shrink = "shrink" in node ? node.shrink : null;
    if (sum.width > lineLength) {
      if (!shrink)
        return INFINITY;
      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  };
  let hyphenWidth = 0;
  for (let i4 = 0; i4 < subnodes.length; i4 += 1) {
    const node = subnodes[i4];
    if (node.type === "box") {
      sum.width += node.width;
    }
    if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    const potentialEndOfLine = skipPastGlueAndPenalty(subnodes, i4);
    hyphenWidth = potentialEndOfLine.type === "penalty" ? potentialEndOfLine.width : 0;
    if (sum.width - sum.shrink + hyphenWidth > lineLength) {
      if (position === null) {
        let j = i4 === 0 ? i4 + 1 : i4;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      const ratio = calculateRatio(node);
      const penalty = node.type === "penalty" ? node.penalty : 0;
      const badness = 100 * Math.abs(ratio) ** 3 + penalty;
      if (minimumBadness >= badness) {
        position = i4;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink + hyphenWidth > lineLength ? position : null;
};
var applyBestFit = (nodes, widths) => {
  let count = 0;
  let lineNumber = 0;
  let subnodes = nodes;
  const breakpoints = [0];
  while (subnodes.length > 0) {
    const breakpoint2 = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint2 !== null) {
      count += breakpoint2;
      breakpoints.push(count);
      subnodes = subnodes.slice(breakpoint2 + 1, subnodes.length);
      count++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
};
var LinkedListNode = class {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "prev");
    __publicField(this, "next");
    this.data = data2;
    this.prev = null;
    this.next = null;
  }
};
var LinkedList = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
    __publicField(this, "listSize");
    __publicField(this, "listLength");
    this.head = null;
    this.tail = null;
    this.listSize = 0;
    this.listLength = 0;
  }
  isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  }
  size() {
    return this.listSize;
  }
  isEmpty() {
    return this.listSize === 0;
  }
  first() {
    return this.head;
  }
  last() {
    return this.last;
  }
  forEach(callback) {
    let node = this.head;
    while (node !== null) {
      callback(node);
      node = node.next;
    }
  }
  at(i4) {
    let node = this.head;
    let index2 = 0;
    if (i4 >= this.listLength || i4 < 0) {
      return null;
    }
    while (node !== null) {
      if (i4 === index2) {
        return node;
      }
      node = node.next;
      index2 += 1;
    }
    return null;
  }
  insertAfter(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  }
  insertBefore(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  }
  push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  }
  unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  }
  remove(node) {
    if (!this.isLinked(node))
      return this;
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  }
};
__publicField(LinkedList, "Node", LinkedListNode);
function breakpoint(position, demerits, line2, fitnessClass, totals, previous) {
  return {
    position,
    demerits,
    line: line2,
    fitnessClass,
    totals: totals || {
      width: 0,
      stretch: 0,
      shrink: 0
    },
    previous
  };
}
function computeCost(nodes, lineLengths, sum, end2, active, currentLine) {
  let width = sum.width - active.totals.width;
  let stretch = 0;
  let shrink = 0;
  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
  if (nodes[end2].type === "penalty") {
    width += nodes[end2].width;
  }
  if (width < lineLength) {
    stretch = sum.stretch - active.totals.stretch;
    if (stretch > 0) {
      return (lineLength - width) / stretch;
    }
    return linebreak.infinity;
  }
  if (width > lineLength) {
    shrink = sum.shrink - active.totals.shrink;
    if (shrink > 0) {
      return (lineLength - width) / shrink;
    }
    return linebreak.infinity;
  }
  return 0;
}
function computeSum(nodes, sum, breakPointIndex) {
  const result = {
    width: sum.width,
    stretch: sum.stretch,
    shrink: sum.shrink
  };
  for (let i4 = breakPointIndex; i4 < nodes.length; i4 += 1) {
    const node = nodes[i4];
    if (node.type === "glue") {
      result.width += node.width;
      result.stretch += node.stretch;
      result.shrink += node.shrink;
    } else if (node.type === "box" || node.type === "penalty" && node.penalty === -linebreak.infinity && i4 > breakPointIndex) {
      break;
    }
  }
  return result;
}
function findBestBreakpoints(activeNodes) {
  const breakpoints = [];
  if (activeNodes.size() === 0)
    return [];
  let tmp = { data: { demerits: Infinity } };
  activeNodes.forEach((node) => {
    if (node.data.demerits < tmp.data.demerits) {
      tmp = node;
    }
  });
  while (tmp !== null) {
    breakpoints.push(tmp.data.position);
    tmp = tmp.data.previous;
  }
  return breakpoints.reverse();
}
var linebreak = (nodes, availableWidths, tolerance) => {
  const options = {
    demerits: { line: 10, flagged: 100, fitness: 3e3 },
    tolerance: tolerance || 3
  };
  const activeNodes = new LinkedList();
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLengths = availableWidths;
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, void 0, null)));
  function mainLoop(node, index2, nodes2) {
    let active = activeNodes.first();
    while (active !== null) {
      let currentLine = 0;
      const candidates = [
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity }
      ];
      while (active !== null) {
        currentLine = active.data.line + 1;
        const ratio = computeCost(nodes2, lineLengths, sum, index2, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          const badness = 100 * Math.pow(Math.abs(ratio), 3);
          let demerits = 0;
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here
            nodes2[active.data.position].flagged;
          }
          let currentClass;
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = { active, demerits };
          }
        }
        active = active.next;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      const tmpSum = computeSum(nodes2, sum, index2);
      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        const candidate = candidates[fitnessClass];
        if (candidate.demerits === Infinity)
          continue;
        const newNode = new LinkedList.Node(breakpoint(index2, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
        if (active !== null) {
          activeNodes.insertBefore(active, newNode);
        } else {
          activeNodes.push(newNode);
        }
      }
    }
  }
  nodes.forEach((node, index2, nodes2) => {
    if (node.type === "box") {
      sum.width += node.width;
      return;
    }
    if (node.type === "glue") {
      const precedesBox = index2 > 0 && nodes2[index2 - 1].type === "box";
      if (precedesBox)
        mainLoop(node, index2, nodes2);
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
      return;
    }
    if (node.type === "penalty" && node.penalty !== linebreak.infinity) {
      mainLoop(node, index2, nodes2);
    }
  });
  return findBestBreakpoints(activeNodes);
};
linebreak.infinity = 1e4;
linebreak.glue = (width, start2, end2, stretch, shrink) => ({
  type: "glue",
  start: start2,
  end: end2,
  width,
  stretch,
  shrink
});
linebreak.box = (width, start2, end2, hyphenated = false) => ({
  type: "box",
  width,
  start: start2,
  end: end2,
  hyphenated
});
linebreak.penalty = (width, penalty, flagged) => ({
  type: "penalty",
  width,
  penalty,
  flagged
});
var add = (index2, run) => {
  const start2 = run.start + index2;
  const end2 = run.end + index2;
  return Object.assign({}, run, { start: start2, end: end2 });
};
var length = (run) => {
  return run.end - run.start;
};
var concat3 = (runA, runB) => {
  const end2 = runA.end + length(runB);
  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  const positions = (runA.positions || []).concat(runB.positions || []);
  const attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  const runAIndices = runA.glyphIndices || [];
  const runALastIndex = last(runAIndices) || 0;
  const runBIndices = (runB.glyphIndices || []).map((i4) => i4 + runALastIndex + 1);
  const glyphIndices = normalize3(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end2,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
};
var insertGlyph$1 = (index2, glyph, run) => {
  if (!glyph)
    return run;
  const leadingRun = slice$1(0, index2, run);
  const trailingRun = slice$1(index2, Infinity, run);
  return concat3(append$1(glyph, leadingRun), trailingRun);
};
var insert = (index2, value2, run) => {
  const font = getFont(run);
  const glyph = isNumber3(value2) ? fromCodePoint(value2, font) : value2;
  return insertGlyph$1(index2, glyph, run);
};
var runIndexAt = (index2, attributedString) => {
  return runIndexAt$1(index2, attributedString.runs);
};
var insertGlyph = (index2, glyph, attributedString) => {
  const runIndex = runIndexAt(index2, attributedString);
  if (runIndex === -1)
    return append(glyph, attributedString);
  const codePoints = [glyph];
  const string = attributedString.string.slice(0, index2) + stringFromCodePoints(codePoints) + attributedString.string.slice(index2);
  const runs = attributedString.runs.map((run, i4) => {
    if (i4 === runIndex)
      return insert(index2 - run.start, glyph, run);
    if (i4 > runIndex)
      return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, { string, runs });
};
var advanceWidthBetween$1 = (start2, end2, run) => {
  const runStart = run.start || 0;
  const glyphStartIndex = Math.max(0, glyphIndexAt(start2 - runStart, run));
  const glyphEndIndex = Math.max(0, glyphIndexAt(end2 - runStart, run));
  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
};
var advanceWidthBetween = (start2, end2, attributedString) => {
  const runs = filter(start2, end2, attributedString.runs);
  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start2, end2, run), 0);
};
var HYPHEN2 = 45;
var TOLERANCE_STEPS = 5;
var TOLERANCE_LIMIT = 50;
var opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
var breakLines = (attributedString, nodes, breaks) => {
  let start2 = 0;
  let end2 = null;
  const lines = breaks.reduce((acc, breakPoint) => {
    const node = nodes[breakPoint];
    const prevNode = nodes[breakPoint - 1];
    if (breakPoint === nodes.length - 1)
      return acc;
    let line2;
    if (node.type === "penalty") {
      end2 = prevNode.end;
      line2 = slice3(start2, end2, attributedString);
      line2 = insertGlyph(line2.string.length, HYPHEN2, line2);
    } else {
      end2 = node.end;
      line2 = slice3(start2, end2, attributedString);
    }
    start2 = end2;
    return [...acc, line2];
  }, []);
  lines.push(slice3(start2, attributedString.string.length, attributedString));
  return lines;
};
var getNodes = (attributedString, { align }, options) => {
  let start2 = 0;
  const hyphenWidth = 5;
  const { syllables } = attributedString;
  const hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  const result = syllables.reduce((acc, s2, index2) => {
    const width = advanceWidthBetween(start2, start2 + s2.length, attributedString);
    if (s2.trim() === "") {
      const stretch = width * opts.width / opts.stretch;
      const shrink = width * opts.width / opts.shrink;
      const end2 = start2 + s2.length;
      acc.push(linebreak.glue(width, start2, end2, stretch, shrink));
    } else {
      const hyphenated = syllables[index2 + 1] !== " ";
      const end2 = start2 + s2.length;
      acc.push(linebreak.box(width, start2, end2, hyphenated));
      if (syllables[index2 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start2 += s2.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, start2, start2, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
};
var getAttributes = (attributedString) => {
  var _a, _b;
  return ((_b = (_a = attributedString.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
};
var linebreaker = (options) => {
  return (attributedString, availableWidths) => {
    let tolerance = options.tolerance || 4;
    const attributes2 = getAttributes(attributedString);
    const nodes = getNodes(attributedString, attributes2, options);
    let breaks = linebreak(nodes, availableWidths, tolerance);
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, tolerance);
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
};
var Direction;
(function(Direction3) {
  Direction3[Direction3["GROW"] = 0] = "GROW";
  Direction3[Direction3["SHRINK"] = 1] = "SHRINK";
})(Direction || (Direction = {}));
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var getCharFactor = (direction, options) => {
  const expandCharFactor = options.expandCharFactor || {};
  const shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
};
var getWhitespaceFactor = (direction, options) => {
  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  const shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
};
var factor = (direction, options) => (glyphs) => {
  const charFactor = getCharFactor(direction, options);
  const whitespaceFactor = getWhitespaceFactor(direction, options);
  const factors = [];
  for (let index2 = 0; index2 < glyphs.length; index2 += 1) {
    let f3;
    const glyph = glyphs[index2];
    if (isWhiteSpace(glyph)) {
      f3 = Object.assign({}, whitespaceFactor);
      if (index2 === glyphs.length - 1) {
        f3.before = 0;
        if (index2 > 0) {
          factors[index2 - 1].after = 0;
        }
      }
    } else if (glyph.isMark && index2 > 0) {
      f3 = Object.assign({}, factors[index2 - 1]);
      f3.before = 0;
      factors[index2 - 1].after = 0;
    } else {
      f3 = Object.assign({}, charFactor);
    }
    factors.push(f3);
  }
  return factors;
};
var getFactors = (gap, line2, options) => {
  const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;
  const getFactor = factor(direction, options);
  const factors = line2.runs.reduce((acc, run) => {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
};
var KASHIDA_PRIORITY = 0;
var NULL_PRIORITY = 3;
var getDistances = (gap, factors) => {
  let total = 0;
  const priorities = [];
  const unconstrained = [];
  for (let priority2 = KASHIDA_PRIORITY; priority2 <= NULL_PRIORITY; priority2 += 1) {
    priorities[priority2] = unconstrained[priority2] = 0;
  }
  for (let j = 0; j < factors.length; j += 1) {
    const f3 = factors[j];
    const sum = f3.before + f3.after;
    total += sum;
    priorities[f3.priority] += sum;
    if (f3.unconstrained) {
      unconstrained[f3.priority] += sum;
    }
  }
  let highestPriority = -1;
  let highestPrioritySum = 0;
  let remainingGap = gap;
  let priority;
  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {
    const prioritySum = priorities[priority];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority] = remainingGap / prioritySum;
        unconstrained[priority] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority] !== 0) {
        unconstrained[priority] = remainingGap / unconstrained[priority];
        remainingGap = 0;
        break;
      }
    }
  }
  for (let p3 = priority + 1; p3 <= NULL_PRIORITY; p3 += 1) {
    priorities[p3] = 0;
    unconstrained[p3] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  const distances = [];
  for (let index2 = 0; index2 < factors.length; index2 += 1) {
    const f3 = factors[index2];
    const next = factors[index2 + 1];
    let dist = f3.after * priorities[f3.priority];
    if (next) {
      dist += next.before * priorities[next.priority];
    }
    if (f3.unconstrained) {
      dist += f3.after * unconstrained[f3.priority];
      if (next) {
        dist += next.before * unconstrained[next.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
};
var justifyLine = (distances, line2) => {
  let index2 = 0;
  for (const run of line2.runs) {
    for (const position of run.positions) {
      position.xAdvance += distances[index2++];
    }
  }
  return line2;
};
var justification = (options) => {
  return (line2) => {
    const gap = line2.box.width - advanceWidth(line2);
    if (gap === 0)
      return line2;
    const factors = getFactors(gap, line2, options);
    const distances = getDistances(gap, factors);
    return justifyLine(distances, line2);
  };
};
var ascent = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, ascent$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
var BASE_FONT_SIZE = 12;
var textDecoration = () => (line2) => {
  let x = line2.overflowLeft || 0;
  const overflowRight = line2.overflowRight || 0;
  const maxX = advanceWidth(line2) - overflowRight;
  line2.decorationLines = [];
  for (let i4 = 0; i4 < line2.runs.length; i4 += 1) {
    const run = line2.runs[i4];
    const width = Math.min(maxX - x, advanceWidth$1(run));
    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
    if (run.attributes.underline) {
      const rect = {
        x,
        y: ascent(line2) + thickness * 2,
        width,
        height: thickness
      };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.underlineColor || "black",
        style: run.attributes.underlineStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    if (run.attributes.strike) {
      const y3 = ascent(line2) - ascent$1(run) / 3;
      const rect = { x, y: y3, width, height: thickness };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.strikeColor || "black",
        style: run.attributes.strikeStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    x += width;
  }
  return line2;
};
var ignoredScripts = ["Common", "Inherited", "Unknown"];
var scriptItemizer = () => {
  return (attributedString) => {
    const { string } = attributedString;
    let lastScript = "Unknown";
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    if (!string)
      return empty();
    for (let i4 = 0; i4 < string.length; i4 += 1) {
      const char = string[i4];
      const codePoint = char.codePointAt(0);
      const script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { script: lastScript }
          });
        }
        lastIndex = index2;
        lastScript = script;
      }
      index2 += char.length;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { script: lastScript }
      });
    }
    const result = { string, runs };
    return result;
  };
};
var SOFT_HYPHEN2 = "";
var hyphenator = (0, import_hyphen.default)(import_en_us.default);
var splitHyphen = (word) => {
  return word.split(SOFT_HYPHEN2);
};
var cache = {};
var getParts = (word) => {
  const base = word.includes(SOFT_HYPHEN2) ? word : hyphenator(word);
  return splitHyphen(base);
};
var wordHyphenation = () => {
  return (word) => {
    const cacheKey = `_${word}`;
    if (isNil(word))
      return [];
    if (cache[cacheKey])
      return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
};
var IGNORED_CODE_POINTS = [173];
var getFontSize = (run) => run.attributes.fontSize || 12;
var pickFontFromFontStack = (codePoint, fontStack, lastFont) => {
  if (IGNORED_CODE_POINTS.includes(codePoint))
    return lastFont;
  const fontStackWithFallback = [...fontStack, lastFont];
  for (let i4 = 0; i4 < fontStackWithFallback.length; i4 += 1) {
    const font = fontStackWithFallback[i4];
    if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
      return font;
    }
  }
  return fontStack.at(-1);
};
var fontSubstitution = () => ({ string, runs }) => {
  let lastFont = null;
  let lastFontSize = null;
  let lastIndex = 0;
  let index2 = 0;
  const res = [];
  for (let i4 = 0; i4 < runs.length; i4 += 1) {
    const run = runs[i4];
    if (string.length === 0) {
      res.push({
        start: 0,
        end: 0,
        attributes: { font: run.attributes.font }
      });
      break;
    }
    const chars = string.slice(run.start, run.end);
    for (let j = 0; j < chars.length; j += 1) {
      const char = chars[j];
      const codePoint = char.codePointAt(0);
      const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);
      const fontSize = getFontSize(run);
      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {
        if (lastFont) {
          res.push({
            start: lastIndex,
            end: index2,
            attributes: {
              font: [lastFont],
              scale: lastFontSize / lastFont.unitsPerEm
            }
          });
        }
        lastFont = font;
        lastFontSize = fontSize;
        lastIndex = index2;
      }
      index2 += char.length;
    }
  }
  if (lastIndex < string.length) {
    const fontSize = getFontSize(last(runs));
    res.push({
      start: lastIndex,
      end: string.length,
      attributes: {
        font: [lastFont],
        scale: fontSize / lastFont.unitsPerEm
      }
    });
  }
  return { string, runs: res };
};

// node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga4) {
    loadYoga4 = loadYoga4 || {};
    var h3;
    h3 || (h3 = typeof loadYoga4 !== "undefined" ? loadYoga4 : {});
    var aa, ca;
    h3.ready = new Promise(function(a4, b3) {
      aa = a4;
      ca = b3;
    });
    var da = Object.assign({}, h3), q = "";
    "undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
    _scriptDir && (q = _scriptDir);
    0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
    var ea = h3.print || console.log.bind(console), v3 = h3.printErr || console.warn.bind(console);
    Object.assign(h3, da);
    da = null;
    var w;
    h3.wasmBinary && (w = h3.wasmBinary);
    var noExitRuntime = h3.noExitRuntime || true;
    "object" != typeof WebAssembly && x("no native wasm support detected");
    var fa, ha = false;
    function z(a4, b3, c4) {
      c4 = b3 + c4;
      for (var d2 = ""; !(b3 >= c4); ) {
        var e4 = a4[b3++];
        if (!e4) break;
        if (e4 & 128) {
          var f3 = a4[b3++] & 63;
          if (192 == (e4 & 224)) d2 += String.fromCharCode((e4 & 31) << 6 | f3);
          else {
            var g3 = a4[b3++] & 63;
            e4 = 224 == (e4 & 240) ? (e4 & 15) << 12 | f3 << 6 | g3 : (e4 & 7) << 18 | f3 << 12 | g3 << 6 | a4[b3++] & 63;
            65536 > e4 ? d2 += String.fromCharCode(e4) : (e4 -= 65536, d2 += String.fromCharCode(55296 | e4 >> 10, 56320 | e4 & 1023));
          }
        } else d2 += String.fromCharCode(e4);
      }
      return d2;
    }
    var ia, ja, A, C, ka, D, E, la, ma;
    function na() {
      var a4 = fa.buffer;
      ia = a4;
      h3.HEAP8 = ja = new Int8Array(a4);
      h3.HEAP16 = C = new Int16Array(a4);
      h3.HEAP32 = D = new Int32Array(a4);
      h3.HEAPU8 = A = new Uint8Array(a4);
      h3.HEAPU16 = ka = new Uint16Array(a4);
      h3.HEAPU32 = E = new Uint32Array(a4);
      h3.HEAPF32 = la = new Float32Array(a4);
      h3.HEAPF64 = ma = new Float64Array(a4);
    }
    var oa, pa = [], qa = [], ra = [];
    function sa() {
      var a4 = h3.preRun.shift();
      pa.unshift(a4);
    }
    var F = 0, ta = null, G2 = null;
    function x(a4) {
      if (h3.onAbort) h3.onAbort(a4);
      a4 = "Aborted(" + a4 + ")";
      v3(a4);
      ha = true;
      a4 = new WebAssembly.RuntimeError(a4 + ". Build with -sASSERTIONS for more info.");
      ca(a4);
      throw a4;
    }
    function ua(a4) {
      return a4.startsWith("data:application/octet-stream;base64,");
    }
    var H;
    H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMk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AWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAF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ASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
    if (!ua(H)) {
      var va = H;
      H = h3.locateFile ? h3.locateFile(va, q) : q + va;
    }
    function wa() {
      var a4 = H;
      try {
        if (a4 == H && w) return new Uint8Array(w);
        if (ua(a4)) try {
          var b3 = xa(a4.slice(37)), c4 = new Uint8Array(b3.length);
          for (a4 = 0; a4 < b3.length; ++a4) c4[a4] = b3.charCodeAt(a4);
          var d2 = c4;
        } catch (f3) {
          throw Error("Converting base64 string to bytes failed.");
        }
        else d2 = void 0;
        var e4 = d2;
        if (e4) return e4;
        throw "both async and sync fetching of the wasm failed";
      } catch (f3) {
        x(f3);
      }
    }
    function ya() {
      return w || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa();
      }) : fetch(H, { credentials: "same-origin" }).then(function(a4) {
        if (!a4.ok) throw "failed to load wasm binary file at '" + H + "'";
        return a4.arrayBuffer();
      }).catch(function() {
        return wa();
      });
    }
    function za(a4) {
      for (; 0 < a4.length; ) a4.shift()(h3);
    }
    function Aa(a4) {
      if (void 0 === a4) return "_unknown";
      a4 = a4.replace(/[^a-zA-Z0-9_]/g, "$");
      var b3 = a4.charCodeAt(0);
      return 48 <= b3 && 57 >= b3 ? "_" + a4 : a4;
    }
    function Ba(a4, b3) {
      a4 = Aa(a4);
      return function() {
        return b3.apply(this, arguments);
      };
    }
    var J = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da(a4) {
      var b3 = Error, c4 = Ba(a4, function(d2) {
        this.name = a4;
        this.message = d2;
        d2 = Error(d2).stack;
        void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c4.prototype = Object.create(b3.prototype);
      c4.prototype.constructor = c4;
      c4.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c4;
    }
    var K = void 0;
    function L(a4) {
      throw new K(a4);
    }
    var M = (a4) => {
      a4 || L("Cannot use deleted val. handle = " + a4);
      return J[a4].value;
    }, Ea = (a4) => {
      switch (a4) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b3 = Ca.length ? Ca.pop() : J.length;
          J[b3] = { ga: 1, value: a4 };
          return b3;
      }
    }, Fa = void 0, Ga = void 0;
    function N(a4) {
      for (var b3 = ""; A[a4]; ) b3 += Ga[A[a4++]];
      return b3;
    }
    var O = [];
    function Ha() {
      for (; O.length; ) {
        var a4 = O.pop();
        a4.M.$ = false;
        a4["delete"]();
      }
    }
    var P = void 0, Q = {};
    function Ia(a4, b3) {
      for (void 0 === b3 && L("ptr should not be undefined"); a4.R; ) b3 = a4.ba(b3), a4 = a4.R;
      return b3;
    }
    var R = {};
    function Ja(a4) {
      a4 = Ka(a4);
      var b3 = N(a4);
      S3(a4);
      return b3;
    }
    function La(a4, b3) {
      var c4 = R[a4];
      void 0 === c4 && L(b3 + " has unknown type " + Ja(a4));
      return c4;
    }
    function Ma() {
    }
    var Na = false;
    function Oa(a4) {
      --a4.count.value;
      0 === a4.count.value && (a4.T ? a4.U.W(a4.T) : a4.P.N.W(a4.O));
    }
    function Pa(a4, b3, c4) {
      if (b3 === c4) return a4;
      if (void 0 === c4.R) return null;
      a4 = Pa(a4, b3, c4.R);
      return null === a4 ? null : c4.na(a4);
    }
    var Qa = {};
    function Ra(a4, b3) {
      b3 = Ia(a4, b3);
      return Q[b3];
    }
    var Sa = void 0;
    function Ta(a4) {
      throw new Sa(a4);
    }
    function Ua(a4, b3) {
      b3.P && b3.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b3.U !== !!b3.T && Ta("Both smartPtrType and smartPtr must be specified");
      b3.count = { value: 1 };
      return T(Object.create(a4, { M: { value: b3 } }));
    }
    function T(a4) {
      if ("undefined" === typeof FinalizationRegistry) return T = (b3) => b3, a4;
      Na = new FinalizationRegistry((b3) => {
        Oa(b3.M);
      });
      T = (b3) => {
        var c4 = b3.M;
        c4.T && Na.register(b3, { M: c4 }, b3);
        return b3;
      };
      Ma = (b3) => {
        Na.unregister(b3);
      };
      return T(a4);
    }
    var Va = {};
    function Wa(a4) {
      for (; a4.length; ) {
        var b3 = a4.pop();
        a4.pop()(b3);
      }
    }
    function Xa(a4) {
      return this.fromWireType(D[a4 >> 2]);
    }
    var U = {}, Ya = {};
    function V(a4, b3, c4) {
      function d2(k3) {
        k3 = c4(k3);
        k3.length !== a4.length && Ta("Mismatched type converter count");
        for (var m = 0; m < a4.length; ++m) W(a4[m], k3[m]);
      }
      a4.forEach(function(k3) {
        Ya[k3] = b3;
      });
      var e4 = Array(b3.length), f3 = [], g3 = 0;
      b3.forEach((k3, m) => {
        R.hasOwnProperty(k3) ? e4[m] = R[k3] : (f3.push(k3), U.hasOwnProperty(k3) || (U[k3] = []), U[k3].push(() => {
          e4[m] = R[k3];
          ++g3;
          g3 === f3.length && d2(e4);
        }));
      });
      0 === f3.length && d2(e4);
    }
    function Za(a4) {
      switch (a4) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a4);
      }
    }
    function W(a4, b3, c4 = {}) {
      if (!("argPackAdvance" in b3)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d2 = b3.name;
      a4 || L('type "' + d2 + '" must have a positive integer typeid pointer');
      if (R.hasOwnProperty(a4)) {
        if (c4.ua) return;
        L("Cannot register type '" + d2 + "' twice");
      }
      R[a4] = b3;
      delete Ya[a4];
      U.hasOwnProperty(a4) && (b3 = U[a4], delete U[a4], b3.forEach((e4) => e4()));
    }
    function $a(a4) {
      L(a4.M.P.N.name + " instance already deleted");
    }
    function X() {
    }
    function ab(a4, b3, c4) {
      if (void 0 === a4[b3].S) {
        var d2 = a4[b3];
        a4[b3] = function() {
          a4[b3].S.hasOwnProperty(arguments.length) || L("Function '" + c4 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a4[b3].S + ")!");
          return a4[b3].S[arguments.length].apply(this, arguments);
        };
        a4[b3].S = [];
        a4[b3].S[d2.Z] = d2;
      }
    }
    function bb(a4, b3) {
      h3.hasOwnProperty(a4) ? (L("Cannot register public name '" + a4 + "' twice"), ab(h3, a4, a4), h3.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h3[a4].S[void 0] = b3) : h3[a4] = b3;
    }
    function cb(a4, b3, c4, d2, e4, f3, g3, k3) {
      this.name = a4;
      this.constructor = b3;
      this.X = c4;
      this.W = d2;
      this.R = e4;
      this.pa = f3;
      this.ba = g3;
      this.na = k3;
      this.ja = [];
    }
    function db(a4, b3, c4) {
      for (; b3 !== c4; ) b3.ba || L("Expected null or instance of " + c4.name + ", got an instance of " + b3.name), a4 = b3.ba(a4), b3 = b3.R;
      return a4;
    }
    function eb(a4, b3) {
      if (null === b3) return this.ea && L("null is not a valid " + this.name), 0;
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function gb(a4, b3) {
      if (null === b3) {
        this.ea && L("null is not a valid " + this.name);
        if (this.da) {
          var c4 = this.fa();
          null !== a4 && a4.push(this.W, c4);
          return c4;
        }
        return 0;
      }
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b3.M.P.ca && L("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
      c4 = db(b3.M.O, b3.M.P.N, this.N);
      if (this.da) switch (void 0 === b3.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
        case 0:
          b3.M.U === this ? c4 = b3.M.T : L("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
          break;
        case 1:
          c4 = b3.M.T;
          break;
        case 2:
          if (b3.M.U === this) c4 = b3.M.T;
          else {
            var d2 = b3.clone();
            c4 = this.xa(c4, Ea(function() {
              d2["delete"]();
            }));
            null !== a4 && a4.push(this.W, c4);
          }
          break;
        default:
          L("Unsupporting sharing policy");
      }
      return c4;
    }
    function hb(a4, b3) {
      if (null === b3) return this.ea && L("null is not a valid " + this.name), 0;
      b3.M || L('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      b3.M.P.ca && L("Cannot convert argument of type " + b3.M.P.name + " to parameter type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function Y(a4, b3, c4, d2) {
      this.name = a4;
      this.N = b3;
      this.ea = c4;
      this.ca = d2;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b3.R ? this.toWireType = gb : (this.toWireType = d2 ? eb : hb, this.V = null);
    }
    function ib(a4, b3) {
      h3.hasOwnProperty(a4) || Ta("Replacing nonexistant public symbol");
      h3[a4] = b3;
      h3[a4].Z = void 0;
    }
    function jb(a4, b3) {
      var c4 = [];
      return function() {
        c4.length = 0;
        Object.assign(c4, arguments);
        if (a4.includes("j")) {
          var d2 = h3["dynCall_" + a4];
          d2 = c4 && c4.length ? d2.apply(null, [b3].concat(c4)) : d2.call(null, b3);
        } else d2 = oa.get(b3).apply(null, c4);
        return d2;
      };
    }
    function Z(a4, b3) {
      a4 = N(a4);
      var c4 = a4.includes("j") ? jb(a4, b3) : oa.get(b3);
      "function" != typeof c4 && L("unknown function pointer with signature " + a4 + ": " + b3);
      return c4;
    }
    var mb = void 0;
    function nb(a4, b3) {
      function c4(f3) {
        e4[f3] || R[f3] || (Ya[f3] ? Ya[f3].forEach(c4) : (d2.push(f3), e4[f3] = true));
      }
      var d2 = [], e4 = {};
      b3.forEach(c4);
      throw new mb(a4 + ": " + d2.map(Ja).join([", "]));
    }
    function ob(a4, b3, c4, d2, e4) {
      var f3 = b3.length;
      2 > f3 && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g3 = null !== b3[1] && null !== c4, k3 = false;
      for (c4 = 1; c4 < b3.length; ++c4) if (null !== b3[c4] && void 0 === b3[c4].V) {
        k3 = true;
        break;
      }
      var m = "void" !== b3[0].name, l2 = f3 - 2, n5 = Array(l2), p3 = [], r5 = [];
      return function() {
        arguments.length !== l2 && L("function " + a4 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
        r5.length = 0;
        p3.length = g3 ? 2 : 1;
        p3[0] = e4;
        if (g3) {
          var u4 = b3[1].toWireType(r5, this);
          p3[1] = u4;
        }
        for (var t4 = 0; t4 < l2; ++t4) n5[t4] = b3[t4 + 2].toWireType(r5, arguments[t4]), p3.push(n5[t4]);
        t4 = d2.apply(null, p3);
        if (k3) Wa(r5);
        else for (var y3 = g3 ? 1 : 2; y3 < b3.length; y3++) {
          var B = 1 === y3 ? u4 : n5[y3 - 2];
          null !== b3[y3].V && b3[y3].V(B);
        }
        u4 = m ? b3[0].fromWireType(t4) : void 0;
        return u4;
      };
    }
    function pb(a4, b3) {
      for (var c4 = [], d2 = 0; d2 < a4; d2++) c4.push(E[b3 + 4 * d2 >> 2]);
      return c4;
    }
    function qb(a4) {
      4 < a4 && 0 === --J[a4].ga && (J[a4] = void 0, Ca.push(a4));
    }
    function fb(a4) {
      if (null === a4) return "null";
      var b3 = typeof a4;
      return "object" === b3 || "array" === b3 || "function" === b3 ? a4.toString() : "" + a4;
    }
    function rb(a4, b3) {
      switch (b3) {
        case 2:
          return function(c4) {
            return this.fromWireType(la[c4 >> 2]);
          };
        case 3:
          return function(c4) {
            return this.fromWireType(ma[c4 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a4);
      }
    }
    function sb(a4, b3, c4) {
      switch (b3) {
        case 0:
          return c4 ? function(d2) {
            return ja[d2];
          } : function(d2) {
            return A[d2];
          };
        case 1:
          return c4 ? function(d2) {
            return C[d2 >> 1];
          } : function(d2) {
            return ka[d2 >> 1];
          };
        case 2:
          return c4 ? function(d2) {
            return D[d2 >> 2];
          } : function(d2) {
            return E[d2 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a4);
      }
    }
    function tb(a4, b3) {
      for (var c4 = "", d2 = 0; !(d2 >= b3 / 2); ++d2) {
        var e4 = C[a4 + 2 * d2 >> 1];
        if (0 == e4) break;
        c4 += String.fromCharCode(e4);
      }
      return c4;
    }
    function ub(a4, b3, c4) {
      void 0 === c4 && (c4 = 2147483647);
      if (2 > c4) return 0;
      c4 -= 2;
      var d2 = b3;
      c4 = c4 < 2 * a4.length ? c4 / 2 : a4.length;
      for (var e4 = 0; e4 < c4; ++e4) C[b3 >> 1] = a4.charCodeAt(e4), b3 += 2;
      C[b3 >> 1] = 0;
      return b3 - d2;
    }
    function vb(a4) {
      return 2 * a4.length;
    }
    function wb(a4, b3) {
      for (var c4 = 0, d2 = ""; !(c4 >= b3 / 4); ) {
        var e4 = D[a4 + 4 * c4 >> 2];
        if (0 == e4) break;
        ++c4;
        65536 <= e4 ? (e4 -= 65536, d2 += String.fromCharCode(55296 | e4 >> 10, 56320 | e4 & 1023)) : d2 += String.fromCharCode(e4);
      }
      return d2;
    }
    function xb(a4, b3, c4) {
      void 0 === c4 && (c4 = 2147483647);
      if (4 > c4) return 0;
      var d2 = b3;
      c4 = d2 + c4 - 4;
      for (var e4 = 0; e4 < a4.length; ++e4) {
        var f3 = a4.charCodeAt(e4);
        if (55296 <= f3 && 57343 >= f3) {
          var g3 = a4.charCodeAt(++e4);
          f3 = 65536 + ((f3 & 1023) << 10) | g3 & 1023;
        }
        D[b3 >> 2] = f3;
        b3 += 4;
        if (b3 + 4 > c4) break;
      }
      D[b3 >> 2] = 0;
      return b3 - d2;
    }
    function yb(a4) {
      for (var b3 = 0, c4 = 0; c4 < a4.length; ++c4) {
        var d2 = a4.charCodeAt(c4);
        55296 <= d2 && 57343 >= d2 && ++c4;
        b3 += 4;
      }
      return b3;
    }
    var zb = {};
    function Ab(a4) {
      var b3 = zb[a4];
      return void 0 === b3 ? N(a4) : b3;
    }
    var Bb = [];
    function Cb(a4) {
      var b3 = Bb.length;
      Bb.push(a4);
      return b3;
    }
    function Db(a4, b3) {
      for (var c4 = Array(a4), d2 = 0; d2 < a4; ++d2) c4[d2] = La(E[b3 + 4 * d2 >> 2], "parameter " + d2);
      return c4;
    }
    var Eb = [], Fb = [null, [], []];
    K = h3.BindingError = Da("BindingError");
    h3.count_emval_handles = function() {
      for (var a4 = 0, b3 = 5; b3 < J.length; ++b3) void 0 !== J[b3] && ++a4;
      return a4;
    };
    h3.get_first_emval = function() {
      for (var a4 = 5; a4 < J.length; ++a4) if (void 0 !== J[a4]) return J[a4];
      return null;
    };
    Fa = h3.PureVirtualError = Da("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h3.getInheritedInstanceCount = function() {
      return Object.keys(Q).length;
    };
    h3.getLiveInheritedInstances = function() {
      var a4 = [], b3;
      for (b3 in Q) Q.hasOwnProperty(b3) && a4.push(Q[b3]);
      return a4;
    };
    h3.flushPendingDeletes = Ha;
    h3.setDelayFunction = function(a4) {
      P = a4;
      O.length && P && P(Ha);
    };
    Sa = h3.InternalError = Da("InternalError");
    X.prototype.isAliasOf = function(a4) {
      if (!(this instanceof X && a4 instanceof X)) return false;
      var b3 = this.M.P.N, c4 = this.M.O, d2 = a4.M.P.N;
      for (a4 = a4.M.O; b3.R; ) c4 = b3.ba(c4), b3 = b3.R;
      for (; d2.R; ) a4 = d2.ba(a4), d2 = d2.R;
      return b3 === d2 && c4 === a4;
    };
    X.prototype.clone = function() {
      this.M.O || $a(this);
      if (this.M.aa) return this.M.count.value += 1, this;
      var a4 = T, b3 = Object, c4 = b3.create, d2 = Object.getPrototypeOf(this), e4 = this.M;
      a4 = a4(c4.call(b3, d2, { M: { value: { count: e4.count, $: e4.$, aa: e4.aa, O: e4.O, P: e4.P, T: e4.T, U: e4.U } } }));
      a4.M.count.value += 1;
      a4.M.$ = false;
      return a4;
    };
    X.prototype["delete"] = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      Ma(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X.prototype.deleteLater = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      O.push(this);
      1 === O.length && P && P(Ha);
      this.M.$ = true;
      return this;
    };
    Y.prototype.qa = function(a4) {
      this.ka && (a4 = this.ka(a4));
      return a4;
    };
    Y.prototype.ha = function(a4) {
      this.W && this.W(a4);
    };
    Y.prototype.argPackAdvance = 8;
    Y.prototype.readValueFromPointer = Xa;
    Y.prototype.deleteObject = function(a4) {
      if (null !== a4) a4["delete"]();
    };
    Y.prototype.fromWireType = function(a4) {
      function b3() {
        return this.da ? Ua(this.N.X, { P: this.wa, O: c4, U: this, T: a4 }) : Ua(this.N.X, { P: this, O: a4 });
      }
      var c4 = this.qa(a4);
      if (!c4) return this.ha(a4), null;
      var d2 = Ra(this.N, c4);
      if (void 0 !== d2) {
        if (0 === d2.M.count.value) return d2.M.O = c4, d2.M.T = a4, d2.clone();
        d2 = d2.clone();
        this.ha(a4);
        return d2;
      }
      d2 = this.N.pa(c4);
      d2 = Qa[d2];
      if (!d2) return b3.call(this);
      d2 = this.ca ? d2.la : d2.pointerType;
      var e4 = Pa(c4, this.N, d2.N);
      return null === e4 ? b3.call(this) : this.da ? Ua(d2.N.X, { P: d2, O: e4, U: this, T: a4 }) : Ua(d2.N.X, { P: d2, O: e4 });
    };
    mb = h3.UnboundTypeError = Da("UnboundTypeError");
    var xa = "function" == typeof atob ? atob : function(a4) {
      var b3 = "", c4 = 0;
      a4 = a4.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c4++));
        var e4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c4++));
        var f3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c4++));
        var g3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a4.charAt(c4++));
        d2 = d2 << 2 | e4 >> 4;
        e4 = (e4 & 15) << 4 | f3 >> 2;
        var k3 = (f3 & 3) << 6 | g3;
        b3 += String.fromCharCode(d2);
        64 !== f3 && (b3 += String.fromCharCode(e4));
        64 !== g3 && (b3 += String.fromCharCode(k3));
      } while (c4 < a4.length);
      return b3;
    }, Jb = {
      l: function(a4, b3, c4, d2) {
        x("Assertion failed: " + (a4 ? z(A, a4) : "") + ", at: " + [b3 ? b3 ? z(A, b3) : "" : "unknown filename", c4, d2 ? d2 ? z(A, d2) : "" : "unknown function"]);
      },
      q: function(a4, b3, c4) {
        a4 = N(a4);
        b3 = La(b3, "wrapper");
        c4 = M(c4);
        var d2 = [].slice, e4 = b3.N, f3 = e4.X, g3 = e4.R.X, k3 = e4.R.constructor;
        a4 = Ba(a4, function() {
          e4.R.ja.forEach((function(l2) {
            if (this[l2] === g3[l2]) throw new Fa("Pure virtual function " + l2 + " must be implemented in JavaScript");
          }).bind(this));
          Object.defineProperty(this, "__parent", { value: f3 });
          this.__construct.apply(this, d2.call(arguments));
        });
        f3.__construct = function() {
          this === f3 && L("Pass correct 'this' to __construct");
          var l2 = k3.implement.apply(void 0, [this].concat(d2.call(arguments)));
          Ma(l2);
          var n5 = l2.M;
          l2.notifyOnDestruction();
          n5.aa = true;
          Object.defineProperties(this, { M: { value: n5 } });
          T(this);
          l2 = n5.O;
          l2 = Ia(e4, l2);
          Q.hasOwnProperty(l2) ? L("Tried to register registered instance: " + l2) : Q[l2] = this;
        };
        f3.__destruct = function() {
          this === f3 && L("Pass correct 'this' to __destruct");
          Ma(this);
          var l2 = this.M.O;
          l2 = Ia(e4, l2);
          Q.hasOwnProperty(l2) ? delete Q[l2] : L("Tried to unregister unregistered instance: " + l2);
        };
        a4.prototype = Object.create(f3);
        for (var m in c4) a4.prototype[m] = c4[m];
        return Ea(a4);
      },
      j: function(a4) {
        var b3 = Va[a4];
        delete Va[a4];
        var c4 = b3.fa, d2 = b3.W, e4 = b3.ia, f3 = e4.map((g3) => g3.ta).concat(e4.map((g3) => g3.za));
        V([a4], f3, (g3) => {
          var k3 = {};
          e4.forEach((m, l2) => {
            var n5 = g3[l2], p3 = m.ra, r5 = m.sa, u4 = g3[l2 + e4.length], t4 = m.ya, y3 = m.Aa;
            k3[m.oa] = { read: (B) => n5.fromWireType(p3(r5, B)), write: (B, ba) => {
              var I = [];
              t4(
                y3,
                B,
                u4.toWireType(I, ba)
              );
              Wa(I);
            } };
          });
          return [{ name: b3.name, fromWireType: function(m) {
            var l2 = {}, n5;
            for (n5 in k3) l2[n5] = k3[n5].read(m);
            d2(m);
            return l2;
          }, toWireType: function(m, l2) {
            for (var n5 in k3) if (!(n5 in l2)) throw new TypeError('Missing field:  "' + n5 + '"');
            var p3 = c4();
            for (n5 in k3) k3[n5].write(p3, l2[n5]);
            null !== m && m.push(d2, p3);
            return p3;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d2 }];
        });
      },
      v: function() {
      },
      B: function(a4, b3, c4, d2, e4) {
        var f3 = Za(c4);
        b3 = N(b3);
        W(a4, {
          name: b3,
          fromWireType: function(g3) {
            return !!g3;
          },
          toWireType: function(g3, k3) {
            return k3 ? d2 : e4;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g3) {
            if (1 === c4) var k3 = ja;
            else if (2 === c4) k3 = C;
            else if (4 === c4) k3 = D;
            else throw new TypeError("Unknown boolean type size: " + b3);
            return this.fromWireType(k3[g3 >> f3]);
          },
          V: null
        });
      },
      f: function(a4, b3, c4, d2, e4, f3, g3, k3, m, l2, n5, p3, r5) {
        n5 = N(n5);
        f3 = Z(e4, f3);
        k3 && (k3 = Z(g3, k3));
        l2 && (l2 = Z(m, l2));
        r5 = Z(p3, r5);
        var u4 = Aa(n5);
        bb(u4, function() {
          nb("Cannot construct " + n5 + " due to unbound types", [d2]);
        });
        V([a4, b3, c4], d2 ? [d2] : [], function(t4) {
          t4 = t4[0];
          if (d2) {
            var y3 = t4.N;
            var B = y3.X;
          } else B = X.prototype;
          t4 = Ba(u4, function() {
            if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n5);
            if (void 0 === I.Y) throw new K(n5 + " has no accessible constructor");
            var kb = I.Y[arguments.length];
            if (void 0 === kb) throw new K("Tried to invoke ctor of " + n5 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba = Object.create(B, { constructor: { value: t4 } });
          t4.prototype = ba;
          var I = new cb(n5, t4, ba, r5, y3, f3, k3, l2);
          y3 = new Y(n5, I, true, false);
          B = new Y(n5 + "*", I, false, false);
          var lb = new Y(n5 + " const*", I, false, true);
          Qa[a4] = {
            pointerType: B,
            la: lb
          };
          ib(u4, t4);
          return [y3, B, lb];
        });
      },
      d: function(a4, b3, c4, d2, e4, f3, g3) {
        var k3 = pb(c4, d2);
        b3 = N(b3);
        f3 = Z(e4, f3);
        V([], [a4], function(m) {
          function l2() {
            nb("Cannot call " + n5 + " due to unbound types", k3);
          }
          m = m[0];
          var n5 = m.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          var p3 = m.N.constructor;
          void 0 === p3[b3] ? (l2.Z = c4 - 1, p3[b3] = l2) : (ab(p3, b3, n5), p3[b3].S[c4 - 1] = l2);
          V([], k3, function(r5) {
            r5 = ob(n5, [r5[0], null].concat(r5.slice(1)), null, f3, g3);
            void 0 === p3[b3].S ? (r5.Z = c4 - 1, p3[b3] = r5) : p3[b3].S[c4 - 1] = r5;
            return [];
          });
          return [];
        });
      },
      p: function(a4, b3, c4, d2, e4, f3) {
        0 < b3 || x();
        var g3 = pb(
          b3,
          c4
        );
        e4 = Z(d2, e4);
        V([], [a4], function(k3) {
          k3 = k3[0];
          var m = "constructor " + k3.name;
          void 0 === k3.N.Y && (k3.N.Y = []);
          if (void 0 !== k3.N.Y[b3 - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b3 - 1) + ") for class '" + k3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k3.N.Y[b3 - 1] = () => {
            nb("Cannot construct " + k3.name + " due to unbound types", g3);
          };
          V([], g3, function(l2) {
            l2.splice(1, 0, null);
            k3.N.Y[b3 - 1] = ob(m, l2, null, e4, f3);
            return [];
          });
          return [];
        });
      },
      a: function(a4, b3, c4, d2, e4, f3, g3, k3) {
        var m = pb(c4, d2);
        b3 = N(b3);
        f3 = Z(e4, f3);
        V([], [a4], function(l2) {
          function n5() {
            nb("Cannot call " + p3 + " due to unbound types", m);
          }
          l2 = l2[0];
          var p3 = l2.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          k3 && l2.N.ja.push(b3);
          var r5 = l2.N.X, u4 = r5[b3];
          void 0 === u4 || void 0 === u4.S && u4.className !== l2.name && u4.Z === c4 - 2 ? (n5.Z = c4 - 2, n5.className = l2.name, r5[b3] = n5) : (ab(r5, b3, p3), r5[b3].S[c4 - 2] = n5);
          V([], m, function(t4) {
            t4 = ob(p3, t4, l2, f3, g3);
            void 0 === r5[b3].S ? (t4.Z = c4 - 2, r5[b3] = t4) : r5[b3].S[c4 - 2] = t4;
            return [];
          });
          return [];
        });
      },
      A: function(a4, b3) {
        b3 = N(b3);
        W(
          a4,
          { name: b3, fromWireType: function(c4) {
            var d2 = M(c4);
            qb(c4);
            return d2;
          }, toWireType: function(c4, d2) {
            return Ea(d2);
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      },
      n: function(a4, b3, c4) {
        c4 = Za(c4);
        b3 = N(b3);
        W(a4, { name: b3, fromWireType: function(d2) {
          return d2;
        }, toWireType: function(d2, e4) {
          return e4;
        }, argPackAdvance: 8, readValueFromPointer: rb(b3, c4), V: null });
      },
      e: function(a4, b3, c4, d2, e4) {
        b3 = N(b3);
        -1 === e4 && (e4 = 4294967295);
        e4 = Za(c4);
        var f3 = (k3) => k3;
        if (0 === d2) {
          var g3 = 32 - 8 * c4;
          f3 = (k3) => k3 << g3 >>> g3;
        }
        c4 = b3.includes("unsigned") ? function(k3, m) {
          return m >>> 0;
        } : function(k3, m) {
          return m;
        };
        W(a4, { name: b3, fromWireType: f3, toWireType: c4, argPackAdvance: 8, readValueFromPointer: sb(b3, e4, 0 !== d2), V: null });
      },
      b: function(a4, b3, c4) {
        function d2(f3) {
          f3 >>= 2;
          var g3 = E;
          return new e4(ia, g3[f3 + 1], g3[f3]);
        }
        var e4 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b3];
        c4 = N(c4);
        W(a4, { name: c4, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { ua: true });
      },
      o: function(a4, b3) {
        b3 = N(b3);
        var c4 = "std::string" === b3;
        W(a4, { name: b3, fromWireType: function(d2) {
          var e4 = E[d2 >> 2], f3 = d2 + 4;
          if (c4) for (var g3 = f3, k3 = 0; k3 <= e4; ++k3) {
            var m = f3 + k3;
            if (k3 == e4 || 0 == A[m]) {
              g3 = g3 ? z(A, g3, m - g3) : "";
              if (void 0 === l2) var l2 = g3;
              else l2 += String.fromCharCode(0), l2 += g3;
              g3 = m + 1;
            }
          }
          else {
            l2 = Array(e4);
            for (k3 = 0; k3 < e4; ++k3) l2[k3] = String.fromCharCode(A[f3 + k3]);
            l2 = l2.join("");
          }
          S3(d2);
          return l2;
        }, toWireType: function(d2, e4) {
          e4 instanceof ArrayBuffer && (e4 = new Uint8Array(e4));
          var f3, g3 = "string" == typeof e4;
          g3 || e4 instanceof Uint8Array || e4 instanceof Uint8ClampedArray || e4 instanceof Int8Array || L("Cannot pass non-string to std::string");
          if (c4 && g3) {
            var k3 = 0;
            for (f3 = 0; f3 < e4.length; ++f3) {
              var m = e4.charCodeAt(f3);
              127 >= m ? k3++ : 2047 >= m ? k3 += 2 : 55296 <= m && 57343 >= m ? (k3 += 4, ++f3) : k3 += 3;
            }
            f3 = k3;
          } else f3 = e4.length;
          k3 = Ib(4 + f3 + 1);
          m = k3 + 4;
          E[k3 >> 2] = f3;
          if (c4 && g3) {
            if (g3 = m, m = f3 + 1, f3 = A, 0 < m) {
              m = g3 + m - 1;
              for (var l2 = 0; l2 < e4.length; ++l2) {
                var n5 = e4.charCodeAt(l2);
                if (55296 <= n5 && 57343 >= n5) {
                  var p3 = e4.charCodeAt(++l2);
                  n5 = 65536 + ((n5 & 1023) << 10) | p3 & 1023;
                }
                if (127 >= n5) {
                  if (g3 >= m) break;
                  f3[g3++] = n5;
                } else {
                  if (2047 >= n5) {
                    if (g3 + 1 >= m) break;
                    f3[g3++] = 192 | n5 >> 6;
                  } else {
                    if (65535 >= n5) {
                      if (g3 + 2 >= m) break;
                      f3[g3++] = 224 | n5 >> 12;
                    } else {
                      if (g3 + 3 >= m) break;
                      f3[g3++] = 240 | n5 >> 18;
                      f3[g3++] = 128 | n5 >> 12 & 63;
                    }
                    f3[g3++] = 128 | n5 >> 6 & 63;
                  }
                  f3[g3++] = 128 | n5 & 63;
                }
              }
              f3[g3] = 0;
            }
          } else if (g3) for (g3 = 0; g3 < f3; ++g3) l2 = e4.charCodeAt(g3), 255 < l2 && (S3(m), L("String has UTF-16 code units that do not fit in 8 bits")), A[m + g3] = l2;
          else for (g3 = 0; g3 < f3; ++g3) A[m + g3] = e4[g3];
          null !== d2 && d2.push(S3, k3);
          return k3;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d2) {
          S3(d2);
        } });
      },
      i: function(a4, b3, c4) {
        c4 = N(c4);
        if (2 === b3) {
          var d2 = tb;
          var e4 = ub;
          var f3 = vb;
          var g3 = () => ka;
          var k3 = 1;
        } else 4 === b3 && (d2 = wb, e4 = xb, f3 = yb, g3 = () => E, k3 = 2);
        W(a4, { name: c4, fromWireType: function(m) {
          for (var l2 = E[m >> 2], n5 = g3(), p3, r5 = m + 4, u4 = 0; u4 <= l2; ++u4) {
            var t4 = m + 4 + u4 * b3;
            if (u4 == l2 || 0 == n5[t4 >> k3]) r5 = d2(r5, t4 - r5), void 0 === p3 ? p3 = r5 : (p3 += String.fromCharCode(0), p3 += r5), r5 = t4 + b3;
          }
          S3(m);
          return p3;
        }, toWireType: function(m, l2) {
          "string" != typeof l2 && L("Cannot pass non-string to C++ string type " + c4);
          var n5 = f3(l2), p3 = Ib(4 + n5 + b3);
          E[p3 >> 2] = n5 >> k3;
          e4(l2, p3 + 4, n5 + b3);
          null !== m && m.push(S3, p3);
          return p3;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m) {
          S3(m);
        } });
      },
      k: function(a4, b3, c4, d2, e4, f3) {
        Va[a4] = { name: N(b3), fa: Z(c4, d2), W: Z(e4, f3), ia: [] };
      },
      h: function(a4, b3, c4, d2, e4, f3, g3, k3, m, l2) {
        Va[a4].ia.push({ oa: N(b3), ta: c4, ra: Z(d2, e4), sa: f3, za: g3, ya: Z(k3, m), Aa: l2 });
      },
      C: function(a4, b3) {
        b3 = N(b3);
        W(a4, {
          va: true,
          name: b3,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      s: function(a4, b3, c4, d2, e4) {
        a4 = Bb[a4];
        b3 = M(b3);
        c4 = Ab(c4);
        var f3 = [];
        E[d2 >> 2] = Ea(f3);
        return a4(b3, c4, f3, e4);
      },
      t: function(a4, b3, c4, d2) {
        a4 = Bb[a4];
        b3 = M(b3);
        c4 = Ab(c4);
        a4(b3, c4, null, d2);
      },
      g: qb,
      m: function(a4, b3) {
        var c4 = Db(a4, b3), d2 = c4[0];
        b3 = d2.name + "_$" + c4.slice(1).map(function(g3) {
          return g3.name;
        }).join("_") + "$";
        var e4 = Eb[b3];
        if (void 0 !== e4) return e4;
        var f3 = Array(a4 - 1);
        e4 = Cb((g3, k3, m, l2) => {
          for (var n5 = 0, p3 = 0; p3 < a4 - 1; ++p3) f3[p3] = c4[p3 + 1].readValueFromPointer(l2 + n5), n5 += c4[p3 + 1].argPackAdvance;
          g3 = g3[k3].apply(
            g3,
            f3
          );
          for (p3 = 0; p3 < a4 - 1; ++p3) c4[p3 + 1].ma && c4[p3 + 1].ma(f3[p3]);
          if (!d2.va) return d2.toWireType(m, g3);
        });
        return Eb[b3] = e4;
      },
      D: function(a4) {
        4 < a4 && (J[a4].ga += 1);
      },
      r: function(a4) {
        var b3 = M(a4);
        Wa(b3);
        qb(a4);
      },
      c: function() {
        x("");
      },
      x: function(a4, b3, c4) {
        A.copyWithin(a4, b3, b3 + c4);
      },
      w: function(a4) {
        var b3 = A.length;
        a4 >>>= 0;
        if (2147483648 < a4) return false;
        for (var c4 = 1; 4 >= c4; c4 *= 2) {
          var d2 = b3 * (1 + 0.2 / c4);
          d2 = Math.min(d2, a4 + 100663296);
          var e4 = Math;
          d2 = Math.max(a4, d2);
          e4 = e4.min.call(e4, 2147483648, d2 + (65536 - d2 % 65536) % 65536);
          a: {
            try {
              fa.grow(e4 - ia.byteLength + 65535 >>> 16);
              na();
              var f3 = 1;
              break a;
            } catch (g3) {
            }
            f3 = void 0;
          }
          if (f3) return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a4, b3, c4, d2) {
        for (var e4 = 0, f3 = 0; f3 < c4; f3++) {
          var g3 = E[b3 >> 2], k3 = E[b3 + 4 >> 2];
          b3 += 8;
          for (var m = 0; m < k3; m++) {
            var l2 = A[g3 + m], n5 = Fb[a4];
            0 === l2 || 10 === l2 ? ((1 === a4 ? ea : v3)(z(n5, 0)), n5.length = 0) : n5.push(l2);
          }
          e4 += k3;
        }
        E[d2 >> 2] = e4;
        return 0;
      }
    };
    (function() {
      function a4(e4) {
        h3.asm = e4.exports;
        fa = h3.asm.E;
        na();
        oa = h3.asm.J;
        qa.unshift(h3.asm.F);
        F--;
        h3.monitorRunDependencies && h3.monitorRunDependencies(F);
        0 == F && (null !== ta && (clearInterval(ta), ta = null), G2 && (e4 = G2, G2 = null, e4()));
      }
      function b3(e4) {
        a4(e4.instance);
      }
      function c4(e4) {
        return ya().then(function(f3) {
          return WebAssembly.instantiate(f3, d2);
        }).then(function(f3) {
          return f3;
        }).then(e4, function(f3) {
          v3("failed to asynchronously prepare wasm: " + f3);
          x(f3);
        });
      }
      var d2 = { a: Jb };
      F++;
      h3.monitorRunDependencies && h3.monitorRunDependencies(F);
      if (h3.instantiateWasm) try {
        return h3.instantiateWasm(
          d2,
          a4
        );
      } catch (e4) {
        v3("Module.instantiateWasm callback failed with error: " + e4), ca(e4);
      }
      (function() {
        return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c4(b3) : fetch(H, { credentials: "same-origin" }).then(function(e4) {
          return WebAssembly.instantiateStreaming(e4, d2).then(b3, function(f3) {
            v3("wasm streaming compile failed: " + f3);
            v3("falling back to ArrayBuffer instantiation");
            return c4(b3);
          });
        });
      })().catch(ca);
      return {};
    })();
    h3.___wasm_call_ctors = function() {
      return (h3.___wasm_call_ctors = h3.asm.F).apply(null, arguments);
    };
    var Ka = h3.___getTypeName = function() {
      return (Ka = h3.___getTypeName = h3.asm.G).apply(null, arguments);
    };
    h3.__embind_initialize_bindings = function() {
      return (h3.__embind_initialize_bindings = h3.asm.H).apply(null, arguments);
    };
    var Ib = h3._malloc = function() {
      return (Ib = h3._malloc = h3.asm.I).apply(null, arguments);
    }, S3 = h3._free = function() {
      return (S3 = h3._free = h3.asm.K).apply(null, arguments);
    };
    h3.dynCall_jiji = function() {
      return (h3.dynCall_jiji = h3.asm.L).apply(null, arguments);
    };
    var Kb;
    G2 = function Lb() {
      Kb || Mb();
      Kb || (G2 = Lb);
    };
    function Mb() {
      function a4() {
        if (!Kb && (Kb = true, h3.calledRun = true, !ha)) {
          za(qa);
          aa(h3);
          if (h3.onRuntimeInitialized) h3.onRuntimeInitialized();
          if (h3.postRun) for ("function" == typeof h3.postRun && (h3.postRun = [h3.postRun]); h3.postRun.length; ) {
            var b3 = h3.postRun.shift();
            ra.unshift(b3);
          }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h3.preRun) for ("function" == typeof h3.preRun && (h3.preRun = [h3.preRun]); h3.preRun.length; ) sa();
        za(pa);
        0 < F || (h3.setStatus ? (h3.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h3.setStatus("");
          }, 1);
          a4();
        }, 1)) : a4());
      }
    }
    if (h3.preInit) for ("function" == typeof h3.preInit && (h3.preInit = [h3.preInit]); 0 < h3.preInit.length; ) h3.preInit.pop()();
    Mb();
    return loadYoga4.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// node_modules/yoga-layout/dist/src/generated/YGEnums.js
var Align = function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var BoxSizing = function(BoxSizing2) {
  BoxSizing2[BoxSizing2["BorderBox"] = 0] = "BorderBox";
  BoxSizing2[BoxSizing2["ContentBox"] = 1] = "ContentBox";
  return BoxSizing2;
}({});
var Dimension = function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction2 = function(Direction3) {
  Direction3[Direction3["Inherit"] = 0] = "Inherit";
  Direction3[Direction3["LTR"] = 1] = "LTR";
  Direction3[Direction3["RTL"] = 2] = "RTL";
  return Direction3;
}({});
var Display = function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  Display2[Display2["Contents"] = 2] = "Contents";
  return Display2;
}({});
var Edge = function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants2 = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
  BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction2.Inherit,
  DIRECTION_LTR: Direction2.LTR,
  DIRECTION_RTL: Direction2.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  DISPLAY_CONTENTS: Display.Contents,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants2;

// node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib3) {
  function patch(prototype, name, fn) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib3.Node.prototype[fnName],
      [Unit.Percent]: lib3.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib3.Node.prototype[`${fnName}Auto`]
    };
    patch(lib3.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value2 = args.pop();
      let unit, asNumber;
      if (value2 === "auto") {
        unit = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value2 === "object") {
        unit = value2.unit;
        asNumber = value2.valueOf();
      } else {
        unit = typeof value2 === "string" && value2.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value2);
        if (value2 !== void 0 && !Number.isNaN(value2) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value2} for ${fnName}`);
        }
      }
      if (!methods[unit]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value2}'`);
      if (asNumber !== void 0) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib3.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height: height2
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height2 ?? NaN
        };
      }
    });
  }
  patch(lib3.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib3.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib3.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib3.Config.prototype, "free", function() {
    lib3.Config.destroy(this);
  });
  patch(lib3.Node, "create", (_, config3) => {
    return config3 ? lib3.Node.createWithConfig(config3) : lib3.Node.createDefault();
  });
  patch(lib3.Node.prototype, "free", function() {
    lib3.Node.destroy(this);
  });
  patch(lib3.Node.prototype, "freeRecursive", function() {
    for (let t4 = 0, T = this.getChildCount(); t4 < T; ++t4) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib3.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction2.LTR;
    return original.call(this, width, height2, direction);
  });
  return {
    Config: lib3.Config,
    Node: lib3.Node,
    ...YGEnums_default
  };
}

// node_modules/yoga-layout/dist/src/load.js
async function loadYoga2() {
  return wrapAssembly(await yoga_wasm_base64_esm_default());
}

// node_modules/emoji-regex-xs/index.mjs
var r = String.raw;
var seq = r`(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})`;
var sTags = r`\u{E0061}-\u{E007A}`;
var emoji_regex_xs_default = () => new RegExp(r`[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[${sTags}]{2}[\u{E0030}-\u{E0039}${sTags}]{1,3}\u{E007F}|${seq}(?:\u200D${seq})*`, "gu");

// node_modules/@react-pdf/image/lib/index.browser.js
var global$13 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup3 = [];
var revLookup3 = [];
var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited3 = false;
function init3() {
  inited3 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup3[i4] = code[i4];
    revLookup3[code.charCodeAt(i4)] = i4;
  }
  revLookup3["-".charCodeAt(0)] = 62;
  revLookup3["_".charCodeAt(0)] = 63;
}
function toByteArray3(b64) {
  if (!inited3) {
    init3();
  }
  var i4, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr3(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i4 = 0, j = 0; i4 < l2; i4 += 4, j += 3) {
    tmp = revLookup3[b64.charCodeAt(i4)] << 18 | revLookup3[b64.charCodeAt(i4 + 1)] << 12 | revLookup3[b64.charCodeAt(i4 + 2)] << 6 | revLookup3[b64.charCodeAt(i4 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup3[b64.charCodeAt(i4)] << 2 | revLookup3[b64.charCodeAt(i4 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup3[b64.charCodeAt(i4)] << 10 | revLookup3[b64.charCodeAt(i4 + 1)] << 4 | revLookup3[b64.charCodeAt(i4 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase643(num) {
  return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
}
function encodeChunk3(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i4 = start2; i4 < end2; i4 += 3) {
    tmp = (uint82[i4] << 16) + (uint82[i4 + 1] << 8) + uint82[i4 + 2];
    output.push(tripletToBase643(tmp));
  }
  return output.join("");
}
function fromByteArray3(uint82) {
  if (!inited3) {
    init3();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len2 = len - extraBytes; i4 < len2; i4 += maxChunkLength) {
    parts.push(encodeChunk3(uint82, i4, i4 + maxChunkLength > len2 ? len2 : i4 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup3[tmp >> 2];
    output += lookup3[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup3[tmp >> 10];
    output += lookup3[tmp >> 4 & 63];
    output += lookup3[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read3(buffer, offset2, isLE, mLen, nBytes) {
  var e4, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i4];
  i4 += d2;
  e4 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e4 = e4 * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  m = e4 & (1 << -nBits) - 1;
  e4 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset2 + i4], i4 += d2, nBits -= 8) {
  }
  if (e4 === 0) {
    e4 = 1 - eBias;
  } else if (e4 === eMax) {
    return m ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e4 = e4 - eBias;
  }
  return (s2 ? -1 : 1) * m * Math.pow(2, e4 - mLen);
}
function write5(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e4, m, c4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m = isNaN(value2) ? 1 : 0;
    e4 = eMax;
  } else {
    e4 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c4 = Math.pow(2, -e4)) < 1) {
      e4--;
      c4 *= 2;
    }
    if (e4 + eBias >= 1) {
      value2 += rt / c4;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c4 >= 2) {
      e4++;
      c4 /= 2;
    }
    if (e4 + eBias >= eMax) {
      m = 0;
      e4 = eMax;
    } else if (e4 + eBias >= 1) {
      m = (value2 * c4 - 1) * Math.pow(2, mLen);
      e4 = e4 + eBias;
    } else {
      m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e4 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i4] = m & 255, i4 += d2, m /= 256, mLen -= 8) {
  }
  e4 = e4 << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i4] = e4 & 255, i4 += d2, e4 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i4 - d2] |= s2 * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES3 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$13.TYPED_ARRAY_SUPPORT !== void 0 ? global$13.TYPED_ARRAY_SUPPORT : true;
kMaxLength3();
function kMaxLength3() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer3(that, length2) {
  if (kMaxLength3() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer4(arg, encodingOrOffset, length2) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe3(this, arg);
  }
  return from3(this, arg, encodingOrOffset, length2);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from3(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer3(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString3(that, value2, encodingOrOffset);
  }
  return fromObject3(that, value2);
}
Buffer4.from = function(value2, encodingOrOffset, length2) {
  return from3(null, value2, encodingOrOffset, length2);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) ;
}
function assertSize3(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc3(that, size, fill4, encoding) {
  assertSize3(size);
  if (size <= 0) {
    return createBuffer3(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer3(that, size).fill(fill4, encoding) : createBuffer3(that, size).fill(fill4);
  }
  return createBuffer3(that, size);
}
Buffer4.alloc = function(size, fill4, encoding) {
  return alloc3(null, size, fill4, encoding);
};
function allocUnsafe3(that, size) {
  assertSize3(size);
  that = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i4 = 0; i4 < size; ++i4) {
      that[i4] = 0;
    }
  }
  return that;
}
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe3(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe3(null, size);
};
function fromString3(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength4(string, encoding) | 0;
  that = createBuffer3(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike3(that, array) {
  var length2 = array.length < 0 ? 0 : checked3(array.length) | 0;
  that = createBuffer3(that, length2);
  for (var i4 = 0; i4 < length2; i4 += 1) {
    that[i4] = array[i4] & 255;
  }
  return that;
}
function fromArrayBuffer3(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike3(that, array);
  }
  return that;
}
function fromObject3(that, obj) {
  if (internalIsBuffer3(obj)) {
    var len = checked3(obj.length) | 0;
    that = createBuffer3(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan3(obj.length)) {
        return createBuffer3(that, 0);
      }
      return fromArrayLike3(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike3(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked3(length2) {
  if (length2 >= kMaxLength3()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3().toString(16) + " bytes");
  }
  return length2 | 0;
}
Buffer4.isBuffer = isBuffer$13;
function internalIsBuffer3(b3) {
  return !!(b3 != null && b3._isBuffer);
}
Buffer4.compare = function compare7(a4, b3) {
  if (!internalIsBuffer3(a4) || !internalIsBuffer3(b3)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a4 === b3) return 0;
  var x = a4.length;
  var y3 = b3.length;
  for (var i4 = 0, len = Math.min(x, y3); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x = a4[i4];
      y3 = b3[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
Buffer4.isEncoding = function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer4.concat = function concat4(list, length2) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i4;
  if (length2 === void 0) {
    length2 = 0;
    for (i4 = 0; i4 < list.length; ++i4) {
      length2 += list[i4].length;
    }
  }
  var buffer = Buffer4.allocUnsafe(length2);
  var pos = 0;
  for (i4 = 0; i4 < list.length; ++i4) {
    var buf = list[i4];
    if (!internalIsBuffer3(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (internalIsBuffer3(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes3(string).length;
      default:
        if (loweredCase) return utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.byteLength = byteLength4;
function slowToString3(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice3(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice3(this, start2, end2);
      case "ascii":
        return asciiSlice3(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice3(this, start2, end2);
      case "base64":
        return base64Slice3(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice3(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.prototype._isBuffer = true;
function swap3(b3, n5, m) {
  var i4 = b3[n5];
  b3[n5] = b3[m];
  b3[m] = i4;
}
Buffer4.prototype.swap16 = function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 2) {
    swap3(this, i4, i4 + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 4) {
    swap3(this, i4, i4 + 3);
    swap3(this, i4 + 1, i4 + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i4 = 0; i4 < len; i4 += 8) {
    swap3(this, i4, i4 + 7);
    swap3(this, i4 + 1, i4 + 6);
    swap3(this, i4 + 2, i4 + 5);
    swap3(this, i4 + 3, i4 + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString6() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice3(this, 0, length2);
  return slowToString3.apply(this, arguments);
};
Buffer4.prototype.equals = function equals3(b3) {
  if (!internalIsBuffer3(b3)) throw new TypeError("Argument must be a Buffer");
  if (this === b3) return true;
  return Buffer4.compare(this, b3) === 0;
};
Buffer4.prototype.inspect = function inspect5() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES3;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare8(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer3(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y3 = end2 - start2;
  var len = Math.min(x, y3);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i4 = 0; i4 < len; ++i4) {
    if (thisCopy[i4] !== targetCopy[i4]) {
      x = thisCopy[i4];
      y3 = targetCopy[i4];
      break;
    }
  }
  if (x < y3) return -1;
  if (y3 < x) return 1;
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer3(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf3(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf3(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf3(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i5) {
    if (indexSize === 1) {
      return buf[i5];
    } else {
      return buf.readUInt16BE(i5 * indexSize);
    }
  }
  var i4;
  if (dir) {
    var foundIndex = -1;
    for (i4 = byteOffset; i4 < arrLength; i4++) {
      if (read4(arr, i4) === read4(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i4 = byteOffset; i4 >= 0; i4--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i4 + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i4;
    }
  }
  return -1;
}
Buffer4.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
function hexWrite3(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i4 = 0; i4 < length2; ++i4) {
    var parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (isNaN(parsed)) return i4;
    buf[offset2 + i4] = parsed;
  }
  return i4;
}
function utf8Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf8ToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite3(buf, string, offset2, length2) {
  return blitBuffer3(asciiToBytes3(string), buf, offset2, length2);
}
function latin1Write3(buf, string, offset2, length2) {
  return asciiWrite3(buf, string, offset2, length2);
}
function base64Write3(buf, string, offset2, length2) {
  return blitBuffer3(base64ToBytes3(string), buf, offset2, length2);
}
function ucs2Write3(buf, string, offset2, length2) {
  return blitBuffer3(utf16leToBytes3(string, buf.length - offset2), buf, offset2, length2);
}
Buffer4.prototype.write = function write6(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite3(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write3(this, string, offset2, length2);
      case "ascii":
        return asciiWrite3(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write3(this, string, offset2, length2);
      case "base64":
        return base64Write3(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write3(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice3(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray3(buf);
  } else {
    return fromByteArray3(buf.slice(start2, end2));
  }
}
function utf8Slice3(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i4 = start2;
  while (i4 < end2) {
    var firstByte = buf[i4];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i4 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          fourthByte = buf[i4 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i4 += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i4 = 0;
  while (i4 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH3)
    );
  }
  return res;
}
function asciiSlice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4] & 127);
  }
  return ret;
}
function latin1Slice3(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i4 = start2; i4 < end2; ++i4) {
    ret += String.fromCharCode(buf[i4]);
  }
  return ret;
}
function hexSlice3(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i4 = start2; i4 < end2; ++i4) {
    out += toHex3(buf[i4]);
  }
  return out;
}
function utf16leSlice3(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i4 = 0; i4 < bytes.length; i4 += 2) {
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  }
  return res;
}
Buffer4.prototype.slice = function slice4(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i4 = 0; i4 < sliceLen; ++i4) {
      newBuf[i4] = this[i4 + start2];
    }
  }
  return newBuf;
};
function checkOffset3(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset3(offset2, byteLength5, this.length);
  }
  var val = this[offset2 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength5] * mul;
  }
  return val;
};
Buffer4.prototype.readUInt8 = function readUInt84(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  return this[offset2];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var val = this[offset2];
  var mul = 1;
  var i4 = 0;
  while (++i4 < byteLength5 && (mul *= 256)) {
    val += this[offset2 + i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readIntBE = function readIntBE3(offset2, byteLength5, noAssert) {
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset2, byteLength5, this.length);
  var i4 = byteLength5;
  var mul = 1;
  var val = this[offset2 + --i4];
  while (i4 > 0 && (mul *= 256)) {
    val += this[offset2 + --i4] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readInt8 = function readInt83(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 4, this.length);
  return read3(this, offset2, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE3(offset2, noAssert) {
  if (!noAssert) checkOffset3(offset2, 8, this.length);
  return read3(this, offset2, false, 52, 8);
};
function checkInt3(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer3(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i4 = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset2, byteLength5, maxBytes, 0);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    this[offset2 + i4] = value2 / mul & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeUInt8 = function writeUInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt163(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 2); i4 < j; ++i4) {
    buf[offset2 + i4] = (value2 & 255 << 8 * (littleEndian ? i4 : 1 - i4)) >>> (littleEndian ? i4 : 1 - i4) * 8;
  }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt323(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i4 = 0, j = Math.min(buf.length - offset2, 4); i4 < j; ++i4) {
    buf[offset2 + i4] = value2 >>> (littleEndian ? i4 : 3 - i4) * 8 & 255;
  }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i4 < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeIntBE = function writeIntBE3(value2, offset2, byteLength5, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset2, byteLength5, limit - 1, -limit);
  }
  var i4 = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i4] = value2 & 255;
  while (--i4 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i4 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength5;
};
Buffer4.prototype.writeInt8 = function writeInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt323(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt3(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE7543(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 4);
  }
  write5(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE3(value2, offset2, noAssert) {
  return writeFloat3(this, value2, offset2, false, noAssert);
};
function writeDouble3(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset2, 8);
  }
  write5(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE3(value2, offset2, noAssert) {
  return writeDouble3(this, value2, offset2, false, noAssert);
};
Buffer4.prototype.copy = function copy4(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i4;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i4 = len - 1; i4 >= 0; --i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i4 = 0; i4 < len; ++i4) {
      target[i4 + targetStart] = this[i4 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer4.prototype.fill = function fill3(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i4;
  if (typeof val === "number") {
    for (i4 = start2; i4 < end2; ++i4) {
      this[i4] = val;
    }
  } else {
    var bytes = internalIsBuffer3(val) ? val : utf8ToBytes3(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i4 = 0; i4 < end2 - start2; ++i4) {
      this[i4 + start2] = bytes[i4 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE3 = /[^+\/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = stringtrim3(str).replace(INVALID_BASE64_RE3, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim3(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex3(n5) {
  if (n5 < 16) return "0" + n5.toString(16);
  return n5.toString(16);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i4 = 0; i4 < length2; ++i4) {
    codePoint = string.charCodeAt(i4);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes3(str) {
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    byteArray.push(str.charCodeAt(i4) & 255);
  }
  return byteArray;
}
function utf16leToBytes3(str, units) {
  var c4, hi, lo;
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    if ((units -= 2) < 0) break;
    c4 = str.charCodeAt(i4);
    hi = c4 >> 8;
    lo = c4 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes3(str) {
  return toByteArray3(base64clean3(str));
}
function blitBuffer3(src, dst, offset2, length2) {
  for (var i4 = 0; i4 < length2; ++i4) {
    if (i4 + offset2 >= dst.length || i4 >= src.length) break;
    dst[i4 + offset2] = src[i4];
  }
  return i4;
}
function isnan3(val) {
  return val !== val;
}
function isBuffer$13(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer3(obj) || isSlowBuffer3(obj));
}
function isFastBuffer3(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer3(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer3(obj.slice(0, 0));
}
var PNG2 = class {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    const png = new PNG(data2);
    this.data = data2;
    this.width = png.width;
    this.height = png.height;
    this.format = "png";
  }
  static isValid(data2) {
    return data2 && Buffer4.isBuffer(data2) && data2[0] === 137 && data2[1] === 80 && data2[2] === 78 && data2[3] === 71 && data2[4] === 13 && data2[5] === 10 && data2[6] === 26 && data2[7] === 10;
  }
};
var JPEG3 = class {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    this.data = data2;
    this.format = "jpeg";
    this.width = 0;
    this.height = 0;
    if (data2.readUInt16BE(0) !== 65496) {
      throw new Error("SOI not found in JPEG");
    }
    const markers = src_default.decode(this.data);
    let orientation;
    for (let i4 = 0; i4 < markers.length; i4 += 1) {
      const marker = markers[i4];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
      }
    }
    if (orientation > 4) {
      [this.width, this.height] = [this.height, this.width];
    }
  }
  static isValid(data2) {
    return data2 && Buffer4.isBuffer(data2) && data2.readUInt16BE(0) === 65496;
  }
};
var createCache = ({ limit = 100 } = {}) => {
  let cache2 = /* @__PURE__ */ new Map();
  return {
    get: (key) => key ? cache2.get(key) ?? void 0 : null,
    set: (key, value2) => {
      cache2.delete(key);
      if (cache2.size >= limit) {
        const firstKey = cache2.keys().next().value;
        cache2.delete(firstKey);
      }
      cache2.set(key, value2);
    },
    reset: () => {
      cache2 = /* @__PURE__ */ new Map();
    },
    length: () => cache2.size
  };
};
var IMAGE_CACHE = createCache({ limit: 30 });
var isBuffer3 = Buffer4.isBuffer;
var isBlob = (src) => {
  return typeof Blob !== "undefined" && src instanceof Blob;
};
var isDataImageSrc = (src) => {
  return "data" in src;
};
var isDataUri = (imageSrc) => "uri" in imageSrc && imageSrc.uri.startsWith("data:");
var fetchRemoteFile = async (src) => {
  const { method = "GET", headers, body, credentials } = src;
  const response = await fetch(src.uri, {
    method,
    headers,
    body,
    credentials
  });
  const buffer = await response.arrayBuffer();
  return Buffer4.from(buffer);
};
var isValidFormat = (format3) => {
  const lower = format3.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
};
var getImageFormat = (buffer) => {
  let format3;
  if (JPEG3.isValid(buffer)) {
    format3 = "jpg";
  } else if (PNG2.isValid(buffer)) {
    format3 = "png";
  }
  return format3;
};
function getImage(body, format3) {
  switch (format3.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG3(body);
    case "png":
      return new PNG2(body);
    default:
      return null;
  }
}
var resolveBase64Image = async ({ uri }) => {
  const match = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  if (!match)
    throw new Error(`Invalid base64 image: ${uri}`);
  const format3 = match[1];
  const data2 = match[2];
  if (!isValidFormat(format3))
    throw new Error(`Base64 image invalid format: ${format3}`);
  return getImage(Buffer4.from(data2, "base64"), format3);
};
var resolveImageFromData = async (src) => {
  if (src.data && src.format) {
    return getImage(src.data, src.format);
  }
  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);
};
var resolveBufferImage = async (buffer) => {
  const format3 = getImageFormat(buffer);
  if (format3) {
    return getImage(buffer, format3);
  }
  return null;
};
var resolveBlobImage = async (blob) => {
  const { type } = blob;
  if (!type || type === "application/octet-stream") {
    const arrayBuffer = await blob.arrayBuffer();
    const buffer2 = Buffer4.from(arrayBuffer);
    return resolveBufferImage(buffer2);
  }
  if (!type.startsWith("image/")) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const format3 = type.replace("image/", "");
  if (!isValidFormat(format3)) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const buffer = await blob.arrayBuffer();
  return getImage(Buffer4.from(buffer), format3);
};
var resolveImageFromUrl = async (src) => {
  const data2 = await fetchRemoteFile(src);
  const format3 = getImageFormat(data2);
  if (!format3) {
    throw new Error("Not valid image extension");
  }
  return getImage(data2, format3);
};
var getCacheKey = (src) => {
  var _a;
  if (isBlob(src) || isBuffer3(src))
    return null;
  if (isDataImageSrc(src))
    return ((_a = src.data) == null ? void 0 : _a.toString("base64")) ?? null;
  return src.uri;
};
var resolveImage = (src, { cache: cache2 = true } = {}) => {
  let image;
  const cacheKey = getCacheKey(src);
  if (isBlob(src)) {
    image = resolveBlobImage(src);
  } else if (isBuffer3(src)) {
    image = resolveBufferImage(src);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isDataUri(src)) {
    image = resolveBase64Image(src);
  } else if (isDataImageSrc(src)) {
    image = resolveImageFromData(src);
  } else {
    image = resolveImageFromUrl(src);
  }
  if (cache2 && cacheKey) {
    IMAGE_CACHE.set(cacheKey, image);
  }
  return image;
};

// node_modules/@react-pdf/layout/lib/index.js
var transformText = (text, transformation) => {
  switch (transformation) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return capitalize(text);
    case "upperfirst":
      return upperFirst(text);
    default:
      return text;
  }
};
var isTspan = (node) => node.type === Tspan;
var isTextInstance$4 = (node) => node.type === TextInstance;
var engines$1 = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine$1 = layoutEngine(engines$1);
var getFragments$1 = (fontStore2, instance) => {
  if (!instance)
    return [{ string: "" }];
  const fragments = [];
  const { fill: fill4 = "black", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity } = instance.props;
  const _textDecoration = instance.props.textDecoration;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj == null ? void 0 : obj.data;
  });
  const attributes2 = {
    font,
    opacity,
    fontSize,
    color: fill4,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill4,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill4
  };
  for (let i4 = 0; i4 < instance.children.length; i4 += 1) {
    const child = instance.children[i4];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments$1(fontStore2, child));
    }
  }
  return fragments;
};
var getAttributedString$1 = (fontStore2, instance) => fromFragments(getFragments$1(fontStore2, instance));
var AlmostInfinity = 999999999999;
var shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };
var layoutTspan = (fontStore2) => (node, xOffset) => {
  var _a;
  const attributedString = getAttributedString$1(fontStore2, node);
  const x = node.props.x === void 0 ? xOffset : node.props.x;
  const y3 = ((_a = node.props) == null ? void 0 : _a.y) || 0;
  const container = { x, y: y3, width: AlmostInfinity, height: AlmostInfinity };
  const hyphenationCallback = node.props.hyphenationCallback || (fontStore2 == null ? void 0 : fontStore2.getHyphenationCallback()) || null;
  const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };
  const lines = engine$1(attributedString, container, layoutOptions).flat();
  return Object.assign({}, node, { lines });
};
var joinTSpanLines = (node) => {
  const children = node.children.map((child, index2) => {
    if (!isTspan(child))
      return child;
    const textInstance = child.children[0];
    if (child.props.x === void 0 && index2 < node.children.length - 1 && (textInstance == null ? void 0 : textInstance.value)) {
      return Object.assign({}, child, {
        children: [{ ...textInstance, value: `${textInstance.value} ` }]
      });
    }
    return child;
  }, []);
  return Object.assign({}, node, { children });
};
var layoutText$1 = (fontStore2, node) => {
  var _a;
  if (!node.children)
    return node;
  let currentXOffset = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const layoutFn = layoutTspan(fontStore2);
  const joinedNode = joinTSpanLines(node);
  const children = joinedNode.children.map((child) => {
    const childWithLayout = layoutFn(child, currentXOffset);
    currentXOffset += childWithLayout.lines[0].xAdvance;
    return childWithLayout;
  });
  return Object.assign({}, node, { children });
};
var isDefs = (node) => node.type === Defs;
var getDefs = (node) => {
  const children = node.children || [];
  const defs = children.find(isDefs);
  const values = (defs == null ? void 0 : defs.children) || [];
  return values.reduce((acc, value2) => {
    var _a;
    const id = (_a = value2.props) == null ? void 0 : _a.id;
    if (id)
      acc[id] = value2;
    return acc;
  }, {});
};
var isNotDefs = (node) => node.type !== Defs;
var detachDefs = (node) => {
  if (!node.children)
    return node;
  const children = node.children.filter(isNotDefs);
  return Object.assign({}, node, { children });
};
var URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
var replaceDef = (defs, value2) => {
  if (!value2)
    return void 0;
  if (!URL_REGEX.test(value2))
    return value2;
  const match = value2.match(URL_REGEX);
  return defs[match[1]];
};
var parseNodeDefs = (defs) => (node) => {
  const props = node.props;
  const fill4 = `fill` in props ? replaceDef(defs, props == null ? void 0 : props.fill) : void 0;
  const clipPath2 = `clipPath` in props ? replaceDef(defs, props == null ? void 0 : props.clipPath) : void 0;
  const newProps = Object.assign({}, node.props, { fill: fill4, clipPath: clipPath2 });
  const children = node.children ? node.children.map(parseNodeDefs(defs)) : void 0;
  return Object.assign({}, node, { props: newProps, children });
};
var parseDefs = (root) => {
  if (!root.children)
    return root;
  const defs = getDefs(root);
  const children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, { children });
};
var replaceDefs = (node) => {
  return detachDefs(parseDefs(node));
};
var parseViewbox = (value2) => {
  if (!value2)
    return null;
  if (typeof value2 !== "string")
    return value2;
  const values = value2.split(/[,\s]+/).map(parseFloat$1);
  if (values.length !== 4)
    return null;
  return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };
};
var getContainer$1 = (node) => {
  const viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return { width: viewbox.maxX, height: viewbox.maxY };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat$1(node.props.width),
      height: parseFloat$1(node.props.height)
    };
  }
  return { width: 0, height: 0 };
};
var BASE_SVG_INHERITED_PROPS = [
  "x",
  "y",
  "clipPath",
  "clipRule",
  "opacity",
  "fill",
  "fillOpacity",
  "fillRule",
  "stroke",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeOpacity",
  "strokeWidth",
  "textAnchor",
  "dominantBaseline",
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
var TEXT_SVG_INHERITED_PROPS = without(["x"], BASE_SVG_INHERITED_PROPS);
var SVG_INHERITED_PROPS = {
  [Text]: TEXT_SVG_INHERITED_PROPS
};
var getInheritProps = (node) => {
  const props = node.props || {};
  const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;
  return pick(svgInheritedProps, props);
};
var inheritProps = (node) => {
  if (!node.children)
    return node;
  const inheritedProps = getInheritProps(node);
  const children = node.children.map((child) => {
    const props = Object.assign({}, inheritedProps, child.props || {});
    const newChild = Object.assign({}, child, { props });
    return inheritProps(newChild);
  });
  return Object.assign({}, node, { children });
};
var parseAspectRatio = (value2) => {
  if (typeof value2 !== "string")
    return value2;
  const match = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  const align = match[0] || "xMidYMid";
  const meetOrSlice = match[1] || "meet";
  return { align, meetOrSlice };
};
var STYLE_PROPS = [
  "width",
  "height",
  "color",
  "stroke",
  "strokeWidth",
  "opacity",
  "fillOpacity",
  "strokeOpacity",
  "fill",
  "fillRule",
  "clipPath",
  "offset",
  "transform",
  "strokeLinejoin",
  "strokeLinecap",
  "strokeDasharray",
  "gradientUnits",
  "gradientTransform"
];
var VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
var HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
var isSvg$3 = (node) => node.type === Svg;
var isText$5 = (node) => node.type === Text;
var isTextInstance$3 = (node) => node.type === TextInstance;
var transformPercent = (container) => (props) => mapValues(props, (value2, key) => {
  const match = matchPercent(value2);
  if (match && VERTICAL_PROPS.includes(key)) {
    return match.percent * container.height;
  }
  if (match && HORIZONTAL_PROPS.includes(key)) {
    return match.percent * container.width;
  }
  return value2;
});
var parsePercent = (value2) => {
  const match = matchPercent(value2);
  return match ? match.percent : parseFloat$1(value2);
};
var parseTransform = (container) => (value2) => {
  return resolveStyles(container, { transform: value2 }).transform;
};
var parseProps = (container) => (node) => {
  let props = transformPercent(container)(node.props);
  props = evolve({
    x: parseFloat$1,
    x1: parseFloat$1,
    x2: parseFloat$1,
    y: parseFloat$1,
    y1: parseFloat$1,
    y2: parseFloat$1,
    r: parseFloat$1,
    rx: parseFloat$1,
    ry: parseFloat$1,
    cx: parseFloat$1,
    cy: parseFloat$1,
    width: parseFloat$1,
    height: parseFloat$1,
    offset: parsePercent,
    fill: transformColor,
    opacity: parsePercent,
    stroke: transformColor,
    stopOpacity: parsePercent,
    stopColor: transformColor,
    transform: parseTransform(container),
    gradientTransform: parseTransform(container)
  }, props);
  return Object.assign({}, node, { props });
};
var mergeStyles$1 = (node) => {
  const style = node.style || {};
  const props = Object.assign({}, style, node.props);
  return Object.assign({}, node, { props });
};
var removeNoneValues = (node) => {
  const removeNone = (value2) => value2 === "none" ? null : value2;
  const props = mapValues(node.props, removeNone);
  return Object.assign({}, node, { props });
};
var pickStyleProps = (node) => {
  const props = node.props || {};
  const styleProps = pick(STYLE_PROPS, props);
  const style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, { style });
};
var parseSvgProps = (node) => {
  const props = evolve({
    width: parseFloat$1,
    height: parseFloat$1,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, { props });
};
var wrapBetweenTspan = (node) => ({
  type: Tspan,
  props: {},
  style: {},
  children: [node]
});
var addMissingTspan = (node) => {
  if (!isText$5(node))
    return node;
  if (!node.children)
    return node;
  const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
var parseText = (fontStore2) => (node) => {
  if (isText$5(node))
    return layoutText$1(fontStore2, node);
  if (!node.children)
    return node;
  const children = node.children.map(parseText(fontStore2));
  return Object.assign({}, node, { children });
};
var resolveSvgNode = (container) => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);
var resolveChildren = (container) => (node) => {
  if (!node.children)
    return node;
  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
var buildXLinksIndex = (node) => {
  var _a;
  const idIndex = {};
  const listToExplore = ((_a = node.children) == null ? void 0 : _a.slice(0)) || [];
  while (listToExplore.length > 0) {
    const child = listToExplore.shift();
    if (child.props && "id" in child.props) {
      idIndex[child.props.id] = child;
    }
    if (child.children)
      listToExplore.push(...child.children);
  }
  return idIndex;
};
var replaceXLinks = (node, idIndex) => {
  var _a;
  if (node.props && "xlinkHref" in node.props) {
    const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, "")];
    if (!linkedNode)
      return node;
    const newProps = Object.assign({}, linkedNode.props, node.props);
    delete newProps.xlinkHref;
    return Object.assign({}, linkedNode, { props: newProps });
  }
  const children = (_a = node.children) == null ? void 0 : _a.map((child) => replaceXLinks(child, idIndex));
  return Object.assign({}, node, { children });
};
var resolveXLinks = (node) => {
  const idIndex = buildXLinksIndex(node);
  return replaceXLinks(node, idIndex);
};
var resolveSvgRoot = (node, fontStore2) => {
  const container = getContainer$1(node);
  return compose(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);
};
var resolveSvg = (node, fontStore2) => {
  var _a;
  if (!("children" in node))
    return node;
  const resolveChild = (child) => resolveSvg(child, fontStore2);
  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  const children = (_a = root.children) == null ? void 0 : _a.map(resolveChild);
  return Object.assign({}, root, { children });
};
var instancePromise;
var loadYoga3 = async () => {
  const instance = await (instancePromise ?? (instancePromise = loadYoga2()));
  const config3 = instance.Config.create();
  config3.setPointScaleFactor(0);
  const node = { create: () => instance.Node.createWithConfig(config3) };
  return { node };
};
var resolveYoga = async (root) => {
  const yoga = await loadYoga3();
  return Object.assign({}, root, { yoga });
};
var getZIndex = (node) => node.style.zIndex;
var shouldSort = (node) => node.type !== Document && node.type !== Svg;
var sortZIndex = (a4, b3) => {
  const za = getZIndex(a4);
  const zb = getZIndex(b3);
  if (!za && !zb)
    return 0;
  if (!za)
    return 1;
  if (!zb)
    return -1;
  return zb - za;
};
var resolveNodeZIndex = (node) => {
  if (!node.children)
    return node;
  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  const children = sortedChildren.map(resolveNodeZIndex);
  return Object.assign({}, node, { children });
};
var resolveZIndex = (root) => resolveNodeZIndex(root);
var emojis = {};
var regex3 = emoji_regex_xs_default();
var removeVariationSelectors = (x) => x !== "";
var getCodePoints = (string, withVariationSelectors = false) => Array.from(string).filter(withVariationSelectors ? () => true : removeVariationSelectors).map((char) => char.codePointAt(0).toString(16)).join("-");
var buildEmojiUrl = (emoji, source) => {
  if ("builder" in source) {
    return source.builder(getCodePoints(emoji, source.withVariationSelectors));
  }
  const { url, format: format3 = "png", withVariationSelectors } = source;
  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format3}`;
};
var fetchEmojis = (string, source) => {
  if (!source)
    return [];
  const promises = [];
  Array.from(string.matchAll(regex3)).forEach((match) => {
    const emoji = match[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      const emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = { loading: true };
      promises.push(resolveImage({ uri: emojiUrl }).then((image) => {
        emojis[emoji].loading = false;
        emojis[emoji].data = image.data;
      }).catch((e4) => {
        console.warn(e4, "Failed to load emoji image");
        emojis[emoji].loading = false;
      }));
    }
  });
  return promises;
};
var embedEmojis = (fragments) => {
  const result = [];
  for (let i4 = 0; i4 < fragments.length; i4 += 1) {
    const fragment = fragments[i4];
    let lastIndex = 0;
    Array.from(fragment.string.matchAll(regex3)).forEach((match) => {
      const { index: index2 } = match;
      const emoji = match[0];
      const emojiSize = fragment.attributes.fontSize;
      const chunk = fragment.string.slice(lastIndex, index2 + match[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match[0], String.fromCharCode(65532)),
          attributes: {
            ...fragment.attributes,
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          }
        });
      } else {
        result.push({
          string: chunk,
          attributes: fragment.attributes
        });
      }
      lastIndex = index2 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  }
  return result;
};
var getSource = (node) => {
  if (node.props.src)
    return node.props.src;
  if (node.props.source)
    return node.props.source;
};
var resolveSource = async (src) => {
  const source = typeof src === "function" ? await src() : await src;
  return typeof source === "string" ? { uri: source } : source;
};
var fetchImage = async (node) => {
  const src = getSource(node);
  const { cache: cache2 } = node.props;
  if (!src) {
    console.warn(false, 'Image should receive either a "src" or "source" prop');
    return;
  }
  try {
    const source = await resolveSource(src);
    if (!source) {
      throw new Error(`Image's "src" or "source" prop returned ${source}`);
    }
    node.image = await resolveImage(source, { cache: cache2 });
    if (Buffer.isBuffer(source) || source instanceof Blob)
      return;
    node.image.key = "data" in source ? source.data.toString() : source.uri;
  } catch (e4) {
    console.warn(e4.message);
  }
};
var isImage$2 = (node) => node.type === Image;
var fetchAssets = (fontStore2, node) => {
  var _a, _b;
  const promises = [];
  const listToExplore = ((_a = node.children) == null ? void 0 : _a.slice(0)) || [];
  const emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    const n5 = listToExplore.shift();
    if (isImage$2(n5)) {
      promises.push(fetchImage(n5));
    }
    if (fontStore2 && ((_b = n5.style) == null ? void 0 : _b.fontFamily)) {
      const fontFamilies = castArray(n5.style.fontFamily);
      promises.push(...fontFamilies.map((fontFamily) => fontStore2.load({
        fontFamily,
        fontStyle: n5.style.fontStyle,
        fontWeight: n5.style.fontWeight
      })));
    }
    if (typeof n5 === "string") {
      promises.push(...fetchEmojis(n5, emojiSource));
    }
    if ("value" in n5 && typeof n5.value === "string") {
      promises.push(...fetchEmojis(n5.value, emojiSource));
    }
    if (n5.children) {
      n5.children.forEach((childNode) => {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
};
var resolveAssets = async (node, fontStore2) => {
  const promises = fetchAssets(fontStore2, node);
  await Promise.all(promises);
  return node;
};
var isLink$1 = (node) => node.type === Link;
var DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
var computeStyle = (container, node) => {
  let baseStyle = [node.style];
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles(container, baseStyle);
};
var resolveNodeStyles = (container) => (node) => {
  const style = computeStyle(container, node);
  if (!node.children)
    return Object.assign({}, node, { style });
  const children = node.children.map(resolveNodeStyles(container));
  return Object.assign({}, node, { style, children });
};
var resolvePageStyles = (page) => {
  var _a, _b, _c, _d;
  const dpi = ((_a = page.props) == null ? void 0 : _a.dpi) || 72;
  const style = page.style;
  const width = ((_b = page.box) == null ? void 0 : _b.width) || style.width;
  const height2 = ((_c = page.box) == null ? void 0 : _c.height) || style.height;
  const orientation = ((_d = page.props) == null ? void 0 : _d.orientation) || "portrait";
  const remBase = (style == null ? void 0 : style.fontSize) || 18;
  const container = { width, height: height2, orientation, dpi, remBase };
  return resolveNodeStyles(container)(page);
};
var resolveStyles2 = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, { children });
};
var getTransformStyle = (s2) => (node) => {
  var _a, _b;
  return isNil((_a = node.style) == null ? void 0 : _a[s2]) ? "50%" : ((_b = node.style) == null ? void 0 : _b[s2]) ?? null;
};
var getOrigin = (node) => {
  if (!node.box)
    return null;
  const { left, top, width, height: height2 } = node.box;
  const transformOriginX = getTransformStyle("transformOriginX")(node);
  const transformOriginY = getTransformStyle("transformOriginY")(node);
  const percentX = matchPercent(transformOriginX);
  const percentY = matchPercent(transformOriginY);
  const offsetX = percentX ? width * percentX.percent : transformOriginX;
  const offsetY = percentY ? height2 * percentY.percent : transformOriginY;
  if (isNil(offsetX) || typeof offsetX === "string")
    throw new Error(`Invalid origin offsetX: ${offsetX}`);
  if (isNil(offsetY) || typeof offsetY === "string")
    throw new Error(`Invalid origin offsetY: ${offsetY}`);
  return { left: left + offsetX, top: top + offsetY };
};
var resolveNodeOrigin = (node) => {
  const origin = getOrigin(node);
  const newNode = Object.assign({}, node, { origin });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolveNodeOrigin);
  return Object.assign({}, newNode, { children });
};
var resolveOrigin = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, { children });
};
var getBookmarkValue = (bookmark) => {
  return typeof bookmark === "string" ? { title: bookmark, fit: false, expanded: false } : bookmark;
};
var resolveBookmarks = (node) => {
  let refs = 0;
  const children = (node.children || []).slice(0);
  const listToExplore = children.map((value2) => ({
    value: value2,
    parent: null
  }));
  while (listToExplore.length > 0) {
    const element = listToExplore.shift();
    if (!element)
      break;
    const child = element.value;
    let parent = element.parent;
    if (child.props && "bookmark" in child.props && child.props.bookmark) {
      const bookmark = getBookmarkValue(child.props.bookmark);
      const ref = refs++;
      const newHierarchy = { ref, parent: parent == null ? void 0 : parent.ref, ...bookmark };
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach((childNode) => {
        listToExplore.push({ value: childNode, parent });
      });
    }
  }
  return node;
};
var VALID_ORIENTATIONS = ["portrait", "landscape"];
var getOrientation = (page) => {
  var _a;
  const value2 = ((_a = page.props) == null ? void 0 : _a.orientation) || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
};
var isLandscape = (page) => getOrientation(page) === "landscape";
var PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
var parseValue2 = (value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|px)?$/g.exec(value2);
  return match ? { value: parseFloat(match[1]), unit: match[2] || "pt" } : { value: value2, unit: void 0 };
};
var transformUnit2 = (value2, inputDpi) => {
  if (!value2)
    return 0;
  const scalar = parseValue2(value2);
  const outputDpi = 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value === "string")
    throw new Error(`Invalid page size: ${value2}`);
  switch (scalar.unit) {
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
var transformUnits = ({ width, height: height2 }, dpi) => ({
  width: transformUnit2(width, dpi),
  height: transformUnit2(height2, dpi)
});
var toSizeObject = (v3) => ({
  width: v3[0],
  height: v3[1]
});
var flipSizeObject = (v3) => ({
  width: v3.height,
  height: v3.width
});
var getStringSize = (v3) => {
  return toSizeObject(PAGE_SIZES[v3.toUpperCase()]);
};
var getNumberSize = (n5) => toSizeObject([n5, n5]);
var getSize = (page) => {
  var _a, _b;
  const value2 = ((_a = page.props) == null ? void 0 : _a.size) || "A4";
  const dpi = ((_b = page.props) == null ? void 0 : _b.dpi) || 72;
  let size;
  if (typeof value2 === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = transformUnits(toSizeObject(value2), dpi);
  } else if (typeof value2 === "number") {
    size = transformUnits(getNumberSize(value2), dpi);
  } else {
    size = transformUnits(value2, dpi);
  }
  return isLandscape(page) ? flipSizeObject(size) : size;
};
var resolvePageSize = (page) => {
  const size = getSize(page);
  const style = flatten(page.style || {});
  return { ...page, style: { ...style, ...size } };
};
var resolvePageSizes = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageSize);
  return Object.assign({}, root, { children });
};
var isFixed = (node) => {
  if (!node.props)
    return false;
  return "fixed" in node.props ? node.props.fixed === true : false;
};
var lineIndexAtHeight = (node, height2) => {
  let y3 = 0;
  if (!node.lines)
    return 0;
  for (let i4 = 0; i4 < node.lines.length; i4 += 1) {
    const line2 = node.lines[i4];
    if (y3 + line2.box.height > height2)
      return i4;
    y3 += line2.box.height;
  }
  return node.lines.length;
};
var heightAtLineIndex = (node, index2) => {
  let counter = 0;
  if (!node.lines)
    return counter;
  for (let i4 = 0; i4 < index2; i4 += 1) {
    const line2 = node.lines[i4];
    if (!line2)
      break;
    counter += line2.box.height;
  }
  return counter;
};
var getLineBreak = (node, height2) => {
  var _a;
  const top = ((_a = node.box) == null ? void 0 : _a.top) || 0;
  const widows = node.props.widows || 2;
  const orphans = node.props.orphans || 2;
  const linesQuantity = node.lines.length;
  const slicedLine = lineIndexAtHeight(node, height2 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
};
var splitText = (node, height2) => {
  const slicedLineIndex = getLineBreak(node, height2);
  const currentHeight = heightAtLineIndex(node, slicedLineIndex);
  const nextHeight = node.box.height - currentHeight;
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      height: currentHeight,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    lines: node.lines.slice(0, slicedLineIndex)
  });
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next];
};
var getTop$1 = (node) => {
  var _a;
  return ((_a = node.box) == null ? void 0 : _a.top) || 0;
};
var hasFixedHeight = (node) => {
  var _a;
  return !isNil((_a = node.style) == null ? void 0 : _a.height);
};
var splitNode = (node, height2) => {
  if (!node)
    return [null, null];
  const nodeTop = getTop$1(node);
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }
  });
  current.style.height = height2 - nodeTop;
  const nextHeight = hasFixedHeight(node) ? node.box.height - (height2 - nodeTop) : null;
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    props: {
      ...node.props,
      bookmark: null
    }
  });
  if (nextHeight) {
    next.style.height = nextHeight;
  }
  return [current, next];
};
var NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
var getWrap = (node) => {
  if (NON_WRAP_TYPES.includes(node.type))
    return false;
  if (!node.props)
    return true;
  return "wrap" in node.props ? node.props.wrap : true;
};
var getComputedPadding = (node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
};
var getPadding = (node) => {
  const { style, box } = node;
  const paddingTop = getComputedPadding(node, Edge.Top) || (box == null ? void 0 : box.paddingTop) || (style == null ? void 0 : style.paddingTop) || 0;
  const paddingRight = getComputedPadding(node, Edge.Right) || (box == null ? void 0 : box.paddingRight) || (style == null ? void 0 : style.paddingRight) || 0;
  const paddingBottom = getComputedPadding(node, Edge.Bottom) || (box == null ? void 0 : box.paddingBottom) || (style == null ? void 0 : style.paddingBottom) || 0;
  const paddingLeft = getComputedPadding(node, Edge.Left) || (box == null ? void 0 : box.paddingLeft) || (style == null ? void 0 : style.paddingLeft) || 0;
  return { paddingTop, paddingRight, paddingBottom, paddingLeft };
};
var getWrapArea = (page) => {
  var _a;
  const height2 = (_a = page.style) == null ? void 0 : _a.height;
  const { paddingBottom } = getPadding(page);
  return height2 - paddingBottom;
};
var getContentArea = (page) => {
  var _a;
  const height2 = (_a = page.style) == null ? void 0 : _a.height;
  const { paddingTop, paddingBottom } = getPadding(page);
  return height2 - paddingBottom - paddingTop;
};
var isString4 = (value2) => typeof value2 === "string";
var isNumber4 = (value2) => typeof value2 === "number";
var isBoolean3 = (value2) => typeof value2 === "boolean";
var isFragment = (value2) => value2 && value2.type === Symbol.for("react.fragment");
var createInstances = (element) => {
  if (!element)
    return [];
  if (Array.isArray(element)) {
    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);
  }
  if (isBoolean3(element)) {
    return [];
  }
  if (isString4(element) || isNumber4(element)) {
    return [{ type: TextInstance, value: `${element}` }];
  }
  if (isFragment(element)) {
    return createInstances(element.props.children);
  }
  if (!isString4(element.type)) {
    return createInstances(element.type(element.props));
  }
  const { type, props: { style = {}, children, ...props } } = element;
  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);
  return [
    {
      type,
      style,
      props,
      children: nextChildren
    }
  ];
};
var getBreak = (node) => "break" in node.props ? node.props.break : false;
var getMinPresenceAhead = (node) => "minPresenceAhead" in node.props ? node.props.minPresenceAhead : 0;
var getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));
var getEndOfMinPresenceAhead = (child) => {
  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);
};
var getEndOfPresence = (child, futureElements) => {
  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);
  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !("fixed" in node.props)));
  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);
};
var shouldBreak = (child, futureElements, height2, previousElements) => {
  if ("fixed" in child.props)
    return false;
  const shouldSplit = height2 < child.box.top + child.box.height;
  const canWrap = getWrap(child);
  const endOfPresence = getEndOfPresence(child, futureElements);
  const breakingImprovesPresence = previousElements.filter((node) => !isFixed(node)).length > 0;
  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height2 && breakingImprovesPresence;
};
var IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
var buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {
  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
    return acc;
  }
  return [...acc, String.fromCharCode(codePoint)];
}, []);
var ignoreChars = (fragments) => fragments.map((fragment) => {
  const charSubset = buildSubsetForFont(fragment.attributes.font[0]);
  const subsetRegex = new RegExp(charSubset.join("|"));
  return {
    string: fragment.string.replace(subsetRegex, ""),
    attributes: fragment.attributes
  };
});
var PREPROCESSORS = [ignoreChars, embedEmojis];
var isImage$1 = (node) => node.type === Image;
var isTextInstance$2 = (node) => node.type === TextInstance;
var getFragments = (fontStore2, instance, parentLink = null, level = 0) => {
  var _a, _b;
  if (!instance)
    return [{ string: "" }];
  let fragments = [];
  const { color = "black", direction = "ltr", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration: textDecoration2, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign } = instance.style;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj == null ? void 0 : obj.data;
  });
  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  const attributes2 = {
    font,
    color,
    opacity,
    fontSize,
    lineHeight,
    direction,
    verticalAlign,
    backgroundColor,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration2 === "underline" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strike: textDecoration2 === "line-through" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    // @ts-expect-error allow this props access
    link: parentLink || ((_a = instance.props) == null ? void 0 : _a.src) || ((_b = instance.props) == null ? void 0 : _b.href),
    align: textAlign || (direction === "rtl" ? "right" : "left")
  };
  for (let i4 = 0; i4 < instance.children.length; i4 += 1) {
    const child = instance.children[i4];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: {
          ...attributes2,
          attachment: {
            width: child.style.width || fontSize,
            height: child.style.height || fontSize,
            image: child.image.data
          }
        }
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (let i4 = 0; i4 < PREPROCESSORS.length; i4 += 1) {
    const preprocessor = PREPROCESSORS[i4];
    fragments = preprocessor(fragments);
  }
  return fragments;
};
var getAttributedString = (fontStore2, instance) => {
  const fragments = getFragments(fontStore2, instance);
  return fromFragments(fragments);
};
var engines = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine = layoutEngine(engines);
var getMaxLines = (node) => {
  var _a;
  return (_a = node.style) == null ? void 0 : _a.maxLines;
};
var getTextOverflow = (node) => {
  var _a;
  return (_a = node.style) == null ? void 0 : _a.textOverflow;
};
var getContainer = (width, height2, node) => {
  const maxLines = getMaxLines(node);
  const textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height2 || Infinity,
    truncateMode: textOverflow
  };
};
var getLayoutOptions = (fontStore2, node) => ({
  hyphenationPenalty: node.props.hyphenationPenalty,
  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },
  hyphenationCallback: node.props.hyphenationCallback || (fontStore2 == null ? void 0 : fontStore2.getHyphenationCallback()) || null
});
var layoutText = (node, width, height2, fontStore2) => {
  const attributedString = getAttributedString(fontStore2, node);
  const container = getContainer(width, height2, node);
  const options = getLayoutOptions(fontStore2, node);
  const lines = engine(attributedString, container, options);
  return lines.reduce((acc, line2) => [...acc, ...line2], []);
};
var isSvg$2 = (node) => node.type === Svg;
var isText$4 = (node) => node.type === Text;
var shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);
var shouldLayoutText = (node) => isText$4(node) && !node.lines;
var resolveTextLayout = (node, fontStore2) => {
  if (shouldLayoutText(node)) {
    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    const height2 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText(node, width, height2, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children)
      return node;
    const mapChild = (child) => resolveTextLayout(child, fontStore2);
    const children = node.children.map(mapChild);
    return Object.assign({}, node, { children });
  }
  return node;
};
var BASE_INHERITABLE_PROPERTIES = [
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "textTransform",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
var TEXT_INHERITABLE_PROPERTIES = [
  ...BASE_INHERITABLE_PROPERTIES,
  "backgroundColor"
];
var isType$2 = (type) => (node) => node.type === type;
var isSvg$1 = isType$2(Svg);
var isText$3 = isType$2(Text);
var mergeValues = (styleName, value2, inheritedValue) => {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter((v3) => v3 && v3 !== "none").join(" ");
    }
    default:
      return value2;
  }
};
var merge = (inheritedStyles, style) => {
  const mergedStyles = { ...inheritedStyles };
  Object.entries(style).forEach(([styleName, value2]) => {
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
};
var mergeStyles2 = (inheritedStyles) => (node) => {
  const style = merge(inheritedStyles, node.style || {});
  return Object.assign({}, node, { style });
};
var resolveInheritance = (node) => {
  if (isSvg$1(node))
    return node;
  if (!("children" in node))
    return node;
  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;
  const inheritStyles = pick(inheritableProperties, node.style || {});
  const resolveChild = compose(resolveInheritance, mergeStyles2(inheritStyles));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
var getComputedMargin = (node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
};
var getMargin = (node) => {
  const { style, box } = node;
  const marginTop = getComputedMargin(node, Edge.Top) || (box == null ? void 0 : box.marginTop) || (style == null ? void 0 : style.marginTop) || 0;
  const marginRight = getComputedMargin(node, Edge.Right) || (box == null ? void 0 : box.marginRight) || (style == null ? void 0 : style.marginRight) || 0;
  const marginBottom = getComputedMargin(node, Edge.Bottom) || (box == null ? void 0 : box.marginBottom) || (style == null ? void 0 : style.marginBottom) || 0;
  const marginLeft = getComputedMargin(node, Edge.Left) || (box == null ? void 0 : box.marginLeft) || (style == null ? void 0 : style.marginLeft) || 0;
  return { marginTop, marginRight, marginBottom, marginLeft };
};
var getPosition = (node) => {
  const { yogaNode } = node;
  return {
    top: (yogaNode == null ? void 0 : yogaNode.getComputedTop()) || 0,
    right: (yogaNode == null ? void 0 : yogaNode.getComputedRight()) || 0,
    bottom: (yogaNode == null ? void 0 : yogaNode.getComputedBottom()) || 0,
    left: (yogaNode == null ? void 0 : yogaNode.getComputedLeft()) || 0
  };
};
var DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
var getDimension = (node) => {
  const { yogaNode } = node;
  if (!yogaNode)
    return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
};
var getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;
var getBorderWidth = (node) => {
  const { yogaNode } = node;
  return {
    borderTopWidth: getComputedBorder(yogaNode, Edge.Top),
    borderRightWidth: getComputedBorder(yogaNode, Edge.Right),
    borderBottomWidth: getComputedBorder(yogaNode, Edge.Bottom),
    borderLeftWidth: getComputedBorder(yogaNode, Edge.Left)
  };
};
var setDisplay = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    yogaNode.setDisplay(value2 === "none" ? Display.None : Display.Flex);
  }
  return node;
};
var OVERFLOW = {
  hidden: Overflow.Hidden,
  scroll: Overflow.Scroll
};
var setOverflow = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const overflow = OVERFLOW[value2] || Overflow.Visible;
    yogaNode.setOverflow(overflow);
  }
  return node;
};
var FLEX_WRAP = {
  wrap: Wrap.Wrap,
  "wrap-reverse": Wrap.WrapReverse
};
var setFlexWrap = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexWrap = FLEX_WRAP[value2] || Wrap.NoWrap;
    yogaNode.setFlexWrap(flexWrap);
  }
  return node;
};
var setYogaValue = (attr, edge) => (value2) => (node) => {
  var _a, _b, _c, _d, _e, _f;
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const hasEdge = !isNil(edge);
    const fixedMethod = `set${upperFirst(attr)}`;
    const autoMethod = `${fixedMethod}Auto`;
    const percentMethod = `${fixedMethod}Percent`;
    const percent = matchPercent(value2);
    if (percent && !yogaNode[percentMethod]) {
      throw new Error(`You can't pass percentage values to ${attr} property`);
    }
    if (percent) {
      if (hasEdge) {
        (_a = yogaNode[percentMethod]) == null ? void 0 : _a.call(yogaNode, edge, percent.value);
      } else {
        (_b = yogaNode[percentMethod]) == null ? void 0 : _b.call(yogaNode, percent.value);
      }
    } else if (value2 === "auto") {
      if (hasEdge) {
        (_c = yogaNode[autoMethod]) == null ? void 0 : _c.call(yogaNode, edge);
      } else {
        (_d = yogaNode[autoMethod]) == null ? void 0 : _d.call(yogaNode);
      }
    } else if (hasEdge) {
      (_e = yogaNode[fixedMethod]) == null ? void 0 : _e.call(yogaNode, edge, value2);
    } else {
      (_f = yogaNode[fixedMethod]) == null ? void 0 : _f.call(yogaNode, value2);
    }
  }
  return node;
};
var setFlexGrow = (value2) => (node) => {
  return setYogaValue("flexGrow")(value2 || 0)(node);
};
var setFlexBasis = setYogaValue("flexBasis");
var ALIGN = {
  "flex-start": Align.FlexStart,
  center: Align.Center,
  "flex-end": Align.FlexEnd,
  stretch: Align.Stretch,
  baseline: Align.Baseline,
  "space-between": Align.SpaceBetween,
  "space-around": Align.SpaceAround,
  "space-evenly": Align.SpaceEvenly
};
var setAlign = (attr) => (value2) => (node) => {
  const { yogaNode } = node;
  const defaultValue = attr === "items" ? Align.Stretch : Align.Auto;
  if (yogaNode) {
    const align = ALIGN[value2] || defaultValue;
    yogaNode[`setAlign${upperFirst(attr)}`](align);
  }
  return node;
};
var setAlignSelf = setAlign("self");
var setAlignItems = setAlign("items");
var setFlexShrink = (value2) => (node) => {
  return setYogaValue("flexShrink")(value2 || 1)(node);
};
var setAspectRatio = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setAspectRatio(value2);
  }
  return node;
};
var setAlignContent = setAlign("content");
var POSITION = {
  absolute: PositionType.Absolute,
  relative: PositionType.Relative,
  static: PositionType.Static
};
var setPositionType = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setPositionType(POSITION[value2]);
  }
  return node;
};
var FLEX_DIRECTIONS = {
  row: FlexDirection.Row,
  "row-reverse": FlexDirection.RowReverse,
  "column-reverse": FlexDirection.ColumnReverse
};
var setFlexDirection = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexDirection = FLEX_DIRECTIONS[value2] || FlexDirection.Column;
    yogaNode.setFlexDirection(flexDirection);
  }
  return node;
};
var JUSTIFY_CONTENT = {
  center: Justify.Center,
  "flex-end": Justify.FlexEnd,
  "space-between": Justify.SpaceBetween,
  "space-around": Justify.SpaceAround,
  "space-evenly": Justify.SpaceEvenly
};
var setJustifyContent = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const justifyContent = JUSTIFY_CONTENT[value2] || Justify.FlexStart;
    yogaNode.setJustifyContent(justifyContent);
  }
  return node;
};
var setMarginTop = setYogaValue("margin", Edge.Top);
var setMarginRight = setYogaValue("margin", Edge.Right);
var setMarginBottom = setYogaValue("margin", Edge.Bottom);
var setMarginLeft = setYogaValue("margin", Edge.Left);
var setPaddingTop = setYogaValue("padding", Edge.Top);
var setPaddingRight = setYogaValue("padding", Edge.Right);
var setPaddingBottom = setYogaValue("padding", Edge.Bottom);
var setPaddingLeft = setYogaValue("padding", Edge.Left);
var setBorderTop = setYogaValue("border", Edge.Top);
var setBorderRight = setYogaValue("border", Edge.Right);
var setBorderBottom = setYogaValue("border", Edge.Bottom);
var setBorderLeft = setYogaValue("border", Edge.Left);
var setPositionTop = setYogaValue("position", Edge.Top);
var setPositionRight = setYogaValue("position", Edge.Right);
var setPositionBottom = setYogaValue("position", Edge.Bottom);
var setPositionLeft = setYogaValue("position", Edge.Left);
var setWidth = setYogaValue("width");
var setMinWidth = setYogaValue("minWidth");
var setMaxWidth = setYogaValue("maxWidth");
var setHeight = setYogaValue("height");
var setMinHeight = setYogaValue("minHeight");
var setMaxHeight = setYogaValue("maxHeight");
var setRowGap = setYogaValue("gap", Gutter.Row);
var setColumnGap = setYogaValue("gap", Gutter.Column);
var getAspectRatio = (viewbox) => {
  if (!viewbox)
    return null;
  if (typeof viewbox === "string")
    return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
};
var measureCanvas$1 = (page, node) => (width, widthMode, height2, heightMode) => {
  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;
  if (widthMode === MeasureMode.Exactly || widthMode === MeasureMode.AtMost) {
    return { width, height: width / aspectRatio };
  }
  if (heightMode === MeasureMode.Exactly) {
    return { width: height2 * aspectRatio };
  }
  return {};
};
var linesWidth = (node) => {
  if (!node.lines)
    return 0;
  return Math.max(0, ...node.lines.map((line2) => line2.xAdvance));
};
var linesHeight = (node) => {
  if (!node.lines)
    return -1;
  return node.lines.reduce((acc, line2) => acc + line2.box.height, 0);
};
var ALIGNMENT_FACTORS2 = { center: 0.5, right: 1 };
var measureText = (page, node, fontStore2) => (width, widthMode, height2) => {
  var _a;
  if (widthMode === MeasureMode.Exactly) {
    if (!node.lines)
      node.lines = layoutText(node, width, height2, fontStore2);
    return { height: linesHeight(node), width };
  }
  if (widthMode === MeasureMode.AtMost) {
    const alignFactor = ALIGNMENT_FACTORS2[(_a = node.style) == null ? void 0 : _a.textAlign] || 0;
    if (!node.lines) {
      node.lines = layoutText(node, width, height2, fontStore2);
      node.alignOffset = (width - linesWidth(node)) * alignFactor;
    }
    return {
      height: linesHeight(node),
      width: Math.min(width, linesWidth(node))
    };
  }
  return {};
};
var getRatio = (node) => {
  var _a;
  return ((_a = node.image) == null ? void 0 : _a.data) ? node.image.width / node.image.height : 1;
};
var isHeightAuto = (page) => {
  var _a;
  return isNil((_a = page.box) == null ? void 0 : _a.height);
};
var SAFETY_HEIGHT$1 = 10;
var measureImage = (page, node) => (width, widthMode, height2, heightMode) => {
  var _a;
  const imageRatio = getRatio(node);
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (((_a = page.box) == null ? void 0 : _a.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
  if (!node.image)
    return { width: 0, height: 0 };
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.Undefined) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(pageArea, scaledHeight) };
  }
  if (heightMode === MeasureMode.Exactly && (widthMode === MeasureMode.AtMost || widthMode === MeasureMode.Undefined)) {
    return { width: Math.min(height2 * imageRatio, width) };
  }
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.AtMost) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(height2, pageArea, scaledHeight) };
  }
  if (widthMode === MeasureMode.AtMost && heightMode === MeasureMode.AtMost) {
    if (imageRatio > 1) {
      return {
        width,
        height: Math.min(width / imageRatio, height2)
      };
    }
    return {
      height: height2,
      width: Math.min(height2 * imageRatio, width)
    };
  }
  return { height: height2, width };
};
var SAFETY_HEIGHT = 10;
var getMax = (values) => Math.max(-Infinity, ...values);
var measureCtx = () => {
  const ctx = {};
  const points = [];
  const nil = () => ctx;
  const addPoint = (x, y3) => points.push([x, y3]);
  const moveTo = (x, y3) => {
    addPoint(x, y3);
    return ctx;
  };
  const rect = (x, y3, w, h3) => {
    addPoint(x, y3);
    addPoint(x + w, y3);
    addPoint(x, y3 + h3);
    addPoint(x + w, y3 + h3);
    return ctx;
  };
  const ellipse = (x, y3, rx, ry) => {
    ry = ry || rx;
    addPoint(x - rx, y3 - ry);
    addPoint(x + rx, y3 - ry);
    addPoint(x + rx, y3 + ry);
    addPoint(x - rx, y3 + ry);
    return ctx;
  };
  const polygon = (...pts) => {
    points.push(...pts);
    return ctx;
  };
  ctx.rect = rect;
  ctx.moveTo = moveTo;
  ctx.lineTo = moveTo;
  ctx.circle = ellipse;
  ctx.polygon = polygon;
  ctx.ellipse = ellipse;
  ctx.roundedRect = rect;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = () => getMax(points.map((p3) => p3[0]));
  ctx.getHeight = () => getMax(points.map((p3) => p3[1]));
  return ctx;
};
var measureCanvas = (page, node) => () => {
  var _a;
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (((_a = page.box) == null ? void 0 : _a.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
  const ctx = measureCtx();
  node.props.paint(ctx);
  const width = ctx.getWidth();
  const height2 = Math.min(pageArea, ctx.getHeight());
  return { width, height: height2 };
};
var isType$1 = (type) => (node) => node.type === type;
var isSvg = isType$1(Svg);
var isText$2 = isType$1(Text);
var isNote = isType$1(Note);
var isPage = isType$1(Page);
var isImage = isType$1(Image);
var isCanvas = isType$1(Canvas);
var isTextInstance$1 = isType$1(TextInstance);
var setNodeHeight = (node) => {
  var _a, _b;
  const value2 = isPage(node) ? (_a = node.box) == null ? void 0 : _a.height : (_b = node.style) == null ? void 0 : _b.height;
  return setHeight(value2);
};
var setYogaValues = (node) => {
  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
};
var insertYogaNodes = (parent) => (child) => {
  parent.insertChild(child.yogaNode, parent.getChildCount());
  return child;
};
var setMeasureFunc = (node, page, fontStore2) => {
  const { yogaNode } = node;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas(page, node));
  }
  if (isSvg(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
};
var isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);
var createYogaNodes = (page, fontStore2, yoga) => (node) => {
  const yogaNode = yoga.node.create();
  const result = Object.assign({}, node, { yogaNode });
  setYogaValues(result);
  if (isLayoutElement(node) && node.children) {
    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore2, yoga));
    result.children = node.children.map(resolveChild);
  }
  setMeasureFunc(result, page, fontStore2);
  return result;
};
var calculateLayout = (page) => {
  page.yogaNode.calculateLayout();
  return page;
};
var persistDimensions = (node) => {
  if (isTextInstance$1(node))
    return node;
  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));
  const newNode = Object.assign({}, node, { box });
  if (!node.children)
    return newNode;
  const children = node.children.map(persistDimensions);
  return Object.assign({}, newNode, { children });
};
var destroyYogaNodes = (node) => {
  const newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children)
    return newNode;
  const children = node.children.map(destroyYogaNodes);
  return Object.assign({}, newNode, { children });
};
var freeYogaNodes = (node) => {
  if (node.yogaNode)
    node.yogaNode.freeRecursive();
  return node;
};
var resolvePageDimensions = (page, fontStore2, yoga) => {
  if (isNil(page))
    return null;
  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2, yoga))(page);
};
var resolveDimensions = (node, fontStore2) => {
  if (!node.children)
    return node;
  const resolveChild = (child) => resolvePageDimensions(child, fontStore2, node.yoga);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
var isText$1 = (node) => node.type === Text;
var SAFETY_THRESHOLD = 1e-3;
var assingChildren = (children, node) => Object.assign({}, node, { children });
var getTop = (node) => {
  var _a;
  return ((_a = node.box) == null ? void 0 : _a.top) || 0;
};
var allFixed = (nodes) => nodes.every(isFixed);
var isDynamic = (node) => node.props && "render" in node.props;
var relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);
var warnUnavailableSpace = (node) => {
  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);
};
var splitNodes = (height2, contentArea, nodes) => {
  const currentChildren = [];
  const nextChildren = [];
  for (let i4 = 0; i4 < nodes.length; i4 += 1) {
    const child = nodes[i4];
    const futureNodes = nodes.slice(i4 + 1);
    const futureFixedNodes = futureNodes.filter(isFixed);
    const nodeTop = getTop(child);
    const nodeHeight = child.box.height;
    const isOutside = height2 <= nodeTop;
    const shouldBreak$1 = shouldBreak(child, futureNodes, height2, currentChildren);
    const shouldSplit = height2 + SAFETY_THRESHOLD < nodeTop + nodeHeight;
    const canWrap = getWrap(child);
    const fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const next = Object.assign({}, child, { box });
      nextChildren.push(next);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push(...futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      const next = Object.assign({}, child, { box, props });
      currentChildren.push(...futureFixedNodes);
      nextChildren.push(next, ...futureNodes);
      break;
    }
    if (shouldSplit) {
      const [currentChild, nextChild] = split(child, height2, contentArea);
      if (child.children.length > 0 && currentChild.children.length === 0) {
        if (currentChildren.length === 0) {
          currentChildren.push(child, ...futureFixedNodes);
          nextChildren.push(...futureNodes);
        } else {
          const box = Object.assign({}, child.box, {
            top: child.box.top - height2
          });
          const next = Object.assign({}, child, { box });
          currentChildren.push(...futureFixedNodes);
          nextChildren.push(next, ...futureNodes);
        }
        break;
      }
      if (currentChild)
        currentChildren.push(currentChild);
      if (nextChild)
        nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
};
var splitChildren = (height2, contentArea, node) => {
  const children = node.children || [];
  const availableHeight = height2 - getTop(node);
  return splitNodes(availableHeight, contentArea, children);
};
var splitView = (node, height2, contentArea) => {
  const [currentNode, nextNode] = splitNode(node, height2);
  const [currentChilds, nextChildren] = splitChildren(height2, contentArea, node);
  return [
    assingChildren(currentChilds, currentNode),
    assingChildren(nextChildren, nextNode)
  ];
};
var split = (node, height2, contentArea) => isText$1(node) ? splitText(node, height2) : splitView(node, height2, contentArea);
var shouldResolveDynamicNodes = (node) => {
  const children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes);
};
var resolveDynamicNodes = (props, node) => {
  const isNodeDynamic = isDynamic(node);
  const resolveChildren2 = (children2 = []) => {
    if (isNodeDynamic) {
      const res = node.props.render(props);
      return createInstances(res).filter(Boolean).map((n5) => resolveDynamicNodes(props, n5));
    }
    return children2.map((c4) => resolveDynamicNodes(props, c4));
  };
  const resetHeight = isNodeDynamic && isText$1(node);
  const box = resetHeight ? { ...node.box, height: 0 } : node.box;
  const children = resolveChildren2(node.children);
  const lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, { box, lines, children });
};
var resolveDynamicPage = (props, page, fontStore2, yoga) => {
  if (shouldResolveDynamicNodes(page)) {
    const resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2, yoga);
  }
  return page;
};
var splitPage = (page, pageNumber, fontStore2, yoga) => {
  const wrapArea = getWrapArea(page);
  const contentArea = getContentArea(page);
  const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore2, yoga);
  const height2 = page.style.height;
  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);
  const relayout = (node) => (
    // @ts-expect-error rework pagination
    relayoutPage(node, fontStore2, yoga)
  );
  const currentBox = { ...page.box, height: height2 };
  const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));
  if (nextChilds.length === 0 || allFixed(nextChilds))
    return [currentPage, null];
  const nextBox = omit("height", page.box);
  const nextProps = omit("bookmark", page.props);
  const nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};
var resolvePageIndices = (fontStore2, yoga, page, pageNumber, pages) => {
  const totalPages = pages.length;
  const props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2, yoga);
};
var assocSubPageData = (subpages) => {
  return subpages.map((page, i4) => ({
    ...page,
    subPageNumber: i4,
    subPageTotalPages: subpages.length
  }));
};
var dissocSubPageData = (page) => {
  return omit(["subPageNumber", "subPageTotalPages"], page);
};
var paginate = (page, pageNumber, fontStore2, yoga) => {
  var _a;
  if (!page)
    return [];
  if (((_a = page.props) == null ? void 0 : _a.wrap) === false)
    return [page];
  let splittedPage = splitPage(page, pageNumber, fontStore2, yoga);
  const pages = [splittedPage[0]];
  let nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2, yoga);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
};
var resolvePagination = (root, fontStore2) => {
  let pages = [];
  let pageNumber = 1;
  for (let i4 = 0; i4 < root.children.length; i4 += 1) {
    const page = root.children[i4];
    let subpages = paginate(page, pageNumber, fontStore2, root.yoga);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore2, root.yoga, ...args)));
  return assingChildren(pages, root);
};
var resolvePageHorizontalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  const width = container.width;
  return match ? match.percent * width : value2;
};
var resolvePageVerticalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  const height2 = container.height;
  return match ? match.percent * height2 : value2;
};
var resolvePagePaddings = (page) => {
  const container = page.style;
  const style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, { style });
};
var resolvePagesPaddings = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, { children });
};
var resolveRadius = (box) => (value2) => {
  if (!value2)
    return void 0;
  const match = matchPercent(value2);
  return match ? match.percent * Math.min(box.width, box.height) : value2;
};
var resolvePercentRadius = (node) => {
  const style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  const newNode = Object.assign({}, node, { style });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolvePercentRadius);
  return Object.assign({}, newNode, { children });
};
var transformHeight = (pageArea, height2) => {
  const match = matchPercent(height2);
  return match ? match.percent * pageArea : height2;
};
var getPageArea = (page) => {
  var _a, _b;
  const pageHeight = page.style.height;
  const pagePaddingTop = ((_a = page.style) == null ? void 0 : _a.paddingTop) || 0;
  const pagePaddingBottom = ((_b = page.style) == null ? void 0 : _b.paddingBottom) || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
};
var resolveNodePercentHeight = (page, node) => {
  var _a, _b;
  if (isNil((_a = page.style) == null ? void 0 : _a.height))
    return node;
  if (isNil((_b = node.style) == null ? void 0 : _b.height))
    return node;
  const pageArea = getPageArea(page);
  const height2 = transformHeight(pageArea, node.style.height);
  const style = Object.assign({}, node.style, { height: height2 });
  return Object.assign({}, node, { style });
};
var resolvePagePercentHeight = (page) => {
  if (!page.children)
    return page;
  const resolveChild = (child) => resolveNodePercentHeight(page, child);
  const children = page.children.map(resolveChild);
  return Object.assign({}, page, { children });
};
var resolvePercentHeight = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, { children });
};
var isType = (type) => (node) => node.type === type;
var isLink = isType(Link);
var isText = isType(Text);
var isTextInstance = isType(TextInstance);
var hasRenderProp = (node) => "render" in node.props;
var isTextType = (node) => isText(node) || isTextInstance(node);
var isTextLink = (node) => {
  const children = node.children || [];
  if (children.every(isTextInstance))
    return true;
  if (children.every(isText))
    return false;
  return children.every(isTextType);
};
var wrapText = (node) => {
  const textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, { children: [textElement] });
};
var transformLink = (node) => {
  if (!isLink(node))
    return node;
  if (hasRenderProp(node))
    return Object.assign({}, node, { type: Text });
  if (isTextLink(node))
    return wrapText(node);
  return node;
};
var resolveLinkSubstitution = (node) => {
  if (!node.children)
    return node;
  const resolveChild = compose(transformLink, resolveLinkSubstitution);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
var layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles2, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);

// node_modules/@react-pdf/reconciler/lib/index.js
var import_react4 = __toESM(require_react());

// node_modules/@react-pdf/reconciler/lib/reconciler-31.js
var import_react = __toESM(require_react(), 1);
var n = __toESM(require_scheduler(), 1);
function t(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
function r2(e4) {
  if (e4.__esModule) return e4;
  var n5 = e4.default;
  if ("function" == typeof n5) {
    var t4 = function e5() {
      return this instanceof e5 ? Reflect.construct(n5, arguments, this.constructor) : n5.apply(this, arguments);
    };
    t4.prototype = n5.prototype;
  } else t4 = {};
  return Object.defineProperty(t4, "__esModule", { value: true }), Object.keys(e4).forEach(function(n6) {
    var r5 = Object.getOwnPropertyDescriptor(e4, n6);
    Object.defineProperty(t4, n6, r5.get ? r5 : { enumerable: true, get: function() {
      return e4[n6];
    } });
  }), t4;
}
var a = { exports: {} };
var u = r2(n);
var i;
var c = { exports: {} };
false ? a.exports = (l || (l = 1, (s = o).exports = function(n5) {
  function t4(e4, n6, t5, r6) {
    return new $r(e4, n6, t5, r6);
  }
  function r5(e4) {
    var n6 = "https://react.dev/errors/" + e4;
    if (1 < arguments.length) {
      n6 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t5 = 2; t5 < arguments.length; t5++) n6 += "&args[]=" + encodeURIComponent(arguments[t5]);
    }
    return "Minified React error #" + e4 + "; visit " + n6 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l2(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = Cl && e4[Cl] || e4["@@iterator"]) ? e4 : null;
  }
  function a4(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.$$typeof === El ? null : e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case dl:
        return "Fragment";
      case fl:
        return "Portal";
      case ml:
        return "Profiler";
      case pl:
        return "StrictMode";
      case vl:
        return "Suspense";
      case Sl:
        return "SuspenseList";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case yl:
        return (e4.displayName || "Context") + ".Provider";
      case gl:
        return (e4._context.displayName || "Context") + ".Consumer";
      case bl:
        var n6 = e4.render;
        return (e4 = e4.displayName) || (e4 = "" !== (e4 = n6.displayName || n6.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
      case kl:
        return null !== (n6 = e4.displayName || null) ? n6 : a4(e4.type) || "Memo";
      case wl:
        n6 = e4._payload, e4 = e4._init;
        try {
          return a4(e4(n6));
        } catch (e5) {
        }
    }
    return null;
  }
  function o2(e4) {
    if (void 0 === rl) try {
      throw Error();
    } catch (e5) {
      var n6 = e5.stack.trim().match(/\n( *(at )?)/);
      rl = n6 && n6[1] || "", ll = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + rl + e4 + ll;
  }
  function i4(e4, n6) {
    if (!e4 || _l) return "";
    _l = true;
    var t5 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r6 = { DetermineComponentFrameRoot: function() {
        try {
          if (n6) {
            var t6 = function() {
              throw Error();
            };
            if (Object.defineProperty(t6.prototype, "props", { set: function() {
              throw Error();
            } }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t6, []);
              } catch (e5) {
                var r7 = e5;
              }
              Reflect.construct(e4, [], t6);
            } else {
              try {
                t6.call();
              } catch (e5) {
                r7 = e5;
              }
              e4.call(t6.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e5) {
              r7 = e5;
            }
            (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
            });
          }
        } catch (e5) {
          if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
        }
        return [null, null];
      } };
      r6.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l3 = Object.getOwnPropertyDescriptor(r6.DetermineComponentFrameRoot, "name");
      l3 && l3.configurable && Object.defineProperty(r6.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a5 = r6.DetermineComponentFrameRoot(), u4 = a5[0], i5 = a5[1];
      if (u4 && i5) {
        var s3 = u4.split("\n"), c5 = i5.split("\n");
        for (l3 = r6 = 0; r6 < s3.length && !s3[r6].includes("DetermineComponentFrameRoot"); ) r6++;
        for (; l3 < c5.length && !c5[l3].includes("DetermineComponentFrameRoot"); ) l3++;
        if (r6 === s3.length || l3 === c5.length) for (r6 = s3.length - 1, l3 = c5.length - 1; 1 <= r6 && 0 <= l3 && s3[r6] !== c5[l3]; ) l3--;
        for (; 1 <= r6 && 0 <= l3; r6--, l3--) if (s3[r6] !== c5[l3]) {
          if (1 !== r6 || 1 !== l3) do {
            if (r6--, 0 > --l3 || s3[r6] !== c5[l3]) {
              var f4 = "\n" + s3[r6].replace(" at new ", " at ");
              return e4.displayName && f4.includes("<anonymous>") && (f4 = f4.replace("<anonymous>", e4.displayName)), f4;
            }
          } while (1 <= r6 && 0 <= l3);
          break;
        }
      }
    } finally {
      _l = false, Error.prepareStackTrace = t5;
    }
    return (t5 = e4 ? e4.displayName || e4.name : "") ? o2(t5) : "";
  }
  function s2(e4) {
    switch (e4.tag) {
      case 26:
      case 27:
      case 5:
        return o2(e4.type);
      case 16:
        return o2("Lazy");
      case 13:
        return o2("Suspense");
      case 19:
        return o2("SuspenseList");
      case 0:
      case 15:
        return i4(e4.type, false);
      case 11:
        return i4(e4.type.render, false);
      case 1:
        return i4(e4.type, true);
      default:
        return "";
    }
  }
  function c4(e4) {
    try {
      var n6 = "";
      do {
        n6 += s2(e4), e4 = e4.return;
      } while (e4);
      return n6;
    } catch (e5) {
      return "\nError generating stack: " + e5.message + "\n" + e5.stack;
    }
  }
  function f3(e4) {
    return { current: e4 };
  }
  function d2(e4) {
    0 > Na || (e4.current = Ta[Na], Ta[Na] = null, Na--);
  }
  function p3(e4, n6) {
    Na++, Ta[Na] = e4.current, e4.current = n6;
  }
  function m(e4) {
    var n6 = 42 & e4;
    if (0 !== n6) return n6;
    switch (e4 & -e4) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 4194176 & e4;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e4;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e4;
    }
  }
  function h3(e4, n6) {
    var t5 = e4.pendingLanes;
    if (0 === t5) return 0;
    var r6 = 0, l3 = e4.suspendedLanes;
    e4 = e4.pingedLanes;
    var a5 = 134217727 & t5;
    return 0 !== a5 ? 0 != (t5 = a5 & ~l3) ? r6 = m(t5) : 0 != (e4 &= a5) && (r6 = m(e4)) : 0 != (t5 &= ~l3) ? r6 = m(t5) : 0 !== e4 && (r6 = m(e4)), 0 === r6 ? 0 : 0 !== n6 && n6 !== r6 && 0 == (n6 & l3) && ((l3 = r6 & -r6) >= (e4 = n6 & -n6) || 32 === l3 && 0 != (4194176 & e4)) ? n6 : r6;
  }
  function g3(e4, n6) {
    switch (e4) {
      case 1:
      case 2:
      case 4:
      case 8:
        return n6 + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n6 + 5e3;
      default:
        return -1;
    }
  }
  function y3() {
    var e4 = Fa;
    return 0 == (4194176 & (Fa <<= 1)) && (Fa = 128), e4;
  }
  function b3() {
    var e4 = Ma;
    return 0 == (62914560 & (Ma <<= 1)) && (Ma = 4194304), e4;
  }
  function v3(e4) {
    for (var n6 = [], t5 = 0; 31 > t5; t5++) n6.push(e4);
    return n6;
  }
  function S3(e4, n6) {
    e4.pendingLanes |= n6, 268435456 !== n6 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
  }
  function k3(e4, n6, t5) {
    e4.pendingLanes |= n6, e4.suspendedLanes &= ~n6;
    var r6 = 31 - Ua(n6);
    e4.entangledLanes |= n6, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 4194218 & t5;
  }
  function w(e4, n6) {
    var t5 = e4.entangledLanes |= n6;
    for (e4 = e4.entanglements; t5; ) {
      var r6 = 31 - Ua(t5), l3 = 1 << r6;
      l3 & n6 | e4[r6] & n6 && (e4[r6] |= n6), t5 &= ~l3;
    }
  }
  function x(e4) {
    return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
  }
  function z(e4) {
    "function" == typeof qa && Ya(e4);
  }
  function C(e4, n6) {
    if ("object" == typeof e4 && null !== e4) {
      var t5 = Ka.get(e4);
      return void 0 !== t5 ? t5 : (n6 = { value: e4, source: n6, stack: c4(n6) }, Ka.set(e4, n6), n6);
    }
    return { value: e4, source: n6, stack: c4(n6) };
  }
  function E(e4) {
    for (; e4 === eo; ) eo = Xa[--Za], Xa[Za] = null, Xa[--Za], Xa[Za] = null;
    for (; e4 === ro; ) ro = no[--to], no[to] = null, no[--to], no[to] = null, no[--to], no[to] = null;
  }
  function P(e4, n6) {
    p3(oo, n6), p3(ao, e4), p3(lo, null), e4 = Nl(n6), d2(lo), p3(lo, e4);
  }
  function _() {
    d2(lo), d2(ao), d2(oo);
  }
  function R(e4) {
    null !== e4.memoizedState && p3(uo, e4);
    var n6 = lo.current, t5 = Ll(n6, e4.type);
    n6 !== t5 && (p3(ao, e4), p3(lo, t5));
  }
  function T(e4) {
    ao.current === e4 && (d2(lo), d2(ao)), uo.current === e4 && (d2(uo), ra._currentValue2 = ta);
  }
  function N() {
    for (var e4 = fo, n6 = po = fo = 0; n6 < e4; ) {
      var t5 = co[n6];
      co[n6++] = null;
      var r6 = co[n6];
      co[n6++] = null;
      var l3 = co[n6];
      co[n6++] = null;
      var a5 = co[n6];
      if (co[n6++] = null, null !== r6 && null !== l3) {
        var o3 = r6.pending;
        null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r6.pending = l3;
      }
      0 !== a5 && I(t5, l3, a5);
    }
  }
  function L(e4, n6, t5, r6) {
    co[fo++] = e4, co[fo++] = n6, co[fo++] = t5, co[fo++] = r6, po |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
  }
  function U(e4, n6, t5, r6) {
    return L(e4, n6, t5, r6), F(e4);
  }
  function D(e4, n6) {
    return L(e4, null, null, n6), F(e4);
  }
  function I(e4, n6, t5) {
    e4.lanes |= t5;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= t5);
    for (var l3 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || 1 & e4._visibility || (l3 = true)), e4 = a5, a5 = a5.return;
    l3 && null !== n6 && 3 === e4.tag && (a5 = e4.stateNode, l3 = 31 - Ua(t5), null === (e4 = (a5 = a5.hiddenUpdates)[l3]) ? a5[l3] = [n6] : e4.push(n6), n6.lane = 536870912 | t5);
  }
  function F(e4) {
    if (50 < ti) throw ti = 0, ri = null, Error(r5(185));
    for (var n6 = e4.return; null !== n6; ) n6 = (e4 = n6).return;
    return 3 === e4.tag ? e4.stateNode : null;
  }
  function M(e4) {
    e4 !== ho && null === e4.next && (null === ho ? mo = ho = e4 : ho = ho.next = e4), yo = true, go || (go = true, Wa(Oa, H));
  }
  function W(e4, n6) {
    if (!bo && yo) {
      bo = true;
      do {
        for (var t5 = false, r6 = mo; null !== r6; ) {
          if (0 !== e4) {
            var l3 = r6.pendingLanes;
            if (0 === l3) var a5 = 0;
            else {
              var o3 = r6.suspendedLanes, u4 = r6.pingedLanes;
              a5 = (1 << 31 - Ua(42 | e4) + 1) - 1, a5 = 201326677 & (a5 &= l3 & ~(o3 & ~u4)) ? 201326677 & a5 | 1 : a5 ? 2 | a5 : 0;
            }
            0 !== a5 && (t5 = true, Q(r6, a5));
          } else a5 = Lu, 0 != (3 & (a5 = h3(r6, r6 === Tu ? a5 : 0))) && (t5 = true, Q(r6, a5));
          r6 = r6.next;
        }
      } while (t5);
      bo = false;
    }
  }
  function H() {
    yo = go = false;
    var e4 = 0;
    0 !== vo && (Gl() && (e4 = vo), vo = 0);
    for (var n6 = Qa(), t5 = null, r6 = mo; null !== r6; ) {
      var l3 = r6.next, a5 = j(r6, n6);
      0 === a5 ? (r6.next = null, null === t5 ? mo = l3 : t5.next = l3, null === l3 && (ho = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (yo = true)), r6 = l3;
    }
    W(e4);
  }
  function j(e4, n6) {
    for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l3 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
      var o3 = 31 - Ua(a5), u4 = 1 << o3, i5 = l3[o3];
      -1 === i5 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l3[o3] = g3(u4, n6)) : i5 <= n6 && (e4.expiredLanes |= u4), a5 &= ~u4;
    }
    if (t5 = Lu, t5 = h3(e4, e4 === (n6 = Tu) ? t5 : 0), r6 = e4.callbackNode, 0 === t5 || e4 === n6 && 2 === Uu || null !== e4.cancelPendingCommit) return null !== r6 && null !== r6 && Ha(r6), e4.callbackNode = null, e4.callbackPriority = 0;
    if (0 != (3 & t5)) return null !== r6 && null !== r6 && Ha(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
    if ((n6 = t5 & -t5) === e4.callbackPriority) return n6;
    switch (null !== r6 && Ha(r6), x(t5)) {
      case 2:
        t5 = Oa;
        break;
      case 8:
        t5 = Ba;
        break;
      case 32:
      default:
        t5 = Va;
        break;
      case 268435456:
        t5 = $a;
    }
    return r6 = A.bind(null, e4), t5 = Wa(t5, r6), e4.callbackPriority = n6, e4.callbackNode = t5, n6;
  }
  function A(e4, n6) {
    var t5 = e4.callbackNode;
    if (Wr() && e4.callbackNode !== t5) return null;
    var r6 = Lu;
    return 0 === (r6 = h3(e4, e4 === Tu ? r6 : 0)) ? null : (gr(e4, r6, n6), j(e4, Qa()), e4.callbackNode === t5 ? A.bind(null, e4) : null);
  }
  function Q(e4, n6) {
    if (Wr()) return null;
    gr(e4, n6, true);
  }
  function O() {
    return 0 === vo && (vo = y3()), vo;
  }
  function B() {
    if (0 == --ko && null !== So) {
      null !== xo && (xo.status = "fulfilled");
      var e4 = So;
      So = null, wo = 0, xo = null;
      for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
    }
  }
  function V(e4) {
    e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  function $(e4, n6) {
    e4 = e4.updateQueue, n6.updateQueue === e4 && (n6.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
  }
  function q(e4) {
    return { lane: e4, tag: 0, payload: null, callback: null, next: null };
  }
  function Y(e4, n6, t5) {
    var r6 = e4.updateQueue;
    if (null === r6) return null;
    if (r6 = r6.shared, 0 != (2 & Ru)) {
      var l3 = r6.pending;
      return null === l3 ? n6.next = n6 : (n6.next = l3.next, l3.next = n6), r6.pending = n6, n6 = F(e4), I(e4, null, t5), n6;
    }
    return L(e4, r6, n6, t5), F(e4);
  }
  function G2(e4, n6, t5) {
    if (null !== (n6 = n6.updateQueue) && (n6 = n6.shared, 0 != (4194176 & t5))) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, w(e4, t5);
    }
  }
  function J(e4, n6) {
    var t5 = e4.updateQueue, r6 = e4.alternate;
    if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
      var l3 = null, a5 = null;
      if (null !== (t5 = t5.firstBaseUpdate)) {
        do {
          var o3 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
          null === a5 ? l3 = a5 = o3 : a5 = a5.next = o3, t5 = t5.next;
        } while (null !== t5);
        null === a5 ? l3 = a5 = n6 : a5 = a5.next = n6;
      } else l3 = a5 = n6;
      return t5 = { baseState: r6.baseState, firstBaseUpdate: l3, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
    }
    null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n6 : e4.next = n6, t5.lastBaseUpdate = n6;
  }
  function K() {
    if (Co && null !== xo) throw xo;
  }
  function X(e4, n6, t5, r6) {
    Co = false;
    var l3 = e4.updateQueue;
    zo = false;
    var a5 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u4 = l3.shared.pending;
    if (null !== u4) {
      l3.shared.pending = null;
      var i5 = u4, s3 = i5.next;
      i5.next = null, null === o3 ? a5 = s3 : o3.next = s3, o3 = i5;
      var c5 = e4.alternate;
      null !== c5 && (u4 = (c5 = c5.updateQueue).lastBaseUpdate) !== o3 && (null === u4 ? c5.firstBaseUpdate = s3 : u4.next = s3, c5.lastBaseUpdate = i5);
    }
    if (null !== a5) {
      var f4 = l3.baseState;
      for (o3 = 0, c5 = s3 = i5 = null, u4 = a5; ; ) {
        var d3 = -536870913 & u4.lane, p4 = d3 !== u4.lane;
        if (p4 ? (Lu & d3) === d3 : (r6 & d3) === d3) {
          0 !== d3 && d3 === wo && (Co = true), null !== c5 && (c5 = c5.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
          e: {
            var m2 = e4, h4 = u4;
            d3 = n6;
            var g4 = t5;
            switch (h4.tag) {
              case 1:
                if ("function" == typeof (m2 = h4.payload)) {
                  f4 = m2.call(g4, f4, d3);
                  break e;
                }
                f4 = m2;
                break e;
              case 3:
                m2.flags = -65537 & m2.flags | 128;
              case 0:
                if (null == (d3 = "function" == typeof (m2 = h4.payload) ? m2.call(g4, f4, d3) : m2)) break e;
                f4 = il({}, f4, d3);
                break e;
              case 2:
                zo = true;
            }
          }
          null !== (d3 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l3.callbacks) ? l3.callbacks = [d3] : p4.push(d3));
        } else p4 = { lane: d3, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c5 ? (s3 = c5 = p4, i5 = f4) : c5 = c5.next = p4, o3 |= d3;
        if (null === (u4 = u4.next)) {
          if (null === (u4 = l3.shared.pending)) break;
          u4 = (p4 = u4).next, p4.next = null, l3.lastBaseUpdate = p4, l3.shared.pending = null;
        }
      }
      null === c5 && (i5 = f4), l3.baseState = i5, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c5, null === a5 && (l3.shared.lanes = 0), Hu |= o3, e4.lanes = o3, e4.memoizedState = f4;
    }
  }
  function Z(e4, n6) {
    if ("function" != typeof e4) throw Error(r5(191, e4));
    e4.call(n6);
  }
  function ee(e4, n6) {
    var t5 = e4.callbacks;
    if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) Z(t5[e4], n6);
  }
  function ne(e4, n6) {
    if (Ja(e4, n6)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof n6 || null === n6) return false;
    var t5 = Object.keys(e4), r6 = Object.keys(n6);
    if (t5.length !== r6.length) return false;
    for (r6 = 0; r6 < t5.length; r6++) {
      var l3 = t5[r6];
      if (!Eo.call(n6, l3) || !Ja(e4[l3], n6[l3])) return false;
    }
    return true;
  }
  function te(e4) {
    return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
  }
  function re() {
  }
  function le(e4, n6, t5) {
    switch (void 0 === (t5 = e4[t5]) ? e4.push(n6) : t5 !== n6 && (n6.then(re, re), n6 = t5), n6.status) {
      case "fulfilled":
        return n6.value;
      case "rejected":
        if ((e4 = n6.reason) === Po) throw Error(r5(483));
        throw e4;
      default:
        if ("string" == typeof n6.status) n6.then(re, re);
        else {
          if (null !== (e4 = Tu) && 100 < e4.shellSuspendCounter) throw Error(r5(482));
          (e4 = n6).status = "pending", e4.then(function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "fulfilled", t6.value = e5;
            }
          }, function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "rejected", t6.reason = e5;
            }
          });
        }
        switch (n6.status) {
          case "fulfilled":
            return n6.value;
          case "rejected":
            if ((e4 = n6.reason) === Po) throw Error(r5(483));
            throw e4;
        }
        throw To = n6, Po;
    }
  }
  function ae() {
    if (null === To) throw Error(r5(459));
    var e4 = To;
    return To = null, e4;
  }
  function oe(e4) {
    var n6 = Lo;
    return Lo += 1, null === No && (No = []), le(No, e4, n6);
  }
  function ue(e4, n6, t5, r6) {
    e4 = r6.props.ref, t5.ref = void 0 !== e4 ? e4 : null;
  }
  function ie(e4, n6) {
    if (n6.$$typeof === sl) throw Error(r5(525));
    throw e4 = Object.prototype.toString.call(n6), Error(r5(31, "[object Object]" === e4 ? "object with keys {" + Object.keys(n6).join(", ") + "}" : e4));
  }
  function se(e4) {
    return (0, e4._init)(e4._payload);
  }
  function ce(e4) {
    function n6(n7, t5) {
      if (e4) {
        var r6 = n7.deletions;
        null === r6 ? (n7.deletions = [t5], n7.flags |= 16) : r6.push(t5);
      }
    }
    function a5(t5, r6) {
      if (!e4) return null;
      for (; null !== r6; ) n6(t5, r6), r6 = r6.sibling;
      return null;
    }
    function o3(e5) {
      for (var n7 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n7.set(e5.key, e5) : n7.set(e5.index, e5), e5 = e5.sibling;
      return n7;
    }
    function u4(e5, n7) {
      return (e5 = Yr(e5, n7)).index = 0, e5.sibling = null, e5;
    }
    function i5(n7, t5, r6) {
      return n7.index = r6, e4 ? null !== (r6 = n7.alternate) ? (r6 = r6.index) < t5 ? (n7.flags |= 33554434, t5) : r6 : (n7.flags |= 33554434, t5) : (n7.flags |= 1048576, t5);
    }
    function s3(n7) {
      return e4 && null === n7.alternate && (n7.flags |= 33554434), n7;
    }
    function c5(e5, n7, t5, r6) {
      return null === n7 || 6 !== n7.tag ? ((n7 = Zr(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    function f4(e5, n7, t5, r6) {
      var l3 = t5.type;
      return l3 === dl ? p4(e5, n7, t5.props.children, r6, t5.key) : null !== n7 && (n7.elementType === l3 || "object" == typeof l3 && null !== l3 && l3.$$typeof === wl && se(l3) === n7.type) ? (ue(e5, 0, r6 = u4(n7, t5.props), t5), r6.return = e5, r6) : (ue(e5, 0, r6 = Jr(t5.type, t5.key, t5.props, null, e5.mode, r6), t5), r6.return = e5, r6);
    }
    function d3(e5, n7, t5, r6) {
      return null === n7 || 4 !== n7.tag || n7.stateNode.containerInfo !== t5.containerInfo || n7.stateNode.implementation !== t5.implementation ? ((n7 = el(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5.children || [])).return = e5, n7);
    }
    function p4(e5, n7, t5, r6, l3) {
      return null === n7 || 7 !== n7.tag ? ((n7 = Kr(t5, e5.mode, r6, l3)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    function m2(e5, n7, t5) {
      if ("string" == typeof n7 && "" !== n7 || "number" == typeof n7 || "bigint" == typeof n7) return (n7 = Zr("" + n7, e5.mode, t5)).return = e5, n7;
      if ("object" == typeof n7 && null !== n7) {
        switch (n7.$$typeof) {
          case cl:
            return ue(e5, 0, t5 = Jr(n7.type, n7.key, n7.props, null, e5.mode, t5), n7), t5.return = e5, t5;
          case fl:
            return (n7 = el(n7, e5.mode, t5)).return = e5, n7;
          case wl:
            return m2(e5, n7 = (0, n7._init)(n7._payload), t5);
        }
        if (Rl(n7) || l2(n7)) return (n7 = Kr(n7, e5.mode, t5, null)).return = e5, n7;
        if ("function" == typeof n7.then) return m2(e5, oe(n7), t5);
        if (n7.$$typeof === yl) return m2(e5, yt(e5, n7), t5);
        ie(e5, n7);
      }
      return null;
    }
    function h4(e5, n7, t5, r6) {
      var a6 = null !== n7 ? n7.key : null;
      if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== a6 ? null : c5(e5, n7, "" + t5, r6);
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case cl:
            return t5.key === a6 ? f4(e5, n7, t5, r6) : null;
          case fl:
            return t5.key === a6 ? d3(e5, n7, t5, r6) : null;
          case wl:
            return h4(e5, n7, t5 = (a6 = t5._init)(t5._payload), r6);
        }
        if (Rl(t5) || l2(t5)) return null !== a6 ? null : p4(e5, n7, t5, r6, null);
        if ("function" == typeof t5.then) return h4(e5, n7, oe(t5), r6);
        if (t5.$$typeof === yl) return h4(e5, n7, yt(e5, t5), r6);
        ie(e5, t5);
      }
      return null;
    }
    function g4(e5, n7, t5, r6, a6) {
      if ("string" == typeof r6 && "" !== r6 || "number" == typeof r6 || "bigint" == typeof r6) return c5(n7, e5 = e5.get(t5) || null, "" + r6, a6);
      if ("object" == typeof r6 && null !== r6) {
        switch (r6.$$typeof) {
          case cl:
            return f4(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case fl:
            return d3(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case wl:
            return g4(e5, n7, t5, r6 = (0, r6._init)(r6._payload), a6);
        }
        if (Rl(r6) || l2(r6)) return p4(n7, e5 = e5.get(t5) || null, r6, a6, null);
        if ("function" == typeof r6.then) return g4(e5, n7, t5, oe(r6), a6);
        if (r6.$$typeof === yl) return g4(e5, n7, t5, yt(n7, r6), a6);
        ie(n7, r6);
      }
      return null;
    }
    function y4(t5, c6, f5, d4) {
      if ("object" == typeof f5 && null !== f5 && f5.type === dl && null === f5.key && (f5 = f5.props.children), "object" == typeof f5 && null !== f5) {
        switch (f5.$$typeof) {
          case cl:
            e: {
              for (var p5 = f5.key, b4 = c6; null !== b4; ) {
                if (b4.key === p5) {
                  if ((p5 = f5.type) === dl) {
                    if (7 === b4.tag) {
                      a5(t5, b4.sibling), (c6 = u4(b4, f5.props.children)).return = t5, t5 = c6;
                      break e;
                    }
                  } else if (b4.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === wl && se(p5) === b4.type) {
                    a5(t5, b4.sibling), ue(t5, 0, c6 = u4(b4, f5.props), f5), c6.return = t5, t5 = c6;
                    break e;
                  }
                  a5(t5, b4);
                  break;
                }
                n6(t5, b4), b4 = b4.sibling;
              }
              f5.type === dl ? ((c6 = Kr(f5.props.children, t5.mode, d4, f5.key)).return = t5, t5 = c6) : (ue(t5, 0, d4 = Jr(f5.type, f5.key, f5.props, null, t5.mode, d4), f5), d4.return = t5, t5 = d4);
            }
            return s3(t5);
          case fl:
            e: {
              for (b4 = f5.key; null !== c6; ) {
                if (c6.key === b4) {
                  if (4 === c6.tag && c6.stateNode.containerInfo === f5.containerInfo && c6.stateNode.implementation === f5.implementation) {
                    a5(t5, c6.sibling), (c6 = u4(c6, f5.children || [])).return = t5, t5 = c6;
                    break e;
                  }
                  a5(t5, c6);
                  break;
                }
                n6(t5, c6), c6 = c6.sibling;
              }
              (c6 = el(f5, t5.mode, d4)).return = t5, t5 = c6;
            }
            return s3(t5);
          case wl:
            return y4(t5, c6, f5 = (b4 = f5._init)(f5._payload), d4);
        }
        if (Rl(f5)) return function(t6, r6, l3, u5) {
          for (var s4 = null, c7 = null, f6 = r6, d5 = r6 = 0, p6 = null; null !== f6 && d5 < l3.length; d5++) {
            f6.index > d5 ? (p6 = f6, f6 = null) : p6 = f6.sibling;
            var y5 = h4(t6, f6, l3[d5], u5);
            if (null === y5) {
              null === f6 && (f6 = p6);
              break;
            }
            e4 && f6 && null === y5.alternate && n6(t6, f6), r6 = i5(y5, r6, d5), null === c7 ? s4 = y5 : c7.sibling = y5, c7 = y5, f6 = p6;
          }
          if (d5 === l3.length) return a5(t6, f6), s4;
          if (null === f6) {
            for (; d5 < l3.length; d5++) null !== (f6 = m2(t6, l3[d5], u5)) && (r6 = i5(f6, r6, d5), null === c7 ? s4 = f6 : c7.sibling = f6, c7 = f6);
            return s4;
          }
          for (f6 = o3(f6); d5 < l3.length; d5++) null !== (p6 = g4(f6, t6, d5, l3[d5], u5)) && (e4 && null !== p6.alternate && f6.delete(null === p6.key ? d5 : p6.key), r6 = i5(p6, r6, d5), null === c7 ? s4 = p6 : c7.sibling = p6, c7 = p6);
          return e4 && f6.forEach(function(e5) {
            return n6(t6, e5);
          }), s4;
        }(t5, c6, f5, d4);
        if (l2(f5)) {
          if ("function" != typeof (b4 = l2(f5))) throw Error(r5(150));
          return function(t6, l3, u5, s4) {
            if (null == u5) throw Error(r5(151));
            for (var c7 = null, f6 = null, d5 = l3, p6 = l3 = 0, y5 = null, b5 = u5.next(); null !== d5 && !b5.done; p6++, b5 = u5.next()) {
              d5.index > p6 ? (y5 = d5, d5 = null) : y5 = d5.sibling;
              var v4 = h4(t6, d5, b5.value, s4);
              if (null === v4) {
                null === d5 && (d5 = y5);
                break;
              }
              e4 && d5 && null === v4.alternate && n6(t6, d5), l3 = i5(v4, l3, p6), null === f6 ? c7 = v4 : f6.sibling = v4, f6 = v4, d5 = y5;
            }
            if (b5.done) return a5(t6, d5), c7;
            if (null === d5) {
              for (; !b5.done; p6++, b5 = u5.next()) null !== (b5 = m2(t6, b5.value, s4)) && (l3 = i5(b5, l3, p6), null === f6 ? c7 = b5 : f6.sibling = b5, f6 = b5);
              return c7;
            }
            for (d5 = o3(d5); !b5.done; p6++, b5 = u5.next()) null !== (b5 = g4(d5, t6, p6, b5.value, s4)) && (e4 && null !== b5.alternate && d5.delete(null === b5.key ? p6 : b5.key), l3 = i5(b5, l3, p6), null === f6 ? c7 = b5 : f6.sibling = b5, f6 = b5);
            return e4 && d5.forEach(function(e5) {
              return n6(t6, e5);
            }), c7;
          }(t5, c6, f5 = b4.call(f5), d4);
        }
        if ("function" == typeof f5.then) return y4(t5, c6, oe(f5), d4);
        if (f5.$$typeof === yl) return y4(t5, c6, yt(t5, f5), d4);
        ie(t5, f5);
      }
      return "string" == typeof f5 && "" !== f5 || "number" == typeof f5 || "bigint" == typeof f5 ? (f5 = "" + f5, null !== c6 && 6 === c6.tag ? (a5(t5, c6.sibling), (c6 = u4(c6, f5)).return = t5, t5 = c6) : (a5(t5, c6), (c6 = Zr(f5, t5.mode, d4)).return = t5, t5 = c6), s3(t5)) : a5(t5, c6);
    }
    return function(e5, n7, r6, l3) {
      try {
        Lo = 0;
        var a6 = y4(e5, n7, r6, l3);
        return No = null, a6;
      } catch (n8) {
        if (n8 === Po) throw n8;
        var o4 = t4(29, n8, null, e5.mode);
        return o4.lanes = l3, o4.return = e5, o4;
      }
    };
  }
  function fe(e4, n6) {
    p3(Fo, e4 = Mu), p3(Io, n6), Mu = e4 | n6.baseLanes;
  }
  function de() {
    p3(Fo, Mu), p3(Io, Io.current);
  }
  function pe() {
    Mu = Fo.current, d2(Io), d2(Fo);
  }
  function me(e4) {
    var n6 = e4.alternate;
    p3(Ho, 1 & Ho.current), p3(Mo, e4), null === Wo && (null === n6 || null !== Io.current || null !== n6.memoizedState) && (Wo = e4);
  }
  function he(e4) {
    if (22 === e4.tag) {
      if (p3(Ho, Ho.current), p3(Mo, e4), null === Wo) {
        var n6 = e4.alternate;
        null !== n6 && null !== n6.memoizedState && (Wo = e4);
      }
    } else ge();
  }
  function ge() {
    p3(Ho, Ho.current), p3(Mo, Mo.current);
  }
  function ye(e4) {
    d2(Mo), Wo === e4 && (Wo = null), d2(Ho);
  }
  function be(e4) {
    for (var n6 = e4; null !== n6; ) {
      if (13 === n6.tag) {
        var t5 = n6.memoizedState;
        if (null !== t5 && (null === (t5 = t5.dehydrated) || Sa(t5) || ka(t5))) return n6;
      } else if (19 === n6.tag && void 0 !== n6.memoizedProps.revealOrder) {
        if (0 != (128 & n6.flags)) return n6;
      } else if (null !== n6.child) {
        n6.child.return = n6, n6 = n6.child;
        continue;
      }
      if (n6 === e4) break;
      for (; null === n6.sibling; ) {
        if (null === n6.return || n6.return === e4) return null;
        n6 = n6.return;
      }
      n6.sibling.return = n6.return, n6 = n6.sibling;
    }
    return null;
  }
  function ve() {
    throw Error(r5(321));
  }
  function Se(e4, n6) {
    if (null === n6) return false;
    for (var t5 = 0; t5 < n6.length && t5 < e4.length; t5++) if (!Ja(e4[t5], n6[t5])) return false;
    return true;
  }
  function ke(e4, n6, t5, r6, l3, a5) {
    return jo = a5, Ao = n6, n6.memoizedState = null, n6.updateQueue = null, n6.lanes = 0, Pl.H = null === e4 || null === e4.memoizedState ? Zo : eu, $o = false, a5 = t5(r6, l3), $o = false, Vo && (a5 = xe(n6, t5, r6, l3)), we(e4), a5;
  }
  function we(e4) {
    Pl.H = Xo;
    var n6 = null !== Qo && null !== Qo.next;
    if (jo = 0, Oo = Qo = Ao = null, Bo = false, Yo = 0, Go = null, n6) throw Error(r5(300));
    null === e4 || lu || null !== (e4 = e4.dependencies) && mt(e4) && (lu = true);
  }
  function xe(e4, n6, t5, l3) {
    Ao = e4;
    var a5 = 0;
    do {
      if (Vo && (Go = null), Yo = 0, Vo = false, 25 <= a5) throw Error(r5(301));
      if (a5 += 1, Oo = Qo = null, null != e4.updateQueue) {
        var o3 = e4.updateQueue;
        o3.lastEffect = null, o3.events = null, o3.stores = null, null != o3.memoCache && (o3.memoCache.index = 0);
      }
      Pl.H = nu, o3 = n6(t5, l3);
    } while (Vo);
    return o3;
  }
  function ze() {
    var e4 = Pl.H, n6 = e4.useState()[0];
    return n6 = "function" == typeof n6.then ? Te(n6) : n6, e4 = e4.useState()[0], (null !== Qo ? Qo.memoizedState : null) !== e4 && (Ao.flags |= 1024), n6;
  }
  function Ce() {
    var e4 = 0 !== qo;
    return qo = 0, e4;
  }
  function Ee(e4, n6, t5) {
    n6.updateQueue = e4.updateQueue, n6.flags &= -2053, e4.lanes &= ~t5;
  }
  function Pe(e4) {
    if (Bo) {
      for (e4 = e4.memoizedState; null !== e4; ) {
        var n6 = e4.queue;
        null !== n6 && (n6.pending = null), e4 = e4.next;
      }
      Bo = false;
    }
    jo = 0, Oo = Qo = Ao = null, Vo = false, Yo = qo = 0, Go = null;
  }
  function _e() {
    var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === Oo ? Ao.memoizedState = Oo = e4 : Oo = Oo.next = e4, Oo;
  }
  function Re() {
    if (null === Qo) {
      var e4 = Ao.alternate;
      e4 = null !== e4 ? e4.memoizedState : null;
    } else e4 = Qo.next;
    var n6 = null === Oo ? Ao.memoizedState : Oo.next;
    if (null !== n6) Oo = n6, Qo = e4;
    else {
      if (null === e4) {
        if (null === Ao.alternate) throw Error(r5(467));
        throw Error(r5(310));
      }
      e4 = { memoizedState: (Qo = e4).memoizedState, baseState: Qo.baseState, baseQueue: Qo.baseQueue, queue: Qo.queue, next: null }, null === Oo ? Ao.memoizedState = Oo = e4 : Oo = Oo.next = e4;
    }
    return Oo;
  }
  function Te(e4) {
    var n6 = Yo;
    return Yo += 1, null === Go && (Go = []), e4 = le(Go, e4, n6), n6 = Ao, null === (null === Oo ? n6.memoizedState : Oo.next) && (n6 = n6.alternate, Pl.H = null === n6 || null === n6.memoizedState ? Zo : eu), e4;
  }
  function Ne(e4) {
    if (null !== e4 && "object" == typeof e4) {
      if ("function" == typeof e4.then) return Te(e4);
      if (e4.$$typeof === yl) return gt(e4);
    }
    throw Error(r5(438, String(e4)));
  }
  function Le(e4) {
    var n6 = null, t5 = Ao.updateQueue;
    if (null !== t5 && (n6 = t5.memoCache), null == n6) {
      var r6 = Ao.alternate;
      null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n6 = { data: r6.data.map(function(e5) {
        return e5.slice();
      }), index: 0 });
    }
    if (null == n6 && (n6 = { data: [], index: 0 }), null === t5 && (t5 = Ko(), Ao.updateQueue = t5), t5.memoCache = n6, void 0 === (t5 = n6.data[n6.index])) for (t5 = n6.data[n6.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = zl;
    return n6.index++, t5;
  }
  function Ue(e4, n6) {
    return "function" == typeof n6 ? n6(e4) : n6;
  }
  function De(e4) {
    return Ie(Re(), Qo, e4);
  }
  function Ie(e4, n6, t5) {
    var l3 = e4.queue;
    if (null === l3) throw Error(r5(311));
    l3.lastRenderedReducer = t5;
    var a5 = e4.baseQueue, o3 = l3.pending;
    if (null !== o3) {
      if (null !== a5) {
        var u4 = a5.next;
        a5.next = o3.next, o3.next = u4;
      }
      n6.baseQueue = a5 = o3, l3.pending = null;
    }
    if (o3 = e4.baseState, null === a5) e4.memoizedState = o3;
    else {
      var i5 = u4 = null, s3 = null, c5 = n6 = a5.next, f4 = false;
      do {
        var d3 = -536870913 & c5.lane;
        if (d3 !== c5.lane ? (Lu & d3) === d3 : (jo & d3) === d3) {
          var p4 = c5.revertLane;
          if (0 === p4) null !== s3 && (s3 = s3.next = { lane: 0, revertLane: 0, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }), d3 === wo && (f4 = true);
          else {
            if ((jo & p4) === p4) {
              c5 = c5.next, p4 === wo && (f4 = true);
              continue;
            }
            d3 = { lane: 0, revertLane: c5.revertLane, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }, null === s3 ? (i5 = s3 = d3, u4 = o3) : s3 = s3.next = d3, Ao.lanes |= p4, Hu |= p4;
          }
          d3 = c5.action, $o && t5(o3, d3), o3 = c5.hasEagerState ? c5.eagerState : t5(o3, d3);
        } else p4 = { lane: d3, revertLane: c5.revertLane, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }, null === s3 ? (i5 = s3 = p4, u4 = o3) : s3 = s3.next = p4, Ao.lanes |= d3, Hu |= d3;
        c5 = c5.next;
      } while (null !== c5 && c5 !== n6);
      if (null === s3 ? u4 = o3 : s3.next = i5, !Ja(o3, e4.memoizedState) && (lu = true, f4 && null !== (t5 = xo))) throw t5;
      e4.memoizedState = o3, e4.baseState = u4, e4.baseQueue = s3, l3.lastRenderedState = o3;
    }
    return null === a5 && (l3.lanes = 0), [e4.memoizedState, l3.dispatch];
  }
  function Fe(e4) {
    var n6 = Re(), t5 = n6.queue;
    if (null === t5) throw Error(r5(311));
    t5.lastRenderedReducer = e4;
    var l3 = t5.dispatch, a5 = t5.pending, o3 = n6.memoizedState;
    if (null !== a5) {
      t5.pending = null;
      var u4 = a5 = a5.next;
      do {
        o3 = e4(o3, u4.action), u4 = u4.next;
      } while (u4 !== a5);
      Ja(o3, n6.memoizedState) || (lu = true), n6.memoizedState = o3, null === n6.baseQueue && (n6.baseState = o3), t5.lastRenderedState = o3;
    }
    return [o3, l3];
  }
  function Me(e4, n6, t5) {
    var l3 = Ao, a5 = Re();
    t5 = n6();
    var o3 = !Ja((Qo || a5).memoizedState, t5);
    if (o3 && (a5.memoizedState = t5, lu = true), a5 = a5.queue, sn(je.bind(null, l3, a5, e4), [e4]), a5.getSnapshot !== n6 || o3 || null !== Oo && 1 & Oo.memoizedState.tag) {
      if (l3.flags |= 2048, rn(9, He.bind(null, l3, a5, t5, n6), { destroy: void 0 }, null), null === Tu) throw Error(r5(349));
      0 != (60 & jo) || We(l3, n6, t5);
    }
    return t5;
  }
  function We(e4, n6, t5) {
    e4.flags |= 16384, e4 = { getSnapshot: n6, value: t5 }, null === (n6 = Ao.updateQueue) ? (n6 = Ko(), Ao.updateQueue = n6, n6.stores = [e4]) : null === (t5 = n6.stores) ? n6.stores = [e4] : t5.push(e4);
  }
  function He(e4, n6, t5, r6) {
    n6.value = t5, n6.getSnapshot = r6, Ae(n6) && Qe(e4);
  }
  function je(e4, n6, t5) {
    return t5(function() {
      Ae(n6) && Qe(e4);
    });
  }
  function Ae(e4) {
    var n6 = e4.getSnapshot;
    e4 = e4.value;
    try {
      var t5 = n6();
      return !Ja(e4, t5);
    } catch (e5) {
      return true;
    }
  }
  function Qe(e4) {
    var n6 = D(e4, 2);
    null !== n6 && hr(n6, 0, 2);
  }
  function Oe(e4) {
    var n6 = _e();
    if ("function" == typeof e4) {
      var t5 = e4;
      if (e4 = t5(), $o) {
        z(true);
        try {
          t5();
        } finally {
          z(false);
        }
      }
    }
    return n6.memoizedState = n6.baseState = e4, n6.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ue, lastRenderedState: e4 }, n6;
  }
  function Be(e4, n6, t5, r6) {
    return e4.baseState = t5, Ie(e4, Qo, "function" == typeof r6 ? r6 : Ue);
  }
  function Ve(e4, n6, t5, l3, a5) {
    if (_n(e4)) throw Error(r5(485));
    if (null !== (e4 = n6.action)) {
      var o3 = { payload: a5, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e5) {
        o3.listeners.push(e5);
      } };
      null !== Pl.T ? t5(true) : o3.isTransition = false, l3(o3), null === (t5 = n6.pending) ? (o3.next = n6.pending = o3, $e(n6, o3)) : (o3.next = t5.next, n6.pending = t5.next = o3);
    }
  }
  function $e(e4, n6) {
    var t5 = n6.action, r6 = n6.payload, l3 = e4.state;
    if (n6.isTransition) {
      var a5 = Pl.T, o3 = {};
      Pl.T = o3;
      try {
        var u4 = t5(l3, r6), i5 = Pl.S;
        null !== i5 && i5(o3, u4), qe(e4, n6, u4);
      } catch (t6) {
        Ge(e4, n6, t6);
      } finally {
        Pl.T = a5;
      }
    } else try {
      qe(e4, n6, a5 = t5(l3, r6));
    } catch (t6) {
      Ge(e4, n6, t6);
    }
  }
  function qe(e4, n6, t5) {
    null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? t5.then(function(t6) {
      Ye(e4, n6, t6);
    }, function(t6) {
      return Ge(e4, n6, t6);
    }) : Ye(e4, n6, t5);
  }
  function Ye(e4, n6, t5) {
    n6.status = "fulfilled", n6.value = t5, Je(n6), e4.state = t5, null !== (n6 = e4.pending) && ((t5 = n6.next) === n6 ? e4.pending = null : (t5 = t5.next, n6.next = t5, $e(e4, t5)));
  }
  function Ge(e4, n6, t5) {
    var r6 = e4.pending;
    if (e4.pending = null, null !== r6) {
      r6 = r6.next;
      do {
        n6.status = "rejected", n6.reason = t5, Je(n6), n6 = n6.next;
      } while (n6 !== r6);
    }
    e4.action = null;
  }
  function Je(e4) {
    e4 = e4.listeners;
    for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
  }
  function Ke(e4, n6) {
    return n6;
  }
  function Xe(e4, n6) {
    var t5, r6, l3;
    (t5 = _e()).memoizedState = t5.baseState = n6, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ke, lastRenderedState: n6 }, t5.queue = r6, t5 = Cn.bind(null, Ao, r6), r6.dispatch = t5, r6 = Oe(false);
    var a5 = Pn.bind(null, Ao, false, r6.queue);
    return l3 = { state: n6, dispatch: null, action: e4, pending: null }, (r6 = _e()).queue = l3, t5 = Ve.bind(null, Ao, l3, a5, t5), l3.dispatch = t5, r6.memoizedState = e4, [n6, t5, false];
  }
  function Ze(e4) {
    return en(Re(), Qo, e4);
  }
  function en(e4, n6, t5) {
    n6 = Ie(e4, n6, Ke)[0], e4 = De(Ue)[0], n6 = "object" == typeof n6 && null !== n6 && "function" == typeof n6.then ? Te(n6) : n6;
    var r6 = Re(), l3 = r6.queue, a5 = l3.dispatch;
    return t5 !== r6.memoizedState && (Ao.flags |= 2048, rn(9, nn.bind(null, l3, t5), { destroy: void 0 }, null)), [n6, a5, e4];
  }
  function nn(e4, n6) {
    e4.action = n6;
  }
  function tn(e4) {
    var n6 = Re(), t5 = Qo;
    if (null !== t5) return en(n6, t5, e4);
    Re(), n6 = n6.memoizedState;
    var r6 = (t5 = Re()).queue.dispatch;
    return t5.memoizedState = e4, [n6, r6, false];
  }
  function rn(e4, n6, t5, r6) {
    return e4 = { tag: e4, create: n6, inst: t5, deps: r6, next: null }, null === (n6 = Ao.updateQueue) && (n6 = Ko(), Ao.updateQueue = n6), null === (t5 = n6.lastEffect) ? n6.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n6.lastEffect = e4), e4;
  }
  function ln() {
    return Re().memoizedState;
  }
  function an(e4, n6, t5, r6) {
    var l3 = _e();
    Ao.flags |= e4, l3.memoizedState = rn(1 | n6, t5, { destroy: void 0 }, void 0 === r6 ? null : r6);
  }
  function on3(e4, n6, t5, r6) {
    var l3 = Re();
    r6 = void 0 === r6 ? null : r6;
    var a5 = l3.memoizedState.inst;
    null !== Qo && null !== r6 && Se(r6, Qo.memoizedState.deps) ? l3.memoizedState = rn(n6, t5, a5, r6) : (Ao.flags |= e4, l3.memoizedState = rn(1 | n6, t5, a5, r6));
  }
  function un(e4, n6) {
    an(8390656, 8, e4, n6);
  }
  function sn(e4, n6) {
    on3(2048, 8, e4, n6);
  }
  function cn(e4, n6) {
    return on3(4, 2, e4, n6);
  }
  function fn(e4, n6) {
    return on3(4, 4, e4, n6);
  }
  function dn(e4, n6) {
    if ("function" == typeof n6) {
      e4 = e4();
      var t5 = n6(e4);
      return function() {
        "function" == typeof t5 ? t5() : n6(null);
      };
    }
    if (null != n6) return e4 = e4(), n6.current = e4, function() {
      n6.current = null;
    };
  }
  function pn(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, on3(4, 4, dn.bind(null, n6, e4), t5);
  }
  function mn() {
  }
  function hn(e4, n6) {
    var t5 = Re();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    return null !== n6 && Se(n6, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n6], e4);
  }
  function gn(e4, n6) {
    var t5 = Re();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    if (null !== n6 && Se(n6, r6[1])) return r6[0];
    if (r6 = e4(), $o) {
      z(true);
      try {
        e4();
      } finally {
        z(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }
  function yn(e4, n6, t5) {
    return void 0 === t5 || 0 != (1073741824 & jo) ? e4.memoizedState = n6 : (e4.memoizedState = t5, e4 = mr(), Ao.lanes |= e4, Hu |= e4, t5);
  }
  function bn(e4, n6, t5, r6) {
    return Ja(t5, n6) ? t5 : null !== Io.current ? (e4 = yn(e4, t5, r6), Ja(e4, n6) || (lu = true), e4) : 0 == (42 & jo) ? (lu = true, e4.memoizedState = t5) : (e4 = mr(), Ao.lanes |= e4, Hu |= e4, n6);
  }
  function vn(e4, n6, t5, r6, l3) {
    var a5 = ql();
    $l(0 !== a5 && 8 > a5 ? a5 : 8);
    var o3, u4, i5, s3 = Pl.T, c5 = {};
    Pl.T = c5, Pn(e4, false, n6, t5);
    try {
      var f4 = l3(), d3 = Pl.S;
      null !== d3 && d3(c5, f4), null !== f4 && "object" == typeof f4 && "function" == typeof f4.then ? En(e4, n6, (o3 = r6, u4 = [], i5 = { status: "pending", value: null, reason: null, then: function(e5) {
        u4.push(e5);
      } }, f4.then(function() {
        i5.status = "fulfilled", i5.value = o3;
        for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o3);
      }, function(e5) {
        for (i5.status = "rejected", i5.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
      }), i5), pr()) : En(e4, n6, r6, pr());
    } catch (t6) {
      En(e4, n6, { then: function() {
      }, status: "rejected", reason: t6 }, pr());
    } finally {
      $l(a5), Pl.T = s3;
    }
  }
  function Sn() {
    return gt(ra);
  }
  function kn() {
    return Re().memoizedState;
  }
  function wn() {
    return Re().memoizedState;
  }
  function xn(e4) {
    for (var n6 = e4.return; null !== n6; ) {
      switch (n6.tag) {
        case 24:
        case 3:
          var t5 = pr(), r6 = Y(n6, e4 = q(t5), t5);
          return null !== r6 && (hr(r6, 0, t5), G2(r6, n6, t5)), n6 = { cache: vt() }, void (e4.payload = n6);
      }
      n6 = n6.return;
    }
  }
  function zn(e4, n6, t5) {
    var r6 = pr();
    t5 = { lane: r6, revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null }, _n(e4) ? Rn(n6, t5) : null !== (t5 = U(e4, n6, t5, r6)) && (hr(t5, 0, r6), Tn(t5, n6, r6));
  }
  function Cn(e4, n6, t5) {
    En(e4, n6, t5, pr());
  }
  function En(e4, n6, t5, r6) {
    var l3 = { lane: r6, revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null };
    if (_n(e4)) Rn(n6, l3);
    else {
      var a5 = e4.alternate;
      if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n6.lastRenderedReducer)) try {
        var o3 = n6.lastRenderedState, u4 = a5(o3, t5);
        if (l3.hasEagerState = true, l3.eagerState = u4, Ja(u4, o3)) return L(e4, n6, l3, 0), null === Tu && N(), false;
      } catch (e5) {
      }
      if (null !== (t5 = U(e4, n6, l3, r6))) return hr(t5, 0, r6), Tn(t5, n6, r6), true;
    }
    return false;
  }
  function Pn(e4, n6, t5, l3) {
    if (l3 = { lane: 2, revertLane: O(), action: l3, hasEagerState: false, eagerState: null, next: null }, _n(e4)) {
      if (n6) throw Error(r5(479));
    } else null !== (n6 = U(e4, t5, l3, 2)) && hr(n6, 0, 2);
  }
  function _n(e4) {
    var n6 = e4.alternate;
    return e4 === Ao || null !== n6 && n6 === Ao;
  }
  function Rn(e4, n6) {
    Vo = Bo = true;
    var t5 = e4.pending;
    null === t5 ? n6.next = n6 : (n6.next = t5.next, t5.next = n6), e4.pending = n6;
  }
  function Tn(e4, n6, t5) {
    if (0 != (4194176 & t5)) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, w(e4, t5);
    }
  }
  function Nn(e4, n6, t5, r6) {
    t5 = null == (t5 = t5(r6, n6 = e4.memoizedState)) ? n6 : il({}, n6, t5), e4.memoizedState = t5, 0 === e4.lanes && (e4.updateQueue.baseState = t5);
  }
  function Ln(e4, n6, t5, r6, l3, a5, o3) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, a5, o3) : !(n6.prototype && n6.prototype.isPureReactComponent && ne(t5, r6) && ne(l3, a5));
  }
  function Un(e4, n6, t5, r6) {
    e4 = n6.state, "function" == typeof n6.componentWillReceiveProps && n6.componentWillReceiveProps(t5, r6), "function" == typeof n6.UNSAFE_componentWillReceiveProps && n6.UNSAFE_componentWillReceiveProps(t5, r6), n6.state !== e4 && tu.enqueueReplaceState(n6, n6.state, null);
  }
  function Dn(e4, n6) {
    var t5 = n6;
    if ("ref" in n6) for (var r6 in t5 = {}, n6) "ref" !== r6 && (t5[r6] = n6[r6]);
    if (e4 = e4.defaultProps) for (var l3 in t5 === n6 && (t5 = il({}, t5)), e4) void 0 === t5[l3] && (t5[l3] = e4[l3]);
    return t5;
  }
  function In(e4, n6) {
    try {
      (0, e4.onUncaughtError)(n6.value, { componentStack: n6.stack });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  function Fn(e4, n6, t5) {
    try {
      (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n6.tag ? n6.stateNode : null });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  function Mn(e4, n6, t5) {
    return (t5 = q(t5)).tag = 3, t5.payload = { element: null }, t5.callback = function() {
      In(e4, n6);
    }, t5;
  }
  function Wn(e4) {
    return (e4 = q(e4)).tag = 3, e4;
  }
  function Hn(e4, n6, t5, r6) {
    var l3 = t5.type.getDerivedStateFromError;
    if ("function" == typeof l3) {
      var a5 = r6.value;
      e4.payload = function() {
        return l3(a5);
      }, e4.callback = function() {
        Fn(n6, t5, r6);
      };
    }
    var o3 = t5.stateNode;
    null !== o3 && "function" == typeof o3.componentDidCatch && (e4.callback = function() {
      Fn(n6, t5, r6), "function" != typeof l3 && (null === Ju ? Ju = /* @__PURE__ */ new Set([this]) : Ju.add(this));
      var e5 = r6.stack;
      this.componentDidCatch(r6.value, { componentStack: null !== e5 ? e5 : "" });
    });
  }
  function jn(e4, n6, t5, r6) {
    n6.child = null === e4 ? Do(n6, null, t5, r6) : Uo(n6, e4.child, t5, r6);
  }
  function An(e4, n6, t5, r6, l3) {
    t5 = t5.render;
    var a5 = n6.ref;
    if ("ref" in r6) {
      var o3 = {};
      for (var u4 in r6) "ref" !== u4 && (o3[u4] = r6[u4]);
    } else o3 = r6;
    return ht(n6), r6 = ke(e4, n6, t5, o3, a5, l3), u4 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, r6, l3), n6.child) : (Ee(e4, n6, l3), at(e4, n6, l3));
  }
  function Qn(e4, n6, t5, r6, l3) {
    if (null === e4) {
      var a5 = t5.type;
      return "function" != typeof a5 || qr(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = Jr(t5.type, null, r6, n6, n6.mode, l3)).ref = n6.ref, e4.return = n6, n6.child = e4) : (n6.tag = 15, n6.type = a5, On(e4, n6, a5, r6, l3));
    }
    if (a5 = e4.child, !ot(e4, l3)) {
      var o3 = a5.memoizedProps;
      if ((t5 = null !== (t5 = t5.compare) ? t5 : ne)(o3, r6) && e4.ref === n6.ref) return at(e4, n6, l3);
    }
    return n6.flags |= 1, (e4 = Yr(a5, r6)).ref = n6.ref, e4.return = n6, n6.child = e4;
  }
  function On(e4, n6, t5, r6, l3) {
    if (null !== e4) {
      var a5 = e4.memoizedProps;
      if (ne(a5, r6) && e4.ref === n6.ref) {
        if (lu = false, n6.pendingProps = r6 = a5, !ot(e4, l3)) return n6.lanes = e4.lanes, at(e4, n6, l3);
        0 != (131072 & e4.flags) && (lu = true);
      }
    }
    return qn(e4, n6, t5, r6, l3);
  }
  function Bn(e4, n6, t5) {
    var r6 = n6.pendingProps, l3 = r6.children, a5 = 0 != (2 & n6.stateNode._pendingVisibility), o3 = null !== e4 ? e4.memoizedState : null;
    if ($n(e4, n6), "hidden" === r6.mode || a5) {
      if (0 != (128 & n6.flags)) {
        if (r6 = null !== o3 ? o3.baseLanes | t5 : t5, null !== e4) {
          for (l3 = n6.child = e4.child, a5 = 0; null !== l3; ) a5 = a5 | l3.lanes | l3.childLanes, l3 = l3.sibling;
          n6.childLanes = a5 & ~r6;
        } else n6.childLanes = 0, n6.child = null;
        return Vn(e4, n6, r6, t5);
      }
      if (0 == (536870912 & t5)) return n6.lanes = n6.childLanes = 536870912, Vn(e4, n6, null !== o3 ? o3.baseLanes | t5 : t5, t5);
      n6.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && wt(0, null !== o3 ? o3.cachePool : null), null !== o3 ? fe(n6, o3) : de(), he(n6);
    } else null !== o3 ? (wt(0, o3.cachePool), fe(n6, o3), ge(), n6.memoizedState = null) : (null !== e4 && wt(0, null), de(), ge());
    return jn(e4, n6, l3, t5), n6.child;
  }
  function Vn(e4, n6, t5, r6) {
    var l3 = kt();
    return l3 = null === l3 ? null : { parent: pu._currentValue2, pool: l3 }, n6.memoizedState = { baseLanes: t5, cachePool: l3 }, null !== e4 && wt(0, null), de(), he(n6), null !== e4 && pt(e4, n6, r6, true), null;
  }
  function $n(e4, n6) {
    var t5 = n6.ref;
    if (null === t5) null !== e4 && null !== e4.ref && (n6.flags |= 2097664);
    else {
      if ("function" != typeof t5 && "object" != typeof t5) throw Error(r5(284));
      null !== e4 && e4.ref === t5 || (n6.flags |= 2097664);
    }
  }
  function qn(e4, n6, t5, r6, l3) {
    return ht(n6), t5 = ke(e4, n6, t5, r6, void 0, l3), r6 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, t5, l3), n6.child) : (Ee(e4, n6, l3), at(e4, n6, l3));
  }
  function Yn(e4, n6, t5, r6, l3, a5) {
    return ht(n6), n6.updateQueue = null, t5 = xe(n6, r6, t5, l3), we(e4), r6 = Ce(), null === e4 || lu ? (n6.flags |= 1, jn(e4, n6, t5, a5), n6.child) : (Ee(e4, n6, a5), at(e4, n6, a5));
  }
  function Gn(e4, n6, t5, r6, l3) {
    if (ht(n6), null === n6.stateNode) {
      var a5 = La, o3 = t5.contextType;
      "object" == typeof o3 && null !== o3 && (a5 = gt(o3)), a5 = new t5(r6, a5), n6.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = tu, n6.stateNode = a5, a5._reactInternals = n6, (a5 = n6.stateNode).props = r6, a5.state = n6.memoizedState, a5.refs = {}, V(n6), o3 = t5.contextType, a5.context = "object" == typeof o3 && null !== o3 ? gt(o3) : La, a5.state = n6.memoizedState, "function" == typeof (o3 = t5.getDerivedStateFromProps) && (Nn(n6, t5, o3, r6), a5.state = n6.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o3 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o3 !== a5.state && tu.enqueueReplaceState(a5, a5.state, null), X(n6, r6, a5, l3), K(), a5.state = n6.memoizedState), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = true;
    } else if (null === e4) {
      a5 = n6.stateNode;
      var u4 = n6.memoizedProps, i5 = Dn(t5, u4);
      a5.props = i5;
      var s3 = a5.context, c5 = t5.contextType;
      o3 = La, "object" == typeof c5 && null !== c5 && (o3 = gt(c5));
      var f4 = t5.getDerivedStateFromProps;
      c5 = "function" == typeof f4 || "function" == typeof a5.getSnapshotBeforeUpdate, u4 = n6.pendingProps !== u4, c5 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 || s3 !== o3) && Un(n6, a5, r6, o3), zo = false;
      var d3 = n6.memoizedState;
      a5.state = d3, X(n6, r6, a5, l3), K(), s3 = n6.memoizedState, u4 || d3 !== s3 || zo ? ("function" == typeof f4 && (Nn(n6, t5, f4, r6), s3 = n6.memoizedState), (i5 = zo || Ln(n6, t5, i5, r6, d3, s3, o3)) ? (c5 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308)) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), n6.memoizedProps = r6, n6.memoizedState = s3), a5.props = r6, a5.state = s3, a5.context = o3, r6 = i5) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = false);
    } else {
      a5 = n6.stateNode, $(e4, n6), c5 = Dn(t5, o3 = n6.memoizedProps), a5.props = c5, f4 = n6.pendingProps, d3 = a5.context, s3 = t5.contextType, i5 = La, "object" == typeof s3 && null !== s3 && (i5 = gt(s3)), (s3 = "function" == typeof (u4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o3 !== f4 || d3 !== i5) && Un(n6, a5, r6, i5), zo = false, d3 = n6.memoizedState, a5.state = d3, X(n6, r6, a5, l3), K();
      var p4 = n6.memoizedState;
      o3 !== f4 || d3 !== p4 || zo || null !== e4 && null !== e4.dependencies && mt(e4.dependencies) ? ("function" == typeof u4 && (Nn(n6, t5, u4, r6), p4 = n6.memoizedState), (c5 = zo || Ln(n6, t5, c5, r6, d3, p4, i5) || null !== e4 && null !== e4.dependencies && mt(e4.dependencies)) ? (s3 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, p4, i5), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, p4, i5)), "function" == typeof a5.componentDidUpdate && (n6.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n6.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && d3 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && d3 === e4.memoizedState || (n6.flags |= 1024), n6.memoizedProps = r6, n6.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = i5, r6 = c5) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && d3 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && d3 === e4.memoizedState || (n6.flags |= 1024), r6 = false);
    }
    return a5 = r6, $n(e4, n6), r6 = 0 != (128 & n6.flags), a5 || r6 ? (a5 = n6.stateNode, t5 = r6 && "function" != typeof t5.getDerivedStateFromError ? null : a5.render(), n6.flags |= 1, null !== e4 && r6 ? (n6.child = Uo(n6, e4.child, null, l3), n6.child = Uo(n6, null, t5, l3)) : jn(e4, n6, t5, l3), n6.memoizedState = a5.state, e4 = n6.child) : e4 = at(e4, n6, l3), e4;
  }
  function Jn(e4) {
    return { baseLanes: e4, cachePool: xt() };
  }
  function Kn(e4, n6, t5) {
    return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n6 && (e4 |= Qu), e4;
  }
  function Xn(e4, n6, t5) {
    var l3, a5, o3, u4, i5 = n6.pendingProps, s3 = false, c5 = 0 != (128 & n6.flags);
    if ((l3 = c5) || (l3 = (null === e4 || null !== e4.memoizedState) && 0 != (2 & Ho.current)), l3 && (s3 = true, n6.flags &= -129), l3 = 0 != (32 & n6.flags), n6.flags &= -33, null === e4) return a5 = i5.children, i5 = i5.fallback, s3 ? (ge(), a5 = et({ mode: "hidden", children: a5 }, s3 = n6.mode), i5 = Kr(i5, s3, t5, null), a5.return = n6, i5.return = n6, a5.sibling = i5, n6.child = a5, (s3 = n6.child).memoizedState = Jn(t5), s3.childLanes = Kn(e4, l3, t5), n6.memoizedState = au, i5) : (me(n6), Zn(n6, a5));
    if (null !== (o3 = e4.memoizedState) && null !== (a5 = o3.dehydrated)) {
      if (c5) 256 & n6.flags ? (me(n6), n6.flags &= -257, n6 = nt(e4, n6, t5)) : null !== n6.memoizedState ? (ge(), n6.child = e4.child, n6.flags |= 128, n6 = null) : (ge(), s3 = i5.fallback, a5 = n6.mode, i5 = et({ mode: "visible", children: i5.children }, a5), (s3 = Kr(s3, a5, t5, null)).flags |= 2, i5.return = n6, s3.return = n6, i5.sibling = s3, n6.child = i5, Uo(n6, e4.child, null, t5), (i5 = n6.child).memoizedState = Jn(t5), i5.childLanes = Kn(e4, l3, t5), n6.memoizedState = au, n6 = s3);
      else if (me(n6), ka(a5)) l3 = wa(a5).digest, (i5 = Error(r5(419))).stack = "", i5.digest = l3, u4 = { value: i5, source: null, stack: null }, null === so ? so = [u4] : so.push(u4), n6 = nt(e4, n6, t5);
      else if (lu || pt(e4, n6, t5, false), l3 = 0 != (t5 & e4.childLanes), lu || l3) {
        if (null !== (l3 = Tu)) {
          if (0 != (42 & (i5 = t5 & -t5))) i5 = 1;
          else switch (i5) {
            case 2:
              i5 = 1;
              break;
            case 8:
              i5 = 4;
              break;
            case 32:
              i5 = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              i5 = 64;
              break;
            case 268435456:
              i5 = 134217728;
              break;
            default:
              i5 = 0;
          }
          if (0 !== (i5 = 0 != (i5 & (l3.suspendedLanes | t5)) ? 0 : i5) && i5 !== o3.retryLane) throw o3.retryLane = i5, D(e4, i5), hr(l3, 0, i5), ru;
        }
        Sa(a5) || Pr(), n6 = nt(e4, n6, t5);
      } else Sa(a5) ? (n6.flags |= 128, n6.child = e4.child, n6 = Br.bind(null, e4), xa(a5, n6), n6 = null) : (e4 = o3.treeContext, (n6 = Zn(n6, i5.children)).flags |= 4096);
      return n6;
    }
    return s3 ? (ge(), s3 = i5.fallback, a5 = n6.mode, c5 = (o3 = e4.child).sibling, (i5 = Yr(o3, { mode: "hidden", children: i5.children })).subtreeFlags = 31457280 & o3.subtreeFlags, null !== c5 ? s3 = Yr(c5, s3) : (s3 = Kr(s3, a5, t5, null)).flags |= 2, s3.return = n6, i5.return = n6, i5.sibling = s3, n6.child = i5, i5 = s3, s3 = n6.child, null === (a5 = e4.child.memoizedState) ? a5 = Jn(t5) : (null !== (o3 = a5.cachePool) ? (c5 = pu._currentValue2, o3 = o3.parent !== c5 ? { parent: c5, pool: c5 } : o3) : o3 = xt(), a5 = { baseLanes: a5.baseLanes | t5, cachePool: o3 }), s3.memoizedState = a5, s3.childLanes = Kn(e4, l3, t5), n6.memoizedState = au, i5) : (me(n6), e4 = (t5 = e4.child).sibling, (t5 = Yr(t5, { mode: "visible", children: i5.children })).return = n6, t5.sibling = null, null !== e4 && (null === (l3 = n6.deletions) ? (n6.deletions = [e4], n6.flags |= 16) : l3.push(e4)), n6.child = t5, n6.memoizedState = null, t5);
  }
  function Zn(e4, n6) {
    return (n6 = et({ mode: "visible", children: n6 }, e4.mode)).return = e4, e4.child = n6;
  }
  function et(e4, n6) {
    return Xr(e4, n6, 0, null);
  }
  function nt(e4, n6, t5) {
    return Uo(n6, e4.child, null, t5), (e4 = Zn(n6, n6.pendingProps.children)).flags |= 2, n6.memoizedState = null, e4;
  }
  function tt(e4, n6, t5) {
    e4.lanes |= n6;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= n6), ft(e4.return, n6, t5);
  }
  function rt(e4, n6, t5, r6, l3) {
    var a5 = e4.memoizedState;
    null === a5 ? e4.memoizedState = { isBackwards: n6, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l3 } : (a5.isBackwards = n6, a5.rendering = null, a5.renderingStartTime = 0, a5.last = r6, a5.tail = t5, a5.tailMode = l3);
  }
  function lt(e4, n6, t5) {
    var r6 = n6.pendingProps, l3 = r6.revealOrder, a5 = r6.tail;
    if (jn(e4, n6, r6.children, t5), 0 != (2 & (r6 = Ho.current))) r6 = 1 & r6 | 2, n6.flags |= 128;
    else {
      if (null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n6.child; null !== e4; ) {
        if (13 === e4.tag) null !== e4.memoizedState && tt(e4, t5, n6);
        else if (19 === e4.tag) tt(e4, t5, n6);
        else if (null !== e4.child) {
          e4.child.return = e4, e4 = e4.child;
          continue;
        }
        if (e4 === n6) break e;
        for (; null === e4.sibling; ) {
          if (null === e4.return || e4.return === n6) break e;
          e4 = e4.return;
        }
        e4.sibling.return = e4.return, e4 = e4.sibling;
      }
      r6 &= 1;
    }
    switch (p3(Ho, r6), l3) {
      case "forwards":
        for (t5 = n6.child, l3 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === be(e4) && (l3 = t5), t5 = t5.sibling;
        null === (t5 = l3) ? (l3 = n6.child, n6.child = null) : (l3 = t5.sibling, t5.sibling = null), rt(n6, false, l3, t5, a5);
        break;
      case "backwards":
        for (t5 = null, l3 = n6.child, n6.child = null; null !== l3; ) {
          if (null !== (e4 = l3.alternate) && null === be(e4)) {
            n6.child = l3;
            break;
          }
          e4 = l3.sibling, l3.sibling = t5, t5 = l3, l3 = e4;
        }
        rt(n6, true, t5, null, a5);
        break;
      case "together":
        rt(n6, false, null, null, void 0);
        break;
      default:
        n6.memoizedState = null;
    }
    return n6.child;
  }
  function at(e4, n6, t5) {
    if (null !== e4 && (n6.dependencies = e4.dependencies), Hu |= n6.lanes, 0 == (t5 & n6.childLanes)) {
      if (null === e4) return null;
      if (pt(e4, n6, t5, false), 0 == (t5 & n6.childLanes)) return null;
    }
    if (null !== e4 && n6.child !== e4.child) throw Error(r5(153));
    if (null !== n6.child) {
      for (t5 = Yr(e4 = n6.child, e4.pendingProps), n6.child = t5, t5.return = n6; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = Yr(e4, e4.pendingProps)).return = n6;
      t5.sibling = null;
    }
    return n6.child;
  }
  function ot(e4, n6) {
    return 0 != (e4.lanes & n6) || !(null === (e4 = e4.dependencies) || !mt(e4));
  }
  function ut(e4, n6, t5) {
    if (null !== e4) if (e4.memoizedProps !== n6.pendingProps) lu = true;
    else {
      if (!ot(e4, t5) && 0 == (128 & n6.flags)) return lu = false, function(e5, n7, t6) {
        switch (n7.tag) {
          case 3:
            P(n7, n7.stateNode.containerInfo), st(0, pu, e5.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n7);
            break;
          case 4:
            P(n7, n7.stateNode.containerInfo);
            break;
          case 10:
            st(0, n7.type, n7.memoizedProps.value);
            break;
          case 13:
            var r6 = n7.memoizedState;
            if (null !== r6) return null !== r6.dehydrated ? (me(n7), n7.flags |= 128, null) : 0 != (t6 & n7.child.childLanes) ? Xn(e5, n7, t6) : (me(n7), null !== (e5 = at(e5, n7, t6)) ? e5.sibling : null);
            me(n7);
            break;
          case 19:
            var l4 = 0 != (128 & e5.flags);
            if ((r6 = 0 != (t6 & n7.childLanes)) || (pt(e5, n7, t6, false), r6 = 0 != (t6 & n7.childLanes)), l4) {
              if (r6) return lt(e5, n7, t6);
              n7.flags |= 128;
            }
            if (null !== (l4 = n7.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), p3(Ho, Ho.current), r6) break;
            return null;
          case 22:
          case 23:
            return n7.lanes = 0, Bn(e5, n7, t6);
          case 24:
            st(0, pu, e5.memoizedState.cache);
        }
        return at(e5, n7, t6);
      }(e4, n6, t5);
      lu = 0 != (131072 & e4.flags);
    }
    else lu = false;
    switch (n6.lanes = 0, n6.tag) {
      case 16:
        e: {
          e4 = n6.pendingProps;
          var l3 = n6.elementType, o3 = l3._init;
          if (l3 = o3(l3._payload), n6.type = l3, "function" != typeof l3) {
            if (null != l3) {
              if ((o3 = l3.$$typeof) === bl) {
                n6.tag = 11, n6 = An(null, n6, l3, e4, t5);
                break e;
              }
              if (o3 === kl) {
                n6.tag = 14, n6 = Qn(null, n6, l3, e4, t5);
                break e;
              }
            }
            throw n6 = a4(l3) || l3, Error(r5(306, n6, ""));
          }
          qr(l3) ? (e4 = Dn(l3, e4), n6.tag = 1, n6 = Gn(null, n6, l3, e4, t5)) : (n6.tag = 0, n6 = qn(null, n6, l3, e4, t5));
        }
        return n6;
      case 0:
        return qn(e4, n6, n6.type, n6.pendingProps, t5);
      case 1:
        return Gn(e4, n6, l3 = n6.type, o3 = Dn(l3, n6.pendingProps), t5);
      case 3:
        if (P(n6, n6.stateNode.containerInfo), null === e4) throw Error(r5(387));
        var u4 = n6.pendingProps;
        l3 = (o3 = n6.memoizedState).element, $(e4, n6), X(n6, u4, null, t5);
        var i5 = n6.memoizedState;
        return u4 = i5.cache, st(0, pu, u4), u4 !== o3.cache && dt(n6, [pu], t5, true), K(), (u4 = i5.element) !== l3 ? (jn(e4, n6, u4, t5), n6 = n6.child) : n6 = at(e4, n6, t5), n6;
      case 26:
      case 27:
      case 5:
        return R(n6), o3 = n6.type, u4 = n6.pendingProps, i5 = null !== e4 ? e4.memoizedProps : null, l3 = u4.children, Wl(o3, u4) ? l3 = null : null !== i5 && Wl(o3, i5) && (n6.flags |= 32), null !== n6.memoizedState && (o3 = ke(e4, n6, ze, null, null, t5), ra._currentValue2 = o3), $n(e4, n6), jn(e4, n6, l3, t5), n6.child;
      case 6:
        return null;
      case 13:
        return Xn(e4, n6, t5);
      case 4:
        return P(n6, n6.stateNode.containerInfo), l3 = n6.pendingProps, null === e4 ? n6.child = Uo(n6, null, l3, t5) : jn(e4, n6, l3, t5), n6.child;
      case 11:
        return An(e4, n6, n6.type, n6.pendingProps, t5);
      case 7:
        return jn(e4, n6, n6.pendingProps, t5), n6.child;
      case 8:
      case 12:
        return jn(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 10:
        return l3 = n6.pendingProps, st(0, n6.type, l3.value), jn(e4, n6, l3.children, t5), n6.child;
      case 9:
        return o3 = n6.type._context, l3 = n6.pendingProps.children, ht(n6), l3 = l3(o3 = gt(o3)), n6.flags |= 1, jn(e4, n6, l3, t5), n6.child;
      case 14:
        return Qn(e4, n6, n6.type, n6.pendingProps, t5);
      case 15:
        return On(e4, n6, n6.type, n6.pendingProps, t5);
      case 19:
        return lt(e4, n6, t5);
      case 22:
        return Bn(e4, n6, t5);
      case 24:
        return ht(n6), l3 = gt(pu), null === e4 ? (null === (o3 = kt()) && (o3 = Tu, u4 = vt(), o3.pooledCache = u4, u4.refCount++, null !== u4 && (o3.pooledCacheLanes |= t5), o3 = u4), n6.memoizedState = { parent: l3, cache: o3 }, V(n6), st(0, pu, o3)) : (0 != (e4.lanes & t5) && ($(e4, n6), X(n6, null, null, t5), K()), o3 = e4.memoizedState, u4 = n6.memoizedState, o3.parent !== l3 ? (o3 = { parent: l3, cache: l3 }, n6.memoizedState = o3, 0 === n6.lanes && (n6.memoizedState = n6.updateQueue.baseState = o3), st(0, pu, l3)) : (l3 = u4.cache, st(0, pu, l3), l3 !== o3.cache && dt(n6, [pu], t5, true))), jn(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 29:
        throw n6.pendingProps;
    }
    throw Error(r5(156, n6.tag));
  }
  function it() {
    su = iu = uu = null;
  }
  function st(e4, n6, t5) {
    p3(ou, n6._currentValue2), n6._currentValue2 = t5;
  }
  function ct(e4) {
    var n6 = ou.current;
    e4._currentValue2 = n6, d2(ou);
  }
  function ft(e4, n6, t5) {
    for (; null !== e4; ) {
      var r6 = e4.alternate;
      if ((e4.childLanes & n6) !== n6 ? (e4.childLanes |= n6, null !== r6 && (r6.childLanes |= n6)) : null !== r6 && (r6.childLanes & n6) !== n6 && (r6.childLanes |= n6), e4 === t5) break;
      e4 = e4.return;
    }
  }
  function dt(e4, n6, t5, l3) {
    var a5 = e4.child;
    for (null !== a5 && (a5.return = e4); null !== a5; ) {
      var o3 = a5.dependencies;
      if (null !== o3) {
        var u4 = a5.child;
        o3 = o3.firstContext;
        e: for (; null !== o3; ) {
          var i5 = o3;
          o3 = a5;
          for (var s3 = 0; s3 < n6.length; s3++) if (i5.context === n6[s3]) {
            o3.lanes |= t5, null !== (i5 = o3.alternate) && (i5.lanes |= t5), ft(o3.return, t5, e4), l3 || (u4 = null);
            break e;
          }
          o3 = i5.next;
        }
      } else if (18 === a5.tag) {
        if (null === (u4 = a5.return)) throw Error(r5(341));
        u4.lanes |= t5, null !== (o3 = u4.alternate) && (o3.lanes |= t5), ft(u4, t5, e4), u4 = null;
      } else u4 = a5.child;
      if (null !== u4) u4.return = a5;
      else for (u4 = a5; null !== u4; ) {
        if (u4 === e4) {
          u4 = null;
          break;
        }
        if (null !== (a5 = u4.sibling)) {
          a5.return = u4.return, u4 = a5;
          break;
        }
        u4 = u4.return;
      }
      a5 = u4;
    }
  }
  function pt(e4, n6, t5, l3) {
    e4 = null;
    for (var a5 = n6, o3 = false; null !== a5; ) {
      if (!o3) {
        if (0 != (524288 & a5.flags)) o3 = true;
        else if (0 != (262144 & a5.flags)) break;
      }
      if (10 === a5.tag) {
        var u4 = a5.alternate;
        if (null === u4) throw Error(r5(387));
        if (null !== (u4 = u4.memoizedProps)) {
          var i5 = a5.type;
          Ja(a5.pendingProps.value, u4.value) || (null !== e4 ? e4.push(i5) : e4 = [i5]);
        }
      } else if (a5 === uo.current) {
        if (null === (u4 = a5.alternate)) throw Error(r5(387));
        u4.memoizedState.memoizedState !== a5.memoizedState.memoizedState && (null !== e4 ? e4.push(ra) : e4 = [ra]);
      }
      a5 = a5.return;
    }
    null !== e4 && dt(n6, e4, t5, l3), n6.flags |= 262144;
  }
  function mt(e4) {
    for (e4 = e4.firstContext; null !== e4; ) {
      var n6 = e4.context;
      if (!Ja(n6._currentValue2, e4.memoizedValue)) return true;
      e4 = e4.next;
    }
    return false;
  }
  function ht(e4) {
    uu = e4, su = iu = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
  }
  function gt(e4) {
    return bt(uu, e4);
  }
  function yt(e4, n6) {
    return null === uu && ht(e4), bt(e4, n6);
  }
  function bt(e4, n6) {
    var t5 = n6._currentValue2;
    if (su !== n6) if (n6 = { context: n6, memoizedValue: t5, next: null }, null === iu) {
      if (null === e4) throw Error(r5(308));
      iu = n6, e4.dependencies = { lanes: 0, firstContext: n6 }, e4.flags |= 524288;
    } else iu = iu.next = n6;
    return t5;
  }
  function vt() {
    return { controller: new cu(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  function St(e4) {
    e4.refCount--, 0 === e4.refCount && fu(du, function() {
      e4.controller.abort();
    });
  }
  function kt() {
    var e4 = hu.current;
    return null !== e4 ? e4 : Tu.pooledCache;
  }
  function wt(e4, n6) {
    p3(hu, null === n6 ? hu.current : n6.pool);
  }
  function xt() {
    var e4 = kt();
    return null === e4 ? null : { parent: pu._currentValue2, pool: e4 };
  }
  function zt(e4) {
    e4.flags |= 4;
  }
  function Ct(e4, n6) {
    null !== n6 && (e4.flags |= 4), 16384 & e4.flags && (n6 = 22 !== e4.tag ? b3() : 536870912, e4.lanes |= n6);
  }
  function Et(e4, n6) {
    switch (e4.tailMode) {
      case "hidden":
        n6 = e4.tail;
        for (var t5 = null; null !== n6; ) null !== n6.alternate && (t5 = n6), n6 = n6.sibling;
        null === t5 ? e4.tail = null : t5.sibling = null;
        break;
      case "collapsed":
        t5 = e4.tail;
        for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
        null === r6 ? n6 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  function Pt(e4) {
    var n6 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
    if (n6) for (var l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= 31457280 & l3.subtreeFlags, r6 |= 31457280 & l3.flags, l3.return = e4, l3 = l3.sibling;
    else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= l3.subtreeFlags, r6 |= l3.flags, l3.return = e4, l3 = l3.sibling;
    return e4.subtreeFlags |= r6, e4.childLanes = t5, n6;
  }
  function _t(e4, n6, t5) {
    var l3 = n6.pendingProps;
    switch (E(n6), n6.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return Pt(n6), null;
      case 3:
        return t5 = n6.stateNode, l3 = null, null !== e4 && (l3 = e4.memoizedState.cache), n6.memoizedState.cache !== l3 && (n6.flags |= 2048), ct(pu), _(), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n6.flags) || (n6.flags |= 1024, null !== so && (yr(so), so = null)), Pt(n6), null;
      case 26:
        var a5;
      case 27:
      case 5:
        if (T(n6), t5 = n6.type, null !== e4 && null != n6.stateNode) !function(e5, n7, t6, r6) {
          e5.memoizedProps !== r6 && zt(n7);
        }(e4, n6, 0, l3);
        else {
          if (!l3) {
            if (null === n6.stateNode) throw Error(r5(166));
            return Pt(n6), null;
          }
          e4 = lo.current, function(e5, n7, t6, r6) {
            for (t6 = n7.child; null !== t6; ) {
              if (5 === t6.tag || 6 === t6.tag) Fl(e5, t6.stateNode);
              else if (4 !== t6.tag && !Ra && null !== t6.child) {
                t6.child.return = t6, t6 = t6.child;
                continue;
              }
              if (t6 === n7) break;
              for (; null === t6.sibling; ) {
                if (null === t6.return || t6.return === n7) return;
                t6 = t6.return;
              }
              t6.sibling.return = t6.return, t6 = t6.sibling;
            }
          }(a5 = Il(t5, l3, oo.current, e4, n6), n6, false), n6.stateNode = a5, Ml(a5, t5, l3, e4) && zt(n6);
        }
        return Pt(n6), function(e5, n7, t6) {
          if (Kl(n7, t6)) {
            if (e5.flags |= 16777216, !Xl(n7, t6)) {
              if (!zr()) throw To = Ro, _o;
              e5.flags |= 8192;
            }
          } else e5.flags &= -16777217;
        }(n6, n6.type, n6.pendingProps), null;
      case 6:
        if (e4 && null != n6.stateNode) (t5 = e4.memoizedProps) !== l3 && zt(n6);
        else {
          if ("string" != typeof l3 && null === n6.stateNode) throw Error(r5(166));
          e4 = oo.current, t5 = lo.current, n6.stateNode = Hl(l3, e4, t5, n6);
        }
        return Pt(n6), null;
      case 13:
        if (l3 = n6.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
          if (a5 = false, null !== l3 && null !== l3.dehydrated) {
            if (null === e4) {
              if (!a5) throw Error(r5(318));
              throw Error(r5(344));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, Pt(n6), a5 = false;
          } else null !== so && (yr(so), so = null), a5 = true;
          if (!a5) return 256 & n6.flags ? (ye(n6), n6) : (ye(n6), null);
        }
        if (ye(n6), 0 != (128 & n6.flags)) return n6.lanes = t5, n6;
        if (t5 = null !== l3, e4 = null !== e4 && null !== e4.memoizedState, t5) {
          a5 = null, null !== (l3 = n6.child).alternate && null !== l3.alternate.memoizedState && null !== l3.alternate.memoizedState.cachePool && (a5 = l3.alternate.memoizedState.cachePool.pool);
          var o3 = null;
          null !== l3.memoizedState && null !== l3.memoizedState.cachePool && (o3 = l3.memoizedState.cachePool.pool), o3 !== a5 && (l3.flags |= 2048);
        }
        return t5 !== e4 && t5 && (n6.child.flags |= 8192), Ct(n6, n6.updateQueue), Pt(n6), null;
      case 4:
        return _(), null === e4 && Vl(n6.stateNode.containerInfo), Pt(n6), null;
      case 10:
        return ct(n6.type), Pt(n6), null;
      case 19:
        if (d2(Ho), null === (a5 = n6.memoizedState)) return Pt(n6), null;
        if (l3 = 0 != (128 & n6.flags), null === (o3 = a5.rendering)) if (l3) Et(a5, false);
        else {
          if (0 !== Wu || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n6.child; null !== e4; ) {
            if (null !== (o3 = be(e4))) {
              for (n6.flags |= 128, Et(a5, false), e4 = o3.updateQueue, n6.updateQueue = e4, Ct(n6, e4), n6.subtreeFlags = 0, e4 = t5, t5 = n6.child; null !== t5; ) Gr(t5, e4), t5 = t5.sibling;
              return p3(Ho, 1 & Ho.current | 2), n6.child;
            }
            e4 = e4.sibling;
          }
          null !== a5.tail && Qa() > Yu && (n6.flags |= 128, l3 = true, Et(a5, false), n6.lanes = 4194304);
        }
        else {
          if (!l3) if (null !== (e4 = be(o3))) {
            if (n6.flags |= 128, l3 = true, e4 = e4.updateQueue, n6.updateQueue = e4, Ct(n6, e4), Et(a5, true), null === a5.tail && "hidden" === a5.tailMode && !o3.alternate) return Pt(n6), null;
          } else 2 * Qa() - a5.renderingStartTime > Yu && 536870912 !== t5 && (n6.flags |= 128, l3 = true, Et(a5, false), n6.lanes = 4194304);
          a5.isBackwards ? (o3.sibling = n6.child, n6.child = o3) : (null !== (e4 = a5.last) ? e4.sibling = o3 : n6.child = o3, a5.last = o3);
        }
        return null !== a5.tail ? (n6 = a5.tail, a5.rendering = n6, a5.tail = n6.sibling, a5.renderingStartTime = Qa(), n6.sibling = null, e4 = Ho.current, p3(Ho, l3 ? 1 & e4 | 2 : 1 & e4), n6) : (Pt(n6), null);
      case 22:
      case 23:
        return ye(n6), pe(), l3 = null !== n6.memoizedState, null !== e4 ? null !== e4.memoizedState !== l3 && (n6.flags |= 8192) : l3 && (n6.flags |= 8192), l3 ? 0 != (536870912 & t5) && 0 == (128 & n6.flags) && (Pt(n6), 6 & n6.subtreeFlags && (n6.flags |= 8192)) : Pt(n6), null !== (t5 = n6.updateQueue) && Ct(n6, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), l3 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (l3 = n6.memoizedState.cachePool.pool), l3 !== t5 && (n6.flags |= 2048), null !== e4 && d2(hu), null;
      case 24:
        return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n6.memoizedState.cache !== t5 && (n6.flags |= 2048), ct(pu), Pt(n6), null;
      case 25:
        return null;
    }
    throw Error(r5(156, n6.tag));
  }
  function Rt(e4, n6) {
    switch (E(n6), n6.tag) {
      case 1:
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 3:
        return ct(pu), _(), 0 != (65536 & (e4 = n6.flags)) && 0 == (128 & e4) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 26:
      case 27:
      case 5:
        return T(n6), null;
      case 13:
        if (ye(n6), null !== (e4 = n6.memoizedState) && null !== e4.dehydrated && null === n6.alternate) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 19:
        return d2(Ho), null;
      case 4:
        return _(), null;
      case 10:
        return ct(n6.type), null;
      case 22:
      case 23:
        return ye(n6), pe(), null !== e4 && d2(hu), 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 24:
        return ct(pu), null;
      default:
        return null;
    }
  }
  function Tt(e4, n6) {
    switch (E(n6), n6.tag) {
      case 3:
        ct(pu), _();
        break;
      case 26:
      case 27:
      case 5:
        T(n6);
        break;
      case 4:
        _();
        break;
      case 13:
        ye(n6);
        break;
      case 19:
        d2(Ho);
        break;
      case 10:
        ct(n6.type);
        break;
      case 22:
      case 23:
        ye(n6), pe(), null !== e4 && d2(hu);
        break;
      case 24:
        ct(pu);
    }
  }
  function Nt(e4, n6) {
    try {
      var t5 = n6.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
      if (null !== r6) {
        var l3 = r6.next;
        t5 = l3;
        do {
          if ((t5.tag & e4) === e4) {
            r6 = void 0;
            var a5 = t5.create, o3 = t5.inst;
            r6 = a5(), o3.destroy = r6;
          }
          t5 = t5.next;
        } while (t5 !== l3);
      }
    } catch (e5) {
      jr(n6, n6.return, e5);
    }
  }
  function Lt(e4, n6, t5) {
    try {
      var r6 = n6.updateQueue, l3 = null !== r6 ? r6.lastEffect : null;
      if (null !== l3) {
        var a5 = l3.next;
        r6 = a5;
        do {
          if ((r6.tag & e4) === e4) {
            var o3 = r6.inst, u4 = o3.destroy;
            if (void 0 !== u4) {
              o3.destroy = void 0, l3 = n6;
              var i5 = t5;
              try {
                u4();
              } catch (e5) {
                jr(l3, i5, e5);
              }
            }
          }
          r6 = r6.next;
        } while (r6 !== a5);
      }
    } catch (e5) {
      jr(n6, n6.return, e5);
    }
  }
  function Ut(e4) {
    var n6 = e4.updateQueue;
    if (null !== n6) {
      var t5 = e4.stateNode;
      try {
        ee(n6, t5);
      } catch (n7) {
        jr(e4, e4.return, n7);
      }
    }
  }
  function Dt(e4, n6, t5) {
    t5.props = Dn(e4.type, e4.memoizedProps), t5.state = e4.memoizedState;
    try {
      t5.componentWillUnmount();
    } catch (t6) {
      jr(e4, n6, t6);
    }
  }
  function It(e4, n6) {
    try {
      var t5 = e4.ref;
      if (null !== t5) {
        var r6 = e4.stateNode;
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            var l3 = Tl(r6);
            break;
          default:
            l3 = r6;
        }
        "function" == typeof t5 ? e4.refCleanup = t5(l3) : t5.current = l3;
      }
    } catch (t6) {
      jr(e4, n6, t6);
    }
  }
  function Ft(e4, n6) {
    var t5 = e4.ref, r6 = e4.refCleanup;
    if (null !== t5) if ("function" == typeof r6) try {
      r6();
    } catch (t6) {
      jr(e4, n6, t6);
    } finally {
      e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
    }
    else if ("function" == typeof t5) try {
      t5(null);
    } catch (t6) {
      jr(e4, n6, t6);
    }
    else t5.current = null;
  }
  function Mt(e4) {
    var n6 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
    try {
      ia(r6, n6, t5, e4);
    } catch (n7) {
      jr(e4, e4.return, n7);
    }
  }
  function Wt(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  function Ht(e4) {
    e: for (; ; ) {
      for (; null === e4.sibling; ) {
        if (null === e4.return || Wt(e4.return)) return null;
        e4 = e4.return;
      }
      for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
        if (2 & e4.flags) continue e;
        if (null === e4.child || 4 === e4.tag) continue e;
        e4.child.return = e4, e4 = e4.child;
      }
      if (!(2 & e4.flags)) return e4.stateNode;
    }
  }
  function jt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? fa(t5, e4, n6) : oa(t5, e4);
    else if (4 !== r6 && !Ra && null !== (e4 = e4.child)) for (jt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) jt(e4, n6, t5), e4 = e4.sibling;
  }
  function At(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ca(t5, e4, n6) : aa(t5, e4);
    else if (4 !== r6 && !Ra && null !== (e4 = e4.child)) for (At(e4, n6, t5), e4 = e4.sibling; null !== e4; ) At(e4, n6, t5), e4 = e4.sibling;
  }
  function Qt(e4, n6, t5) {
    var r6 = t5.flags;
    switch (t5.tag) {
      case 0:
      case 11:
      case 15:
        Kt(e4, t5), 4 & r6 && Nt(5, t5);
        break;
      case 1:
        if (Kt(e4, t5), 4 & r6) if (e4 = t5.stateNode, null === n6) try {
          e4.componentDidMount();
        } catch (e5) {
          jr(t5, t5.return, e5);
        }
        else {
          var l3 = Dn(t5.type, n6.memoizedProps);
          n6 = n6.memoizedState;
          try {
            e4.componentDidUpdate(l3, n6, e4.__reactInternalSnapshotBeforeUpdate);
          } catch (e5) {
            jr(t5, t5.return, e5);
          }
        }
        64 & r6 && Ut(t5), 512 & r6 && It(t5, t5.return);
        break;
      case 3:
        if (Kt(e4, t5), 64 & r6 && null !== (r6 = t5.updateQueue)) {
          if (e4 = null, null !== t5.child) switch (t5.child.tag) {
            case 27:
            case 5:
              e4 = Tl(t5.child.stateNode);
              break;
            case 1:
              e4 = t5.child.stateNode;
          }
          try {
            ee(r6, e4);
          } catch (e5) {
            jr(t5, t5.return, e5);
          }
        }
        break;
      case 26:
      case 27:
      case 5:
        Kt(e4, t5), null === n6 && 4 & r6 && Mt(t5), 512 & r6 && It(t5, t5.return);
        break;
      case 12:
      case 13:
      default:
        Kt(e4, t5);
        break;
      case 22:
        if (!(l3 = null !== t5.memoizedState || gu)) {
          n6 = null !== n6 && null !== n6.memoizedState || yu;
          var a5 = gu, o3 = yu;
          gu = l3, (yu = n6) && !o3 ? Zt(e4, t5, 0 != (8772 & t5.subtreeFlags)) : Kt(e4, t5), gu = a5, yu = o3;
        }
        512 & r6 && ("manual" === t5.memoizedProps.mode ? It(t5, t5.return) : Ft(t5, t5.return));
    }
  }
  function Ot(e4) {
    var n6 = e4.alternate;
    null !== n6 && (e4.alternate = null, Ot(n6)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n6 = e4.stateNode) && Jl(n6), e4.stateNode = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
  }
  function Bt(e4, n6, t5) {
    for (t5 = t5.child; null !== t5; ) Vt(e4, n6, t5), t5 = t5.sibling;
  }
  function Vt(e4, n6, t5) {
    switch (t5.tag) {
      case 26:
      case 27:
        var r6, l3;
      case 5:
        yu || Ft(t5, n6);
      case 6:
        if (r6 = wu, l3 = xu, wu = null, Bt(e4, n6, t5), xu = l3, null !== (wu = r6)) if (xu) try {
          pa(wu, t5.stateNode);
        } catch (e5) {
          jr(t5, n6, e5);
        }
        else try {
          da(wu, t5.stateNode);
        } catch (e5) {
          jr(t5, n6, e5);
        }
        break;
      case 18:
        null !== wu && (xu ? Ca(wu, t5.stateNode) : za(wu, t5.stateNode));
        break;
      case 4:
        r6 = wu, l3 = xu, wu = t5.stateNode.containerInfo, xu = true, Bt(e4, n6, t5), wu = r6, xu = l3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        yu || Lt(2, t5, n6), yu || Lt(4, t5, n6), Bt(e4, n6, t5);
        break;
      case 1:
        yu || (Ft(t5, n6), "function" == typeof (r6 = t5.stateNode).componentWillUnmount && Dt(t5, n6, r6)), Bt(e4, n6, t5);
        break;
      case 21:
        Bt(e4, n6, t5);
        break;
      case 22:
        Ft(t5, n6), yu = (r6 = yu) || null !== t5.memoizedState, Bt(e4, n6, t5), yu = r6;
        break;
      default:
        Bt(e4, n6, t5);
    }
  }
  function $t(e4, n6) {
    var t5 = function(e5) {
      switch (e5.tag) {
        case 13:
        case 19:
          var n7 = e5.stateNode;
          return null === n7 && (n7 = e5.stateNode = new vu()), n7;
        case 22:
          return null === (n7 = (e5 = e5.stateNode)._retryCache) && (n7 = e5._retryCache = new vu()), n7;
        default:
          throw Error(r5(435, e5.tag));
      }
    }(e4);
    n6.forEach(function(n7) {
      var r6 = Vr.bind(null, e4, n7);
      t5.has(n7) || (t5.add(n7), n7.then(r6, r6));
    });
  }
  function qt(e4, n6) {
    var t5 = n6.deletions;
    if (null !== t5) for (var l3 = 0; l3 < t5.length; l3++) {
      var a5 = t5[l3], o3 = e4, u4 = n6, i5 = u4;
      e: for (; null !== i5; ) {
        switch (i5.tag) {
          case 27:
          case 5:
            wu = i5.stateNode, xu = false;
            break e;
          case 3:
          case 4:
            wu = i5.stateNode.containerInfo, xu = true;
            break e;
        }
        i5 = i5.return;
      }
      if (null === wu) throw Error(r5(160));
      Vt(o3, u4, a5), wu = null, xu = false, null !== (o3 = a5.alternate) && (o3.return = null), a5.return = null;
    }
    if (13878 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Yt(n6, e4), n6 = n6.sibling;
  }
  function Yt(e4, n6) {
    var t5 = e4.alternate, l3 = e4.flags;
    switch (e4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        qt(n6, e4), Gt(e4), 4 & l3 && (Lt(3, e4, e4.return), Nt(3, e4), Lt(5, e4, e4.return));
        break;
      case 1:
        qt(n6, e4), Gt(e4), 512 & l3 && null !== t5 && Ft(t5, t5.return), 64 & l3 && gu && null !== (e4 = e4.updateQueue) && null !== (l3 = e4.callbacks) && (t5 = e4.shared.hiddenCallbacks, e4.shared.hiddenCallbacks = null === t5 ? l3 : t5.concat(l3));
        break;
      case 26:
        var a5;
      case 27:
        var o3;
      case 5:
        if (qt(n6, e4), Gt(e4), 512 & l3 && null !== t5 && Ft(t5, t5.return), 32 & e4.flags) {
          n6 = e4.stateNode;
          try {
            ma(n6);
          } catch (n7) {
            jr(e4, e4.return, n7);
          }
        }
        4 & l3 && null != e4.stateNode && function(e5, n7, t6) {
          try {
            sa(e5.stateNode, e5.type, t6, n7, e5);
          } catch (n8) {
            jr(e5, e5.return, n8);
          }
        }(e4, n6 = e4.memoizedProps, null !== t5 ? t5.memoizedProps : n6), 1024 & l3 && (bu = true);
        break;
      case 6:
        if (qt(n6, e4), Gt(e4), 4 & l3 && Ol) {
          if (null === e4.stateNode) throw Error(r5(162));
          l3 = e4.memoizedProps, t5 = null !== t5 ? t5.memoizedProps : l3, n6 = e4.stateNode;
          try {
            ua(n6, t5, l3);
          } catch (n7) {
            jr(e4, e4.return, n7);
          }
        }
        break;
      case 3:
        qt(n6, e4), Gt(e4), bu && (bu = false, Jt(e4));
        break;
      case 4:
      case 12:
        qt(n6, e4), Gt(e4);
        break;
      case 13:
        qt(n6, e4), Gt(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== t5 && null !== t5.memoizedState) && (qu = Qa()), 4 & l3 && null !== (l3 = e4.updateQueue) && (e4.updateQueue = null, $t(e4, l3));
        break;
      case 22:
        512 & l3 && null !== t5 && Ft(t5, t5.return), a5 = null !== e4.memoizedState;
        var u4 = null !== t5 && null !== t5.memoizedState, i5 = gu, s3 = yu;
        if (gu = i5 || a5, yu = s3 || u4, qt(n6, e4), yu = s3, gu = i5, Gt(e4), (n6 = e4.stateNode)._current = e4, n6._visibility &= -3, n6._visibility |= 2 & n6._pendingVisibility, 8192 & l3 && (n6._visibility = a5 ? -2 & n6._visibility : 1 | n6._visibility, a5 && (n6 = gu || yu, null === t5 || u4 || n6 || Xt(e4)), null === e4.memoizedProps || "manual" !== e4.memoizedProps.mode)) {
          e: if (t5 = null, Ol) for (n6 = e4; ; ) {
            if (5 === n6.tag || Ea || Ra) {
              if (null === t5) {
                u4 = t5 = n6;
                try {
                  o3 = u4.stateNode, a5 ? ha(o3) : ya(u4.stateNode, u4.memoizedProps);
                } catch (e5) {
                  jr(u4, u4.return, e5);
                }
              }
            } else if (6 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var c5 = u4.stateNode;
                  a5 ? ga(c5) : ba(c5, u4.memoizedProps);
                } catch (e5) {
                  jr(u4, u4.return, e5);
                }
              }
            } else if ((22 !== n6.tag && 23 !== n6.tag || null === n6.memoizedState || n6 === e4) && null !== n6.child) {
              n6.child.return = n6, n6 = n6.child;
              continue;
            }
            if (n6 === e4) break e;
            for (; null === n6.sibling; ) {
              if (null === n6.return || n6.return === e4) break e;
              t5 === n6 && (t5 = null), n6 = n6.return;
            }
            t5 === n6 && (t5 = null), n6.sibling.return = n6.return, n6 = n6.sibling;
          }
        }
        4 & l3 && null !== (l3 = e4.updateQueue) && null !== (t5 = l3.retryQueue) && (l3.retryQueue = null, $t(e4, t5));
        break;
      case 19:
        qt(n6, e4), Gt(e4), 4 & l3 && null !== (l3 = e4.updateQueue) && (e4.updateQueue = null, $t(e4, l3));
        break;
      case 21:
        break;
      default:
        qt(n6, e4), Gt(e4);
    }
  }
  function Gt(e4) {
    var n6 = e4.flags;
    if (2 & n6) {
      try {
        if (Ol && (!Ra || 27 !== e4.tag)) {
          e: {
            for (var t5 = e4.return; null !== t5; ) {
              if (Wt(t5)) {
                var l3 = t5;
                break e;
              }
              t5 = t5.return;
            }
            throw Error(r5(160));
          }
          switch (l3.tag) {
            case 27:
            case 5:
              var a5 = l3.stateNode;
              32 & l3.flags && (ma(a5), l3.flags &= -33), At(e4, Ht(e4), a5);
              break;
            case 3:
            case 4:
              var o3 = l3.stateNode.containerInfo;
              jt(e4, Ht(e4), o3);
              break;
            default:
              throw Error(r5(161));
          }
        }
      } catch (n7) {
        jr(e4, e4.return, n7);
      }
      e4.flags &= -3;
    }
    4096 & n6 && (e4.flags &= -4097);
  }
  function Jt(e4) {
    if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      Jt(n6), 5 === n6.tag && 1024 & n6.flags && la(n6.stateNode), e4 = e4.sibling;
    }
  }
  function Kt(e4, n6) {
    if (8772 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Qt(e4, n6.alternate, n6), n6 = n6.sibling;
  }
  function Xt(e4) {
    for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      switch (n6.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Lt(4, n6, n6.return), Xt(n6);
          break;
        case 1:
          Ft(n6, n6.return);
          var t5 = n6.stateNode;
          "function" == typeof t5.componentWillUnmount && Dt(n6, n6.return, t5), Xt(n6);
          break;
        case 26:
        case 27:
        case 5:
          Ft(n6, n6.return), Xt(n6);
          break;
        case 22:
          Ft(n6, n6.return), null === n6.memoizedState && Xt(n6);
          break;
        default:
          Xt(n6);
      }
      e4 = e4.sibling;
    }
  }
  function Zt(e4, n6, t5) {
    for (t5 = t5 && 0 != (8772 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var r6 = n6.alternate, l3 = e4, a5 = n6, o3 = a5.flags;
      switch (a5.tag) {
        case 0:
        case 11:
        case 15:
          Zt(l3, a5, t5), Nt(4, a5);
          break;
        case 1:
          if (Zt(l3, a5, t5), "function" == typeof (l3 = (r6 = a5).stateNode).componentDidMount) try {
            l3.componentDidMount();
          } catch (e5) {
            jr(r6, r6.return, e5);
          }
          if (null !== (l3 = (r6 = a5).updateQueue)) {
            var u4 = r6.stateNode;
            try {
              var i5 = l3.shared.hiddenCallbacks;
              if (null !== i5) for (l3.shared.hiddenCallbacks = null, l3 = 0; l3 < i5.length; l3++) Z(i5[l3], u4);
            } catch (e5) {
              jr(r6, r6.return, e5);
            }
          }
          t5 && 64 & o3 && Ut(a5), It(a5, a5.return);
          break;
        case 26:
        case 27:
        case 5:
          Zt(l3, a5, t5), t5 && null === r6 && 4 & o3 && Mt(a5), It(a5, a5.return);
          break;
        case 12:
        case 13:
        default:
          Zt(l3, a5, t5);
          break;
        case 22:
          null === a5.memoizedState && Zt(l3, a5, t5), It(a5, a5.return);
      }
      n6 = n6.sibling;
    }
  }
  function er(e4, n6) {
    var t5 = null;
    null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (e4 = n6.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && e4.refCount++, null != t5 && St(t5));
  }
  function nr(e4, n6) {
    e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && St(e4));
  }
  function tr(e4, n6, t5, r6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) rr(e4, n6, t5, r6), n6 = n6.sibling;
  }
  function rr(e4, n6, t5, r6) {
    var l3 = n6.flags;
    switch (n6.tag) {
      case 0:
      case 11:
      case 15:
        tr(e4, n6, t5, r6), 2048 & l3 && Nt(9, n6);
        break;
      case 3:
        tr(e4, n6, t5, r6), 2048 & l3 && (e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && St(e4)));
        break;
      case 12:
        if (2048 & l3) {
          tr(e4, n6, t5, r6), e4 = n6.stateNode;
          try {
            var a5 = n6.memoizedProps, o3 = a5.id, u4 = a5.onPostCommit;
            "function" == typeof u4 && u4(o3, null === n6.alternate ? "mount" : "update", e4.passiveEffectDuration, -0);
          } catch (e5) {
            jr(n6, n6.return, e5);
          }
        } else tr(e4, n6, t5, r6);
        break;
      case 23:
        break;
      case 22:
        a5 = n6.stateNode, null !== n6.memoizedState ? 4 & a5._visibility ? tr(e4, n6, t5, r6) : ar(e4, n6) : 4 & a5._visibility ? tr(e4, n6, t5, r6) : (a5._visibility |= 4, lr(e4, n6, t5, r6, 0 != (10256 & n6.subtreeFlags))), 2048 & l3 && er(n6.alternate, n6);
        break;
      case 24:
        tr(e4, n6, t5, r6), 2048 & l3 && nr(n6.alternate, n6);
        break;
      default:
        tr(e4, n6, t5, r6);
    }
  }
  function lr(e4, n6, t5, r6, l3) {
    for (l3 = l3 && 0 != (10256 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var a5 = e4, o3 = n6, u4 = t5, i5 = r6, s3 = o3.flags;
      switch (o3.tag) {
        case 0:
        case 11:
        case 15:
          lr(a5, o3, u4, i5, l3), Nt(8, o3);
          break;
        case 23:
          break;
        case 22:
          var c5 = o3.stateNode;
          null !== o3.memoizedState ? 4 & c5._visibility ? lr(a5, o3, u4, i5, l3) : ar(a5, o3) : (c5._visibility |= 4, lr(a5, o3, u4, i5, l3)), l3 && 2048 & s3 && er(o3.alternate, o3);
          break;
        case 24:
          lr(a5, o3, u4, i5, l3), l3 && 2048 & s3 && nr(o3.alternate, o3);
          break;
        default:
          lr(a5, o3, u4, i5, l3);
      }
      n6 = n6.sibling;
    }
  }
  function ar(e4, n6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) {
      var t5 = e4, r6 = n6, l3 = r6.flags;
      switch (r6.tag) {
        case 22:
          ar(t5, r6), 2048 & l3 && er(r6.alternate, r6);
          break;
        case 24:
          ar(t5, r6), 2048 & l3 && nr(r6.alternate, r6);
          break;
        default:
          ar(t5, r6);
      }
      n6 = n6.sibling;
    }
  }
  function or(e4) {
    if (e4.subtreeFlags & Cu) for (e4 = e4.child; null !== e4; ) ur(e4), e4 = e4.sibling;
  }
  function ur(e4) {
    switch (e4.tag) {
      case 26:
        or(e4), e4.flags & Cu && (null !== e4.memoizedState ? _a(zu, e4.memoizedState, e4.memoizedProps) : ea(e4.type, e4.memoizedProps));
        break;
      case 5:
        or(e4), e4.flags & Cu && ea(e4.type, e4.memoizedProps);
        break;
      case 3:
      case 4:
        var n6;
        or(e4);
        break;
      case 22:
        null === e4.memoizedState && (null !== (n6 = e4.alternate) && null !== n6.memoizedState ? (n6 = Cu, Cu = 16777216, or(e4), Cu = n6) : or(e4));
        break;
      default:
        or(e4);
    }
  }
  function ir(e4) {
    var n6 = e4.alternate;
    if (null !== n6 && null !== (e4 = n6.child)) {
      n6.child = null;
      do {
        n6 = e4.sibling, e4.sibling = null, e4 = n6;
      } while (null !== e4);
    }
  }
  function sr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Su = r6, dr(r6, e4);
      }
      ir(e4);
    }
    if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) cr(e4), e4 = e4.sibling;
  }
  function cr(e4) {
    switch (e4.tag) {
      case 0:
      case 11:
      case 15:
        sr(e4), 2048 & e4.flags && Lt(9, e4, e4.return);
        break;
      case 3:
      case 12:
      default:
        sr(e4);
        break;
      case 22:
        var n6 = e4.stateNode;
        null !== e4.memoizedState && 4 & n6._visibility && (null === e4.return || 13 !== e4.return.tag) ? (n6._visibility &= -5, fr(e4)) : sr(e4);
    }
  }
  function fr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Su = r6, dr(r6, e4);
      }
      ir(e4);
    }
    for (e4 = e4.child; null !== e4; ) {
      switch ((n6 = e4).tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, n6, n6.return), fr(n6);
          break;
        case 22:
          4 & (t5 = n6.stateNode)._visibility && (t5._visibility &= -5, fr(n6));
          break;
        default:
          fr(n6);
      }
      e4 = e4.sibling;
    }
  }
  function dr(e4, n6) {
    for (; null !== Su; ) {
      var t5 = Su;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, t5, n6);
          break;
        case 23:
        case 22:
          if (null !== t5.memoizedState && null !== t5.memoizedState.cachePool) {
            var r6 = t5.memoizedState.cachePool.pool;
            null != r6 && r6.refCount++;
          }
          break;
        case 24:
          St(t5.memoizedState.cache);
      }
      if (null !== (r6 = t5.child)) r6.return = t5, Su = r6;
      else e: for (t5 = e4; null !== Su; ) {
        var l3 = (r6 = Su).sibling, a5 = r6.return;
        if (Ot(r6), r6 === t5) {
          Su = null;
          break e;
        }
        if (null !== l3) {
          l3.return = a5, Su = l3;
          break e;
        }
        Su = a5;
      }
    }
  }
  function pr() {
    return 0 != (2 & Ru) && 0 !== Lu ? Lu & -Lu : null !== Pl.T ? 0 !== wo ? wo : O() : Yl();
  }
  function mr() {
    0 === Qu && (Qu = 0 == (536870912 & Lu) || io ? y3() : 536870912);
    var e4 = Mo.current;
    return null !== e4 && (e4.flags |= 32), Qu;
  }
  function hr(e4, n6, t5) {
    (e4 === Tu && 2 === Uu || null !== e4.cancelPendingCommit) && (wr(e4, 0), Sr(e4, Lu, Qu)), S3(e4, t5), 0 != (2 & Ru) && e4 === Tu || (e4 === Tu && (0 == (2 & Ru) && (ju |= t5), 4 === Wu && Sr(e4, Lu, Qu)), M(e4));
  }
  function gr(e4, n6, t5) {
    if (0 != (6 & Ru)) throw Error(r5(327));
    var l3 = (t5 = !t5 && 0 == (60 & n6) && 0 == (n6 & e4.expiredLanes)) ? function(e5, n7) {
      var t6 = Ru;
      Ru |= 2;
      var l4 = Cr(), a6 = Er();
      Tu === e5 && Lu === n7 || (Gu = null, Yu = Qa() + 500, wr(e5, n7));
      e: for (; ; ) try {
        if (0 !== Uu && null !== Nu) {
          n7 = Nu;
          var o4 = Du;
          n: switch (Uu) {
            case 1:
            case 6:
              Uu = 0, Du = null, Ur(e5, n7, o4);
              break;
            case 2:
              if (te(o4)) {
                Uu = 0, Du = null, Lr(n7);
                break;
              }
              n7 = function() {
                2 === Uu && Tu === e5 && (Uu = 7), M(e5);
              }, o4.then(n7, n7);
              break e;
            case 3:
              Uu = 7;
              break e;
            case 4:
              Uu = 5;
              break e;
            case 7:
              te(o4) ? (Uu = 0, Du = null, Lr(n7)) : (Uu = 0, Du = null, Ur(e5, n7, o4));
              break;
            case 5:
              var u5 = null;
              switch (Nu.tag) {
                case 26:
                  u5 = Nu.memoizedState;
                case 5:
                case 27:
                  var i6 = Nu, s3 = i6.type, c5 = i6.pendingProps;
                  if (u5 ? Pa(u5) : Xl(s3, c5)) {
                    Uu = 0, Du = null;
                    var f4 = i6.sibling;
                    if (null !== f4) Nu = f4;
                    else {
                      var d3 = i6.return;
                      null !== d3 ? (Nu = d3, Dr(d3)) : Nu = null;
                    }
                    break n;
                  }
              }
              Uu = 0, Du = null, Ur(e5, n7, o4);
              break;
            case 8:
              kr(), Wu = 6;
              break e;
            default:
              throw Error(r5(462));
          }
        }
        Tr();
        break;
      } catch (n8) {
        xr(e5, n8);
      }
      return it(), Pl.H = l4, Pl.A = a6, Ru = t6, null !== Nu ? 0 : (Tu = null, Lu = 0, N(), Wu);
    }(e4, n6) : _r(e4, n6);
    if (0 !== l3) for (var a5 = t5; ; ) {
      if (6 === l3) Sr(e4, n6, 0);
      else {
        if (t5 = e4.current.alternate, a5 && !vr(t5)) {
          l3 = _r(e4, n6), a5 = false;
          continue;
        }
        if (2 === l3) {
          if (a5 = n6, e4.errorRecoveryDisabledLanes & a5) var o3 = 0;
          else o3 = 0 != (o3 = -536870913 & e4.pendingLanes) ? o3 : 536870912 & o3 ? 536870912 : 0;
          if (0 !== o3) {
            n6 = o3;
            e: {
              var u4 = e4;
              l3 = Bu;
              var i5 = Bl;
              if (i5 && (wr(u4, o3).flags |= 256), 2 !== (o3 = _r(u4, o3))) {
                if (Fu && !i5) {
                  u4.errorRecoveryDisabledLanes |= a5, ju |= a5, l3 = 4;
                  break e;
                }
                a5 = Vu, Vu = l3, null !== a5 && yr(a5);
              }
              l3 = o3;
            }
            if (a5 = false, 2 !== l3) continue;
          }
        }
        if (1 === l3) {
          wr(e4, 0), Sr(e4, n6, 0);
          break;
        }
        e: {
          switch (a5 = e4, l3) {
            case 0:
            case 1:
              throw Error(r5(345));
            case 4:
              if ((4194176 & n6) === n6) {
                Sr(a5, n6, Qu);
                break e;
              }
              break;
            case 2:
              Vu = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r5(329));
          }
          if (a5.finishedWork = t5, a5.finishedLanes = n6, (62914560 & n6) === n6 && 10 < (l3 = qu + 300 - Qa())) {
            if (Sr(a5, n6, Qu), 0 !== h3(a5, 0)) break e;
            a5.timeoutHandle = jl(br.bind(null, a5, t5, Vu, Gu, $u, n6, Qu, ju, Ou, Iu, 2, -0, 0), l3);
          } else br(a5, t5, Vu, Gu, $u, n6, Qu, ju, Ou, Iu, 0, -0, 0);
        }
      }
      break;
    }
    M(e4);
  }
  function yr(e4) {
    null === Vu ? Vu = e4 : Vu.push.apply(Vu, e4);
  }
  function br(e4, n6, t5, r6, l3, a5, o3, u4, i5, s3, c5, f4, d3) {
    if ((8192 & (s3 = n6.subtreeFlags) || 16785408 == (16785408 & s3)) && (Zl(), ur(n6), null !== (n6 = na()))) return e4.cancelPendingCommit = n6(Fr.bind(null, e4, t5, r6, l3, o3, u4, i5, 1, f4, d3)), void Sr(e4, a5, o3);
    Fr(e4, t5, r6, l3, o3);
  }
  function vr(e4) {
    for (var n6 = e4; ; ) {
      var t5 = n6.tag;
      if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n6.flags && null !== (t5 = n6.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
        var l3 = t5[r6], a5 = l3.getSnapshot;
        l3 = l3.value;
        try {
          if (!Ja(a5(), l3)) return false;
        } catch (e5) {
          return false;
        }
      }
      if (t5 = n6.child, 16384 & n6.subtreeFlags && null !== t5) t5.return = n6, n6 = t5;
      else {
        if (n6 === e4) break;
        for (; null === n6.sibling; ) {
          if (null === n6.return || n6.return === e4) return true;
          n6 = n6.return;
        }
        n6.sibling.return = n6.return, n6 = n6.sibling;
      }
    }
    return true;
  }
  function Sr(e4, n6, t5) {
    n6 &= ~Au, n6 &= ~ju, e4.suspendedLanes |= n6, e4.pingedLanes &= ~n6;
    for (var r6 = e4.expirationTimes, l3 = n6; 0 < l3; ) {
      var a5 = 31 - Ua(l3), o3 = 1 << a5;
      r6[a5] = -1, l3 &= ~o3;
    }
    0 !== t5 && k3(e4, t5, n6);
  }
  function kr() {
    if (null !== Nu) {
      if (0 === Uu) var e4 = Nu.return;
      else e4 = Nu, it(), Pe(e4), No = null, Lo = 0, e4 = Nu;
      for (; null !== e4; ) Tt(e4.alternate, e4), e4 = e4.return;
      Nu = null;
    }
  }
  function wr(e4, n6) {
    e4.finishedWork = null, e4.finishedLanes = 0;
    var t5 = e4.timeoutHandle;
    t5 !== Ql && (e4.timeoutHandle = Ql, Al(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), kr(), Tu = e4, Nu = t5 = Yr(e4.current, null), Lu = n6, Uu = 0, Du = null, Fu = Iu = false, Ou = Qu = Au = ju = Hu = Wu = 0, Vu = Bu = null, $u = false, 0 != (8 & n6) && (n6 |= 32 & n6);
    var r6 = e4.entangledLanes;
    if (0 !== r6) for (e4 = e4.entanglements, r6 &= n6; 0 < r6; ) {
      var l3 = 31 - Ua(r6), a5 = 1 << l3;
      n6 |= e4[l3], r6 &= ~a5;
    }
    return Mu = n6, N(), t5;
  }
  function xr(e4, n6) {
    Ao = null, Pl.H = Xo, n6 === Po ? (n6 = ae(), Uu = zr() && 0 == (134217727 & Hu) && 0 == (134217727 & ju) ? 2 : 3) : n6 === _o ? (n6 = ae(), Uu = 4) : Uu = n6 === ru ? 8 : null !== n6 && "object" == typeof n6 && "function" == typeof n6.then ? 6 : 1, Du = n6, null === Nu && (Wu = 1, In(e4, C(n6, e4.current)));
  }
  function zr() {
    var e4 = Mo.current;
    return null === e4 || ((4194176 & Lu) === Lu ? null === Wo : ((62914560 & Lu) === Lu || 0 != (536870912 & Lu)) && e4 === Wo);
  }
  function Cr() {
    var e4 = Pl.H;
    return Pl.H = Xo, null === e4 ? Xo : e4;
  }
  function Er() {
    var e4 = Pl.A;
    return Pl.A = Eu, e4;
  }
  function Pr() {
    Wu = 4, 0 == (134217727 & Hu) && 0 == (134217727 & ju) || null === Tu || Sr(Tu, Lu, Qu);
  }
  function _r(e4, n6) {
    var t5 = Ru;
    Ru |= 2;
    var l3 = Cr(), a5 = Er();
    Tu === e4 && Lu === n6 || (Gu = null, wr(e4, n6)), n6 = false;
    e: for (; ; ) try {
      if (0 !== Uu && null !== Nu) {
        var o3 = Nu, u4 = Du;
        switch (Uu) {
          case 8:
            kr(), Wu = 6;
            break e;
          case 3:
          case 2:
            n6 || null !== Mo.current || (n6 = true);
          default:
            Uu = 0, Du = null, Ur(e4, o3, u4);
        }
      }
      Rr();
      break;
    } catch (n7) {
      xr(e4, n7);
    }
    if (n6 && e4.shellSuspendCounter++, it(), Ru = t5, Pl.H = l3, Pl.A = a5, null !== Nu) throw Error(r5(261));
    return Tu = null, Lu = 0, N(), Wu;
  }
  function Rr() {
    for (; null !== Nu; ) Nr(Nu);
  }
  function Tr() {
    for (; null !== Nu && !ja(); ) Nr(Nu);
  }
  function Nr(e4) {
    var n6 = ut(e4.alternate, e4, Mu);
    e4.memoizedProps = e4.pendingProps, null === n6 ? Dr(e4) : Nu = n6;
  }
  function Lr(e4) {
    var n6 = e4, t5 = n6.alternate;
    switch (n6.tag) {
      case 15:
      case 0:
        n6 = Yn(t5, n6, n6.pendingProps, n6.type, void 0, Lu);
        break;
      case 11:
        n6 = Yn(t5, n6, n6.pendingProps, n6.type.render, n6.ref, Lu);
        break;
      case 5:
        Pe(n6);
      default:
        Tt(t5, n6), n6 = ut(t5, n6 = Nu = Gr(n6, Mu), Mu);
    }
    e4.memoizedProps = e4.pendingProps, null === n6 ? Dr(e4) : Nu = n6;
  }
  function Ur(e4, n6, t5) {
    it(), Pe(n6), No = null, Lo = 0;
    var l3 = n6.return;
    try {
      if (function(e5, n7, t6, l4, a5) {
        if (t6.flags |= 32768, null !== l4 && "object" == typeof l4 && "function" == typeof l4.then) {
          if (null !== (n7 = t6.alternate) && pt(n7, t6, a5, true), null !== (t6 = Mo.current)) {
            switch (t6.tag) {
              case 13:
                return null === Wo ? Pr() : null === t6.alternate && 0 === Wu && (Wu = 3), t6.flags &= -257, t6.flags |= 65536, t6.lanes = a5, l4 === Ro ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([l4]) : n7.add(l4), Ar(e5, l4, a5)), false;
              case 22:
                return t6.flags |= 65536, l4 === Ro ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? (n7 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l4]) }, t6.updateQueue = n7) : null === (t6 = n7.retryQueue) ? n7.retryQueue = /* @__PURE__ */ new Set([l4]) : t6.add(l4), Ar(e5, l4, a5)), false;
            }
            throw Error(r5(435, t6.tag));
          }
          return Ar(e5, l4, a5), Pr(), false;
        }
        var o3 = Error(r5(520), { cause: l4 });
        if (o3 = C(o3, t6), null === Bu ? Bu = [o3] : Bu.push(o3), 4 !== Wu && (Wu = 2), null === n7) return true;
        l4 = C(l4, t6), t6 = n7;
        do {
          switch (t6.tag) {
            case 3:
              return t6.flags |= 65536, e5 = a5 & -a5, t6.lanes |= e5, J(t6, e5 = Mn(t6.stateNode, l4, e5)), false;
            case 1:
              if (n7 = t6.type, o3 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n7.getDerivedStateFromError || null !== o3 && "function" == typeof o3.componentDidCatch && (null === Ju || !Ju.has(o3)))) return t6.flags |= 65536, a5 &= -a5, t6.lanes |= a5, Hn(a5 = Wn(a5), e5, t6, l4), J(t6, a5), false;
          }
          t6 = t6.return;
        } while (null !== t6);
        return false;
      }(e4, l3, n6, t5, Lu)) return Wu = 1, In(e4, C(t5, e4.current)), void (Nu = null);
    } catch (n7) {
      if (null !== l3) throw Nu = l3, n7;
      return Wu = 1, In(e4, C(t5, e4.current)), void (Nu = null);
    }
    32768 & n6.flags ? Ir(n6, true) : Dr(n6);
  }
  function Dr(e4) {
    var n6 = e4;
    do {
      if (0 != (32768 & n6.flags)) return void Ir(n6, Iu);
      e4 = n6.return;
      var t5 = _t(n6.alternate, n6, Mu);
      if (null !== t5) return void (Nu = t5);
      if (null !== (n6 = n6.sibling)) return void (Nu = n6);
      Nu = n6 = e4;
    } while (null !== n6);
    0 === Wu && (Wu = 5);
  }
  function Ir(e4, n6) {
    do {
      var t5 = Rt(e4.alternate, e4);
      if (null !== t5) return t5.flags &= 32767, void (Nu = t5);
      if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n6 && null !== (e4 = e4.sibling)) return void (Nu = e4);
      Nu = e4 = t5;
    } while (null !== e4);
    Wu = 6, Nu = null;
  }
  function Fr(e4, n6, t5, l3, a5, o3, u4, i5, s3, c5) {
    var f4 = Pl.T, d3 = ql();
    try {
      $l(2), Pl.T = null, function(e5, n7, t6, l4, a6, o4) {
        do {
          Wr();
        } while (null !== Xu);
        if (0 != (6 & Ru)) throw Error(r5(327));
        var u5 = e5.finishedWork;
        if (l4 = e5.finishedLanes, null === u5) return null;
        if (e5.finishedWork = null, e5.finishedLanes = 0, u5 === e5.current) throw Error(r5(177));
        e5.callbackNode = null, e5.callbackPriority = 0, e5.cancelPendingCommit = null;
        var i6 = u5.lanes | u5.childLanes;
        if (function(e6, n8, t7, r6) {
          var l5 = e6.pendingLanes;
          e6.pendingLanes = t7, e6.suspendedLanes = 0, e6.pingedLanes = 0, e6.warmLanes = 0, e6.expiredLanes &= t7, e6.entangledLanes &= t7, e6.errorRecoveryDisabledLanes &= t7, e6.shellSuspendCounter = 0, n8 = e6.entanglements;
          var a7 = e6.expirationTimes, o5 = e6.hiddenUpdates;
          for (t7 = l5 & ~t7; 0 < t7; ) {
            var u6 = 31 - Ua(t7);
            l5 = 1 << u6, n8[u6] = 0, a7[u6] = -1;
            var i7 = o5[u6];
            if (null !== i7) for (o5[u6] = null, u6 = 0; u6 < i7.length; u6++) {
              var s5 = i7[u6];
              null !== s5 && (s5.lane &= -536870913);
            }
            t7 &= ~l5;
          }
          0 !== r6 && k3(e6, r6, 0);
        }(e5, l4, i6 |= po, o4), e5 === Tu && (Nu = Tu = null, Lu = 0), 0 == (10256 & u5.subtreeFlags) && 0 == (10256 & u5.flags) || Ku || (Ku = true, ei = i6, ni = t6, Wa(Va, function() {
          return Wr(), null;
        })), t6 = 0 != (15990 & u5.flags), 0 != (15990 & u5.subtreeFlags) || t6) {
          t6 = Pl.T, Pl.T = null, o4 = ql(), $l(2);
          var s4 = Ru;
          Ru |= 4, function(e6, n8) {
            for (Ul(e6.containerInfo), Su = n8; null !== Su; ) if (n8 = (e6 = Su).child, 0 != (1028 & e6.subtreeFlags) && null !== n8) n8.return = e6, Su = n8;
            else for (; null !== Su; ) {
              var t7 = (e6 = Su).alternate;
              switch (n8 = e6.flags, e6.tag) {
                case 0:
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n8) && null !== t7) {
                    n8 = void 0;
                    var l5 = e6, a7 = t7.memoizedProps;
                    t7 = t7.memoizedState;
                    var o5 = l5.stateNode;
                    try {
                      var u6 = Dn(l5.type, a7, (l5.elementType, l5.type));
                      n8 = o5.getSnapshotBeforeUpdate(u6, t7), o5.__reactInternalSnapshotBeforeUpdate = n8;
                    } catch (e7) {
                      jr(l5, l5.return, e7);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n8) && Ol && va(e6.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n8)) throw Error(r5(163));
              }
              if (null !== (n8 = e6.sibling)) {
                n8.return = e6.return, Su = n8;
                break;
              }
              Su = e6.return;
            }
            u6 = ku, ku = false;
          }(e5, u5), Yt(u5, e5), Dl(e5.containerInfo), e5.current = u5, Qt(e5, u5.alternate, u5), Aa(), Ru = s4, $l(o4), Pl.T = t6;
        } else e5.current = u5;
        if (Ku ? (Ku = false, Xu = e5, Zu = l4) : Mr(e5, i6), 0 === (i6 = e5.pendingLanes) && (Ju = null), u5.stateNode, M(e5), null !== n7) for (a6 = e5.onRecoverableError, u5 = 0; u5 < n7.length; u5++) a6((i6 = n7[u5]).value, { componentStack: i6.stack });
        0 != (3 & Zu) && Wr(), i6 = e5.pendingLanes, 0 != (4194218 & l4) && 0 != (42 & i6) ? e5 === ri ? ti++ : (ti = 0, ri = e5) : ti = 0, W(0);
      }(e4, n6, t5, l3, d3, a5);
    } finally {
      Pl.T = f4, $l(d3);
    }
  }
  function Mr(e4, n6) {
    0 == (e4.pooledCacheLanes &= n6) && null != (n6 = e4.pooledCache) && (e4.pooledCache = null, St(n6));
  }
  function Wr() {
    if (null !== Xu) {
      var e4 = Xu, n6 = ei;
      ei = 0;
      var t5 = x(Zu), l3 = 32 > t5 ? 32 : t5;
      t5 = Pl.T;
      var a5 = ql();
      try {
        if ($l(l3), Pl.T = null, null === Xu) var o3 = false;
        else {
          l3 = ni, ni = null;
          var u4 = Xu, i5 = Zu;
          if (Xu = null, Zu = 0, 0 != (6 & Ru)) throw Error(r5(331));
          var s3 = Ru;
          Ru |= 4, cr(u4.current), rr(u4, u4.current, i5, l3), Ru = s3, W(0), Ga && Ga.onPostCommitFiberRoot, o3 = true;
        }
        return o3;
      } finally {
        $l(a5), Pl.T = t5, Mr(e4, n6);
      }
    }
    return false;
  }
  function Hr(e4, n6, t5) {
    n6 = C(t5, n6), null !== (e4 = Y(e4, n6 = Mn(e4.stateNode, n6, 2), 2)) && (S3(e4, 2), M(e4));
  }
  function jr(e4, n6, t5) {
    if (3 === e4.tag) Hr(e4, e4, t5);
    else for (; null !== n6; ) {
      if (3 === n6.tag) {
        Hr(n6, e4, t5);
        break;
      }
      if (1 === n6.tag) {
        var r6 = n6.stateNode;
        if ("function" == typeof n6.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === Ju || !Ju.has(r6))) {
          e4 = C(t5, e4), null !== (r6 = Y(n6, t5 = Wn(2), 2)) && (Hn(t5, r6, n6, e4), S3(r6, 2), M(r6));
          break;
        }
      }
      n6 = n6.return;
    }
  }
  function Ar(e4, n6, t5) {
    var r6 = e4.pingCache;
    if (null === r6) {
      r6 = e4.pingCache = new _u();
      var l3 = /* @__PURE__ */ new Set();
      r6.set(n6, l3);
    } else void 0 === (l3 = r6.get(n6)) && (l3 = /* @__PURE__ */ new Set(), r6.set(n6, l3));
    l3.has(t5) || (Fu = true, l3.add(t5), e4 = Qr.bind(null, e4, n6, t5), n6.then(e4, e4));
  }
  function Qr(e4, n6, t5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(n6), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, Tu === e4 && (Lu & t5) === t5 && (4 === Wu || 3 === Wu && (62914560 & Lu) === Lu && 300 > Qa() - qu ? 0 == (2 & Ru) && wr(e4, 0) : Au |= t5, Ou === Lu && (Ou = 0)), M(e4);
  }
  function Or(e4, n6) {
    0 === n6 && (n6 = b3()), null !== (e4 = D(e4, n6)) && (S3(e4, n6), M(e4));
  }
  function Br(e4) {
    var n6 = e4.memoizedState, t5 = 0;
    null !== n6 && (t5 = n6.retryLane), Or(e4, t5);
  }
  function Vr(e4, n6) {
    var t5 = 0;
    switch (e4.tag) {
      case 13:
        var l3 = e4.stateNode, a5 = e4.memoizedState;
        null !== a5 && (t5 = a5.retryLane);
        break;
      case 19:
        l3 = e4.stateNode;
        break;
      case 22:
        l3 = e4.stateNode._retryCache;
        break;
      default:
        throw Error(r5(314));
    }
    null !== l3 && l3.delete(n6), Or(e4, t5);
  }
  function $r(e4, n6, t5, r6) {
    this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n6, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function qr(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  function Yr(e4, n6) {
    var r6 = e4.alternate;
    return null === r6 ? ((r6 = t4(e4.tag, n6, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n6, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null), r6.flags = 31457280 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n6 = e4.dependencies, r6.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6;
  }
  function Gr(e4, n6) {
    e4.flags &= 31457282;
    var t5 = e4.alternate;
    return null === t5 ? (e4.childLanes = 0, e4.lanes = n6, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n6 = t5.dependencies, e4.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }), e4;
  }
  function Jr(e4, n6, l3, a5, o3, u4) {
    var i5 = 0;
    if (a5 = e4, "function" == typeof e4) qr(e4) && (i5 = 1);
    else if ("string" == typeof e4) i5 = 5;
    else e: switch (e4) {
      case dl:
        return Kr(l3.children, o3, u4, n6);
      case pl:
        i5 = 8, o3 |= 24;
        break;
      case ml:
        return (e4 = t4(12, l3, n6, 2 | o3)).elementType = ml, e4.lanes = u4, e4;
      case vl:
        return (e4 = t4(13, l3, n6, o3)).elementType = vl, e4.lanes = u4, e4;
      case Sl:
        return (e4 = t4(19, l3, n6, o3)).elementType = Sl, e4.lanes = u4, e4;
      case xl:
        return Xr(l3, o3, u4, n6);
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case hl:
          case yl:
            i5 = 10;
            break e;
          case gl:
            i5 = 9;
            break e;
          case bl:
            i5 = 11;
            break e;
          case kl:
            i5 = 14;
            break e;
          case wl:
            i5 = 16, a5 = null;
            break e;
        }
        i5 = 29, l3 = Error(r5(130, null === e4 ? "null" : typeof e4, "")), a5 = null;
    }
    return (n6 = t4(i5, l3, n6, o3)).elementType = e4, n6.type = a5, n6.lanes = u4, n6;
  }
  function Kr(e4, n6, r6, l3) {
    return (e4 = t4(7, e4, l3, n6)).lanes = r6, e4;
  }
  function Xr(e4, n6, l3, a5) {
    (e4 = t4(22, e4, a5, n6)).elementType = xl, e4.lanes = l3;
    var o3 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function() {
      var e5 = o3._current;
      if (null === e5) throw Error(r5(456));
      if (0 == (2 & o3._pendingVisibility)) {
        var n7 = D(e5, 2);
        null !== n7 && (o3._pendingVisibility |= 2, hr(n7, 0, 2));
      }
    }, attach: function() {
      var e5 = o3._current;
      if (null === e5) throw Error(r5(456));
      if (0 != (2 & o3._pendingVisibility)) {
        var n7 = D(e5, 2);
        null !== n7 && (o3._pendingVisibility &= -3, hr(n7, 0, 2));
      }
    } };
    return e4.stateNode = o3, e4;
  }
  function Zr(e4, n6, r6) {
    return (e4 = t4(6, e4, null, n6)).lanes = r6, e4;
  }
  function el(e4, n6, r6) {
    return (n6 = t4(4, null !== e4.children ? e4.children : [], e4.key, n6)).lanes = r6, n6.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n6;
  }
  function nl(e4, n6, t5, r6, l3, a5, o3, u4) {
    this.tag = 1, this.containerInfo = e4, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ql, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = v3(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = v3(0), this.hiddenUpdates = v3(null), this.identifierPrefix = r6, this.onUncaughtError = l3, this.onCaughtError = a5, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u4, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function tl(e4, n6, t5, r6, l3, a5) {
    l3 = function(e5) {
      return e5 ? e5 = La : La;
    }(l3), null === r6.context ? r6.context = l3 : r6.pendingContext = l3, (r6 = q(n6)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && (r6.callback = a5), null !== (t5 = Y(e4, r6, n6)) && (hr(t5, 0, n6), G2(t5, e4, n6));
  }
  var rl, ll, al = {}, ol = import_react.default, ul = u, il = Object.assign, sl = Symbol.for("react.element"), cl = Symbol.for("react.transitional.element"), fl = Symbol.for("react.portal"), dl = Symbol.for("react.fragment"), pl = Symbol.for("react.strict_mode"), ml = Symbol.for("react.profiler"), hl = Symbol.for("react.provider"), gl = Symbol.for("react.consumer"), yl = Symbol.for("react.context"), bl = Symbol.for("react.forward_ref"), vl = Symbol.for("react.suspense"), Sl = Symbol.for("react.suspense_list"), kl = Symbol.for("react.memo"), wl = Symbol.for("react.lazy"), xl = Symbol.for("react.offscreen"), zl = Symbol.for("react.memo_cache_sentinel"), Cl = Symbol.iterator, El = Symbol.for("react.client.reference"), Pl = ol.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, _l = false, Rl = Array.isArray, Tl = n5.getPublicInstance, Nl = n5.getRootHostContext, Ll = n5.getChildHostContext, Ul = n5.prepareForCommit, Dl = n5.resetAfterCommit, Il = n5.createInstance, Fl = n5.appendInitialChild, Ml = n5.finalizeInitialChildren, Wl = n5.shouldSetTextContent, Hl = n5.createTextInstance, jl = null, Al = null, Ql = n5.noTimeout, Ol = true, Bl = null, Vl = null, $l = n5.setCurrentUpdatePriority, ql = n5.getCurrentUpdatePriority, Yl = n5.resolveUpdatePriority;
  n5.resolveEventType, n5.resolveEventTimeStamp;
  var Gl = n5.shouldAttemptEagerTransition, Jl = n5.detachDeletedInstance;
  n5.requestPostPaintCallback;
  var Kl = n5.maySuspendCommit, Xl = null, Zl = null, ea = null, na = null, ta = null, ra = null, la = null, aa = n5.appendChild, oa = n5.appendChildToContainer, ua = n5.commitTextUpdate, ia = null, sa = n5.commitUpdate, ca = n5.insertBefore, fa = null, da = n5.removeChild, pa = n5.removeChildFromContainer, ma = n5.resetTextContent, ha = null, ga = null, ya = null, ba = null, va = n5.clearContainer, Sa = null, ka = null, wa = null, xa = null, za = null, Ca = null, Ea = null, Pa = null, _a = null, Ra = null, Ta = [], Na = -1, La = {}, Ua = Math.clz32 ? Math.clz32 : function(e4) {
    return 0 == (e4 >>>= 0) ? 32 : 31 - (Da(e4) / Ia | 0) | 0;
  }, Da = Math.log, Ia = Math.LN2, Fa = 128, Ma = 4194304, Wa = ul.unstable_scheduleCallback, Ha = ul.unstable_cancelCallback, ja = ul.unstable_shouldYield, Aa = ul.unstable_requestPaint, Qa = ul.unstable_now, Oa = ul.unstable_ImmediatePriority, Ba = ul.unstable_UserBlockingPriority, Va = ul.unstable_NormalPriority, $a = ul.unstable_IdlePriority, qa = ul.log, Ya = ul.unstable_setDisableYieldValue, Ga = null, Ja = "function" == typeof Object.is ? Object.is : function(e4, n6) {
    return e4 === n6 && (0 !== e4 || 1 / e4 == 1 / n6) || e4 != e4 && n6 != n6;
  }, Ka = /* @__PURE__ */ new WeakMap(), Xa = [], Za = 0, eo = null, no = [], to = 0, ro = null, lo = f3(null), ao = f3(null), oo = f3(null), uo = f3(null), io = false, so = null;
  Error(r5(519));
  var co = [], fo = 0, po = 0, mo = null, ho = null, go = false, yo = false, bo = false, vo = 0, So = null, ko = 0, wo = 0, xo = null, zo = false, Co = false, Eo = Object.prototype.hasOwnProperty, Po = Error(r5(460)), _o = Error(r5(474)), Ro = { then: function() {
  } }, To = null, No = null, Lo = 0, Uo = ce(true), Do = ce(false), Io = f3(null), Fo = f3(0), Mo = f3(null), Wo = null, Ho = f3(0), jo = 0, Ao = null, Qo = null, Oo = null, Bo = false, Vo = false, $o = false, qo = 0, Yo = 0, Go = null, Jo = 0, Ko = function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }, Xo = { readContext: gt, use: Ne, useCallback: ve, useContext: ve, useEffect: ve, useImperativeHandle: ve, useLayoutEffect: ve, useInsertionEffect: ve, useMemo: ve, useReducer: ve, useRef: ve, useState: ve, useDebugValue: ve, useDeferredValue: ve, useTransition: ve, useSyncExternalStore: ve, useId: ve };
  Xo.useCacheRefresh = ve, Xo.useMemoCache = ve, Xo.useHostTransitionStatus = ve, Xo.useFormState = ve, Xo.useActionState = ve, Xo.useOptimistic = ve;
  var Zo = { readContext: gt, use: Ne, useCallback: function(e4, n6) {
    return _e().memoizedState = [e4, void 0 === n6 ? null : n6], e4;
  }, useContext: gt, useEffect: un, useImperativeHandle: function(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, an(4194308, 4, dn.bind(null, n6, e4), t5);
  }, useLayoutEffect: function(e4, n6) {
    return an(4194308, 4, e4, n6);
  }, useInsertionEffect: function(e4, n6) {
    an(4, 2, e4, n6);
  }, useMemo: function(e4, n6) {
    var t5 = _e();
    n6 = void 0 === n6 ? null : n6;
    var r6 = e4();
    if ($o) {
      z(true);
      try {
        e4();
      } finally {
        z(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }, useReducer: function(e4, n6, t5) {
    var r6 = _e();
    if (void 0 !== t5) {
      var l3 = t5(n6);
      if ($o) {
        z(true);
        try {
          t5(n6);
        } finally {
          z(false);
        }
      }
    } else l3 = n6;
    return r6.memoizedState = r6.baseState = l3, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l3 }, r6.queue = e4, e4 = e4.dispatch = zn.bind(null, Ao, e4), [r6.memoizedState, e4];
  }, useRef: function(e4) {
    return e4 = { current: e4 }, _e().memoizedState = e4;
  }, useState: function(e4) {
    var n6 = (e4 = Oe(e4)).queue, t5 = Cn.bind(null, Ao, n6);
    return n6.dispatch = t5, [e4.memoizedState, t5];
  }, useDebugValue: mn, useDeferredValue: function(e4, n6) {
    return yn(_e(), e4, n6);
  }, useTransition: function() {
    var e4 = Oe(false);
    return e4 = vn.bind(null, Ao, e4.queue, true, false), _e().memoizedState = e4, [false, e4];
  }, useSyncExternalStore: function(e4, n6, t5) {
    var l3 = Ao, a5 = _e();
    if (t5 = n6(), null === Tu) throw Error(r5(349));
    0 != (60 & Lu) || We(l3, n6, t5), a5.memoizedState = t5;
    var o3 = { value: t5, getSnapshot: n6 };
    return a5.queue = o3, un(je.bind(null, l3, o3, e4), [e4]), l3.flags |= 2048, rn(9, He.bind(null, l3, o3, t5, n6), { destroy: void 0 }, null), t5;
  }, useId: function() {
    var e4 = _e(), n6 = Tu.identifierPrefix;
    return n6 = ":" + n6 + "r" + (Jo++).toString(32) + ":", e4.memoizedState = n6;
  }, useCacheRefresh: function() {
    return _e().memoizedState = xn.bind(null, Ao);
  } };
  Zo.useMemoCache = Le, Zo.useHostTransitionStatus = Sn, Zo.useFormState = Xe, Zo.useActionState = Xe, Zo.useOptimistic = function(e4) {
    var n6 = _e();
    n6.memoizedState = n6.baseState = e4;
    var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n6.queue = t5, n6 = Pn.bind(null, Ao, true, t5), t5.dispatch = n6, [e4, n6];
  };
  var eu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: De, useRef: ln, useState: function() {
    return De(Ue);
  }, useDebugValue: mn, useDeferredValue: function(e4, n6) {
    return bn(Re(), Qo.memoizedState, e4, n6);
  }, useTransition: function() {
    var e4 = De(Ue)[0], n6 = Re().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Te(e4), n6];
  }, useSyncExternalStore: Me, useId: kn };
  eu.useCacheRefresh = wn, eu.useMemoCache = Le, eu.useHostTransitionStatus = Sn, eu.useFormState = Ze, eu.useActionState = Ze, eu.useOptimistic = function(e4, n6) {
    return Be(Re(), 0, e4, n6);
  };
  var nu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: Fe, useRef: ln, useState: function() {
    return Fe(Ue);
  }, useDebugValue: mn, useDeferredValue: function(e4, n6) {
    var t5 = Re();
    return null === Qo ? yn(t5, e4, n6) : bn(t5, Qo.memoizedState, e4, n6);
  }, useTransition: function() {
    var e4 = Fe(Ue)[0], n6 = Re().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Te(e4), n6];
  }, useSyncExternalStore: Me, useId: kn };
  nu.useCacheRefresh = wn, nu.useMemoCache = Le, nu.useHostTransitionStatus = Sn, nu.useFormState = tn, nu.useActionState = tn, nu.useOptimistic = function(e4, n6) {
    var t5 = Re();
    return null !== Qo ? Be(t5, 0, e4, n6) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
  };
  var tu = { isMounted: function(e4) {
    return !!(e4 = e4._reactInternals) && function(e5) {
      var n6 = e5, t5 = e5;
      if (e5.alternate) for (; n6.return; ) n6 = n6.return;
      else {
        e5 = n6;
        do {
          0 != (4098 & (n6 = e5).flags) && (t5 = n6.return), e5 = n6.return;
        } while (e5);
      }
      return 3 === n6.tag ? t5 : null;
    }(e4) === e4;
  }, enqueueSetState: function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = pr(), l3 = q(r6);
    l3.payload = n6, null != t5 && (l3.callback = t5), null !== (n6 = Y(e4, l3, r6)) && (hr(n6, 0, r6), G2(n6, e4, r6));
  }, enqueueReplaceState: function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = pr(), l3 = q(r6);
    l3.tag = 1, l3.payload = n6, null != t5 && (l3.callback = t5), null !== (n6 = Y(e4, l3, r6)) && (hr(n6, 0, r6), G2(n6, e4, r6));
  }, enqueueForceUpdate: function(e4, n6) {
    e4 = e4._reactInternals;
    var t5 = pr(), r6 = q(t5);
    r6.tag = 2, null != n6 && (r6.callback = n6), null !== (n6 = Y(e4, r6, t5)) && (hr(n6, 0, t5), G2(n6, e4, t5));
  } };
  "function" == typeof reportError && reportError;
  var ru = Error(r5(461)), lu = false, au = { dehydrated: null, treeContext: null, retryLane: 0 }, ou = f3(null), uu = null, iu = null, su = null, cu = "undefined" != typeof AbortController ? AbortController : function() {
    var e4 = [], n6 = this.signal = { aborted: false, addEventListener: function(n7, t5) {
      e4.push(t5);
    } };
    this.abort = function() {
      n6.aborted = true, e4.forEach(function(e5) {
        return e5();
      });
    };
  }, fu = ul.unstable_scheduleCallback, du = ul.unstable_NormalPriority, pu = { $$typeof: yl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, mu = Pl.S;
  Pl.S = function(e4, n6) {
    "object" == typeof n6 && null !== n6 && "function" == typeof n6.then && function(e5, n7) {
      if (null === So) {
        var t5 = So = [];
        ko = 0, wo = O(), xo = { status: "pending", value: void 0, then: function(e6) {
          t5.push(e6);
        } };
      }
      ko++, n7.then(B, B);
    }(0, n6), null !== mu && mu(e4, n6);
  };
  var hu = f3(null), gu = false, yu = false, bu = false, vu = "function" == typeof WeakSet ? WeakSet : Set, Su = null, ku = false, wu = null, xu = false, zu = null, Cu = 8192, Eu = { getCacheForType: function(e4) {
    var n6 = gt(pu), t5 = n6.data.get(e4);
    return void 0 === t5 && (t5 = e4(), n6.data.set(e4, t5)), t5;
  } };
  if ("function" == typeof Symbol && Symbol.for) {
    var Pu = Symbol.for;
    Pu("selector.component"), Pu("selector.has_pseudo_class"), Pu("selector.role"), Pu("selector.test_id"), Pu("selector.text");
  }
  var _u = "function" == typeof WeakMap ? WeakMap : Map, Ru = 0, Tu = null, Nu = null, Lu = 0, Uu = 0, Du = null, Iu = false, Fu = false, Mu = 0, Wu = 0, Hu = 0, ju = 0, Au = 0, Qu = 0, Ou = 0, Bu = null, Vu = null, $u = false, qu = 0, Yu = 1 / 0, Gu = null, Ju = null, Ku = false, Xu = null, Zu = 0, ei = 0, ni = null, ti = 0, ri = null;
  return al.createContainer = function(e4, n6, r6, l3, a5, o3, u4, i5, s3, c5) {
    return function(e5, n7, r7, l4, a6, o4, u5, i6, s4, c6, f4, d3) {
      return e5 = new nl(e5, n7, r7, u5, i6, s4, c6, null), n7 = 1, true === o4 && (n7 |= 24), o4 = t4(3, null, null, n7), e5.current = o4, o4.stateNode = e5, (n7 = vt()).refCount++, e5.pooledCache = n7, n7.refCount++, o4.memoizedState = { element: l4, isDehydrated: r7, cache: n7 }, V(o4), e5;
    }(e4, n6, false, null, 0, l3, o3, u4, i5, s3);
  }, al.flushSyncWork = function() {
    return 0 != (6 & Ru) || (W(0), false);
  }, al.updateContainer = function(e4, n6, t5, r6) {
    var l3 = n6.current, a5 = pr();
    return tl(l3, a5, e4, n6, t5, r6), a5;
  }, al.updateContainerSync = function(e4, n6, t5, r6) {
    return 0 === n6.tag && Wr(), tl(n6.current, 2, e4, n6, t5, r6), 2;
  }, al;
}, s.exports.default = s.exports, Object.defineProperty(s.exports, "__esModule", { value: true })), o.exports) : a.exports = function() {
  return i || (i = 1, n5 = c, n5.exports = function(n6) {
    function t4(e4, n7, t5, r6) {
      return new sa(e4, n7, t5, r6);
    }
    function r5() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function l2() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function a4() {
    }
    function o2(e4) {
      var n7 = [];
      return e4.forEach(function(e5) {
        n7.push(e5);
      }), n7.sort().join(", ");
    }
    function i4(e4) {
      return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = Ya && e4[Ya] || e4["@@iterator"]) ? e4 : null;
    }
    function s2(e4) {
      if (null == e4) return null;
      if ("function" == typeof e4) return e4.$$typeof === Ga ? null : e4.displayName || e4.name || null;
      if ("string" == typeof e4) return e4;
      switch (e4) {
        case Ia:
          return "Fragment";
        case Da:
          return "Portal";
        case Ma:
          return "Profiler";
        case Fa:
          return "StrictMode";
        case Qa:
          return "Suspense";
        case Oa:
          return "SuspenseList";
      }
      if ("object" == typeof e4) switch ("number" == typeof e4.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e4.$$typeof) {
        case ja:
          return (e4.displayName || "Context") + ".Provider";
        case Ha:
          return (e4._context.displayName || "Context") + ".Consumer";
        case Aa:
          var n7 = e4.render;
          return (e4 = e4.displayName) || (e4 = "" !== (e4 = n7.displayName || n7.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
        case Ba:
          return null !== (n7 = e4.displayName || null) ? n7 : s2(e4.type) || "Memo";
        case Va:
          n7 = e4._payload, e4 = e4._init;
          try {
            return s2(e4(n7));
          } catch (e5) {
          }
      }
      return null;
    }
    function c4(e4) {
      var n7 = e4.type;
      switch (e4.tag) {
        case 24:
          return "Cache";
        case 9:
          return (n7._context.displayName || "Context") + ".Consumer";
        case 10:
          return (n7.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return e4 = (e4 = n7.render).displayName || e4.name || "", n7.displayName || ("" !== e4 ? "ForwardRef(" + e4 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return n7;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return s2(n7);
        case 8:
          return n7 === Fa ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" == typeof n7) return n7.displayName || n7.name || null;
          if ("string" == typeof n7) return n7;
          break;
        case 29:
          if (null != (n7 = e4._debugInfo)) {
            for (var t5 = n7.length - 1; 0 <= t5; t5--) if ("string" == typeof n7[t5].name) return n7[t5].name;
          }
          if (null !== e4.return) return c4(e4.return);
      }
      return null;
    }
    function f3() {
    }
    function d2(e4) {
      if (void 0 === Xa) try {
        throw Error();
      } catch (e5) {
        var n7 = e5.stack.trim().match(/\n( *(at )?)/);
        Xa = n7 && n7[1] || "", Za = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + Xa + e4 + Za;
    }
    function p3(e4, n7) {
      if (!e4 || eo) return "";
      var t5, r6 = no.get(e4);
      if (void 0 !== r6) return r6;
      eo = true, r6 = Error.prepareStackTrace, Error.prepareStackTrace = void 0, t5 = Ja.H, Ja.H = null, function() {
        if (0 === Ka) {
          ka = console.log, wa = console.info, xa = console.warn, za = console.error, Ca = console.group, Ea = console.groupCollapsed, Pa = console.groupEnd;
          var e5 = { configurable: true, enumerable: true, value: f3, writable: true };
          Object.defineProperties(console, { info: e5, log: e5, warn: e5, error: e5, group: e5, groupCollapsed: e5, groupEnd: e5 });
        }
        Ka++;
      }();
      try {
        var l3 = { DetermineComponentFrameRoot: function() {
          try {
            if (n7) {
              var t6 = function() {
                throw Error();
              };
              if (Object.defineProperty(t6.prototype, "props", { set: function() {
                throw Error();
              } }), "object" == typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(t6, []);
                } catch (e5) {
                  var r7 = e5;
                }
                Reflect.construct(e4, [], t6);
              } else {
                try {
                  t6.call();
                } catch (e5) {
                  r7 = e5;
                }
                e4.call(t6.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (e5) {
                r7 = e5;
              }
              (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
              });
            }
          } catch (e5) {
            if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
          }
          return [null, null];
        } };
        l3.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var a5 = Object.getOwnPropertyDescriptor(l3.DetermineComponentFrameRoot, "name");
        a5 && a5.configurable && Object.defineProperty(l3.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var o3 = l3.DetermineComponentFrameRoot(), u4 = o3[0], i5 = o3[1];
        if (u4 && i5) {
          var s3 = u4.split("\n"), c5 = i5.split("\n");
          for (o3 = a5 = 0; a5 < s3.length && !s3[a5].includes("DetermineComponentFrameRoot"); ) a5++;
          for (; o3 < c5.length && !c5[o3].includes("DetermineComponentFrameRoot"); ) o3++;
          if (a5 === s3.length || o3 === c5.length) for (a5 = s3.length - 1, o3 = c5.length - 1; 1 <= a5 && 0 <= o3 && s3[a5] !== c5[o3]; ) o3--;
          for (; 1 <= a5 && 0 <= o3; a5--, o3--) if (s3[a5] !== c5[o3]) {
            if (1 !== a5 || 1 !== o3) do {
              if (a5--, 0 > --o3 || s3[a5] !== c5[o3]) {
                var p4 = "\n" + s3[a5].replace(" at new ", " at ");
                return e4.displayName && p4.includes("<anonymous>") && (p4 = p4.replace("<anonymous>", e4.displayName)), "function" == typeof e4 && no.set(e4, p4), p4;
              }
            } while (1 <= a5 && 0 <= o3);
            break;
          }
        }
      } finally {
        eo = false, Ja.H = t5, function() {
          if (0 == --Ka) {
            var e5 = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, { log: Na({}, e5, { value: ka }), info: Na({}, e5, { value: wa }), warn: Na({}, e5, { value: xa }), error: Na({}, e5, { value: za }), group: Na({}, e5, { value: Ca }), groupCollapsed: Na({}, e5, { value: Ea }), groupEnd: Na({}, e5, { value: Pa }) });
          }
          0 > Ka && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }(), Error.prepareStackTrace = r6;
      }
      return s3 = (s3 = e4 ? e4.displayName || e4.name : "") ? d2(s3) : "", "function" == typeof e4 && no.set(e4, s3), s3;
    }
    function m(e4) {
      switch (e4.tag) {
        case 26:
        case 27:
        case 5:
          return d2(e4.type);
        case 16:
          return d2("Lazy");
        case 13:
          return d2("Suspense");
        case 19:
          return d2("SuspenseList");
        case 0:
        case 15:
          return p3(e4.type, false);
        case 11:
          return p3(e4.type.render, false);
        case 1:
          return p3(e4.type, true);
        default:
          return "";
      }
    }
    function h3(e4) {
      try {
        var n7 = "";
        do {
          n7 += m(e4);
          var t5 = e4._debugInfo;
          if (t5) for (var r6 = t5.length - 1; 0 <= r6; r6--) {
            var l3 = t5[r6];
            if ("string" == typeof l3.name) {
              var a5 = n7, o3 = l3.env;
              n7 = a5 + d2(l3.name + (o3 ? " [" + o3 + "]" : ""));
            }
          }
          e4 = e4.return;
        } while (e4);
        return n7;
      } catch (e5) {
        return "\nError generating stack: " + e5.message + "\n" + e5.stack;
      }
    }
    function g3() {
      return null === to ? "" : h3(to);
    }
    function y3(e4, n7, t5, r6, l3, a5, o3) {
      var u4 = to;
      Ja.getCurrentStack = null === e4 ? null : g3, ro = false, to = e4;
      try {
        return n7(t5, r6, l3, a5, o3);
      } finally {
        to = u4;
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function b3(e4) {
      return { current: e4 };
    }
    function v3(e4, n7) {
      0 > iu ? console.error("Unexpected pop.") : (n7 !== uu[iu] && console.error("Unexpected Fiber popped."), e4.current = ou[iu], ou[iu] = null, uu[iu] = null, iu--);
    }
    function S3(e4, n7, t5) {
      iu++, ou[iu] = e4.current, uu[iu] = t5, e4.current = n7;
    }
    function k3(e4) {
      var n7 = 42 & e4;
      if (0 !== n7) return n7;
      switch (e4 & -e4) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return 4194176 & e4;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return 62914560 & e4;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), e4;
      }
    }
    function w(e4, n7) {
      var t5 = e4.pendingLanes;
      if (0 === t5) return 0;
      var r6 = 0, l3 = e4.suspendedLanes;
      e4 = e4.pingedLanes;
      var a5 = 134217727 & t5;
      return 0 !== a5 ? 0 != (t5 = a5 & ~l3) ? r6 = k3(t5) : 0 != (e4 &= a5) && (r6 = k3(e4)) : 0 != (t5 &= ~l3) ? r6 = k3(t5) : 0 !== e4 && (r6 = k3(e4)), 0 === r6 ? 0 : 0 !== n7 && n7 !== r6 && 0 == (n7 & l3) && ((l3 = r6 & -r6) >= (e4 = n7 & -n7) || 32 === l3 && 0 != (4194176 & e4)) ? n7 : r6;
    }
    function x(e4, n7) {
      switch (e4) {
        case 1:
        case 2:
        case 4:
        case 8:
          return n7 + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return n7 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function z() {
      var e4 = pu;
      return 0 == (4194176 & (pu <<= 1)) && (pu = 128), e4;
    }
    function C() {
      var e4 = mu;
      return 0 == (62914560 & (mu <<= 1)) && (mu = 4194304), e4;
    }
    function E(e4) {
      for (var n7 = [], t5 = 0; 31 > t5; t5++) n7.push(e4);
      return n7;
    }
    function P(e4, n7) {
      e4.pendingLanes |= n7, 268435456 !== n7 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
    }
    function _(e4, n7, t5) {
      e4.pendingLanes |= n7, e4.suspendedLanes &= ~n7;
      var r6 = 31 - cu(n7);
      e4.entangledLanes |= n7, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 4194218 & t5;
    }
    function R(e4, n7) {
      var t5 = e4.entangledLanes |= n7;
      for (e4 = e4.entanglements; t5; ) {
        var r6 = 31 - cu(t5), l3 = 1 << r6;
        l3 & n7 | e4[r6] & n7 && (e4[r6] |= n7), t5 &= ~l3;
      }
    }
    function T(e4, n7, t5) {
      if (_u) for (e4 = e4.pendingUpdatersLaneMap; 0 < t5; ) {
        var r6 = 31 - cu(t5), l3 = 1 << r6;
        e4[r6].add(n7), t5 &= ~l3;
      }
    }
    function N(e4, n7) {
      if (_u) for (var t5 = e4.pendingUpdatersLaneMap, r6 = e4.memoizedUpdaters; 0 < n7; ) {
        var l3 = 31 - cu(n7);
        e4 = 1 << l3, 0 < (l3 = t5[l3]).size && (l3.forEach(function(e5) {
          var n8 = e5.alternate;
          null !== n8 && r6.has(n8) || r6.add(e5);
        }), l3.clear()), n7 &= ~e4;
      }
    }
    function L(e4) {
      return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
    }
    function U(e4) {
      "function" == typeof zu && Cu(e4);
    }
    function D(e4, n7) {
      if ("object" == typeof e4 && null !== e4) {
        var t5 = Tu.get(e4);
        return void 0 !== t5 ? t5 : (n7 = { value: e4, source: n7, stack: h3(n7) }, Tu.set(e4, n7), n7);
      }
      return { value: e4, source: n7, stack: h3(n7) };
    }
    function I(e4) {
      for (; e4 === Uu; ) Uu = Nu[--Lu], Nu[Lu] = null, Du = Nu[--Lu], Nu[Lu] = null;
      for (; e4 === Mu; ) Mu = Iu[--Fu], Iu[Fu] = null, Hu = Iu[--Fu], Iu[Fu] = null, Wu = Iu[--Fu], Iu[Fu] = null;
    }
    function F() {
      console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function M(e4) {
      return null === e4 && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."), e4;
    }
    function W(e4, n7) {
      S3(Qu, n7, e4), S3(Au, e4, e4), S3(ju, null, e4), n7 = oo(n7), v3(ju, e4), S3(ju, n7, e4);
    }
    function H(e4) {
      v3(ju, e4), v3(Au, e4), v3(Qu, e4);
    }
    function j() {
      return M(ju.current);
    }
    function A(e4) {
      null !== e4.memoizedState && S3(Ou, e4, e4);
      var n7 = M(ju.current), t5 = uo(n7, e4.type);
      n7 !== t5 && (S3(Au, e4, e4), S3(ju, t5, e4));
    }
    function Q(e4) {
      Au.current === e4 && (v3(ju, e4), v3(Au, e4)), Ou.current === e4 && (v3(Ou, e4), Uo._currentValue2 = Lo);
    }
    function O() {
      for (var e4 = Yu, n7 = Gu = Yu = 0; n7 < e4; ) {
        var t5 = qu[n7];
        qu[n7++] = null;
        var r6 = qu[n7];
        qu[n7++] = null;
        var l3 = qu[n7];
        qu[n7++] = null;
        var a5 = qu[n7];
        if (qu[n7++] = null, null !== r6 && null !== l3) {
          var o3 = r6.pending;
          null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r6.pending = l3;
        }
        0 !== a5 && q(t5, l3, a5);
      }
    }
    function B(e4, n7, t5, r6) {
      qu[Yu++] = e4, qu[Yu++] = n7, qu[Yu++] = t5, qu[Yu++] = r6, Gu |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
    }
    function V(e4, n7, t5, r6) {
      return B(e4, n7, t5, r6), Y(e4);
    }
    function $(e4, n7) {
      return B(e4, null, null, n7), Y(e4);
    }
    function q(e4, n7, t5) {
      e4.lanes |= t5;
      var r6 = e4.alternate;
      null !== r6 && (r6.lanes |= t5);
      for (var l3 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || 1 & e4._visibility || (l3 = true)), e4 = a5, a5 = a5.return;
      l3 && null !== n7 && 3 === e4.tag && (a5 = e4.stateNode, l3 = 31 - cu(t5), null === (e4 = (a5 = a5.hiddenUpdates)[l3]) ? a5[l3] = [n7] : e4.push(n7), n7.lane = 536870912 | t5);
    }
    function Y(e4) {
      if (Yf > qf) throw Zf = Yf = 0, ed = Gf = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Zf > Xf && (Zf = 0, ed = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")), null === e4.alternate && 0 != (4098 & e4.flags) && ua(e4);
      for (var n7 = e4, t5 = n7.return; null !== t5; ) null === n7.alternate && 0 != (4098 & n7.flags) && ua(e4), t5 = (n7 = t5).return;
      return 3 === n7.tag ? n7.stateNode : null;
    }
    function G2() {
      var e4 = Zu;
      return Zu = 0, e4;
    }
    function J(e4) {
      var n7 = Zu;
      return Zu = e4, n7;
    }
    function K(e4) {
      var n7 = Zu;
      return Zu += e4, n7;
    }
    function X(e4) {
      Xu = Ju(), 0 > e4.actualStartTime && (e4.actualStartTime = Xu);
    }
    function Z(e4) {
      if (0 <= Xu) {
        var n7 = Ju() - Xu;
        e4.actualDuration += n7, e4.selfBaseDuration = n7, Xu = -1;
      }
    }
    function ee(e4) {
      if (0 <= Xu) {
        var n7 = Ju() - Xu;
        e4.actualDuration += n7, Xu = -1;
      }
    }
    function ne() {
      if (0 <= Xu) {
        var e4 = Ju() - Xu;
        Xu = -1, Zu += e4;
      }
    }
    function te() {
      Xu = Ju();
    }
    function re(e4) {
      for (var n7 = e4.child; n7; ) e4.actualDuration += n7.actualDuration, n7 = n7.sibling;
    }
    function le(e4) {
      e4 !== ri && null === e4.next && (null === ri ? ti = ri = e4 : ri = ri.next = e4), oi = true, null !== Ja.actQueue ? ai || (ai = true, fe(oe)) : li || (li = true, fe(oe));
    }
    function ae(e4, n7) {
      if (!ui && oi) {
        ui = true;
        do {
          for (var t5 = false, r6 = ti; null !== r6; ) {
            if (0 !== e4) {
              var l3 = r6.pendingLanes;
              if (0 === l3) var a5 = 0;
              else {
                var o3 = r6.suspendedLanes, u4 = r6.pingedLanes;
                a5 = (1 << 31 - cu(42 | e4) + 1) - 1, a5 = 201326677 & (a5 &= l3 & ~(o3 & ~u4)) ? 201326677 & a5 | 1 : a5 ? 2 | a5 : 0;
              }
              0 !== a5 && (t5 = true, se(r6, a5));
            } else a5 = df, 0 != (3 & (a5 = w(r6, r6 === cf ? a5 : 0))) && (t5 = true, se(r6, a5));
            r6 = r6.next;
          }
        } while (t5);
        ui = false;
      }
    }
    function oe() {
      oi = ai = li = false;
      var e4 = 0;
      0 !== ii && (Co() && (e4 = ii), ii = 0);
      for (var n7 = vu(), t5 = null, r6 = ti; null !== r6; ) {
        var l3 = r6.next, a5 = ue(r6, n7);
        0 === a5 ? (r6.next = null, null === t5 ? ti = l3 : t5.next = l3, null === l3 && (ri = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (oi = true)), r6 = l3;
      }
      ae(e4);
    }
    function ue(e4, n7) {
      for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l3 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
        var o3 = 31 - cu(a5), u4 = 1 << o3, i5 = l3[o3];
        -1 === i5 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l3[o3] = x(u4, n7)) : i5 <= n7 && (e4.expiredLanes |= u4), a5 &= ~u4;
      }
      if (t5 = df, t5 = w(e4, e4 === (n7 = cf) ? t5 : 0), r6 = e4.callbackNode, 0 === t5 || e4 === n7 && wf === hf || null !== e4.cancelPendingCommit) return null !== r6 && ce(r6), e4.callbackNode = null, e4.callbackPriority = 0;
      if (0 != (3 & t5)) return null !== r6 && ce(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
      if ((n7 = t5 & -t5) === e4.callbackPriority && (null === Ja.actQueue || r6 === si)) return n7;
      switch (ce(r6), L(t5)) {
        case 2:
          t5 = Su;
          break;
        case 8:
          t5 = ku;
          break;
        case 32:
        default:
          t5 = wu;
          break;
        case 268435456:
          t5 = xu;
      }
      return r6 = ie.bind(null, e4), null !== Ja.actQueue ? (Ja.actQueue.push(r6), t5 = si) : t5 = hu(t5, r6), e4.callbackPriority = n7, e4.callbackNode = t5, n7;
    }
    function ie(e4, n7) {
      ni = ei = false;
      var t5 = e4.callbackNode;
      if (Jl() && e4.callbackNode !== t5) return null;
      var r6 = df;
      return 0 === (r6 = w(e4, e4 === cf ? r6 : 0)) ? null : (El(e4, r6, n7), ue(e4, vu()), e4.callbackNode === t5 ? ie.bind(null, e4) : null);
    }
    function se(e4, n7) {
      if (Jl()) return null;
      ei = ni, ni = false, El(e4, n7, true);
    }
    function ce(e4) {
      e4 !== si && null !== e4 && gu(e4);
    }
    function fe(e4) {
      null !== Ja.actQueue && Ja.actQueue.push(function() {
        return e4(), null;
      }), hu(Su, e4);
    }
    function de() {
      return 0 === ii && (ii = z()), ii;
    }
    function pe() {
      if (0 == --fi && null !== ci) {
        null !== pi && (pi.status = "fulfilled");
        var e4 = ci;
        ci = null, di = 0, pi = null;
        for (var n7 = 0; n7 < e4.length; n7++) (0, e4[n7])();
      }
    }
    function me(e4) {
      e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
    }
    function he(e4, n7) {
      e4 = e4.updateQueue, n7.updateQueue === e4 && (n7.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
    }
    function ge(e4) {
      return { lane: e4, tag: mi, payload: null, callback: null, next: null };
    }
    function ye(e4, n7, t5) {
      var r6 = e4.updateQueue;
      if (null === r6) return null;
      if (r6 = r6.shared, Si === r6 && !vi) {
        var l3 = c4(e4);
        console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", l3), vi = true;
      }
      return (sf & Zc) !== Xc ? (null === (l3 = r6.pending) ? n7.next = n7 : (n7.next = l3.next, l3.next = n7), r6.pending = n7, n7 = Y(e4), q(e4, null, t5), n7) : (B(e4, r6, n7, t5), Y(e4));
    }
    function be(e4, n7, t5) {
      if (null !== (n7 = n7.updateQueue) && (n7 = n7.shared, 0 != (4194176 & t5))) {
        var r6 = n7.lanes;
        t5 |= r6 &= e4.pendingLanes, n7.lanes = t5, R(e4, t5);
      }
    }
    function ve(e4, n7) {
      var t5 = e4.updateQueue, r6 = e4.alternate;
      if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
        var l3 = null, a5 = null;
        if (null !== (t5 = t5.firstBaseUpdate)) {
          do {
            var o3 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
            null === a5 ? l3 = a5 = o3 : a5 = a5.next = o3, t5 = t5.next;
          } while (null !== t5);
          null === a5 ? l3 = a5 = n7 : a5 = a5.next = n7;
        } else l3 = a5 = n7;
        return t5 = { baseState: r6.baseState, firstBaseUpdate: l3, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
      }
      null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n7 : e4.next = n7, t5.lastBaseUpdate = n7;
    }
    function Se() {
      if (ki && null !== pi) throw pi;
    }
    function ke(e4, n7, t5, r6) {
      ki = false;
      var l3 = e4.updateQueue;
      bi = false, Si = l3.shared;
      var a5 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u4 = l3.shared.pending;
      if (null !== u4) {
        l3.shared.pending = null;
        var i5 = u4, s3 = i5.next;
        i5.next = null, null === o3 ? a5 = s3 : o3.next = s3, o3 = i5;
        var c5 = e4.alternate;
        null !== c5 && (u4 = (c5 = c5.updateQueue).lastBaseUpdate) !== o3 && (null === u4 ? c5.firstBaseUpdate = s3 : u4.next = s3, c5.lastBaseUpdate = i5);
      }
      if (null !== a5) {
        var f4 = l3.baseState;
        for (o3 = 0, c5 = s3 = i5 = null, u4 = a5; ; ) {
          var d3 = -536870913 & u4.lane, p4 = d3 !== u4.lane;
          if (p4 ? (df & d3) === d3 : (r6 & d3) === d3) {
            0 !== d3 && d3 === di && (ki = true), null !== c5 && (c5 = c5.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
            e: {
              d3 = e4;
              var m2 = u4, h4 = n7, g4 = t5;
              switch (m2.tag) {
                case hi:
                  if ("function" == typeof (m2 = m2.payload)) {
                    Rc = true;
                    var y4 = m2.call(g4, f4, h4);
                    if (8 & d3.mode) {
                      U(true);
                      try {
                        m2.call(g4, f4, h4);
                      } finally {
                        U(false);
                      }
                    }
                    Rc = false, f4 = y4;
                    break e;
                  }
                  f4 = m2;
                  break e;
                case yi:
                  d3.flags = -65537 & d3.flags | 128;
                case mi:
                  if ("function" == typeof (y4 = m2.payload)) {
                    if (Rc = true, m2 = y4.call(g4, f4, h4), 8 & d3.mode) {
                      U(true);
                      try {
                        y4.call(g4, f4, h4);
                      } finally {
                        U(false);
                      }
                    }
                    Rc = false;
                  } else m2 = y4;
                  if (null == m2) break e;
                  f4 = Na({}, f4, m2);
                  break e;
                case gi:
                  bi = true;
              }
            }
            null !== (d3 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l3.callbacks) ? l3.callbacks = [d3] : p4.push(d3));
          } else p4 = { lane: d3, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c5 ? (s3 = c5 = p4, i5 = f4) : c5 = c5.next = p4, o3 |= d3;
          if (null === (u4 = u4.next)) {
            if (null === (u4 = l3.shared.pending)) break;
            u4 = (p4 = u4).next, p4.next = null, l3.lastBaseUpdate = p4, l3.shared.pending = null;
          }
        }
        null === c5 && (i5 = f4), l3.baseState = i5, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c5, null === a5 && (l3.shared.lanes = 0), _f |= o3, e4.lanes = o3, e4.memoizedState = f4;
      }
      Si = null;
    }
    function we(e4, n7) {
      if ("function" != typeof e4) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + e4);
      e4.call(n7);
    }
    function xe(e4, n7) {
      var t5 = e4.shared.hiddenCallbacks;
      if (null !== t5) for (e4.shared.hiddenCallbacks = null, e4 = 0; e4 < t5.length; e4++) we(t5[e4], n7);
    }
    function ze(e4, n7) {
      var t5 = e4.callbacks;
      if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) we(t5[e4], n7);
    }
    function Ce(e4, n7) {
      if (Ru(e4, n7)) return true;
      if ("object" != typeof e4 || null === e4 || "object" != typeof n7 || null === n7) return false;
      var t5 = Object.keys(e4), r6 = Object.keys(n7);
      if (t5.length !== r6.length) return false;
      for (r6 = 0; r6 < t5.length; r6++) {
        var l3 = t5[r6];
        if (!wi.call(n7, l3) || !Ru(e4[l3], n7[l3])) return false;
      }
      return true;
    }
    function Ee(e4) {
      return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
    }
    function Pe() {
    }
    function _e(e4, n7, t5) {
      null !== Ja.actQueue && (Ja.didUsePromise = true);
      var r6 = e4.thenables;
      switch (void 0 === (t5 = r6[t5]) ? r6.push(n7) : t5 !== n7 && (e4.didWarnAboutUncachedPromise || (e4.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), n7.then(Pe, Pe), n7 = t5), n7.status) {
        case "fulfilled":
          return n7.value;
        case "rejected":
          throw Te(e4 = n7.reason), e4;
        default:
          if ("string" == typeof n7.status) n7.then(Pe, Pe);
          else {
            if (null !== (e4 = cf) && 100 < e4.shellSuspendCounter) throw Error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            (e4 = n7).status = "pending", e4.then(function(e5) {
              if ("pending" === n7.status) {
                var t6 = n7;
                t6.status = "fulfilled", t6.value = e5;
              }
            }, function(e5) {
              if ("pending" === n7.status) {
                var t6 = n7;
                t6.status = "rejected", t6.reason = e5;
              }
            });
          }
          switch (n7.status) {
            case "fulfilled":
              return n7.value;
            case "rejected":
              throw Te(e4 = n7.reason), e4;
          }
          throw Mi = n7, Wi = true, Di;
      }
    }
    function Re() {
      if (null === Mi) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var e4 = Mi;
      return Mi = null, Wi = false, e4;
    }
    function Te(e4) {
      if (e4 === Di) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function Ne(e4) {
      var n7 = as;
      return null != e4 && (as = null === n7 ? e4 : n7.concat(e4)), n7;
    }
    function Le(e4, n7, t5) {
      for (var r6 = Object.keys(e4.props), l3 = 0; l3 < r6.length; l3++) {
        var a5 = r6[l3];
        if ("children" !== a5 && "key" !== a5) {
          null === n7 && ((n7 = ma(e4, t5.mode, 0))._debugInfo = as, n7.return = t5), y3(n7, function(e5) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", e5);
          }, a5);
          break;
        }
      }
    }
    function Ue(e4) {
      var n7 = ls;
      return ls += 1, null === rs && (rs = { didWarnAboutUncachedPromise: false, thenables: [] }), _e(rs, e4, n7);
    }
    function De(e4, n7, t5, r6) {
      e4 = r6.props.ref, t5.ref = void 0 !== e4 ? e4 : null;
    }
    function Ie(e4, n7) {
      if (n7.$$typeof === La) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
      throw e4 = Object.prototype.toString.call(n7), Error("Objects are not valid as a React child (found: " + ("[object Object]" === e4 ? "object with keys {" + Object.keys(n7).join(", ") + "}" : e4) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Fe(e4, n7) {
      var t5 = c4(e4) || "Component";
      is[t5] || (is[t5] = true, n7 = n7.displayName || n7.name || "Component", 3 === e4.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", n7, n7, n7) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", n7, n7, t5, n7, t5));
    }
    function Me(e4, n7) {
      var t5 = c4(e4) || "Component";
      ss[t5] || (ss[t5] = true, n7 = String(n7), 3 === e4.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", n7) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", t5, n7, t5));
    }
    function We(e4) {
      function n7(n8, t5) {
        if (e4) {
          var r7 = n8.deletions;
          null === r7 ? (n8.deletions = [t5], n8.flags |= 16) : r7.push(t5);
        }
      }
      function r6(t5, r7) {
        if (!e4) return null;
        for (; null !== r7; ) n7(t5, r7), r7 = r7.sibling;
        return null;
      }
      function l3(e5) {
        for (var n8 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n8.set(e5.key, e5) : n8.set(e5.index, e5), e5 = e5.sibling;
        return n8;
      }
      function o3(e5, n8) {
        return (e5 = fa(e5, n8)).index = 0, e5.sibling = null, e5;
      }
      function u4(n8, t5, r7) {
        return n8.index = r7, e4 ? null !== (r7 = n8.alternate) ? (r7 = r7.index) < t5 ? (n8.flags |= 33554434, t5) : r7 : (n8.flags |= 33554434, t5) : (n8.flags |= 1048576, t5);
      }
      function s3(n8) {
        return e4 && null === n8.alternate && (n8.flags |= 33554434), n8;
      }
      function c5(e5, n8, t5, r7) {
        return null === n8 || 6 !== n8.tag ? ((n8 = ya(t5, e5.mode, r7)).return = e5, n8._debugOwner = e5, n8._debugInfo = as, n8) : ((n8 = o3(n8, t5)).return = e5, n8._debugInfo = as, n8);
      }
      function f4(e5, n8, t5, r7) {
        var l4 = t5.type;
        return l4 === Ia ? (Le(t5, n8 = p4(e5, n8, t5.props.children, r7, t5.key), e5), n8) : null !== n8 && (n8.elementType === l4 || "object" == typeof l4 && null !== l4 && l4.$$typeof === Va && ts(l4) === n8.type) ? (De(e5, 0, r7 = o3(n8, t5.props), t5), r7.return = e5, r7._debugOwner = t5._owner, r7._debugInfo = as, r7) : (De(e5, 0, r7 = ma(t5, e5.mode, r7), t5), r7.return = e5, r7._debugInfo = as, r7);
      }
      function d3(e5, n8, t5, r7) {
        return null === n8 || 4 !== n8.tag || n8.stateNode.containerInfo !== t5.containerInfo || n8.stateNode.implementation !== t5.implementation ? ((n8 = ba(t5, e5.mode, r7)).return = e5, n8._debugInfo = as, n8) : ((n8 = o3(n8, t5.children || [])).return = e5, n8._debugInfo = as, n8);
      }
      function p4(e5, n8, t5, r7, l4) {
        return null === n8 || 7 !== n8.tag ? ((n8 = ha(t5, e5.mode, r7, l4)).return = e5, n8._debugOwner = e5, n8._debugInfo = as, n8) : ((n8 = o3(n8, t5)).return = e5, n8._debugInfo = as, n8);
      }
      function m2(e5, n8, t5) {
        if ("string" == typeof n8 && "" !== n8 || "number" == typeof n8 || "bigint" == typeof n8) return (n8 = ya("" + n8, e5.mode, t5)).return = e5, n8._debugOwner = e5, n8._debugInfo = as, n8;
        if ("object" == typeof n8 && null !== n8) {
          switch (n8.$$typeof) {
            case Ua:
              return De(e5, 0, t5 = ma(n8, e5.mode, t5), n8), t5.return = e5, e5 = Ne(n8._debugInfo), t5._debugInfo = as, as = e5, t5;
            case Da:
              return (n8 = ba(n8, e5.mode, t5)).return = e5, n8._debugInfo = as, n8;
            case Va:
              var r7 = Ne(n8._debugInfo);
              return e5 = m2(e5, n8 = ts(n8), t5), as = r7, e5;
          }
          if (lo(n8) || i4(n8)) return (t5 = ha(n8, e5.mode, t5, null)).return = e5, t5._debugOwner = e5, e5 = Ne(n8._debugInfo), t5._debugInfo = as, as = e5, t5;
          if ("function" == typeof n8.then) return r7 = Ne(n8._debugInfo), e5 = m2(e5, Ue(n8), t5), as = r7, e5;
          if (n8.$$typeof === ja) return m2(e5, cr(e5, n8), t5);
          Ie(e5, n8);
        }
        return "function" == typeof n8 && Fe(e5, n8), "symbol" == typeof n8 && Me(e5, n8), null;
      }
      function h4(e5, n8, t5, r7) {
        var l4 = null !== n8 ? n8.key : null;
        if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== l4 ? null : c5(e5, n8, "" + t5, r7);
        if ("object" == typeof t5 && null !== t5) {
          switch (t5.$$typeof) {
            case Ua:
              return t5.key === l4 ? (l4 = Ne(t5._debugInfo), e5 = f4(e5, n8, t5, r7), as = l4, e5) : null;
            case Da:
              return t5.key === l4 ? d3(e5, n8, t5, r7) : null;
            case Va:
              return l4 = Ne(t5._debugInfo), e5 = h4(e5, n8, t5 = ts(t5), r7), as = l4, e5;
          }
          if (lo(t5) || i4(t5)) return null !== l4 ? null : (l4 = Ne(t5._debugInfo), e5 = p4(e5, n8, t5, r7, null), as = l4, e5);
          if ("function" == typeof t5.then) return l4 = Ne(t5._debugInfo), e5 = h4(e5, n8, Ue(t5), r7), as = l4, e5;
          if (t5.$$typeof === ja) return h4(e5, n8, cr(e5, t5), r7);
          Ie(e5, t5);
        }
        return "function" == typeof t5 && Fe(e5, t5), "symbol" == typeof t5 && Me(e5, t5), null;
      }
      function g4(e5, n8, t5, r7, l4) {
        if ("string" == typeof r7 && "" !== r7 || "number" == typeof r7 || "bigint" == typeof r7) return c5(n8, e5 = e5.get(t5) || null, "" + r7, l4);
        if ("object" == typeof r7 && null !== r7) {
          switch (r7.$$typeof) {
            case Ua:
              return t5 = e5.get(null === r7.key ? t5 : r7.key) || null, e5 = Ne(r7._debugInfo), n8 = f4(n8, t5, r7, l4), as = e5, n8;
            case Da:
              return d3(n8, e5 = e5.get(null === r7.key ? t5 : r7.key) || null, r7, l4);
            case Va:
              var a5 = Ne(r7._debugInfo);
              return n8 = g4(e5, n8, t5, r7 = ts(r7), l4), as = a5, n8;
          }
          if (lo(r7) || i4(r7)) return t5 = e5.get(t5) || null, e5 = Ne(r7._debugInfo), n8 = p4(n8, t5, r7, l4, null), as = e5, n8;
          if ("function" == typeof r7.then) return a5 = Ne(r7._debugInfo), n8 = g4(e5, n8, t5, Ue(r7), l4), as = a5, n8;
          if (r7.$$typeof === ja) return g4(e5, n8, t5, cr(n8, r7), l4);
          Ie(n8, r7);
        }
        return "function" == typeof r7 && Fe(n8, r7), "symbol" == typeof r7 && Me(n8, r7), null;
      }
      function b4(e5, n8, t5, r7) {
        if ("object" != typeof t5 || null === t5) return r7;
        switch (t5.$$typeof) {
          case Ua:
          case Da:
            a4(e5, n8, t5);
            var l4 = t5.key;
            if ("string" != typeof l4) break;
            if (null === r7) {
              (r7 = /* @__PURE__ */ new Set()).add(l4);
              break;
            }
            if (!r7.has(l4)) {
              r7.add(l4);
              break;
            }
            y3(n8, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", l4);
            });
            break;
          case Va:
            b4(e5, n8, t5 = ts(t5), r7);
        }
        return r7;
      }
      function v4(t5, a5, c6, f5) {
        if ("object" == typeof c6 && null !== c6 && c6.type === Ia && null === c6.key && (Le(c6, null, t5), c6 = c6.props.children), "object" == typeof c6 && null !== c6) {
          switch (c6.$$typeof) {
            case Ua:
              var d4 = Ne(c6._debugInfo);
              e: {
                for (var p5 = c6.key, y4 = a5; null !== y4; ) {
                  if (y4.key === p5) {
                    if ((p5 = c6.type) === Ia) {
                      if (7 === y4.tag) {
                        r6(t5, y4.sibling), (a5 = o3(y4, c6.props.children)).return = t5, a5._debugOwner = c6._owner, a5._debugInfo = as, Le(c6, a5, t5), t5 = a5;
                        break e;
                      }
                    } else if (y4.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === Va && ts(p5) === y4.type) {
                      r6(t5, y4.sibling), De(t5, 0, a5 = o3(y4, c6.props), c6), a5.return = t5, a5._debugOwner = c6._owner, a5._debugInfo = as, t5 = a5;
                      break e;
                    }
                    r6(t5, y4);
                    break;
                  }
                  n7(t5, y4), y4 = y4.sibling;
                }
                c6.type === Ia ? ((a5 = ha(c6.props.children, t5.mode, f5, c6.key)).return = t5, a5._debugOwner = t5, a5._debugInfo = as, Le(c6, a5, t5), t5 = a5) : (De(t5, 0, f5 = ma(c6, t5.mode, f5), c6), f5.return = t5, f5._debugInfo = as, t5 = f5);
              }
              return t5 = s3(t5), as = d4, t5;
            case Da:
              e: {
                for (c6 = (d4 = c6).key; null !== a5; ) {
                  if (a5.key === c6) {
                    if (4 === a5.tag && a5.stateNode.containerInfo === d4.containerInfo && a5.stateNode.implementation === d4.implementation) {
                      r6(t5, a5.sibling), (a5 = o3(a5, d4.children || [])).return = t5, t5 = a5;
                      break e;
                    }
                    r6(t5, a5);
                    break;
                  }
                  n7(t5, a5), a5 = a5.sibling;
                }
                (a5 = ba(d4, t5.mode, f5)).return = t5, t5 = a5;
              }
              return s3(t5);
            case Va:
              return d4 = Ne(c6._debugInfo), t5 = v4(t5, a5, c6 = ts(c6), f5), as = d4, t5;
          }
          if (lo(c6)) return d4 = Ne(c6._debugInfo), t5 = function(t6, a6, o4, i5) {
            for (var s4 = null, c7 = null, f6 = null, d5 = a6, p6 = a6 = 0, y5 = null; null !== d5 && p6 < o4.length; p6++) {
              d5.index > p6 ? (y5 = d5, d5 = null) : y5 = d5.sibling;
              var v5 = h4(t6, d5, o4[p6], i5);
              if (null === v5) {
                null === d5 && (d5 = y5);
                break;
              }
              s4 = b4(t6, v5, o4[p6], s4), e4 && d5 && null === v5.alternate && n7(t6, d5), a6 = u4(v5, a6, p6), null === f6 ? c7 = v5 : f6.sibling = v5, f6 = v5, d5 = y5;
            }
            if (p6 === o4.length) return r6(t6, d5), c7;
            if (null === d5) {
              for (; p6 < o4.length; p6++) null !== (d5 = m2(t6, o4[p6], i5)) && (s4 = b4(t6, d5, o4[p6], s4), a6 = u4(d5, a6, p6), null === f6 ? c7 = d5 : f6.sibling = d5, f6 = d5);
              return c7;
            }
            for (d5 = l3(d5); p6 < o4.length; p6++) null !== (y5 = g4(d5, t6, p6, o4[p6], i5)) && (s4 = b4(t6, y5, o4[p6], s4), e4 && null !== y5.alternate && d5.delete(null === y5.key ? p6 : y5.key), a6 = u4(y5, a6, p6), null === f6 ? c7 = y5 : f6.sibling = y5, f6 = y5);
            return e4 && d5.forEach(function(e5) {
              return n7(t6, e5);
            }), c7;
          }(t5, a5, c6, f5), as = d4, t5;
          if (i4(c6)) {
            if (d4 = Ne(c6._debugInfo), "function" != typeof (y4 = i4(c6))) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            return (p5 = y4.call(c6)) === c6 ? 0 === t5.tag && "[object GeneratorFunction]" === Object.prototype.toString.call(t5.type) && "[object Generator]" === Object.prototype.toString.call(p5) || (os || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), os = true) : c6.entries !== y4 || Ui || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ui = true), t5 = function(t6, a6, o4, i5) {
              if (null == o4) throw Error("An iterable object provided no iterator.");
              for (var s4 = null, c7 = null, f6 = a6, d5 = a6 = 0, p6 = null, y5 = null, v5 = o4.next(); null !== f6 && !v5.done; d5++, v5 = o4.next()) {
                f6.index > d5 ? (p6 = f6, f6 = null) : p6 = f6.sibling;
                var S4 = h4(t6, f6, v5.value, i5);
                if (null === S4) {
                  null === f6 && (f6 = p6);
                  break;
                }
                y5 = b4(t6, S4, v5.value, y5), e4 && f6 && null === S4.alternate && n7(t6, f6), a6 = u4(S4, a6, d5), null === c7 ? s4 = S4 : c7.sibling = S4, c7 = S4, f6 = p6;
              }
              if (v5.done) return r6(t6, f6), s4;
              if (null === f6) {
                for (; !v5.done; d5++, v5 = o4.next()) null !== (f6 = m2(t6, v5.value, i5)) && (y5 = b4(t6, f6, v5.value, y5), a6 = u4(f6, a6, d5), null === c7 ? s4 = f6 : c7.sibling = f6, c7 = f6);
                return s4;
              }
              for (f6 = l3(f6); !v5.done; d5++, v5 = o4.next()) null !== (p6 = g4(f6, t6, d5, v5.value, i5)) && (y5 = b4(t6, p6, v5.value, y5), e4 && null !== p6.alternate && f6.delete(null === p6.key ? d5 : p6.key), a6 = u4(p6, a6, d5), null === c7 ? s4 = p6 : c7.sibling = p6, c7 = p6);
              return e4 && f6.forEach(function(e5) {
                return n7(t6, e5);
              }), s4;
            }(t5, a5, p5, f5), as = d4, t5;
          }
          if ("function" == typeof c6.then) return d4 = Ne(c6._debugInfo), t5 = v4(t5, a5, Ue(c6), f5), as = d4, t5;
          if (c6.$$typeof === ja) return v4(t5, a5, cr(t5, c6), f5);
          Ie(t5, c6);
        }
        return "string" == typeof c6 && "" !== c6 || "number" == typeof c6 || "bigint" == typeof c6 ? (d4 = "" + c6, null !== a5 && 6 === a5.tag ? (r6(t5, a5.sibling), (a5 = o3(a5, d4)).return = t5, t5 = a5) : (r6(t5, a5), (a5 = ya(d4, t5.mode, f5)).return = t5, a5._debugOwner = t5, a5._debugInfo = as, t5 = a5), s3(t5)) : ("function" == typeof c6 && Fe(t5, c6), "symbol" == typeof c6 && Me(t5, c6), r6(t5, a5));
      }
      return function(e5, n8, r7, l4) {
        var a5 = as;
        as = null;
        try {
          ls = 0;
          var o4 = v4(e5, n8, r7, l4);
          return rs = null, o4;
        } catch (n9) {
          if (n9 === Di) throw n9;
          var u5 = t4(29, n9, null, e5.mode);
          u5.lanes = l4, u5.return = e5;
          var i5 = u5._debugInfo = as;
          if (u5._debugOwner = e5._debugOwner, null != i5) {
            for (var s4 = i5.length - 1; 0 <= s4; s4--) if ("string" == typeof i5[s4].stack) {
              u5._debugOwner = i5[s4];
              break;
            }
          }
          return u5;
        } finally {
          as = a5;
        }
      };
    }
    function He(e4, n7) {
      var t5 = Ef;
      S3(ms, t5, e4), S3(ps, n7, e4), Ef = t5 | n7.baseLanes;
    }
    function je(e4) {
      S3(ms, Ef, e4), S3(ps, ps.current, e4);
    }
    function Ae(e4) {
      Ef = ms.current, v3(ps, e4), v3(ms, e4);
    }
    function Qe(e4) {
      var n7 = e4.alternate;
      S3(vs, vs.current & ys, e4), S3(hs, e4, e4), null === gs && (null === n7 || null !== ps.current || null !== n7.memoizedState) && (gs = e4);
    }
    function Oe(e4) {
      if (22 === e4.tag) {
        if (S3(vs, vs.current, e4), S3(hs, e4, e4), null === gs) {
          var n7 = e4.alternate;
          null !== n7 && null !== n7.memoizedState && (gs = e4);
        }
      } else Be(e4);
    }
    function Be(e4) {
      S3(vs, vs.current, e4), S3(hs, hs.current, e4);
    }
    function Ve(e4) {
      v3(hs, e4), gs === e4 && (gs = null), v3(vs, e4);
    }
    function $e(e4) {
      for (var n7 = e4; null !== n7; ) {
        if (13 === n7.tag) {
          var t5 = n7.memoizedState;
          if (null !== t5 && (null === (t5 = t5.dehydrated) || Jo(t5) || Ko(t5))) return n7;
        } else if (19 === n7.tag && void 0 !== n7.memoizedProps.revealOrder) {
          if (0 != (128 & n7.flags)) return n7;
        } else if (null !== n7.child) {
          n7.child.return = n7, n7 = n7.child;
          continue;
        }
        if (n7 === e4) break;
        for (; null === n7.sibling; ) {
          if (null === n7.return || n7.return === e4) return null;
          n7 = n7.return;
        }
        n7.sibling.return = n7.return, n7 = n7.sibling;
      }
      return null;
    }
    function qe() {
      var e4 = As;
      null === Qs ? Qs = [e4] : Qs.push(e4);
    }
    function Ye() {
      var e4 = As;
      if (null !== Qs && (Os++, Qs[Os] !== e4)) {
        var n7 = c4(Ts);
        if (!Cs.has(n7) && (Cs.add(n7), null !== Qs)) {
          for (var t5 = "", r6 = 0; r6 <= Os; r6++) {
            var l3 = Qs[r6], a5 = r6 === Os ? e4 : l3;
            for (l3 = r6 + 1 + ". " + l3; 30 > l3.length; ) l3 += " ";
            t5 += l3 += a5 + "\n";
          }
          console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", n7, t5);
        }
      }
    }
    function Ge(e4) {
      null == e4 || lo(e4) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", As, typeof e4);
    }
    function Je() {
      var e4 = c4(Ts);
      _s.has(e4) || (_s.add(e4), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", e4));
    }
    function Ke() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function Xe(e4, n7) {
      if (Bs) return false;
      if (null === n7) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", As), false;
      e4.length !== n7.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", As, "[" + n7.join(", ") + "]", "[" + e4.join(", ") + "]");
      for (var t5 = 0; t5 < n7.length && t5 < e4.length; t5++) if (!Ru(e4[t5], n7[t5])) return false;
      return true;
    }
    function Ze(e4, n7, t5, r6, l3, a5) {
      Rs = a5, Ts = n7, Qs = null !== e4 ? e4._debugHookTypes : null, Os = -1, Bs = null !== e4 && e4.type !== n7.type, "[object AsyncFunction]" !== Object.prototype.toString.call(t5) && "[object AsyncGeneratorFunction]" !== Object.prototype.toString.call(t5) || (a5 = c4(Ts), Ps.has(a5) || (Ps.add(a5), console.error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."))), n7.memoizedState = null, n7.updateQueue = null, n7.lanes = 0, Ja.H = null !== e4 && null !== e4.memoizedState ? Gs : null !== Qs ? Ys : qs, Is = a5 = (8 & n7.mode) !== $u;
      var o3 = ji(t5, r6, l3);
      if (Is = false, Ds && (o3 = nn(n7, t5, r6, l3)), a5) {
        U(true);
        try {
          o3 = nn(n7, t5, r6, l3);
        } finally {
          U(false);
        }
      }
      return en(e4, n7), o3;
    }
    function en(e4, n7) {
      n7._debugHookTypes = Qs, null === n7.dependencies ? null !== Ws && (n7.dependencies = { lanes: 0, firstContext: null, _debugThenableState: Ws }) : n7.dependencies._debugThenableState = Ws, Ja.H = $s;
      var t5 = null !== Ns && null !== Ns.next;
      if (Rs = 0, Qs = As = Ls = Ns = Ts = null, Os = -1, null !== e4 && (31457280 & e4.flags) != (31457280 & n7.flags) && console.error("Internal React error: Expected static flag was missing. Please notify the React team."), Us = false, Ms = 0, Ws = null, t5) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      null === e4 || pc || null !== (e4 = e4.dependencies) && ur(e4) && (pc = true), Wi ? (Wi = false, e4 = true) : e4 = false, e4 && (n7 = c4(n7) || "Unknown", Es.has(n7) || Ps.has(n7) || (Es.add(n7), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function nn(e4, n7, t5, r6) {
      Ts = e4;
      var l3 = 0;
      do {
        if (Ds && (Ws = null), Ms = 0, Ds = false, l3 >= js) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (l3 += 1, Bs = false, Ls = Ns = null, null != e4.updateQueue) {
          var a5 = e4.updateQueue;
          a5.lastEffect = null, a5.events = null, a5.stores = null, null != a5.memoCache && (a5.memoCache.index = 0);
        }
        Os = -1, Ja.H = Js, a5 = ji(n7, t5, r6);
      } while (Ds);
      return a5;
    }
    function tn() {
      var e4 = Ja.H, n7 = e4.useState()[0];
      return n7 = "function" == typeof n7.then ? sn(n7) : n7, e4 = e4.useState()[0], (null !== Ns ? Ns.memoizedState : null) !== e4 && (Ts.flags |= 1024), n7;
    }
    function rn() {
      var e4 = 0 !== Fs;
      return Fs = 0, e4;
    }
    function ln(e4, n7, t5) {
      n7.updateQueue = e4.updateQueue, n7.flags = (16 & n7.mode) !== $u ? -201328645 & n7.flags : -2053 & n7.flags, e4.lanes &= ~t5;
    }
    function an(e4) {
      if (Us) {
        for (e4 = e4.memoizedState; null !== e4; ) {
          var n7 = e4.queue;
          null !== n7 && (n7.pending = null), e4 = e4.next;
        }
        Us = false;
      }
      Rs = 0, Qs = Ls = Ns = Ts = null, Os = -1, As = null, Ds = false, Ms = Fs = 0, Ws = null;
    }
    function on3() {
      var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return null === Ls ? Ts.memoizedState = Ls = e4 : Ls = Ls.next = e4, Ls;
    }
    function un() {
      if (null === Ns) {
        var e4 = Ts.alternate;
        e4 = null !== e4 ? e4.memoizedState : null;
      } else e4 = Ns.next;
      var n7 = null === Ls ? Ts.memoizedState : Ls.next;
      if (null !== n7) Ls = n7, Ns = e4;
      else {
        if (null === e4) {
          if (null === Ts.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        e4 = { memoizedState: (Ns = e4).memoizedState, baseState: Ns.baseState, baseQueue: Ns.baseQueue, queue: Ns.queue, next: null }, null === Ls ? Ts.memoizedState = Ls = e4 : Ls = Ls.next = e4;
      }
      return Ls;
    }
    function sn(e4) {
      var n7 = Ms;
      return Ms += 1, null === Ws && (Ws = { didWarnAboutUncachedPromise: false, thenables: [] }), e4 = _e(Ws, e4, n7), n7 = Ts, null === (null === Ls ? n7.memoizedState : Ls.next) && (n7 = n7.alternate, Ja.H = null !== n7 && null !== n7.memoizedState ? Gs : qs), e4;
    }
    function cn(e4) {
      if (null !== e4 && "object" == typeof e4) {
        if ("function" == typeof e4.then) return sn(e4);
        if (e4.$$typeof === ja) return sr(e4);
      }
      throw Error("An unsupported type was passed to use(): " + String(e4));
    }
    function fn(e4) {
      var n7 = null, t5 = Ts.updateQueue;
      if (null !== t5 && (n7 = t5.memoCache), null == n7) {
        var r6 = Ts.alternate;
        null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n7 = { data: r6.data.map(function(e5) {
          return e5.slice();
        }), index: 0 });
      }
      if (null == n7 && (n7 = { data: [], index: 0 }), null === t5 && (t5 = Vs(), Ts.updateQueue = t5), t5.memoCache = n7, void 0 === (t5 = n7.data[n7.index]) || Bs) for (t5 = n7.data[n7.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = qa;
      else t5.length !== e4 && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", t5.length, e4);
      return n7.index++, t5;
    }
    function dn(e4, n7) {
      return "function" == typeof n7 ? n7(e4) : n7;
    }
    function pn(e4, n7, t5) {
      var r6 = on3();
      if (void 0 !== t5) {
        var l3 = t5(n7);
        if (Is) {
          U(true);
          try {
            t5(n7);
          } finally {
            U(false);
          }
        }
      } else l3 = n7;
      return r6.memoizedState = r6.baseState = l3, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l3 }, r6.queue = e4, e4 = e4.dispatch = mt.bind(null, Ts, e4), [r6.memoizedState, e4];
    }
    function mn(e4) {
      return hn(un(), Ns, e4);
    }
    function hn(e4, n7, t5) {
      var r6 = e4.queue;
      if (null === r6) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      r6.lastRenderedReducer = t5;
      var l3 = e4.baseQueue, a5 = r6.pending;
      if (null !== a5) {
        if (null !== l3) {
          var o3 = l3.next;
          l3.next = a5.next, a5.next = o3;
        }
        n7.baseQueue !== l3 && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), n7.baseQueue = l3 = a5, r6.pending = null;
      }
      if (a5 = e4.baseState, null === l3) e4.memoizedState = a5;
      else {
        var u4 = o3 = null, i5 = null, s3 = n7 = l3.next, c5 = false;
        do {
          var f4 = -536870913 & s3.lane;
          if (f4 !== s3.lane ? (df & f4) === f4 : (Rs & f4) === f4) {
            var d3 = s3.revertLane;
            if (0 === d3) null !== i5 && (i5 = i5.next = { lane: 0, revertLane: 0, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }), f4 === di && (c5 = true);
            else {
              if ((Rs & d3) === d3) {
                s3 = s3.next, d3 === di && (c5 = true);
                continue;
              }
              f4 = { lane: 0, revertLane: s3.revertLane, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i5 ? (u4 = i5 = f4, o3 = a5) : i5 = i5.next = f4, Ts.lanes |= d3, _f |= d3;
            }
            f4 = s3.action, Is && t5(a5, f4), a5 = s3.hasEagerState ? s3.eagerState : t5(a5, f4);
          } else d3 = { lane: f4, revertLane: s3.revertLane, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i5 ? (u4 = i5 = d3, o3 = a5) : i5 = i5.next = d3, Ts.lanes |= f4, _f |= f4;
          s3 = s3.next;
        } while (null !== s3 && s3 !== n7);
        if (null === i5 ? o3 = a5 : i5.next = u4, !Ru(a5, e4.memoizedState) && (pc = true, c5 && null !== (t5 = pi))) throw t5;
        e4.memoizedState = a5, e4.baseState = o3, e4.baseQueue = i5, r6.lastRenderedState = a5;
      }
      return null === l3 && (r6.lanes = 0), [e4.memoizedState, r6.dispatch];
    }
    function gn(e4) {
      var n7 = un(), t5 = n7.queue;
      if (null === t5) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      t5.lastRenderedReducer = e4;
      var r6 = t5.dispatch, l3 = t5.pending, a5 = n7.memoizedState;
      if (null !== l3) {
        t5.pending = null;
        var o3 = l3 = l3.next;
        do {
          a5 = e4(a5, o3.action), o3 = o3.next;
        } while (o3 !== l3);
        Ru(a5, n7.memoizedState) || (pc = true), n7.memoizedState = a5, null === n7.baseQueue && (n7.baseState = a5), t5.lastRenderedState = a5;
      }
      return [a5, r6];
    }
    function yn(e4, n7, t5) {
      var r6, l3 = Ts, a5 = on3();
      if (r6 = n7(), cs || (t5 = n7(), Ru(r6, t5) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), cs = true)), null === cf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      return 0 != (60 & df) || vn(l3, n7, r6), a5.memoizedState = r6, t5 = { value: r6, getSnapshot: n7 }, a5.queue = t5, $n(kn.bind(null, l3, t5, e4), [e4]), l3.flags |= 2048, Qn(ks | zs, Sn.bind(null, l3, t5, r6, n7), { destroy: void 0 }, null), r6;
    }
    function bn(e4, n7, t5) {
      var r6 = Ts, l3 = un();
      if (t5 = n7(), !cs) {
        var a5 = n7();
        Ru(t5, a5) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), cs = true);
      }
      (a5 = !Ru((Ns || l3).memoizedState, t5)) && (l3.memoizedState = t5, pc = true), l3 = l3.queue;
      var o3 = kn.bind(null, r6, l3, e4);
      if (Vn(2048, zs, o3, [e4]), l3.getSnapshot !== n7 || a5 || null !== Ls && Ls.memoizedState.tag & ks) {
        if (r6.flags |= 2048, Qn(ks | zs, Sn.bind(null, r6, l3, t5, n7), { destroy: void 0 }, null), null === cf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        0 != (60 & Rs) || vn(r6, n7, t5);
      }
      return t5;
    }
    function vn(e4, n7, t5) {
      e4.flags |= 16384, e4 = { getSnapshot: n7, value: t5 }, null === (n7 = Ts.updateQueue) ? (n7 = Vs(), Ts.updateQueue = n7, n7.stores = [e4]) : null === (t5 = n7.stores) ? n7.stores = [e4] : t5.push(e4);
    }
    function Sn(e4, n7, t5, r6) {
      n7.value = t5, n7.getSnapshot = r6, wn(n7) && xn(e4);
    }
    function kn(e4, n7, t5) {
      return t5(function() {
        wn(n7) && xn(e4);
      });
    }
    function wn(e4) {
      var n7 = e4.getSnapshot;
      e4 = e4.value;
      try {
        var t5 = n7();
        return !Ru(e4, t5);
      } catch (e5) {
        return true;
      }
    }
    function xn(e4) {
      var n7 = $(e4, 2);
      null !== n7 && Cl(n7, e4, 2);
    }
    function zn(e4) {
      var n7 = on3();
      if ("function" == typeof e4) {
        var t5 = e4;
        if (e4 = t5(), Is) {
          U(true);
          try {
            t5();
          } finally {
            U(false);
          }
        }
      }
      return n7.memoizedState = n7.baseState = e4, n7.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: dn, lastRenderedState: e4 }, n7;
    }
    function Cn(e4) {
      var n7 = (e4 = zn(e4)).queue, t5 = ht.bind(null, Ts, n7);
      return n7.dispatch = t5, [e4.memoizedState, t5];
    }
    function En(e4) {
      var n7 = on3();
      n7.memoizedState = n7.baseState = e4;
      var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
      return n7.queue = t5, n7 = yt.bind(null, Ts, true, t5), t5.dispatch = n7, [e4, n7];
    }
    function Pn(e4, n7) {
      return _n(un(), 0, e4, n7);
    }
    function _n(e4, n7, t5, r6) {
      return e4.baseState = t5, hn(e4, Ns, "function" == typeof r6 ? r6 : dn);
    }
    function Rn(e4, n7) {
      var t5 = un();
      return null !== Ns ? _n(t5, 0, e4, n7) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
    }
    function Tn(e4, n7, t5, r6, l3) {
      if (bt(e4)) throw Error("Cannot update form state while rendering.");
      if (null !== (e4 = n7.action)) {
        var a5 = { payload: l3, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e5) {
          a5.listeners.push(e5);
        } };
        null !== Ja.T ? t5(true) : a5.isTransition = false, r6(a5), null === (t5 = n7.pending) ? (a5.next = n7.pending = a5, Nn(n7, a5)) : (a5.next = t5.next, n7.pending = t5.next = a5);
      }
    }
    function Nn(e4, n7) {
      var t5 = n7.action, r6 = n7.payload, l3 = e4.state;
      if (n7.isTransition) {
        var a5 = Ja.T, o3 = {};
        Ja.T = o3, Ja.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var u4 = t5(l3, r6), i5 = Ja.S;
          null !== i5 && i5(o3, u4), Ln(e4, n7, u4);
        } catch (t6) {
          Dn(e4, n7, t6);
        } finally {
          Ja.T = a5, null === a5 && o3._updatedFibers && (e4 = o3._updatedFibers.size, o3._updatedFibers.clear(), 10 < e4 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else try {
        Ln(e4, n7, o3 = t5(l3, r6));
      } catch (t6) {
        Dn(e4, n7, t6);
      }
    }
    function Ln(e4, n7, t5) {
      null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? (t5.then(function(t6) {
        Un(e4, n7, t6);
      }, function(t6) {
        return Dn(e4, n7, t6);
      }), n7.isTransition || console.error("An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`")) : Un(e4, n7, t5);
    }
    function Un(e4, n7, t5) {
      n7.status = "fulfilled", n7.value = t5, In(n7), e4.state = t5, null !== (n7 = e4.pending) && ((t5 = n7.next) === n7 ? e4.pending = null : (t5 = t5.next, n7.next = t5, Nn(e4, t5)));
    }
    function Dn(e4, n7, t5) {
      var r6 = e4.pending;
      if (e4.pending = null, null !== r6) {
        r6 = r6.next;
        do {
          n7.status = "rejected", n7.reason = t5, In(n7), n7 = n7.next;
        } while (n7 !== r6);
      }
      e4.action = null;
    }
    function In(e4) {
      e4 = e4.listeners;
      for (var n7 = 0; n7 < e4.length; n7++) (0, e4[n7])();
    }
    function Fn(e4, n7) {
      return n7;
    }
    function Mn(e4, n7) {
      var t5, r6, l3;
      (t5 = on3()).memoizedState = t5.baseState = n7, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Fn, lastRenderedState: n7 }, t5.queue = r6, t5 = ht.bind(null, Ts, r6), r6.dispatch = t5, r6 = zn(false);
      var a5 = yt.bind(null, Ts, false, r6.queue);
      return l3 = { state: n7, dispatch: null, action: e4, pending: null }, (r6 = on3()).queue = l3, t5 = Tn.bind(null, Ts, l3, a5, t5), l3.dispatch = t5, r6.memoizedState = e4, [n7, t5, false];
    }
    function Wn(e4) {
      return Hn(un(), Ns, e4);
    }
    function Hn(e4, n7, t5) {
      n7 = hn(e4, n7, Fn)[0], e4 = mn(dn)[0], n7 = "object" == typeof n7 && null !== n7 && "function" == typeof n7.then ? sn(n7) : n7;
      var r6 = un(), l3 = r6.queue, a5 = l3.dispatch;
      return t5 !== r6.memoizedState && (Ts.flags |= 2048, Qn(ks | zs, jn.bind(null, l3, t5), { destroy: void 0 }, null)), [n7, a5, e4];
    }
    function jn(e4, n7) {
      e4.action = n7;
    }
    function An(e4) {
      var n7 = un(), t5 = Ns;
      if (null !== t5) return Hn(n7, t5, e4);
      un(), n7 = n7.memoizedState;
      var r6 = (t5 = un()).queue.dispatch;
      return t5.memoizedState = e4, [n7, r6, false];
    }
    function Qn(e4, n7, t5, r6) {
      return e4 = { tag: e4, create: n7, inst: t5, deps: r6, next: null }, null === (n7 = Ts.updateQueue) && (n7 = Vs(), Ts.updateQueue = n7), null === (t5 = n7.lastEffect) ? n7.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n7.lastEffect = e4), e4;
    }
    function On(e4) {
      return e4 = { current: e4 }, on3().memoizedState = e4;
    }
    function Bn(e4, n7, t5, r6) {
      var l3 = on3();
      Ts.flags |= e4, l3.memoizedState = Qn(ks | n7, t5, { destroy: void 0 }, void 0 === r6 ? null : r6);
    }
    function Vn(e4, n7, t5, r6) {
      var l3 = un();
      r6 = void 0 === r6 ? null : r6;
      var a5 = l3.memoizedState.inst;
      null !== Ns && null !== r6 && Xe(r6, Ns.memoizedState.deps) ? l3.memoizedState = Qn(n7, t5, a5, r6) : (Ts.flags |= e4, l3.memoizedState = Qn(ks | n7, t5, a5, r6));
    }
    function $n(e4, n7) {
      (16 & Ts.mode) !== $u && (64 & Ts.mode) === $u ? Bn(142608384, zs, e4, n7) : Bn(8390656, zs, e4, n7);
    }
    function qn(e4, n7) {
      var t5 = 4194308;
      return (16 & Ts.mode) !== $u && (t5 |= 67108864), Bn(t5, xs, e4, n7);
    }
    function Yn(e4, n7) {
      if ("function" == typeof n7) {
        e4 = e4();
        var t5 = n7(e4);
        return function() {
          "function" == typeof t5 ? t5() : n7(null);
        };
      }
      if (null != n7) return n7.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(n7).join(", ") + "}"), e4 = e4(), n7.current = e4, function() {
        n7.current = null;
      };
    }
    function Gn(e4, n7, t5) {
      "function" != typeof n7 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n7 ? typeof n7 : "null"), t5 = null != t5 ? t5.concat([e4]) : null;
      var r6 = 4194308;
      (16 & Ts.mode) !== $u && (r6 |= 67108864), Bn(r6, xs, Yn.bind(null, n7, e4), t5);
    }
    function Jn(e4, n7, t5) {
      "function" != typeof n7 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n7 ? typeof n7 : "null"), t5 = null != t5 ? t5.concat([e4]) : null, Vn(4, xs, Yn.bind(null, n7, e4), t5);
    }
    function Kn(e4, n7) {
      return on3().memoizedState = [e4, void 0 === n7 ? null : n7], e4;
    }
    function Xn(e4, n7) {
      var t5 = un();
      n7 = void 0 === n7 ? null : n7;
      var r6 = t5.memoizedState;
      return null !== n7 && Xe(n7, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n7], e4);
    }
    function Zn(e4, n7) {
      var t5 = on3();
      n7 = void 0 === n7 ? null : n7;
      var r6 = e4();
      if (Is) {
        U(true);
        try {
          e4();
        } finally {
          U(false);
        }
      }
      return t5.memoizedState = [r6, n7], r6;
    }
    function et(e4, n7) {
      var t5 = un();
      n7 = void 0 === n7 ? null : n7;
      var r6 = t5.memoizedState;
      if (null !== n7 && Xe(n7, r6[1])) return r6[0];
      if (r6 = e4(), Is) {
        U(true);
        try {
          e4();
        } finally {
          U(false);
        }
      }
      return t5.memoizedState = [r6, n7], r6;
    }
    function nt(e4, n7) {
      return lt(on3(), e4, n7);
    }
    function tt(e4, n7) {
      return at(un(), Ns.memoizedState, e4, n7);
    }
    function rt(e4, n7) {
      var t5 = un();
      return null === Ns ? lt(t5, e4, n7) : at(t5, Ns.memoizedState, e4, n7);
    }
    function lt(e4, n7, t5) {
      return void 0 === t5 || 0 != (1073741824 & Rs) ? e4.memoizedState = n7 : (e4.memoizedState = t5, e4 = zl(), Ts.lanes |= e4, _f |= e4, t5);
    }
    function at(e4, n7, t5, r6) {
      return Ru(t5, n7) ? t5 : null !== ps.current ? (e4 = lt(e4, t5, r6), Ru(e4, n7) || (pc = true), e4) : 0 == (42 & Rs) ? (pc = true, e4.memoizedState = t5) : (e4 = zl(), Ts.lanes |= e4, _f |= e4, n7);
    }
    function ot(e4, n7, t5, r6, l3) {
      var a5 = xo();
      wo(0 !== a5 && 8 > a5 ? a5 : 8);
      var o3, u4, i5, s3 = Ja.T, c5 = {};
      Ja.T = c5, yt(e4, false, n7, t5), c5._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var f4 = l3(), d3 = Ja.S;
        null !== d3 && d3(c5, f4), null !== f4 && "object" == typeof f4 && "function" == typeof f4.then ? gt(e4, n7, (o3 = r6, u4 = [], i5 = { status: "pending", value: null, reason: null, then: function(e5) {
          u4.push(e5);
        } }, f4.then(function() {
          i5.status = "fulfilled", i5.value = o3;
          for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o3);
        }, function(e5) {
          for (i5.status = "rejected", i5.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
        }), i5), xl(e4)) : gt(e4, n7, r6, xl(e4));
      } catch (t6) {
        gt(e4, n7, { then: function() {
        }, status: "rejected", reason: t6 }, xl(e4));
      } finally {
        wo(a5), Ja.T = s3, null === s3 && c5._updatedFibers && (e4 = c5._updatedFibers.size, c5._updatedFibers.clear(), 10 < e4 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function ut() {
      var e4 = zn(false);
      return e4 = ot.bind(null, Ts, e4.queue, true, false), on3().memoizedState = e4, [false, e4];
    }
    function it() {
      var e4 = mn(dn)[0], n7 = un().memoizedState;
      return ["boolean" == typeof e4 ? e4 : sn(e4), n7];
    }
    function st() {
      var e4 = gn(dn)[0], n7 = un().memoizedState;
      return ["boolean" == typeof e4 ? e4 : sn(e4), n7];
    }
    function ct() {
      return sr(Uo);
    }
    function ft() {
      var e4 = on3(), n7 = cf.identifierPrefix;
      return n7 = ":" + n7 + "r" + (Hs++).toString(32) + ":", e4.memoizedState = n7;
    }
    function dt() {
      return on3().memoizedState = pt.bind(null, Ts);
    }
    function pt(e4, n7) {
      for (var t5 = e4.return; null !== t5; ) {
        switch (t5.tag) {
          case 24:
          case 3:
            var r6 = xl(t5), l3 = ye(t5, e4 = ge(r6), r6);
            return null !== l3 && (Cl(l3, t5, r6), be(l3, t5, r6)), t5 = dr(), null != n7 && null !== l3 && console.error("The seed argument is not enabled outside experimental channels."), void (e4.payload = { cache: t5 });
        }
        t5 = t5.return;
      }
    }
    function mt(e4, n7, t5, r6) {
      "function" == typeof r6 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), t5 = { lane: r6 = xl(e4), revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null }, bt(e4) ? vt(n7, t5) : null !== (t5 = V(e4, n7, t5, r6)) && (Cl(t5, e4, r6), St(t5, n7, r6));
    }
    function ht(e4, n7, t5, r6) {
      "function" == typeof r6 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), gt(e4, n7, t5, r6 = xl(e4));
    }
    function gt(e4, n7, t5, r6) {
      var l3 = { lane: r6, revertLane: 0, action: t5, hasEagerState: false, eagerState: null, next: null };
      if (bt(e4)) vt(n7, l3);
      else {
        var a5 = e4.alternate;
        if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n7.lastRenderedReducer)) {
          var o3 = Ja.H;
          Ja.H = Xs;
          try {
            var u4 = n7.lastRenderedState, i5 = a5(u4, t5);
            if (l3.hasEagerState = true, l3.eagerState = i5, Ru(i5, u4)) return B(e4, n7, l3, 0), null === cf && O(), false;
          } catch (e5) {
          } finally {
            Ja.H = o3;
          }
        }
        if (null !== (t5 = V(e4, n7, l3, r6))) return Cl(t5, e4, r6), St(t5, n7, r6), true;
      }
      return false;
    }
    function yt(e4, n7, t5, r6) {
      if (null === Ja.T && 0 === di && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."), r6 = { lane: 2, revertLane: de(), action: r6, hasEagerState: false, eagerState: null, next: null }, bt(e4)) {
        if (n7) throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else null !== (n7 = V(e4, t5, r6, 2)) && Cl(n7, e4, 2);
    }
    function bt(e4) {
      var n7 = e4.alternate;
      return e4 === Ts || null !== n7 && n7 === Ts;
    }
    function vt(e4, n7) {
      Ds = Us = true;
      var t5 = e4.pending;
      null === t5 ? n7.next = n7 : (n7.next = t5.next, t5.next = n7), e4.pending = n7;
    }
    function St(e4, n7, t5) {
      if (0 != (4194176 & t5)) {
        var r6 = n7.lanes;
        t5 |= r6 &= e4.pendingLanes, n7.lanes = t5, R(e4, t5);
      }
    }
    function kt(e4) {
      if (null !== e4 && "function" != typeof e4) {
        var n7 = String(e4);
        cc.has(n7) || (cc.add(n7), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", e4));
      }
    }
    function wt(e4, n7, t5, r6) {
      var l3 = e4.memoizedState, a5 = t5(r6, l3);
      if (8 & e4.mode) {
        U(true);
        try {
          a5 = t5(r6, l3);
        } finally {
          U(false);
        }
      }
      void 0 === a5 && (n7 = s2(n7) || "Component", oc.has(n7) || (oc.add(n7), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", n7))), l3 = null == a5 ? l3 : Na({}, l3, a5), e4.memoizedState = l3, 0 === e4.lanes && (e4.updateQueue.baseState = l3);
    }
    function xt(e4, n7, t5, r6, l3, a5, o3) {
      var u4 = e4.stateNode;
      if ("function" == typeof u4.shouldComponentUpdate) {
        if (t5 = u4.shouldComponentUpdate(r6, a5, o3), 8 & e4.mode) {
          U(true);
          try {
            t5 = u4.shouldComponentUpdate(r6, a5, o3);
          } finally {
            U(false);
          }
        }
        return void 0 === t5 && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", s2(n7) || "Component"), t5;
      }
      return !(n7.prototype && n7.prototype.isPureReactComponent && Ce(t5, r6) && Ce(l3, a5));
    }
    function zt(e4, n7, t5, r6) {
      var l3 = n7.state;
      "function" == typeof n7.componentWillReceiveProps && n7.componentWillReceiveProps(t5, r6), "function" == typeof n7.UNSAFE_componentWillReceiveProps && n7.UNSAFE_componentWillReceiveProps(t5, r6), n7.state !== l3 && (e4 = c4(e4) || "Component", nc.has(e4) || (nc.add(e4), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", e4)), fc.enqueueReplaceState(n7, n7.state, null));
    }
    function Ct(e4, n7) {
      var t5 = n7;
      if ("ref" in n7) for (var r6 in t5 = {}, n7) "ref" !== r6 && (t5[r6] = n7[r6]);
      if (e4 = e4.defaultProps) for (var l3 in t5 === n7 && (t5 = Na({}, t5)), e4) void 0 === t5[l3] && (t5[l3] = e4[l3]);
      return t5;
    }
    function Et(e4, n7) {
      try {
        n7.source && c4(n7.source);
        var t5 = n7.value;
        null !== Ja.actQueue ? Ja.thrownErrors.push(t5) : (0, e4.onUncaughtError)(t5, { componentStack: n7.stack });
      } catch (e5) {
        setTimeout(function() {
          throw e5;
        });
      }
    }
    function Pt(e4, n7, t5) {
      try {
        t5.source && c4(t5.source), c4(n7), (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n7.tag ? n7.stateNode : null });
      } catch (e5) {
        setTimeout(function() {
          throw e5;
        });
      }
    }
    function _t(e4, n7, t5) {
      return (t5 = ge(t5)).tag = yi, t5.payload = { element: null }, t5.callback = function() {
        y3(n7.source, Et, e4, n7);
      }, t5;
    }
    function Rt(e4) {
      return (e4 = ge(e4)).tag = yi, e4;
    }
    function Tt(e4, n7, t5, r6) {
      var l3 = t5.type.getDerivedStateFromError;
      if ("function" == typeof l3) {
        var a5 = r6.value;
        e4.payload = function() {
          return l3(a5);
        }, e4.callback = function() {
          y3(r6.source, Pt, n7, t5, r6);
        };
      }
      var o3 = t5.stateNode;
      null !== o3 && "function" == typeof o3.componentDidCatch && (e4.callback = function() {
        y3(r6.source, Pt, n7, t5, r6), "function" != typeof l3 && (null === Af ? Af = /* @__PURE__ */ new Set([this]) : Af.add(this)), Yi(this, r6), "function" == typeof l3 || 0 == (2 & t5.lanes) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", c4(t5) || "Unknown");
      });
    }
    function Nt(e4, n7, t5, r6) {
      n7.child = null === e4 ? ds(n7, null, t5, r6) : fs2(n7, e4.child, t5, r6);
    }
    function Lt(e4, n7, t5, r6, l3) {
      t5 = t5.render;
      var a5 = n7.ref;
      if ("ref" in r6) {
        var o3 = {};
        for (var u4 in r6) "ref" !== u4 && (o3[u4] = r6[u4]);
      } else o3 = r6;
      return ir(n7), r6 = Ze(e4, n7, t5, o3, a5, l3), u4 = rn(), null === e4 || pc ? (n7.flags |= 1, Nt(e4, n7, r6, l3), n7.child) : (ln(e4, n7, l3), Xt(e4, n7, l3));
    }
    function Ut(e4, n7, t5, r6, l3) {
      if (null === e4) {
        var a5 = t5.type;
        return "function" != typeof a5 || ca(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = pa(t5.type, null, r6, n7, n7.mode, l3)).ref = n7.ref, e4.return = n7, n7.child = e4) : (t5 = a5, n7.tag = 15, n7.type = t5, At(n7, a5), Dt(e4, n7, t5, r6, l3));
      }
      if (a5 = e4.child, !Zt(e4, l3)) {
        var o3 = a5.memoizedProps;
        if ((t5 = null !== (t5 = t5.compare) ? t5 : Ce)(o3, r6) && e4.ref === n7.ref) return Xt(e4, n7, l3);
      }
      return n7.flags |= 1, (e4 = fa(a5, r6)).ref = n7.ref, e4.return = n7, n7.child = e4;
    }
    function Dt(e4, n7, t5, r6, l3) {
      if (null !== e4) {
        var a5 = e4.memoizedProps;
        if (Ce(a5, r6) && e4.ref === n7.ref && n7.type === e4.type) {
          if (pc = false, n7.pendingProps = r6 = a5, !Zt(e4, l3)) return n7.lanes = e4.lanes, Xt(e4, n7, l3);
          0 != (131072 & e4.flags) && (pc = true);
        }
      }
      return Wt(e4, n7, t5, r6, l3);
    }
    function It(e4, n7, t5) {
      var r6 = n7.pendingProps, l3 = r6.children, a5 = 0 != (2 & n7.stateNode._pendingVisibility), o3 = null !== e4 ? e4.memoizedState : null;
      if (Mt(e4, n7), "hidden" === r6.mode || a5) {
        if (0 != (128 & n7.flags)) {
          if (r6 = null !== o3 ? o3.baseLanes | t5 : t5, null !== e4) {
            for (l3 = n7.child = e4.child, a5 = 0; null !== l3; ) a5 = a5 | l3.lanes | l3.childLanes, l3 = l3.sibling;
            n7.childLanes = a5 & ~r6;
          } else n7.childLanes = 0, n7.child = null;
          return Ft(e4, n7, r6, t5);
        }
        if (0 == (536870912 & t5)) return n7.lanes = n7.childLanes = 536870912, Ft(e4, n7, null !== o3 ? o3.baseLanes | t5 : t5, t5);
        n7.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && gr(n7, null !== o3 ? o3.cachePool : null), null !== o3 ? He(n7, o3) : je(n7), Oe(n7);
      } else null !== o3 ? (gr(n7, o3.cachePool), He(n7, o3), Be(n7), n7.memoizedState = null) : (null !== e4 && gr(n7, null), je(n7), Be(n7));
      return Nt(e4, n7, l3, t5), n7.child;
    }
    function Ft(e4, n7, t5, r6) {
      var l3 = hr();
      return l3 = null === l3 ? null : { parent: Uc._currentValue2, pool: l3 }, n7.memoizedState = { baseLanes: t5, cachePool: l3 }, null !== e4 && gr(n7, null), je(n7), Oe(n7), null !== e4 && or(e4, n7, r6, true), null;
    }
    function Mt(e4, n7) {
      var t5 = n7.ref;
      if (null === t5) null !== e4 && null !== e4.ref && (n7.flags |= 2097664);
      else {
        if ("function" != typeof t5 && "object" != typeof t5) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        null !== e4 && e4.ref === t5 || (n7.flags |= 2097664);
      }
    }
    function Wt(e4, n7, t5, r6, l3) {
      if (t5.prototype && "function" == typeof t5.prototype.render) {
        var a5 = s2(t5) || "Unknown";
        mc[a5] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", a5, a5), mc[a5] = true);
      }
      return 8 & n7.mode && xi.recordLegacyContextWarning(n7, null), null === e4 && (At(n7, n7.type), t5.contextTypes && (a5 = s2(t5) || "Unknown", gc[a5] || (gc[a5] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", a5)))), ir(n7), t5 = Ze(e4, n7, t5, r6, void 0, l3), r6 = rn(), null === e4 || pc ? (n7.flags |= 1, Nt(e4, n7, t5, l3), n7.child) : (ln(e4, n7, l3), Xt(e4, n7, l3));
    }
    function Ht(e4, n7, t5, r6, l3, a5) {
      return ir(n7), Os = -1, Bs = null !== e4 && e4.type !== n7.type, n7.updateQueue = null, t5 = nn(n7, r6, t5, l3), en(e4, n7), r6 = rn(), null === e4 || pc ? (n7.flags |= 1, Nt(e4, n7, t5, a5), n7.child) : (ln(e4, n7, a5), Xt(e4, n7, a5));
    }
    function jt(e4, n7, t5, r6, l3) {
      var a5, o3, u4;
      if (ir(n7), null === n7.stateNode) {
        if (o3 = su, a5 = t5.contextType, "contextType" in t5 && null !== a5 && (void 0 === a5 || a5.$$typeof !== ja) && !sc.has(t5) && (sc.add(t5), u4 = void 0 === a5 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" != typeof a5 ? " However, it is set to a " + typeof a5 + "." : a5.$$typeof === Ha ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(a5).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", s2(t5) || "Component", u4)), "object" == typeof a5 && null !== a5 && (o3 = sr(a5)), a5 = new t5(r6, o3), 8 & n7.mode) {
          U(true);
          try {
            a5 = new t5(r6, o3);
          } finally {
            U(false);
          }
        }
        if (o3 = n7.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = fc, n7.stateNode = a5, a5._reactInternals = n7, a5._reactInternalInstance = ec, "function" == typeof t5.getDerivedStateFromProps && null === o3 && (o3 = s2(t5) || "Component", tc.has(o3) || (tc.add(o3), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", o3, null === a5.state ? "null" : "undefined", o3))), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate) {
          var i5 = u4 = o3 = null;
          if ("function" == typeof a5.componentWillMount && true !== a5.componentWillMount.__suppressDeprecationWarning ? o3 = "componentWillMount" : "function" == typeof a5.UNSAFE_componentWillMount && (o3 = "UNSAFE_componentWillMount"), "function" == typeof a5.componentWillReceiveProps && true !== a5.componentWillReceiveProps.__suppressDeprecationWarning ? u4 = "componentWillReceiveProps" : "function" == typeof a5.UNSAFE_componentWillReceiveProps && (u4 = "UNSAFE_componentWillReceiveProps"), "function" == typeof a5.componentWillUpdate && true !== a5.componentWillUpdate.__suppressDeprecationWarning ? i5 = "componentWillUpdate" : "function" == typeof a5.UNSAFE_componentWillUpdate && (i5 = "UNSAFE_componentWillUpdate"), null !== o3 || null !== u4 || null !== i5) {
            a5 = s2(t5) || "Component";
            var f4 = "function" == typeof t5.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            lc.has(a5) || (lc.add(a5), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", a5, f4, null !== o3 ? "\n  " + o3 : "", null !== u4 ? "\n  " + u4 : "", null !== i5 ? "\n  " + i5 : ""));
          }
        }
        a5 = n7.stateNode, o3 = s2(t5) || "Component", a5.render || (t5.prototype && "function" == typeof t5.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", o3) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", o3)), !a5.getInitialState || a5.getInitialState.isReactClassApproved || a5.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", o3), a5.getDefaultProps && !a5.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", o3), a5.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", o3), t5.childContextTypes && !ic.has(t5) && (ic.add(t5), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", o3)), t5.contextTypes && !uc.has(t5) && (uc.add(t5), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", o3)), "function" == typeof a5.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", o3), t5.prototype && t5.prototype.isPureReactComponent && void 0 !== a5.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", s2(t5) || "A pure component"), "function" == typeof a5.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", o3), "function" == typeof a5.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", o3), "function" == typeof a5.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", o3), "function" == typeof a5.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", o3), u4 = a5.props !== r6, void 0 !== a5.props && u4 && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", o3), a5.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", o3, o3), "function" != typeof a5.getSnapshotBeforeUpdate || "function" == typeof a5.componentDidUpdate || rc.has(t5) || (rc.add(t5), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", s2(t5))), "function" == typeof a5.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof a5.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof t5.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", o3), (u4 = a5.state) && ("object" != typeof u4 || lo(u4)) && console.error("%s.state: must be set to an object or null", o3), "function" == typeof a5.getChildContext && "object" != typeof t5.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", o3), (a5 = n7.stateNode).props = r6, a5.state = n7.memoizedState, a5.refs = {}, me(n7), o3 = t5.contextType, a5.context = "object" == typeof o3 && null !== o3 ? sr(o3) : su, a5.state === r6 && (o3 = s2(t5) || "Component", ac.has(o3) || (ac.add(o3), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", o3))), 8 & n7.mode && xi.recordLegacyContextWarning(n7, a5), xi.recordUnsafeLifecycleWarnings(n7, a5), a5.state = n7.memoizedState, "function" == typeof (o3 = t5.getDerivedStateFromProps) && (wt(n7, t5, o3, r6), a5.state = n7.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o3 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o3 !== a5.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", c4(n7) || "Component"), fc.enqueueReplaceState(a5, a5.state, null)), ke(n7, r6, a5, l3), Se(), a5.state = n7.memoizedState), "function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== $u && (n7.flags |= 67108864), a5 = true;
      } else if (null === e4) {
        a5 = n7.stateNode;
        var d3 = n7.memoizedProps;
        u4 = Ct(t5, d3), a5.props = u4;
        var p4 = a5.context;
        i5 = t5.contextType, o3 = su, "object" == typeof i5 && null !== i5 && (o3 = sr(i5)), i5 = "function" == typeof (f4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate, d3 = n7.pendingProps !== d3, i5 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (d3 || p4 !== o3) && zt(n7, a5, r6, o3), bi = false;
        var m2 = n7.memoizedState;
        a5.state = m2, ke(n7, r6, a5, l3), Se(), p4 = n7.memoizedState, d3 || m2 !== p4 || bi ? ("function" == typeof f4 && (wt(n7, t5, f4, r6), p4 = n7.memoizedState), (u4 = bi || xt(n7, t5, u4, r6, m2, p4, o3)) ? (i5 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== $u && (n7.flags |= 67108864)) : ("function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== $u && (n7.flags |= 67108864), n7.memoizedProps = r6, n7.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = o3, a5 = u4) : ("function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== $u && (n7.flags |= 67108864), a5 = false);
      } else {
        a5 = n7.stateNode, he(e4, n7), i5 = Ct(t5, o3 = n7.memoizedProps), a5.props = i5, f4 = n7.pendingProps, m2 = a5.context, p4 = t5.contextType, u4 = su, "object" == typeof p4 && null !== p4 && (u4 = sr(p4)), (p4 = "function" == typeof (d3 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o3 !== f4 || m2 !== u4) && zt(n7, a5, r6, u4), bi = false, m2 = n7.memoizedState, a5.state = m2, ke(n7, r6, a5, l3), Se();
        var h4 = n7.memoizedState;
        o3 !== f4 || m2 !== h4 || bi || null !== e4 && null !== e4.dependencies && ur(e4.dependencies) ? ("function" == typeof d3 && (wt(n7, t5, d3, r6), h4 = n7.memoizedState), (i5 = bi || xt(n7, t5, i5, r6, m2, h4, u4) || null !== e4 && null !== e4.dependencies && ur(e4.dependencies)) ? (p4 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, h4, u4), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, h4, u4)), "function" == typeof a5.componentDidUpdate && (n7.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n7.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 1024), n7.memoizedProps = r6, n7.memoizedState = h4), a5.props = r6, a5.state = h4, a5.context = u4, a5 = i5) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 1024), a5 = false);
      }
      if (u4 = a5, Mt(e4, n7), o3 = 0 != (128 & n7.flags), u4 || o3) {
        if (u4 = n7.stateNode, Ja.getCurrentStack = null === n7 ? null : g3, ro = false, to = n7, o3 && "function" != typeof t5.getDerivedStateFromError) t5 = null, Xu = -1;
        else if (t5 = Qi(u4), 8 & n7.mode) {
          U(true);
          try {
            Qi(u4);
          } finally {
            U(false);
          }
        }
        n7.flags |= 1, null !== e4 && o3 ? (n7.child = fs2(n7, e4.child, null, l3), n7.child = fs2(n7, null, t5, l3)) : Nt(e4, n7, t5, l3), n7.memoizedState = u4.state, e4 = n7.child;
      } else e4 = Xt(e4, n7, l3);
      return l3 = n7.stateNode, a5 && l3.props !== r6 && (bc || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", c4(n7) || "a component"), bc = true), e4;
    }
    function At(e4, n7) {
      n7 && n7.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", n7.displayName || n7.name || "Component"), "function" == typeof n7.getDerivedStateFromProps && (e4 = s2(n7) || "Unknown", yc[e4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", e4), yc[e4] = true)), "object" == typeof n7.contextType && null !== n7.contextType && (n7 = s2(n7) || "Unknown", hc[n7] || (console.error("%s: Function components do not support contextType.", n7), hc[n7] = true));
    }
    function Qt(e4) {
      return { baseLanes: e4, cachePool: yr() };
    }
    function Ot(e4, n7, t5) {
      return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n7 && (e4 |= Nf), e4;
    }
    function Bt(e4, n7, t5) {
      var r6, l3, a5, o3, u4 = n7.pendingProps, i5 = false, s3 = 0 != (128 & n7.flags);
      if ((r6 = s3) || (r6 = (null === e4 || null !== e4.memoizedState) && 0 != (vs.current & bs)), r6 && (i5 = true, n7.flags &= -129), r6 = 0 != (32 & n7.flags), n7.flags &= -33, null === e4) return l3 = u4.children, u4 = u4.fallback, i5 ? (Be(n7), l3 = $t({ mode: "hidden", children: l3 }, i5 = n7.mode), u4 = ha(u4, i5, t5, null), l3.return = n7, u4.return = n7, l3.sibling = u4, n7.child = l3, (i5 = n7.child).memoizedState = Qt(t5), i5.childLanes = Ot(e4, r6, t5), n7.memoizedState = kc, u4) : (Qe(n7), Vt(n7, l3));
      if (null !== (a5 = e4.memoizedState) && null !== (l3 = a5.dehydrated)) {
        if (s3) 256 & n7.flags ? (Qe(n7), n7.flags &= -257, n7 = qt(e4, n7, t5)) : null !== n7.memoizedState ? (Be(n7), n7.child = e4.child, n7.flags |= 128, n7 = null) : (Be(n7), i5 = u4.fallback, l3 = n7.mode, u4 = $t({ mode: "visible", children: u4.children }, l3), (i5 = ha(i5, l3, t5, null)).flags |= 2, u4.return = n7, i5.return = n7, u4.sibling = i5, n7.child = u4, fs2(n7, e4.child, null, t5), (u4 = n7.child).memoizedState = Qt(t5), u4.childLanes = Ot(e4, r6, t5), n7.memoizedState = kc, n7 = i5);
        else if (Qe(n7), Ko(l3)) r6 = (l3 = Xo(l3)).digest, i5 = l3.message, u4 = l3.stack, l3 = l3.componentStack, (i5 = i5 ? Error(i5) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")).stack = u4 || "", i5.digest = r6, u4 = { value: i5, source: null, stack: r6 = void 0 === l3 ? null : l3 }, "string" == typeof r6 && Tu.set(i5, u4), o3 = u4, null === Vu ? Vu = [o3] : Vu.push(o3), n7 = qt(e4, n7, t5);
        else if (pc || or(e4, n7, t5, false), r6 = 0 != (t5 & e4.childLanes), pc || r6) {
          if (null !== (r6 = cf)) {
            if (0 != (42 & (u4 = t5 & -t5))) u4 = 1;
            else switch (u4) {
              case 2:
                u4 = 1;
                break;
              case 8:
                u4 = 4;
                break;
              case 32:
                u4 = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                u4 = 64;
                break;
              case 268435456:
                u4 = 134217728;
                break;
              default:
                u4 = 0;
            }
            if (0 !== (u4 = 0 != (u4 & (r6.suspendedLanes | t5)) ? 0 : u4) && u4 !== a5.retryLane) throw a5.retryLane = u4, $(e4, u4), Cl(r6, e4, u4), dc;
          }
          Jo(l3) || Ml(), n7 = qt(e4, n7, t5);
        } else Jo(l3) ? (n7.flags |= 128, n7.child = e4.child, n7 = ta.bind(null, e4), Zo(l3, n7), n7 = null) : (e4 = a5.treeContext, (n7 = Vt(n7, u4.children)).flags |= 4096);
        return n7;
      }
      return i5 ? (Be(n7), i5 = u4.fallback, l3 = n7.mode, s3 = (a5 = e4.child).sibling, (u4 = fa(a5, { mode: "hidden", children: u4.children })).subtreeFlags = 31457280 & a5.subtreeFlags, null !== s3 ? i5 = fa(s3, i5) : (i5 = ha(i5, l3, t5, null)).flags |= 2, i5.return = n7, u4.return = n7, u4.sibling = i5, n7.child = u4, u4 = i5, i5 = n7.child, null === (l3 = e4.child.memoizedState) ? l3 = Qt(t5) : (null !== (a5 = l3.cachePool) ? (s3 = Uc._currentValue2, a5 = a5.parent !== s3 ? { parent: s3, pool: s3 } : a5) : a5 = yr(), l3 = { baseLanes: l3.baseLanes | t5, cachePool: a5 }), i5.memoizedState = l3, i5.childLanes = Ot(e4, r6, t5), n7.memoizedState = kc, u4) : (Qe(n7), e4 = (t5 = e4.child).sibling, (t5 = fa(t5, { mode: "visible", children: u4.children })).return = n7, t5.sibling = null, null !== e4 && (null === (r6 = n7.deletions) ? (n7.deletions = [e4], n7.flags |= 16) : r6.push(e4)), n7.child = t5, n7.memoizedState = null, t5);
    }
    function Vt(e4, n7) {
      return (n7 = $t({ mode: "visible", children: n7 }, e4.mode)).return = e4, e4.child = n7;
    }
    function $t(e4, n7) {
      return ga(e4, n7, 0, null);
    }
    function qt(e4, n7, t5) {
      return fs2(n7, e4.child, null, t5), (e4 = Vt(n7, n7.pendingProps.children)).flags |= 2, n7.memoizedState = null, e4;
    }
    function Yt(e4, n7, t5) {
      e4.lanes |= n7;
      var r6 = e4.alternate;
      null !== r6 && (r6.lanes |= n7), lr(e4.return, n7, t5);
    }
    function Gt(e4, n7) {
      var t5 = lo(e4);
      return e4 = !t5 && "function" == typeof i4(e4), !t5 && !e4 || (t5 = t5 ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", t5, n7, t5), false);
    }
    function Jt(e4, n7, t5, r6, l3) {
      var a5 = e4.memoizedState;
      null === a5 ? e4.memoizedState = { isBackwards: n7, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l3 } : (a5.isBackwards = n7, a5.rendering = null, a5.renderingStartTime = 0, a5.last = r6, a5.tail = t5, a5.tailMode = l3);
    }
    function Kt(e4, n7, t5) {
      var r6 = n7.pendingProps, l3 = r6.revealOrder, a5 = r6.tail;
      if (r6 = r6.children, void 0 !== l3 && "forwards" !== l3 && "backwards" !== l3 && "together" !== l3 && !vc[l3]) if (vc[l3] = true, "string" == typeof l3) switch (l3.toLowerCase()) {
        case "together":
        case "forwards":
        case "backwards":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', l3, l3.toLowerCase());
          break;
        case "forward":
        case "backward":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', l3, l3.toLowerCase());
          break;
        default:
          console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l3);
      }
      else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l3);
      void 0 === a5 || Sc[a5] || ("collapsed" !== a5 && "hidden" !== a5 ? (Sc[a5] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a5)) : "forwards" !== l3 && "backwards" !== l3 && (Sc[a5] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a5)));
      e: if (("forwards" === l3 || "backwards" === l3) && null != r6 && false !== r6) if (lo(r6)) {
        for (var o3 = 0; o3 < r6.length; o3++) if (!Gt(r6[o3], o3)) break e;
      } else if (o3 = i4(r6), "function" == typeof o3) {
        if (o3 = o3.call(r6)) for (var u4 = o3.next(), s3 = 0; !u4.done; u4 = o3.next()) {
          if (!Gt(u4.value, s3)) break e;
          s3++;
        }
      } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', l3);
      if (Nt(e4, n7, r6, t5), 0 != ((r6 = vs.current) & bs)) r6 = r6 & ys | bs, n7.flags |= 128;
      else {
        if (null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n7.child; null !== e4; ) {
          if (13 === e4.tag) null !== e4.memoizedState && Yt(e4, t5, n7);
          else if (19 === e4.tag) Yt(e4, t5, n7);
          else if (null !== e4.child) {
            e4.child.return = e4, e4 = e4.child;
            continue;
          }
          if (e4 === n7) break e;
          for (; null === e4.sibling; ) {
            if (null === e4.return || e4.return === n7) break e;
            e4 = e4.return;
          }
          e4.sibling.return = e4.return, e4 = e4.sibling;
        }
        r6 &= ys;
      }
      switch (S3(vs, r6, n7), l3) {
        case "forwards":
          for (t5 = n7.child, l3 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === $e(e4) && (l3 = t5), t5 = t5.sibling;
          null === (t5 = l3) ? (l3 = n7.child, n7.child = null) : (l3 = t5.sibling, t5.sibling = null), Jt(n7, false, l3, t5, a5);
          break;
        case "backwards":
          for (t5 = null, l3 = n7.child, n7.child = null; null !== l3; ) {
            if (null !== (e4 = l3.alternate) && null === $e(e4)) {
              n7.child = l3;
              break;
            }
            e4 = l3.sibling, l3.sibling = t5, t5 = l3, l3 = e4;
          }
          Jt(n7, true, t5, null, a5);
          break;
        case "together":
          Jt(n7, false, null, null, void 0);
          break;
        default:
          n7.memoizedState = null;
      }
      return n7.child;
    }
    function Xt(e4, n7, t5) {
      if (null !== e4 && (n7.dependencies = e4.dependencies), Xu = -1, _f |= n7.lanes, 0 == (t5 & n7.childLanes)) {
        if (null === e4) return null;
        if (or(e4, n7, t5, false), 0 == (t5 & n7.childLanes)) return null;
      }
      if (null !== e4 && n7.child !== e4.child) throw Error("Resuming work not yet implemented.");
      if (null !== n7.child) {
        for (t5 = fa(e4 = n7.child, e4.pendingProps), n7.child = t5, t5.return = n7; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = fa(e4, e4.pendingProps)).return = n7;
        t5.sibling = null;
      }
      return n7.child;
    }
    function Zt(e4, n7) {
      return 0 != (e4.lanes & n7) || !(null === (e4 = e4.dependencies) || !ur(e4));
    }
    function er(e4, n7, t5) {
      if (n7._debugNeedsRemount && null !== e4) {
        t5 = pa(n7.type, n7.key, n7.pendingProps, n7._debugOwner || null, n7.mode, n7.lanes);
        var r6 = n7.return;
        if (null === r6) throw Error("Cannot swap the root fiber.");
        if (e4.alternate = null, n7.alternate = null, t5.index = n7.index, t5.sibling = n7.sibling, t5.return = n7.return, t5.ref = n7.ref, t5._debugInfo = n7._debugInfo, n7 === r6.child) r6.child = t5;
        else {
          var l3 = r6.child;
          if (null === l3) throw Error("Expected parent to have a child.");
          for (; l3.sibling !== n7; ) if (null === (l3 = l3.sibling)) throw Error("Expected to find the previous sibling.");
          l3.sibling = t5;
        }
        return null === (n7 = r6.deletions) ? (r6.deletions = [e4], r6.flags |= 16) : n7.push(e4), t5.flags |= 2, t5;
      }
      if (null !== e4) if (e4.memoizedProps !== n7.pendingProps || n7.type !== e4.type) pc = true;
      else {
        if (!Zt(e4, t5) && 0 == (128 & n7.flags)) return pc = false, function(e5, n8, t6) {
          switch (n8.tag) {
            case 3:
              W(n8, n8.stateNode.containerInfo), tr(n8, Uc, e5.memoizedState.cache);
              break;
            case 27:
            case 5:
              A(n8);
              break;
            case 4:
              W(n8, n8.stateNode.containerInfo);
              break;
            case 10:
              tr(n8, n8.type, n8.memoizedProps.value);
              break;
            case 12:
              0 != (t6 & n8.childLanes) && (n8.flags |= 4), n8.flags |= 2048;
              var r7 = n8.stateNode;
              r7.effectDuration = -0, r7.passiveEffectDuration = -0;
              break;
            case 13:
              if (null !== (r7 = n8.memoizedState)) return null !== r7.dehydrated ? (Qe(n8), n8.flags |= 128, null) : 0 != (t6 & n8.child.childLanes) ? Bt(e5, n8, t6) : (Qe(n8), null !== (e5 = Xt(e5, n8, t6)) ? e5.sibling : null);
              Qe(n8);
              break;
            case 19:
              var l4 = 0 != (128 & e5.flags);
              if ((r7 = 0 != (t6 & n8.childLanes)) || (or(e5, n8, t6, false), r7 = 0 != (t6 & n8.childLanes)), l4) {
                if (r7) return Kt(e5, n8, t6);
                n8.flags |= 128;
              }
              if (null !== (l4 = n8.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), S3(vs, vs.current, n8), r7) break;
              return null;
            case 22:
            case 23:
              return n8.lanes = 0, It(e5, n8, t6);
            case 24:
              tr(n8, Uc, e5.memoizedState.cache);
          }
          return Xt(e5, n8, t6);
        }(e4, n7, t5);
        pc = 0 != (131072 & e4.flags);
      }
      else pc = false, (r6 = Bu) && (F(), r6 = 0 != (1048576 & n7.flags)), r6 && (r6 = n7.index, F(), function(e5, n8, t6) {
        F(), Iu[Fu++] = Wu, Iu[Fu++] = Hu, Iu[Fu++] = Mu, Mu = e5;
        var r7 = Wu;
        e5 = Hu;
        var l4 = 32 - cu(r7) - 1;
        r7 &= ~(1 << l4), t6 += 1;
        var a6 = 32 - cu(n8) + l4;
        if (30 < a6) {
          var o4 = l4 - l4 % 5;
          a6 = (r7 & (1 << o4) - 1).toString(32), r7 >>= o4, l4 -= o4, Wu = 1 << 32 - cu(n8) + l4 | t6 << l4 | r7, Hu = a6 + e5;
        } else Wu = 1 << a6 | t6 << l4 | r7, Hu = e5;
      }(n7, Du, r6));
      switch (n7.lanes = 0, n7.tag) {
        case 16:
          e: {
            if (r6 = n7.pendingProps, e4 = ts(n7.elementType), n7.type = e4, "function" != typeof e4) {
              if (null != e4) {
                if ((l3 = e4.$$typeof) === Aa) {
                  n7.tag = 11, n7.type = e4, n7 = Lt(null, n7, e4, r6, t5);
                  break e;
                }
                if (l3 === Ba) {
                  n7.tag = 14, n7 = Ut(null, n7, e4, r6, t5);
                  break e;
                }
              }
              throw n7 = "", null !== e4 && "object" == typeof e4 && e4.$$typeof === Va && (n7 = " Did you wrap a component in React.lazy() more than once?"), e4 = s2(e4) || e4, Error("Element type is invalid. Received a promise that resolves to: " + e4 + ". Lazy element type must resolve to a class or function." + n7);
            }
            ca(e4) ? (r6 = Ct(e4, r6), n7.tag = 1, n7.type = e4, n7 = jt(null, n7, e4, r6, t5)) : (n7.tag = 0, At(n7, e4), n7.type = e4, n7 = Wt(null, n7, e4, r6, t5));
          }
          return n7;
        case 0:
          return Wt(e4, n7, n7.type, n7.pendingProps, t5);
        case 1:
          return jt(e4, n7, r6 = n7.type, l3 = Ct(r6, n7.pendingProps), t5);
        case 3:
          if (W(n7, n7.stateNode.containerInfo), null === e4) throw Error("Should have a current fiber. This is a bug in React.");
          var a5 = n7.pendingProps;
          r6 = (l3 = n7.memoizedState).element, he(e4, n7), ke(n7, a5, null, t5);
          var o3 = n7.memoizedState;
          return a5 = o3.cache, tr(n7, Uc, a5), a5 !== l3.cache && ar(n7, [Uc], t5, true), Se(), (a5 = o3.element) !== r6 ? (Nt(e4, n7, a5, t5), n7 = n7.child) : n7 = Xt(e4, n7, t5), n7;
        case 26:
        case 27:
        case 5:
          return A(n7), l3 = n7.type, a5 = n7.pendingProps, o3 = null !== e4 ? e4.memoizedProps : null, r6 = a5.children, mo(l3, a5) ? r6 = null : null !== o3 && mo(l3, o3) && (n7.flags |= 32), null !== n7.memoizedState && (l3 = Ze(e4, n7, tn, null, null, t5), Uo._currentValue2 = l3), Mt(e4, n7), Nt(e4, n7, r6, t5), n7.child;
        case 6:
          return null;
        case 13:
          return Bt(e4, n7, t5);
        case 4:
          return W(n7, n7.stateNode.containerInfo), r6 = n7.pendingProps, null === e4 ? n7.child = fs2(n7, null, r6, t5) : Nt(e4, n7, r6, t5), n7.child;
        case 11:
          return Lt(e4, n7, n7.type, n7.pendingProps, t5);
        case 7:
          return Nt(e4, n7, n7.pendingProps, t5), n7.child;
        case 8:
          return Nt(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 12:
          return n7.flags |= 4, n7.flags |= 2048, (r6 = n7.stateNode).effectDuration = -0, r6.passiveEffectDuration = -0, Nt(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 10:
          return r6 = n7.type, a5 = (l3 = n7.pendingProps).value, "value" in l3 || wc || (wc = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), tr(n7, r6, a5), Nt(e4, n7, l3.children, t5), n7.child;
        case 9:
          return l3 = n7.type._context, "function" != typeof (r6 = n7.pendingProps.children) && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), ir(n7), l3 = sr(l3), r6 = ji(r6, l3, void 0), n7.flags |= 1, Nt(e4, n7, r6, t5), n7.child;
        case 14:
          return Ut(e4, n7, n7.type, n7.pendingProps, t5);
        case 15:
          return Dt(e4, n7, n7.type, n7.pendingProps, t5);
        case 19:
          return Kt(e4, n7, t5);
        case 22:
          return It(e4, n7, t5);
        case 24:
          return ir(n7), r6 = sr(Uc), null === e4 ? (null === (l3 = hr()) && (l3 = cf, a5 = dr(), l3.pooledCache = a5, pr(a5), null !== a5 && (l3.pooledCacheLanes |= t5), l3 = a5), n7.memoizedState = { parent: r6, cache: l3 }, me(n7), tr(n7, Uc, l3)) : (0 != (e4.lanes & t5) && (he(e4, n7), ke(n7, null, null, t5), Se()), l3 = e4.memoizedState, a5 = n7.memoizedState, l3.parent !== r6 ? (l3 = { parent: r6, cache: r6 }, n7.memoizedState = l3, 0 === n7.lanes && (n7.memoizedState = n7.updateQueue.baseState = l3), tr(n7, Uc, r6)) : (r6 = a5.cache, tr(n7, Uc, r6), r6 !== l3.cache && ar(n7, [Uc], t5, true))), Nt(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 29:
          throw n7.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + n7.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function nr() {
      _c = Pc = Ec = null, Rc = false;
    }
    function tr(e4, n7, t5) {
      S3(xc, n7._currentValue2, e4), n7._currentValue2 = t5, S3(zc, n7._currentRenderer2, e4), void 0 !== n7._currentRenderer2 && null !== n7._currentRenderer2 && n7._currentRenderer2 !== Cc && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), n7._currentRenderer2 = Cc;
    }
    function rr(e4, n7) {
      var t5 = xc.current;
      e4._currentValue2 = t5, t5 = zc.current, v3(zc, n7), e4._currentRenderer2 = t5, v3(xc, n7);
    }
    function lr(e4, n7, t5) {
      for (; null !== e4; ) {
        var r6 = e4.alternate;
        if ((e4.childLanes & n7) !== n7 ? (e4.childLanes |= n7, null !== r6 && (r6.childLanes |= n7)) : null !== r6 && (r6.childLanes & n7) !== n7 && (r6.childLanes |= n7), e4 === t5) break;
        e4 = e4.return;
      }
      e4 !== t5 && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ar(e4, n7, t5, r6) {
      var l3 = e4.child;
      for (null !== l3 && (l3.return = e4); null !== l3; ) {
        var a5 = l3.dependencies;
        if (null !== a5) {
          var o3 = l3.child;
          a5 = a5.firstContext;
          e: for (; null !== a5; ) {
            var u4 = a5;
            a5 = l3;
            for (var i5 = 0; i5 < n7.length; i5++) if (u4.context === n7[i5]) {
              a5.lanes |= t5, null !== (u4 = a5.alternate) && (u4.lanes |= t5), lr(a5.return, t5, e4), r6 || (o3 = null);
              break e;
            }
            a5 = u4.next;
          }
        } else if (18 === l3.tag) {
          if (null === (o3 = l3.return)) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          o3.lanes |= t5, null !== (a5 = o3.alternate) && (a5.lanes |= t5), lr(o3, t5, e4), o3 = null;
        } else o3 = l3.child;
        if (null !== o3) o3.return = l3;
        else for (o3 = l3; null !== o3; ) {
          if (o3 === e4) {
            o3 = null;
            break;
          }
          if (null !== (l3 = o3.sibling)) {
            l3.return = o3.return, o3 = l3;
            break;
          }
          o3 = o3.return;
        }
        l3 = o3;
      }
    }
    function or(e4, n7, t5, r6) {
      e4 = null;
      for (var l3 = n7, a5 = false; null !== l3; ) {
        if (!a5) {
          if (0 != (524288 & l3.flags)) a5 = true;
          else if (0 != (262144 & l3.flags)) break;
        }
        if (10 === l3.tag) {
          var o3 = l3.alternate;
          if (null === o3) throw Error("Should have a current fiber. This is a bug in React.");
          if (null !== (o3 = o3.memoizedProps)) {
            var u4 = l3.type;
            Ru(l3.pendingProps.value, o3.value) || (null !== e4 ? e4.push(u4) : e4 = [u4]);
          }
        } else if (l3 === Ou.current) {
          if (null === (o3 = l3.alternate)) throw Error("Should have a current fiber. This is a bug in React.");
          o3.memoizedState.memoizedState !== l3.memoizedState.memoizedState && (null !== e4 ? e4.push(Uo) : e4 = [Uo]);
        }
        l3 = l3.return;
      }
      null !== e4 && ar(n7, e4, t5, r6), n7.flags |= 262144;
    }
    function ur(e4) {
      for (e4 = e4.firstContext; null !== e4; ) {
        var n7 = e4.context;
        if (!Ru(n7._currentValue2, e4.memoizedValue)) return true;
        e4 = e4.next;
      }
      return false;
    }
    function ir(e4) {
      Ec = e4, _c = Pc = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
    }
    function sr(e4) {
      return Rc && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), fr(Ec, e4);
    }
    function cr(e4, n7) {
      return null === Ec && ir(e4), fr(e4, n7);
    }
    function fr(e4, n7) {
      var t5 = n7._currentValue2;
      if (_c !== n7) if (n7 = { context: n7, memoizedValue: t5, next: null }, null === Pc) {
        if (null === e4) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        Pc = n7, e4.dependencies = { lanes: 0, firstContext: n7, _debugThenableState: null }, e4.flags |= 524288;
      } else Pc = Pc.next = n7;
      return t5;
    }
    function dr() {
      return { controller: new Tc(), data: /* @__PURE__ */ new Map(), refCount: 0 };
    }
    function pr(e4) {
      e4.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React."), e4.refCount++;
    }
    function mr(e4) {
      e4.refCount--, 0 > e4.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React."), 0 === e4.refCount && Nc(Lc, function() {
        e4.controller.abort();
      });
    }
    function hr() {
      var e4 = Ic.current;
      return null !== e4 ? e4 : cf.pooledCache;
    }
    function gr(e4, n7) {
      S3(Ic, null === n7 ? Ic.current : n7.pool, e4);
    }
    function yr() {
      var e4 = hr();
      return null === e4 ? null : { parent: Uc._currentValue2, pool: e4 };
    }
    function br(e4) {
      e4.flags |= 4;
    }
    function vr(e4, n7) {
      null !== n7 && (e4.flags |= 4), 16384 & e4.flags && (n7 = 22 !== e4.tag ? C() : 536870912, e4.lanes |= n7);
    }
    function Sr(e4, n7) {
      switch (e4.tailMode) {
        case "hidden":
          n7 = e4.tail;
          for (var t5 = null; null !== n7; ) null !== n7.alternate && (t5 = n7), n7 = n7.sibling;
          null === t5 ? e4.tail = null : t5.sibling = null;
          break;
        case "collapsed":
          t5 = e4.tail;
          for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
          null === r6 ? n7 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
      }
    }
    function kr(e4) {
      var n7 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
      if (n7) if ((2 & e4.mode) !== $u) {
        for (var l3 = e4.selfBaseDuration, a5 = e4.child; null !== a5; ) t5 |= a5.lanes | a5.childLanes, r6 |= 31457280 & a5.subtreeFlags, r6 |= 31457280 & a5.flags, l3 += a5.treeBaseDuration, a5 = a5.sibling;
        e4.treeBaseDuration = l3;
      } else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= 31457280 & l3.subtreeFlags, r6 |= 31457280 & l3.flags, l3.return = e4, l3 = l3.sibling;
      else if ((2 & e4.mode) !== $u) {
        l3 = e4.actualDuration, a5 = e4.selfBaseDuration;
        for (var o3 = e4.child; null !== o3; ) t5 |= o3.lanes | o3.childLanes, r6 |= o3.subtreeFlags, r6 |= o3.flags, l3 += o3.actualDuration, a5 += o3.treeBaseDuration, o3 = o3.sibling;
        e4.actualDuration = l3, e4.treeBaseDuration = a5;
      } else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= l3.subtreeFlags, r6 |= l3.flags, l3.return = e4, l3 = l3.sibling;
      return e4.subtreeFlags |= r6, e4.childLanes = t5, n7;
    }
    function wr(e4, n7, t5) {
      var r6 = n7.pendingProps;
      switch (I(n7), n7.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
        case 1:
          return kr(n7), null;
        case 3:
          return t5 = n7.stateNode, r6 = null, null !== e4 && (r6 = e4.memoizedState.cache), n7.memoizedState.cache !== r6 && (n7.flags |= 2048), rr(Uc, n7), H(n7), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n7.flags) || (n7.flags |= 1024, null !== Vu && (Pl(Vu), Vu = null)), kr(n7), null;
        case 26:
          var l3;
        case 27:
        case 5:
          if (Q(n7), t5 = n7.type, null !== e4 && null != n7.stateNode) !function(e5, n8, t6, r7) {
            e5.memoizedProps !== r7 && br(n8);
          }(e4, n7, 0, r6);
          else {
            if (!r6) {
              if (null === n7.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return kr(n7), null;
            }
            e4 = j(), l3 = M(Qu.current), function(e5, n8, t6, r7) {
              for (t6 = n8.child; null !== t6; ) {
                if (5 === t6.tag || 6 === t6.tag) fo(e5, t6.stateNode);
                else if (4 !== t6.tag && !au && null !== t6.child) {
                  t6.child.return = t6, t6 = t6.child;
                  continue;
                }
                if (t6 === n8) break;
                for (; null === t6.sibling; ) {
                  if (null === t6.return || t6.return === n8) return;
                  t6 = t6.return;
                }
                t6.sibling.return = t6.return, t6 = t6.sibling;
              }
            }(l3 = co(t5, r6, l3, e4, n7), n7, false), n7.stateNode = l3, po(l3, t5, r6, e4) && br(n7);
          }
          return kr(n7), function(e5, n8, t6) {
            if (Po(n8, t6)) {
              if (e5.flags |= 16777216, !_o(n8, t6)) {
                if (!Dl()) throw Mi = Fi, Ii;
                e5.flags |= 8192;
              }
            } else e5.flags &= -16777217;
          }(n7, n7.type, n7.pendingProps), null;
        case 6:
          if (e4 && null != n7.stateNode) (t5 = e4.memoizedProps) !== r6 && br(n7);
          else {
            if ("string" != typeof r6 && null === n7.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var a5;
            e4 = M(Qu.current), t5 = j(), n7.stateNode = ho(r6, e4, t5, n7);
          }
          return kr(n7), null;
        case 13:
          if (r6 = n7.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
            if (l3 = false, null !== r6 && null !== r6.dehydrated) {
              if (null === e4) {
                if (!l3) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              }
              0 == (128 & n7.flags) && (n7.memoizedState = null), n7.flags |= 4, kr(n7), (2 & n7.mode) !== $u && null !== r6 && null !== (l3 = n7.child) && (n7.treeBaseDuration -= l3.treeBaseDuration), l3 = false;
            } else null !== Vu && (Pl(Vu), Vu = null), l3 = true;
            if (!l3) return 256 & n7.flags ? (Ve(n7), n7) : (Ve(n7), null);
          }
          return Ve(n7), 0 != (128 & n7.flags) ? (n7.lanes = t5, (2 & n7.mode) !== $u && re(n7), n7) : (t5 = null !== r6, e4 = null !== e4 && null !== e4.memoizedState, t5 && (l3 = null, null !== (r6 = n7.child).alternate && null !== r6.alternate.memoizedState && null !== r6.alternate.memoizedState.cachePool && (l3 = r6.alternate.memoizedState.cachePool.pool), a5 = null, null !== r6.memoizedState && null !== r6.memoizedState.cachePool && (a5 = r6.memoizedState.cachePool.pool), a5 !== l3 && (r6.flags |= 2048)), t5 !== e4 && t5 && (n7.child.flags |= 8192), vr(n7, n7.updateQueue), kr(n7), (2 & n7.mode) !== $u && t5 && null !== (e4 = n7.child) && (n7.treeBaseDuration -= e4.treeBaseDuration), null);
        case 4:
          return H(n7), null === e4 && ko(n7.stateNode.containerInfo), kr(n7), null;
        case 10:
          return rr(n7.type, n7), kr(n7), null;
        case 19:
          if (v3(vs, n7), null === (l3 = n7.memoizedState)) return kr(n7), null;
          if (r6 = 0 != (128 & n7.flags), null === (a5 = l3.rendering)) if (r6) Sr(l3, false);
          else {
            if (Pf !== nf || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n7.child; null !== e4; ) {
              if (null !== (a5 = $e(e4))) {
                for (n7.flags |= 128, Sr(l3, false), e4 = a5.updateQueue, n7.updateQueue = e4, vr(n7, e4), n7.subtreeFlags = 0, e4 = t5, t5 = n7.child; null !== t5; ) da(t5, e4), t5 = t5.sibling;
                return S3(vs, vs.current & ys | bs, n7), n7.child;
              }
              e4 = e4.sibling;
            }
            null !== l3.tail && vu() > Wf && (n7.flags |= 128, r6 = true, Sr(l3, false), n7.lanes = 4194304);
          }
          else {
            if (!r6) if (null !== (e4 = $e(a5))) {
              if (n7.flags |= 128, r6 = true, e4 = e4.updateQueue, n7.updateQueue = e4, vr(n7, e4), Sr(l3, true), null === l3.tail && "hidden" === l3.tailMode && !a5.alternate) return kr(n7), null;
            } else 2 * vu() - l3.renderingStartTime > Wf && 536870912 !== t5 && (n7.flags |= 128, r6 = true, Sr(l3, false), n7.lanes = 4194304);
            l3.isBackwards ? (a5.sibling = n7.child, n7.child = a5) : (null !== (e4 = l3.last) ? e4.sibling = a5 : n7.child = a5, l3.last = a5);
          }
          return null !== l3.tail ? (e4 = l3.tail, l3.rendering = e4, l3.tail = e4.sibling, l3.renderingStartTime = vu(), e4.sibling = null, t5 = vs.current, S3(vs, t5 = r6 ? t5 & ys | bs : t5 & ys, n7), e4) : (kr(n7), null);
        case 22:
        case 23:
          return Ve(n7), Ae(n7), r6 = null !== n7.memoizedState, null !== e4 ? null !== e4.memoizedState !== r6 && (n7.flags |= 8192) : r6 && (n7.flags |= 8192), r6 ? 0 != (536870912 & t5) && 0 == (128 & n7.flags) && (kr(n7), 6 & n7.subtreeFlags && (n7.flags |= 8192)) : kr(n7), null !== (t5 = n7.updateQueue) && vr(n7, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), r6 = null, null !== n7.memoizedState && null !== n7.memoizedState.cachePool && (r6 = n7.memoizedState.cachePool.pool), r6 !== t5 && (n7.flags |= 2048), null !== e4 && v3(Ic, n7), null;
        case 24:
          return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n7.memoizedState.cache !== t5 && (n7.flags |= 2048), rr(Uc, n7), kr(n7), null;
        case 25:
          return null;
      }
      throw Error("Unknown unit of work tag (" + n7.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function xr(e4, n7) {
      switch (I(n7), n7.tag) {
        case 1:
          return 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== $u && re(n7), n7) : null;
        case 3:
          return rr(Uc, n7), H(n7), 0 != (65536 & (e4 = n7.flags)) && 0 == (128 & e4) ? (n7.flags = -65537 & e4 | 128, n7) : null;
        case 26:
        case 27:
        case 5:
          return Q(n7), null;
        case 13:
          if (Ve(n7), null !== (e4 = n7.memoizedState) && null !== e4.dehydrated && null === n7.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
          return 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== $u && re(n7), n7) : null;
        case 19:
          return v3(vs, n7), null;
        case 4:
          return H(n7), null;
        case 10:
          return rr(n7.type, n7), null;
        case 22:
        case 23:
          return Ve(n7), Ae(n7), null !== e4 && v3(Ic, n7), 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== $u && re(n7), n7) : null;
        case 24:
          return rr(Uc, n7), null;
        default:
          return null;
      }
    }
    function zr(e4, n7) {
      switch (I(n7), n7.tag) {
        case 3:
          rr(Uc, n7), H(n7);
          break;
        case 26:
        case 27:
        case 5:
          Q(n7);
          break;
        case 4:
          H(n7);
          break;
        case 13:
          Ve(n7);
          break;
        case 19:
          v3(vs, n7);
          break;
        case 10:
          rr(n7.type, n7);
          break;
        case 22:
        case 23:
          Ve(n7), Ae(n7), null !== e4 && v3(Ic, n7);
          break;
        case 24:
          rr(Uc, n7);
      }
    }
    function Cr(e4) {
      return (2 & e4.mode) !== $u;
    }
    function Er(e4, n7) {
      Cr(e4) ? (te(), _r(n7, e4), ne()) : _r(n7, e4);
    }
    function Pr(e4, n7, t5) {
      Cr(e4) ? (te(), Rr(t5, e4, n7), ne()) : Rr(t5, e4, n7);
    }
    function _r(e4, n7) {
      try {
        var t5 = n7.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
        if (null !== r6) {
          var l3 = r6.next;
          t5 = l3;
          do {
            var a5;
            (t5.tag & e4) === e4 && ((e4 & zs) !== Ss ? null !== Pu && "function" == typeof Pu.markComponentPassiveEffectMountStarted && Pu.markComponentPassiveEffectMountStarted(n7) : (e4 & xs) !== Ss && null !== Pu && "function" == typeof Pu.markComponentLayoutEffectMountStarted && Pu.markComponentLayoutEffectMountStarted(n7), r6 = void 0, (e4 & ws) !== Ss && (nd = true), r6 = y3(n7, Xi, t5), (e4 & ws) !== Ss && (nd = false), (e4 & zs) !== Ss ? null !== Pu && "function" == typeof Pu.markComponentPassiveEffectMountStopped && Pu.markComponentPassiveEffectMountStopped() : (e4 & xs) !== Ss && null !== Pu && "function" == typeof Pu.markComponentLayoutEffectMountStopped && Pu.markComponentLayoutEffectMountStopped(), void 0 !== r6 && "function" != typeof r6) && y3(n7, function(e5, n8) {
              console.error("%s must not return anything besides a function, which is used for clean-up.%s", e5, n8);
            }, a5 = 0 != (t5.tag & xs) ? "useLayoutEffect" : 0 != (t5.tag & ws) ? "useInsertionEffect" : "useEffect", null === r6 ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" == typeof r6.then ? "\n\nIt looks like you wrote " + a5 + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + a5 + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + r6), t5 = t5.next;
          } while (t5 !== l3);
        }
      } catch (e5) {
        Xl(n7, n7.return, e5);
      }
    }
    function Rr(e4, n7, t5) {
      try {
        var r6 = n7.updateQueue, l3 = null !== r6 ? r6.lastEffect : null;
        if (null !== l3) {
          var a5 = l3.next;
          r6 = a5;
          do {
            if ((r6.tag & e4) === e4) {
              var o3 = r6.inst, u4 = o3.destroy;
              void 0 !== u4 && (o3.destroy = void 0, (e4 & zs) !== Ss ? null !== Pu && "function" == typeof Pu.markComponentPassiveEffectUnmountStarted && Pu.markComponentPassiveEffectUnmountStarted(n7) : (e4 & xs) !== Ss && null !== Pu && "function" == typeof Pu.markComponentLayoutEffectUnmountStarted && Pu.markComponentLayoutEffectUnmountStarted(n7), (e4 & ws) !== Ss && (nd = true), y3(n7, es, n7, t5, u4), (e4 & ws) !== Ss && (nd = false), (e4 & zs) !== Ss ? null !== Pu && "function" == typeof Pu.markComponentPassiveEffectUnmountStopped && Pu.markComponentPassiveEffectUnmountStopped() : (e4 & xs) !== Ss && null !== Pu && "function" == typeof Pu.markComponentLayoutEffectUnmountStopped && Pu.markComponentLayoutEffectUnmountStopped());
            }
            r6 = r6.next;
          } while (r6 !== a5);
        }
      } catch (e5) {
        Xl(n7, n7.return, e5);
      }
    }
    function Tr(e4, n7) {
      Cr(e4) ? (te(), _r(n7, e4), ne()) : _r(n7, e4);
    }
    function Nr(e4, n7, t5) {
      Cr(e4) ? (te(), Rr(t5, e4, n7), ne()) : Rr(t5, e4, n7);
    }
    function Lr(e4) {
      var n7 = e4.updateQueue;
      if (null !== n7) {
        var t5 = e4.stateNode;
        e4.type.defaultProps || "ref" in e4.memoizedProps || bc || (t5.props !== e4.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(e4) || "instance"), t5.state !== e4.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(e4) || "instance"));
        try {
          y3(e4, ze, n7, t5);
        } catch (n8) {
          Xl(e4, e4.return, n8);
        }
      }
    }
    function Ur(e4, n7, t5) {
      return e4.getSnapshotBeforeUpdate(n7, t5);
    }
    function Dr(e4, n7) {
      var t5 = n7.memoizedProps, r6 = n7.memoizedState;
      n7 = e4.stateNode, e4.type.defaultProps || "ref" in e4.memoizedProps || bc || (n7.props !== e4.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(e4) || "instance"), n7.state !== e4.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(e4) || "instance"));
      try {
        var l3 = Ct(e4.type, t5, (e4.elementType, e4.type)), a5 = y3(e4, Ur, n7, l3, r6);
        t5 = Fc, void 0 !== a5 || t5.has(e4.type) || (t5.add(e4.type), y3(e4, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", c4(e4));
        })), n7.__reactInternalSnapshotBeforeUpdate = a5;
      } catch (n8) {
        Xl(e4, e4.return, n8);
      }
    }
    function Ir(e4, n7, t5) {
      t5.props = Ct(e4.type, e4.memoizedProps), t5.state = e4.memoizedState, Cr(e4) ? (te(), y3(e4, Ji, e4, n7, t5), ne()) : y3(e4, Ji, e4, n7, t5);
    }
    function Fr(e4) {
      var n7 = e4.ref;
      if (null !== n7) {
        var t5 = e4.stateNode;
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            t5 = ao(t5);
        }
        if ("function" == typeof n7) if (Cr(e4)) try {
          te(), e4.refCleanup = n7(t5);
        } finally {
          ne();
        }
        else e4.refCleanup = n7(t5);
        else "string" == typeof n7 ? console.error("String refs are no longer supported.") : n7.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", c4(e4)), n7.current = t5;
      }
    }
    function Mr(e4, n7) {
      try {
        y3(e4, Fr, e4);
      } catch (t5) {
        Xl(e4, n7, t5);
      }
    }
    function Wr(e4, n7) {
      var t5 = e4.ref, r6 = e4.refCleanup;
      if (null !== t5) if ("function" == typeof r6) try {
        if (Cr(e4)) try {
          te(), y3(e4, r6);
        } finally {
          ne();
        }
        else y3(e4, r6);
      } catch (t6) {
        Xl(e4, n7, t6);
      } finally {
        e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
      }
      else if ("function" == typeof t5) try {
        if (Cr(e4)) try {
          te(), y3(e4, t5, null);
        } finally {
          ne();
        }
        else y3(e4, t5, null);
      } catch (t6) {
        Xl(e4, n7, t6);
      }
      else t5.current = null;
    }
    function Hr(e4, n7, t5, r6) {
      var l3 = e4.memoizedProps, a5 = l3.id, o3 = l3.onCommit;
      l3 = l3.onRender, n7 = null === n7 ? "mount" : "update", ei && (n7 = "nested-update"), "function" == typeof l3 && l3(a5, n7, e4.actualDuration, e4.treeBaseDuration, e4.actualStartTime, t5), "function" == typeof o3 && o3(e4.memoizedProps.id, n7, r6, t5);
    }
    function jr(e4, n7, t5, r6) {
      var l3 = e4.memoizedProps;
      e4 = l3.id, l3 = l3.onPostCommit, n7 = null === n7 ? "mount" : "update", ei && (n7 = "nested-update"), "function" == typeof l3 && l3(e4, n7, r6, t5);
    }
    function Ar(e4) {
      var n7 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
      try {
        y3(e4, Wo, r6, n7, t5, e4);
      } catch (n8) {
        Xl(e4, e4.return, n8);
      }
    }
    function Qr(e4) {
      return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
    }
    function Or(e4) {
      e: for (; ; ) {
        for (; null === e4.sibling; ) {
          if (null === e4.return || Qr(e4.return)) return null;
          e4 = e4.return;
        }
        for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
          if (2 & e4.flags) continue e;
          if (null === e4.child || 4 === e4.tag) continue e;
          e4.child.return = e4, e4 = e4.child;
        }
        if (!(2 & e4.flags)) return e4.stateNode;
      }
    }
    function Br(e4, n7, t5) {
      var r6 = e4.tag;
      if (5 === r6 || 6 === r6) e4 = e4.stateNode, n7 ? Ao(t5, e4, n7) : Fo(t5, e4);
      else if (4 !== r6 && !au && null !== (e4 = e4.child)) for (Br(e4, n7, t5), e4 = e4.sibling; null !== e4; ) Br(e4, n7, t5), e4 = e4.sibling;
    }
    function Vr(e4, n7, t5) {
      var r6 = e4.tag;
      if (5 === r6 || 6 === r6) e4 = e4.stateNode, n7 ? jo(t5, e4, n7) : Io(t5, e4);
      else if (4 !== r6 && !au && null !== (e4 = e4.child)) for (Vr(e4, n7, t5), e4 = e4.sibling; null !== e4; ) Vr(e4, n7, t5), e4 = e4.sibling;
    }
    function $r(e4) {
      e: {
        for (var n7 = e4.return; null !== n7; ) {
          if (Qr(n7)) {
            var t5 = n7;
            break e;
          }
          n7 = n7.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      switch (t5.tag) {
        case 27:
        case 5:
          n7 = t5.stateNode, 32 & t5.flags && (Bo(n7), t5.flags &= -33), Vr(e4, t5 = Or(e4), n7);
          break;
        case 3:
        case 4:
          n7 = t5.stateNode.containerInfo, Br(e4, t5 = Or(e4), n7);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function qr(e4, n7, t5) {
      var r6 = t5.flags;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          tl(e4, t5), 4 & r6 && Er(t5, xs | ks);
          break;
        case 1:
          if (tl(e4, t5), 4 & r6) if (e4 = t5.stateNode, null === n7) t5.type.defaultProps || "ref" in t5.memoizedProps || bc || (e4.props !== t5.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(t5) || "instance"), e4.state !== t5.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(t5) || "instance")), Cr(t5) ? (te(), y3(t5, Bi, t5, e4), ne()) : y3(t5, Bi, t5, e4);
          else {
            var l3 = Ct(t5.type, n7.memoizedProps);
            n7 = n7.memoizedState, t5.type.defaultProps || "ref" in t5.memoizedProps || bc || (e4.props !== t5.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(t5) || "instance"), e4.state !== t5.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(t5) || "instance")), Cr(t5) ? (te(), y3(t5, $i, t5, e4, l3, n7, e4.__reactInternalSnapshotBeforeUpdate), ne()) : y3(t5, $i, t5, e4, l3, n7, e4.__reactInternalSnapshotBeforeUpdate);
          }
          64 & r6 && Lr(t5), 512 & r6 && Mr(t5, t5.return);
          break;
        case 3:
          if (n7 = G2(), tl(e4, t5), 64 & r6 && null !== (r6 = t5.updateQueue)) {
            if (l3 = null, null !== t5.child) switch (t5.child.tag) {
              case 27:
              case 5:
                l3 = ao(t5.child.stateNode);
                break;
              case 1:
                l3 = t5.child.stateNode;
            }
            try {
              y3(t5, ze, r6, l3);
            } catch (e5) {
              Xl(t5, t5.return, e5);
            }
          }
          e4.effectDuration += J(n7);
          break;
        case 26:
        case 27:
        case 5:
          tl(e4, t5), null === n7 && 4 & r6 && Ar(t5), 512 & r6 && Mr(t5, t5.return);
          break;
        case 12:
          if (4 & r6) {
            r6 = G2(), tl(e4, t5), (e4 = t5.stateNode).effectDuration += K(r6);
            try {
              y3(t5, Hr, t5, n7, Ku, e4.effectDuration);
            } catch (e5) {
              Xl(t5, t5.return, e5);
            }
          } else tl(e4, t5);
          break;
        case 13:
        default:
          tl(e4, t5);
          break;
        case 22:
          if (!(l3 = null !== t5.memoizedState || Mc)) {
            n7 = null !== n7 && null !== n7.memoizedState || Wc;
            var a5 = Mc, o3 = Wc;
            Mc = l3, (Wc = n7) && !o3 ? ol(e4, t5, 0 != (8772 & t5.subtreeFlags)) : tl(e4, t5), Mc = a5, Wc = o3;
          }
          512 & r6 && ("manual" === t5.memoizedProps.mode ? Mr(t5, t5.return) : Wr(t5, t5.return));
      }
    }
    function Yr(e4) {
      var n7 = e4.alternate;
      null !== n7 && (e4.alternate = null, Yr(n7)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n7 = e4.stateNode) && Eo(n7), e4.stateNode = null, e4._debugOwner = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
    }
    function Gr(e4, n7, t5) {
      for (t5 = t5.child; null !== t5; ) Jr(e4, n7, t5), t5 = t5.sibling;
    }
    function Jr(e4, n7, t5) {
      switch (t5.tag) {
        case 26:
        case 27:
          var r6, l3;
        case 5:
          Wc || Wr(t5, n7);
        case 6:
          if (r6 = Vc, l3 = $c, Vc = null, Gr(e4, n7, t5), $c = l3, null !== (Vc = r6)) if ($c) try {
            y3(t5, Oo, Vc, t5.stateNode);
          } catch (e5) {
            Xl(t5, n7, e5);
          }
          else try {
            y3(t5, Qo, Vc, t5.stateNode);
          } catch (e5) {
            Xl(t5, n7, e5);
          }
          break;
        case 18:
          null !== Vc && ($c ? nu(Vc, t5.stateNode) : eu(Vc, t5.stateNode));
          break;
        case 4:
          r6 = Vc, l3 = $c, Vc = t5.stateNode.containerInfo, $c = true, Gr(e4, n7, t5), Vc = r6, $c = l3;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Wc || Rr(ws, t5, n7), Wc || Pr(t5, n7, xs), Gr(e4, n7, t5);
          break;
        case 1:
          Wc || (Wr(t5, n7), "function" == typeof (r6 = t5.stateNode).componentWillUnmount && Ir(t5, n7, r6)), Gr(e4, n7, t5);
          break;
        case 21:
          Gr(e4, n7, t5);
          break;
        case 22:
          Wr(t5, n7), Wc = (r6 = Wc) || null !== t5.memoizedState, Gr(e4, n7, t5), Wc = r6;
          break;
        default:
          Gr(e4, n7, t5);
      }
    }
    function Kr(e4, n7) {
      var t5 = function(e5) {
        switch (e5.tag) {
          case 13:
          case 19:
            var n8 = e5.stateNode;
            return null === n8 && (n8 = e5.stateNode = new jc()), n8;
          case 22:
            return null === (n8 = (e5 = e5.stateNode)._retryCache) && (n8 = e5._retryCache = new jc()), n8;
          default:
            throw Error("Unexpected Suspense handler tag (" + e5.tag + "). This is a bug in React.");
        }
      }(e4);
      n7.forEach(function(n8) {
        var r6 = ra.bind(null, e4, n8);
        if (!t5.has(n8)) {
          if (t5.add(n8), _u) {
            if (null === Qc || null === Oc) throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            ia(Oc, Qc);
          }
          n8.then(r6, r6);
        }
      });
    }
    function Xr(e4, n7) {
      var t5 = n7.deletions;
      if (null !== t5) for (var r6 = 0; r6 < t5.length; r6++) {
        var l3 = e4, a5 = n7, o3 = t5[r6], u4 = a5;
        e: for (; null !== u4; ) {
          switch (u4.tag) {
            case 27:
            case 5:
              Vc = u4.stateNode, $c = false;
              break e;
            case 3:
            case 4:
              Vc = u4.stateNode.containerInfo, $c = true;
              break e;
          }
          u4 = u4.return;
        }
        if (null === Vc) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        Jr(l3, a5, o3), Vc = null, $c = false, null !== (a5 = (l3 = o3).alternate) && (a5.return = null), l3.return = null;
      }
      if (13878 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) Zr(n7, e4), n7 = n7.sibling;
    }
    function Zr(e4, n7) {
      var t5 = e4.alternate, r6 = e4.flags;
      switch (e4.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Xr(n7, e4), el(e4), 4 & r6 && (Rr(ws | ks, e4, e4.return), _r(ws | ks, e4), Pr(e4, e4.return, xs | ks));
          break;
        case 1:
          Xr(n7, e4), el(e4), 512 & r6 && null !== t5 && Wr(t5, t5.return), 64 & r6 && Mc && null !== (e4 = e4.updateQueue) && null !== (r6 = e4.callbacks) && (t5 = e4.shared.hiddenCallbacks, e4.shared.hiddenCallbacks = null === t5 ? r6 : t5.concat(r6));
          break;
        case 26:
          var l3;
        case 27:
          var a5;
        case 5:
          if (Xr(n7, e4), el(e4), 512 & r6 && null !== t5 && Wr(t5, t5.return), 32 & e4.flags) {
            n7 = e4.stateNode;
            try {
              y3(e4, Bo, n7);
            } catch (n8) {
              Xl(e4, e4.return, n8);
            }
          }
          4 & r6 && null != e4.stateNode && function(e5, n8, t6) {
            try {
              y3(e5, Ho, e5.stateNode, e5.type, t6, n8, e5);
            } catch (n9) {
              Xl(e5, e5.return, n9);
            }
          }(e4, n7 = e4.memoizedProps, null !== t5 ? t5.memoizedProps : n7), 1024 & r6 && (Hc = true, "form" !== e4.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          if (Xr(n7, e4), el(e4), 4 & r6 && vo) {
            if (null === e4.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            r6 = e4.memoizedProps, t5 = null !== t5 ? t5.memoizedProps : r6, n7 = e4.stateNode;
            try {
              y3(e4, Mo, n7, t5, r6);
            } catch (n8) {
              Xl(e4, e4.return, n8);
            }
          }
          break;
        case 3:
          l3 = G2(), Xr(n7, e4), el(e4), Hc && (Hc = false, nl(e4)), n7.effectDuration += J(l3);
          break;
        case 4:
          Xr(n7, e4), el(e4);
          break;
        case 12:
          r6 = G2(), Xr(n7, e4), el(e4), e4.stateNode.effectDuration += K(r6);
          break;
        case 13:
          Xr(n7, e4), el(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== t5 && null !== t5.memoizedState) && (Ff = vu()), 4 & r6 && null !== (r6 = e4.updateQueue) && (e4.updateQueue = null, Kr(e4, r6));
          break;
        case 22:
          512 & r6 && null !== t5 && Wr(t5, t5.return), l3 = null !== e4.memoizedState;
          var o3 = null !== t5 && null !== t5.memoizedState, u4 = Mc, i5 = Wc;
          if (Mc = u4 || l3, Wc = i5 || o3, Xr(n7, e4), Wc = i5, Mc = u4, el(e4), (n7 = e4.stateNode)._current = e4, n7._visibility &= -3, n7._visibility |= 2 & n7._pendingVisibility, 8192 & r6 && (n7._visibility = l3 ? -2 & n7._visibility : 1 | n7._visibility, l3 && (n7 = Mc || Wc, null === t5 || o3 || n7 || ll(e4)), null === e4.memoizedProps || "manual" !== e4.memoizedProps.mode)) {
            e: if (t5 = null, vo) for (n7 = e4; ; ) {
              if (5 === n7.tag || tu || au) {
                if (null === t5) {
                  o3 = t5 = n7;
                  try {
                    a5 = o3.stateNode, l3 ? y3(o3, Vo, a5) : y3(o3, qo, o3.stateNode, o3.memoizedProps);
                  } catch (e5) {
                    Xl(o3, o3.return, e5);
                  }
                }
              } else if (6 === n7.tag) {
                if (null === t5) {
                  o3 = n7;
                  try {
                    var s3 = o3.stateNode;
                    l3 ? y3(o3, $o, s3) : y3(o3, Yo, s3, o3.memoizedProps);
                  } catch (e5) {
                    Xl(o3, o3.return, e5);
                  }
                }
              } else if ((22 !== n7.tag && 23 !== n7.tag || null === n7.memoizedState || n7 === e4) && null !== n7.child) {
                n7.child.return = n7, n7 = n7.child;
                continue;
              }
              if (n7 === e4) break e;
              for (; null === n7.sibling; ) {
                if (null === n7.return || n7.return === e4) break e;
                t5 === n7 && (t5 = null), n7 = n7.return;
              }
              t5 === n7 && (t5 = null), n7.sibling.return = n7.return, n7 = n7.sibling;
            }
          }
          4 & r6 && null !== (r6 = e4.updateQueue) && null !== (t5 = r6.retryQueue) && (r6.retryQueue = null, Kr(e4, t5));
          break;
        case 19:
          Xr(n7, e4), el(e4), 4 & r6 && null !== (r6 = e4.updateQueue) && (e4.updateQueue = null, Kr(e4, r6));
          break;
        case 21:
          break;
        default:
          Xr(n7, e4), el(e4);
      }
    }
    function el(e4) {
      var n7 = e4.flags;
      if (2 & n7) {
        try {
          y3(e4, $r, e4);
        } catch (n8) {
          Xl(e4, e4.return, n8);
        }
        e4.flags &= -3;
      }
      4096 & n7 && (e4.flags &= -4097);
    }
    function nl(e4) {
      if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
        var n7 = e4;
        nl(n7), 5 === n7.tag && 1024 & n7.flags && Do(n7.stateNode), e4 = e4.sibling;
      }
    }
    function tl(e4, n7) {
      if (8772 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) qr(e4, n7.alternate, n7), n7 = n7.sibling;
    }
    function rl(e4) {
      switch (e4.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Pr(e4, e4.return, xs), ll(e4);
          break;
        case 1:
          Wr(e4, e4.return);
          var n7 = e4.stateNode;
          "function" == typeof n7.componentWillUnmount && Ir(e4, e4.return, n7), ll(e4);
          break;
        case 26:
        case 27:
        case 5:
          Wr(e4, e4.return), ll(e4);
          break;
        case 22:
          Wr(e4, e4.return), null === e4.memoizedState && ll(e4);
          break;
        default:
          ll(e4);
      }
    }
    function ll(e4) {
      for (e4 = e4.child; null !== e4; ) rl(e4), e4 = e4.sibling;
    }
    function al(e4, n7, t5, r6) {
      var l3 = t5.flags;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          ol(e4, t5, r6), Er(t5, xs);
          break;
        case 1:
          if (ol(e4, t5, r6), "function" == typeof (n7 = t5.stateNode).componentDidMount && y3(t5, Bi, t5, n7), null !== (n7 = t5.updateQueue)) {
            e4 = t5.stateNode;
            try {
              y3(t5, xe, n7, e4);
            } catch (e5) {
              Xl(t5, t5.return, e5);
            }
          }
          r6 && 64 & l3 && Lr(t5), Mr(t5, t5.return);
          break;
        case 26:
        case 27:
        case 5:
          ol(e4, t5, r6), r6 && null === n7 && 4 & l3 && Ar(t5), Mr(t5, t5.return);
          break;
        case 12:
          if (r6 && 4 & l3) {
            l3 = G2(), ol(e4, t5, r6), (r6 = t5.stateNode).effectDuration += K(l3);
            try {
              y3(t5, Hr, t5, n7, Ku, r6.effectDuration);
            } catch (e5) {
              Xl(t5, t5.return, e5);
            }
          } else ol(e4, t5, r6);
          break;
        case 13:
        default:
          ol(e4, t5, r6);
          break;
        case 22:
          null === t5.memoizedState && ol(e4, t5, r6), Mr(t5, t5.return);
      }
    }
    function ol(e4, n7, t5) {
      for (t5 = t5 && 0 != (8772 & n7.subtreeFlags), n7 = n7.child; null !== n7; ) al(e4, n7.alternate, n7, t5), n7 = n7.sibling;
    }
    function ul(e4, n7) {
      var t5 = null;
      null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n7.memoizedState && null !== n7.memoizedState.cachePool && (e4 = n7.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && pr(e4), null != t5 && mr(t5));
    }
    function il(e4, n7) {
      e4 = null, null !== n7.alternate && (e4 = n7.alternate.memoizedState.cache), (n7 = n7.memoizedState.cache) !== e4 && (pr(n7), null != e4 && mr(e4));
    }
    function sl(e4, n7, t5, r6) {
      if (10256 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) cl(e4, n7, t5, r6), n7 = n7.sibling;
    }
    function cl(e4, n7, t5, r6) {
      var l3 = n7.flags;
      switch (n7.tag) {
        case 0:
        case 11:
        case 15:
          sl(e4, n7, t5, r6), 2048 & l3 && Tr(n7, zs | ks);
          break;
        case 3:
          var a5 = G2();
          sl(e4, n7, t5, r6), 2048 & l3 && (t5 = null, null !== n7.alternate && (t5 = n7.alternate.memoizedState.cache), (n7 = n7.memoizedState.cache) !== t5 && (pr(n7), null != t5 && mr(t5))), e4.passiveEffectDuration += J(a5);
          break;
        case 12:
          if (2048 & l3) {
            a5 = G2(), sl(e4, n7, t5, r6), (e4 = n7.stateNode).passiveEffectDuration += K(a5);
            try {
              y3(n7, jr, n7, n7.alternate, Ku, e4.passiveEffectDuration);
            } catch (e5) {
              Xl(n7, n7.return, e5);
            }
          } else sl(e4, n7, t5, r6);
          break;
        case 23:
          break;
        case 22:
          a5 = n7.stateNode, null !== n7.memoizedState ? 4 & a5._visibility ? sl(e4, n7, t5, r6) : pl(e4, n7) : 4 & a5._visibility ? sl(e4, n7, t5, r6) : (a5._visibility |= 4, fl(e4, n7, t5, r6, 0 != (10256 & n7.subtreeFlags))), 2048 & l3 && ul(n7.alternate, n7);
          break;
        case 24:
          sl(e4, n7, t5, r6), 2048 & l3 && il(n7.alternate, n7);
          break;
        default:
          sl(e4, n7, t5, r6);
      }
    }
    function fl(e4, n7, t5, r6, l3) {
      for (l3 = l3 && 0 != (10256 & n7.subtreeFlags), n7 = n7.child; null !== n7; ) dl(e4, n7, t5, r6, l3), n7 = n7.sibling;
    }
    function dl(e4, n7, t5, r6, l3) {
      var a5 = n7.flags;
      switch (n7.tag) {
        case 0:
        case 11:
        case 15:
          fl(e4, n7, t5, r6, l3), Tr(n7, zs);
          break;
        case 23:
          break;
        case 22:
          var o3 = n7.stateNode;
          null !== n7.memoizedState ? 4 & o3._visibility ? fl(e4, n7, t5, r6, l3) : pl(e4, n7) : (o3._visibility |= 4, fl(e4, n7, t5, r6, l3)), l3 && 2048 & a5 && ul(n7.alternate, n7);
          break;
        case 24:
          fl(e4, n7, t5, r6, l3), l3 && 2048 & a5 && il(n7.alternate, n7);
          break;
        default:
          fl(e4, n7, t5, r6, l3);
      }
    }
    function pl(e4, n7) {
      if (10256 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) {
        var t5 = e4, r6 = n7, l3 = r6.flags;
        switch (r6.tag) {
          case 22:
            pl(t5, r6), 2048 & l3 && ul(r6.alternate, r6);
            break;
          case 24:
            pl(t5, r6), 2048 & l3 && il(r6.alternate, r6);
            break;
          default:
            pl(t5, r6);
        }
        n7 = n7.sibling;
      }
    }
    function ml(e4) {
      if (e4.subtreeFlags & Yc) for (e4 = e4.child; null !== e4; ) hl(e4), e4 = e4.sibling;
    }
    function hl(e4) {
      switch (e4.tag) {
        case 26:
          ml(e4), e4.flags & Yc && (null !== e4.memoizedState ? lu(qc, e4.memoizedState, e4.memoizedProps) : To(e4.type, e4.memoizedProps));
          break;
        case 5:
          ml(e4), e4.flags & Yc && To(e4.type, e4.memoizedProps);
          break;
        case 3:
        case 4:
          var n7;
          ml(e4);
          break;
        case 22:
          null === e4.memoizedState && (null !== (n7 = e4.alternate) && null !== n7.memoizedState ? (n7 = Yc, Yc = 16777216, ml(e4), Yc = n7) : ml(e4));
          break;
        default:
          ml(e4);
      }
    }
    function gl(e4) {
      var n7 = e4.alternate;
      if (null !== n7 && null !== (e4 = n7.child)) {
        n7.child = null;
        do {
          n7 = e4.sibling, e4.sibling = null, e4 = n7;
        } while (null !== e4);
      }
    }
    function yl(e4) {
      var n7 = e4.deletions;
      if (0 != (16 & e4.flags)) {
        if (null !== n7) for (var t5 = 0; t5 < n7.length; t5++) {
          var r6 = n7[t5];
          Ac = r6, kl(r6, e4);
        }
        gl(e4);
      }
      if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) bl(e4), e4 = e4.sibling;
    }
    function bl(e4) {
      switch (e4.tag) {
        case 0:
        case 11:
        case 15:
          yl(e4), 2048 & e4.flags && Nr(e4, e4.return, zs | ks);
          break;
        case 3:
          var n7 = G2();
          yl(e4), e4.stateNode.passiveEffectDuration += J(n7);
          break;
        case 12:
          n7 = G2(), yl(e4), e4.stateNode.passiveEffectDuration += K(n7);
          break;
        case 22:
          n7 = e4.stateNode, null !== e4.memoizedState && 4 & n7._visibility && (null === e4.return || 13 !== e4.return.tag) ? (n7._visibility &= -5, vl(e4)) : yl(e4);
          break;
        default:
          yl(e4);
      }
    }
    function vl(e4) {
      var n7 = e4.deletions;
      if (0 != (16 & e4.flags)) {
        if (null !== n7) for (var t5 = 0; t5 < n7.length; t5++) {
          var r6 = n7[t5];
          Ac = r6, kl(r6, e4);
        }
        gl(e4);
      }
      for (e4 = e4.child; null !== e4; ) Sl(e4), e4 = e4.sibling;
    }
    function Sl(e4) {
      switch (e4.tag) {
        case 0:
        case 11:
        case 15:
          Nr(e4, e4.return, zs), vl(e4);
          break;
        case 22:
          var n7 = e4.stateNode;
          4 & n7._visibility && (n7._visibility &= -5, vl(e4));
          break;
        default:
          vl(e4);
      }
    }
    function kl(e4, n7) {
      for (; null !== Ac; ) {
        var t5 = Ac, r6 = t5;
        switch (r6.tag) {
          case 0:
          case 11:
          case 15:
            Nr(r6, n7, zs);
            break;
          case 23:
          case 22:
            null !== r6.memoizedState && null !== r6.memoizedState.cachePool && null != (r6 = r6.memoizedState.cachePool.pool) && pr(r6);
            break;
          case 24:
            mr(r6.memoizedState.cache);
        }
        if (null !== (r6 = t5.child)) r6.return = t5, Ac = r6;
        else e: for (t5 = e4; null !== Ac; ) {
          var l3 = (r6 = Ac).sibling, a5 = r6.return;
          if (Yr(r6), r6 === t5) {
            Ac = null;
            break e;
          }
          if (null !== l3) {
            l3.return = a5, Ac = l3;
            break e;
          }
          Ac = a5;
        }
      }
    }
    function wl() {
      var e4 = "undefined" != typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return e4 || null === Ja.actQueue || console.error("The current testing environment is not configured to support act(...)"), e4;
    }
    function xl(e4) {
      if ((sf & Zc) !== Xc && 0 !== df) return df & -df;
      var n7 = Ja.T;
      return null !== n7 ? (n7._updatedFibers || (n7._updatedFibers = /* @__PURE__ */ new Set()), n7._updatedFibers.add(e4), 0 !== (e4 = di) ? e4 : de()) : zo();
    }
    function zl() {
      0 === Nf && (Nf = 0 == (536870912 & df) || Bu ? z() : 536870912);
      var e4 = hs.current;
      return null !== e4 && (e4.flags |= 32), Nf;
    }
    function Cl(e4, n7, t5) {
      if (nd && console.error("useInsertionEffect must not schedule updates."), Jf && (Kf = true), (e4 === cf && wf === hf || null !== e4.cancelPendingCommit) && (Ll(e4, 0), Tl(e4, df, Nf)), P(e4, t5), 0 != (sf & Zc) && e4 === cf) {
        if (ro) switch (n7.tag) {
          case 0:
          case 11:
          case 15:
            e4 = ff && c4(ff) || "Unknown", ud.has(e4) || (ud.add(e4), n7 = c4(n7) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", n7, e4, e4));
            break;
          case 1:
            od || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), od = true);
        }
      } else _u && T(e4, n7, t5), function(e5) {
        wl() && null === Ja.actQueue && y3(e5, function() {
          console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", c4(e5));
        });
      }(n7), e4 === cf && ((sf & Zc) === Xc && (Rf |= t5), Pf === af && Tl(e4, df, Nf)), le(e4);
    }
    function El(e4, n7, t5) {
      if ((sf & (Zc | ef)) !== Xc) throw Error("Should not already be working.");
      var r6 = (t5 = !t5 && 0 == (60 & n7) && 0 == (n7 & e4.expiredLanes)) ? function(e5, n8) {
        var t6 = sf;
        sf |= Zc;
        var r7 = Il(), l4 = Fl();
        if (cf !== e5 || df !== n8) {
          if (_u) {
            var a6 = e5.memoizedUpdaters;
            0 < a6.size && (ia(e5, df), a6.clear()), N(e5, n8);
          }
          jf = null, Wf = vu() + Hf, Ll(e5, n8);
        }
        e: for (; ; ) try {
          if (wf !== pf && null !== ff) n: switch (n8 = ff, a6 = xf, wf) {
            case mf:
              wf = pf, xf = null, Bl(e5, n8, a6);
              break;
            case hf:
              if (Ee(a6)) {
                wf = pf, xf = null, Ql(n8);
                break;
              }
              n8 = function() {
                wf === hf && cf === e5 && (wf = Sf), le(e5);
              }, a6.then(n8, n8);
              break e;
            case gf:
              wf = Sf;
              break e;
            case yf:
              wf = bf;
              break e;
            case Sf:
              Ee(a6) ? (wf = pf, xf = null, Ql(n8)) : (wf = pf, xf = null, Bl(e5, n8, a6));
              break;
            case bf:
              var o4 = null;
              switch (ff.tag) {
                case 26:
                  o4 = ff.memoizedState;
                case 5:
                case 27:
                  var u5 = ff, i5 = u5.type, s3 = u5.pendingProps;
                  if (o4 ? ru(o4) : _o(i5, s3)) {
                    wf = pf, xf = null;
                    var c5 = u5.sibling;
                    if (null !== c5) ff = c5;
                    else {
                      var f4 = u5.return;
                      null !== f4 ? (ff = f4, Vl(f4)) : ff = null;
                    }
                    break n;
                  }
                  break;
                default:
                  console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
              }
              wf = pf, xf = null, Bl(e5, n8, a6);
              break;
            case vf:
              wf = pf, xf = null, Bl(e5, n8, a6);
              break;
            case kf:
              Nl(), Pf = uf;
              break e;
            default:
              throw Error("Unexpected SuspendedReason. This is a bug in React.");
          }
          null !== Ja.actQueue ? Hl() : jl();
          break;
        } catch (n9) {
          Ul(e5, n9);
        }
        return nr(), Ja.H = r7, Ja.A = l4, sf = t6, null !== ff ? nf : (cf = null, df = 0, O(), Pf);
      }(e4, n7) : Wl(e4, n7);
      if (r6 !== nf) for (var l3 = t5; ; ) {
        if (r6 === uf) Tl(e4, n7, 0);
        else {
          if (t5 = e4.current.alternate, l3 && !Rl(t5)) {
            r6 = Wl(e4, n7), l3 = false;
            continue;
          }
          if (r6 === rf) {
            if (l3 = n7, e4.errorRecoveryDisabledLanes & l3) var a5 = 0;
            else a5 = 0 != (a5 = -536870913 & e4.pendingLanes) ? a5 : 536870912 & a5 ? 536870912 : 0;
            if (0 !== a5) {
              n7 = a5;
              e: {
                r6 = e4;
                var o3 = a5;
                a5 = Uf;
                var u4 = So;
                if (u4 && (Ll(r6, o3).flags |= 256), (o3 = Wl(r6, o3)) !== rf) {
                  if (Cf && !u4) {
                    r6.errorRecoveryDisabledLanes |= l3, Rf |= l3, r6 = af;
                    break e;
                  }
                  r6 = Df, Df = a5, null !== r6 && Pl(r6);
                }
                r6 = o3;
              }
              if (l3 = false, r6 !== rf) continue;
            }
          }
          if (r6 === tf) {
            Ll(e4, 0), Tl(e4, n7, 0);
            break;
          }
          e: {
            switch (l3 = e4, r6) {
              case nf:
              case tf:
                throw Error("Root did not complete. This is a bug in React.");
              case af:
                if ((4194176 & n7) === n7) {
                  Tl(l3, n7, Nf);
                  break e;
                }
                break;
              case rf:
                Df = null;
                break;
              case lf:
              case of:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (l3.finishedWork = t5, l3.finishedLanes = n7, null !== Ja.actQueue) ql(l3, Df, jf, If, Nf);
            else {
              if ((62914560 & n7) === n7 && 10 < (r6 = Ff + Mf - vu())) {
                if (Tl(l3, n7, Nf), 0 !== w(l3, 0)) break e;
                l3.timeoutHandle = go(_l.bind(null, l3, t5, Df, jf, If, n7, Nf, Rf, Lf, zf, ld, -0, 0), r6);
                break e;
              }
              _l(l3, t5, Df, jf, If, n7, Nf, Rf, Lf, zf, td, -0, 0);
            }
          }
        }
        break;
      }
      le(e4);
    }
    function Pl(e4) {
      null === Df ? Df = e4 : Df.push.apply(Df, e4);
    }
    function _l(e4, n7, t5, r6, l3, a5, o3, u4, i5, s3, c5, f4, d3) {
      if ((8192 & (s3 = n7.subtreeFlags) || 16785408 == (16785408 & s3)) && (Ro(), hl(n7), null !== (n7 = No()))) return e4.cancelPendingCommit = n7(ql.bind(null, e4, t5, r6, l3, o3, u4, i5, rd, f4, d3)), void Tl(e4, a5, o3);
      ql(e4, t5, r6, l3, o3);
    }
    function Rl(e4) {
      for (var n7 = e4; ; ) {
        var t5 = n7.tag;
        if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n7.flags && null !== (t5 = n7.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
          var l3 = t5[r6], a5 = l3.getSnapshot;
          l3 = l3.value;
          try {
            if (!Ru(a5(), l3)) return false;
          } catch (e5) {
            return false;
          }
        }
        if (t5 = n7.child, 16384 & n7.subtreeFlags && null !== t5) t5.return = n7, n7 = t5;
        else {
          if (n7 === e4) break;
          for (; null === n7.sibling; ) {
            if (null === n7.return || n7.return === e4) return true;
            n7 = n7.return;
          }
          n7.sibling.return = n7.return, n7 = n7.sibling;
        }
      }
      return true;
    }
    function Tl(e4, n7, t5) {
      n7 &= ~Tf, n7 &= ~Rf, e4.suspendedLanes |= n7, e4.pingedLanes &= ~n7;
      for (var r6 = e4.expirationTimes, l3 = n7; 0 < l3; ) {
        var a5 = 31 - cu(l3), o3 = 1 << a5;
        r6[a5] = -1, l3 &= ~o3;
      }
      0 !== t5 && _(e4, t5, n7);
    }
    function Nl() {
      if (null !== ff) {
        if (wf === pf) var e4 = ff.return;
        else e4 = ff, nr(), an(e4), rs = null, ls = 0, e4 = ff;
        for (; null !== e4; ) zr(e4.alternate, e4), e4 = e4.return;
        ff = null;
      }
    }
    function Ll(e4, n7) {
      e4.finishedWork = null, e4.finishedLanes = 0;
      var t5 = e4.timeoutHandle;
      t5 !== bo && (e4.timeoutHandle = bo, yo(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), Nl(), cf = e4, ff = t5 = fa(e4.current, null), df = n7, wf = pf, xf = null, Cf = zf = false, Pf = nf, Lf = Nf = Tf = Rf = _f = 0, Df = Uf = null, If = false, 0 != (8 & n7) && (n7 |= 32 & n7);
      var r6 = e4.entangledLanes;
      if (0 !== r6) for (e4 = e4.entanglements, r6 &= n7; 0 < r6; ) {
        var l3 = 31 - cu(r6), a5 = 1 << l3;
        n7 |= e4[l3], r6 &= ~a5;
      }
      return Ef = n7, O(), xi.discardPendingWarnings(), t5;
    }
    function Ul(e4, n7) {
      Ts = null, Ja.H = $s, Ja.getCurrentStack = null, ro = false, to = null, n7 === Di ? (n7 = Re(), wf = Dl() && 0 == (134217727 & _f) && 0 == (134217727 & Rf) ? hf : gf) : n7 === Ii ? (n7 = Re(), wf = yf) : wf = n7 === dc ? kf : null !== n7 && "object" == typeof n7 && "function" == typeof n7.then ? vf : mf, xf = n7;
      var t5 = ff;
      null === t5 ? (Pf = tf, Et(e4, D(n7, e4.current))) : 2 & t5.mode && Z(t5);
    }
    function Dl() {
      var e4 = hs.current;
      return null === e4 || ((4194176 & df) === df ? null === gs : ((62914560 & df) === df || 0 != (536870912 & df)) && e4 === gs);
    }
    function Il() {
      var e4 = Ja.H;
      return Ja.H = $s, null === e4 ? $s : e4;
    }
    function Fl() {
      var e4 = Ja.A;
      return Ja.A = Gc, e4;
    }
    function Ml() {
      Pf = af, 0 == (134217727 & _f) && 0 == (134217727 & Rf) || null === cf || Tl(cf, df, Nf);
    }
    function Wl(e4, n7) {
      var t5 = sf;
      sf |= Zc;
      var r6 = Il(), l3 = Fl();
      if (cf !== e4 || df !== n7) {
        if (_u) {
          var a5 = e4.memoizedUpdaters;
          0 < a5.size && (ia(e4, df), a5.clear()), N(e4, n7);
        }
        jf = null, Ll(e4, n7);
      }
      n7 = false;
      e: for (; ; ) try {
        if (wf !== pf && null !== ff) {
          a5 = ff;
          var o3 = xf;
          switch (wf) {
            case kf:
              Nl(), Pf = uf;
              break e;
            case gf:
            case hf:
              n7 || null !== hs.current || (n7 = true);
            default:
              wf = pf, xf = null, Bl(e4, a5, o3);
          }
        }
        Hl();
        break;
      } catch (n8) {
        Ul(e4, n8);
      }
      if (n7 && e4.shellSuspendCounter++, nr(), sf = t5, Ja.H = r6, Ja.A = l3, null !== ff) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return cf = null, df = 0, O(), Pf;
    }
    function Hl() {
      for (; null !== ff; ) Al(ff);
    }
    function jl() {
      for (; null !== ff && !yu(); ) Al(ff);
    }
    function Al(e4) {
      var n7 = e4.alternate;
      (2 & e4.mode) !== $u ? (X(e4), n7 = y3(e4, er, n7, e4, Ef), Z(e4)) : n7 = y3(e4, er, n7, e4, Ef), e4.memoizedProps = e4.pendingProps, null === n7 ? Vl(e4) : ff = n7;
    }
    function Ql(e4) {
      var n7 = y3(e4, Ol, e4);
      e4.memoizedProps = e4.pendingProps, null === n7 ? Vl(e4) : ff = n7;
    }
    function Ol(e4) {
      var n7 = e4.alternate, t5 = (2 & e4.mode) !== $u;
      switch (t5 && X(e4), e4.tag) {
        case 15:
        case 0:
          n7 = Ht(n7, e4, e4.pendingProps, e4.type, void 0, df);
          break;
        case 11:
          n7 = Ht(n7, e4, e4.pendingProps, e4.type.render, e4.ref, df);
          break;
        case 5:
          an(e4);
        default:
          zr(n7, e4), n7 = er(n7, e4 = ff = da(e4, Ef), Ef);
      }
      return t5 && Z(e4), n7;
    }
    function Bl(e4, n7, t5) {
      nr(), an(n7), rs = null, ls = 0;
      var r6 = n7.return;
      try {
        if (function(e5, n8, t6, r7, l3) {
          if (t6.flags |= 32768, _u && ia(e5, l3), null !== r7 && "object" == typeof r7 && "function" == typeof r7.then) {
            if (null !== (n8 = t6.alternate) && or(n8, t6, l3, true), null !== (t6 = hs.current)) {
              switch (t6.tag) {
                case 13:
                  return null === gs ? Ml() : null === t6.alternate && Pf === nf && (Pf = lf), t6.flags &= -257, t6.flags |= 65536, t6.lanes = l3, r7 === Fi ? t6.flags |= 16384 : (null === (n8 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([r7]) : n8.add(r7), Zl(e5, r7, l3)), false;
                case 22:
                  return t6.flags |= 65536, r7 === Fi ? t6.flags |= 16384 : (null === (n8 = t6.updateQueue) ? (n8 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([r7]) }, t6.updateQueue = n8) : null === (t6 = n8.retryQueue) ? n8.retryQueue = /* @__PURE__ */ new Set([r7]) : t6.add(r7), Zl(e5, r7, l3)), false;
              }
              throw Error("Unexpected Suspense handler tag (" + t6.tag + "). This is a bug in React.");
            }
            return Zl(e5, r7, l3), Ml(), false;
          }
          var a5 = D(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: r7 }), t6);
          if (null === Uf ? Uf = [a5] : Uf.push(a5), Pf !== af && (Pf = rf), null === n8) return true;
          r7 = D(r7, t6), t6 = n8;
          do {
            switch (t6.tag) {
              case 3:
                return t6.flags |= 65536, e5 = l3 & -l3, t6.lanes |= e5, ve(t6, e5 = _t(t6.stateNode, r7, e5)), false;
              case 1:
                if (n8 = t6.type, a5 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n8.getDerivedStateFromError || null !== a5 && "function" == typeof a5.componentDidCatch && (null === Af || !Af.has(a5)))) return t6.flags |= 65536, l3 &= -l3, t6.lanes |= l3, Tt(l3 = Rt(l3), e5, t6, r7), ve(t6, l3), false;
            }
            t6 = t6.return;
          } while (null !== t6);
          return false;
        }(e4, r6, n7, t5, df)) return Pf = tf, Et(e4, D(t5, e4.current)), void (ff = null);
      } catch (n8) {
        if (null !== r6) throw ff = r6, n8;
        return Pf = tf, Et(e4, D(t5, e4.current)), void (ff = null);
      }
      32768 & n7.flags ? $l(n7, true) : Vl(n7);
    }
    function Vl(e4) {
      var n7 = e4;
      do {
        if (0 != (32768 & n7.flags)) return void $l(n7, zf);
        var t5 = n7.alternate;
        if (e4 = n7.return, X(n7), t5 = y3(n7, wr, t5, n7, Ef), (2 & n7.mode) !== $u && ee(n7), null !== t5) return void (ff = t5);
        if (null !== (n7 = n7.sibling)) return void (ff = n7);
        ff = n7 = e4;
      } while (null !== n7);
      Pf === nf && (Pf = of);
    }
    function $l(e4, n7) {
      do {
        var t5 = xr(e4.alternate, e4);
        if (null !== t5) return t5.flags &= 32767, void (ff = t5);
        if ((2 & e4.mode) !== $u) {
          ee(e4), t5 = e4.actualDuration;
          for (var r6 = e4.child; null !== r6; ) t5 += r6.actualDuration, r6 = r6.sibling;
          e4.actualDuration = t5;
        }
        if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n7 && null !== (e4 = e4.sibling)) return void (ff = e4);
        ff = e4 = t5;
      } while (null !== e4);
      Pf = uf, ff = null;
    }
    function ql(e4, n7, t5, r6, l3, a5, o3, u4, i5, s3) {
      var c5 = Ja.T, f4 = xo();
      try {
        wo(2), Ja.T = null, function(e5, n8, t6, r7, l4, a6) {
          do {
            Jl();
          } while (null !== Of);
          if (xi.flushLegacyContextWarning(), xi.flushPendingUnsafeLifecycleWarnings(), (sf & (Zc | ef)) !== Xc) throw Error("Should not already be working.");
          var o4 = e5.finishedWork;
          if (r7 = e5.finishedLanes, null === o4) return null;
          if (0 === r7 && console.error("root.finishedLanes should not be empty during a commit. This is a bug in React."), e5.finishedWork = null, e5.finishedLanes = 0, o4 === e5.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          e5.callbackNode = null, e5.callbackPriority = 0, e5.cancelPendingCommit = null;
          var u5, i6, s4, c6 = o4.lanes | o4.childLanes;
          if (function(e6, n9, t7, r8) {
            var l5 = e6.pendingLanes;
            e6.pendingLanes = t7, e6.suspendedLanes = 0, e6.pingedLanes = 0, e6.warmLanes = 0, e6.expiredLanes &= t7, e6.entangledLanes &= t7, e6.errorRecoveryDisabledLanes &= t7, e6.shellSuspendCounter = 0, n9 = e6.entanglements;
            var a7 = e6.expirationTimes, o5 = e6.hiddenUpdates;
            for (t7 = l5 & ~t7; 0 < t7; ) {
              var u6 = 31 - cu(t7);
              l5 = 1 << u6, n9[u6] = 0, a7[u6] = -1;
              var i7 = o5[u6];
              if (null !== i7) for (o5[u6] = null, u6 = 0; u6 < i7.length; u6++) {
                var s5 = i7[u6];
                null !== s5 && (s5.lane &= -536870913);
              }
              t7 &= ~l5;
            }
            0 !== r8 && _(e6, r8, 0);
          }(e5, r7, c6 |= Gu, a6), e5 === cf && (ff = cf = null, df = 0), 0 == (10256 & o4.subtreeFlags) && 0 == (10256 & o4.flags) || Qf || (Qf = true, Vf = c6, $f = t6, u5 = wu, i6 = function() {
            return Jl(), null;
          }, null !== (s4 = Ja.actQueue) ? s4.push(i6) : hu(u5, i6)), Ku = Ju(), t6 = 0 != (15990 & o4.flags), 0 != (15990 & o4.subtreeFlags) || t6) {
            t6 = Ja.T, Ja.T = null, a6 = xo(), wo(2);
            var f5 = sf;
            sf |= ef, function(e6, n9) {
              for (io(e6.containerInfo), Ac = n9; null !== Ac; ) if (n9 = (e6 = Ac).child, 0 != (1028 & e6.subtreeFlags) && null !== n9) n9.return = e6, Ac = n9;
              else for (; null !== Ac; ) {
                var t7 = (n9 = e6 = Ac).alternate, r8 = n9.flags;
                switch (n9.tag) {
                  case 0:
                  case 11:
                  case 15:
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  case 1:
                    0 != (1024 & r8) && null !== t7 && Dr(n9, t7);
                    break;
                  case 3:
                    0 != (1024 & r8) && vo && Go(n9.stateNode.containerInfo);
                    break;
                  default:
                    if (0 != (1024 & r8)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
                if (null !== (n9 = e6.sibling)) {
                  n9.return = e6.return, Ac = n9;
                  break;
                }
                Ac = e6.return;
              }
              e6 = Bc, Bc = false;
            }(e5, o4), function(e6, n9, t7) {
              Qc = t7, Oc = e6, Zr(n9, e6), Oc = Qc = null;
            }(e5, o4, r7), so(e5.containerInfo), e5.current = o4, function(e6, n9, t7) {
              Qc = t7, Oc = n9, qr(n9, e6.alternate, e6), Oc = Qc = null;
            }(o4, e5, r7), bu(), sf = f5, wo(a6), Ja.T = t6;
          } else e5.current = o4;
          if ((t6 = Qf) ? (Qf = false, Of = e5, Bf = r7) : (Gl(e5, c6), Zf = 0, ed = null), 0 === (c6 = e5.pendingLanes) && (Af = null), t6 || oa(e5), o4.stateNode, _u && e5.memoizedUpdaters.clear(), le(e5), null !== n8) for (l4 = e5.onRecoverableError, o4 = 0; o4 < n8.length; o4++) t6 = Yl((c6 = n8[o4]).stack), y3(c6.source, l4, c6.value, t6);
          0 != (3 & Bf) && Jl(), c6 = e5.pendingLanes, 0 != (4194218 & r7) && 0 != (42 & c6) ? (ni = true, e5 === Gf ? Yf++ : (Yf = 0, Gf = e5)) : Yf = 0, ae(0);
        }(e4, n7, t5, r6, f4, l3);
      } finally {
        Ja.T = c5, wo(f4);
      }
    }
    function Yl(e4) {
      return e4 = { componentStack: e4 }, Object.defineProperty(e4, "digest", { get: function() {
        console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
      } }), e4;
    }
    function Gl(e4, n7) {
      0 == (e4.pooledCacheLanes &= n7) && null != (n7 = e4.pooledCache) && (e4.pooledCache = null, mr(n7));
    }
    function Jl() {
      if (null !== Of) {
        var e4 = Of, n7 = Vf;
        Vf = 0;
        var t5 = L(Bf), r6 = 32 > t5 ? 32 : t5;
        t5 = Ja.T;
        var l3 = xo();
        try {
          if (wo(r6), Ja.T = null, null === Of) var a5 = false;
          else {
            r6 = $f, $f = null;
            var o3 = Of, u4 = Bf;
            if (Of = null, Bf = 0, (sf & (Zc | ef)) !== Xc) throw Error("Cannot flush passive effects while already rendering.");
            Jf = true, Kf = false, null !== Pu && "function" == typeof Pu.markPassiveEffectsStarted && Pu.markPassiveEffectsStarted(u4);
            var i5 = sf;
            sf |= ef, bl(o3.current), cl(o3, o3.current, u4, r6), null !== Pu && "function" == typeof Pu.markPassiveEffectsStopped && Pu.markPassiveEffectsStopped(), oa(o3), sf = i5, ae(0), Kf ? o3 === ed ? Zf++ : (Zf = 0, ed = o3) : Zf = 0, Kf = Jf = false, Eu && Eu.onPostCommitFiberRoot;
            var s3 = o3.current.stateNode;
            s3.effectDuration = 0, s3.passiveEffectDuration = 0, a5 = true;
          }
          return a5;
        } finally {
          wo(l3), Ja.T = t5, Gl(e4, n7);
        }
      }
      return false;
    }
    function Kl(e4, n7, t5) {
      n7 = D(t5, n7), null !== (e4 = ye(e4, n7 = _t(e4.stateNode, n7, 2), 2)) && (P(e4, 2), le(e4));
    }
    function Xl(e4, n7, t5) {
      if (nd = false, 3 === e4.tag) Kl(e4, e4, t5);
      else {
        for (; null !== n7; ) {
          if (3 === n7.tag) return void Kl(n7, e4, t5);
          if (1 === n7.tag) {
            var r6 = n7.stateNode;
            if ("function" == typeof n7.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === Af || !Af.has(r6))) return e4 = D(t5, e4), void (null !== (r6 = ye(n7, t5 = Rt(2), 2)) && (Tt(t5, r6, n7, e4), P(r6, 2), le(r6)));
          }
          n7 = n7.return;
        }
        console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", t5);
      }
    }
    function Zl(e4, n7, t5) {
      var r6 = e4.pingCache;
      if (null === r6) {
        r6 = e4.pingCache = new Kc();
        var l3 = /* @__PURE__ */ new Set();
        r6.set(n7, l3);
      } else void 0 === (l3 = r6.get(n7)) && (l3 = /* @__PURE__ */ new Set(), r6.set(n7, l3));
      l3.has(t5) || (Cf = true, l3.add(t5), r6 = ea.bind(null, e4, n7, t5), _u && ia(e4, t5), n7.then(r6, r6));
    }
    function ea(e4, n7, t5) {
      var r6 = e4.pingCache;
      null !== r6 && r6.delete(n7), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, wl() && null === Ja.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"), cf === e4 && (df & t5) === t5 && (Pf === af || Pf === lf && (62914560 & df) === df && vu() - Ff < Mf ? (sf & Zc) === Xc && Ll(e4, 0) : Tf |= t5, Lf === df && (Lf = 0)), le(e4);
    }
    function na(e4, n7) {
      0 === n7 && (n7 = C()), null !== (e4 = $(e4, n7)) && (P(e4, n7), le(e4));
    }
    function ta(e4) {
      var n7 = e4.memoizedState, t5 = 0;
      null !== n7 && (t5 = n7.retryLane), na(e4, t5);
    }
    function ra(e4, n7) {
      var t5 = 0;
      switch (e4.tag) {
        case 13:
          var r6 = e4.stateNode, l3 = e4.memoizedState;
          null !== l3 && (t5 = l3.retryLane);
          break;
        case 19:
          r6 = e4.stateNode;
          break;
        case 22:
          r6 = e4.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      null !== r6 && r6.delete(n7), na(e4, t5);
    }
    function la(e4, n7, t5) {
      if (0 != (33562624 & n7.subtreeFlags)) for (n7 = n7.child; null !== n7; ) {
        var r6 = e4, l3 = n7, a5 = l3.type === Fa;
        a5 = t5 || a5, 22 !== l3.tag ? 33554432 & l3.flags ? a5 && y3(l3, aa, r6, l3, (64 & l3.mode) === $u) : la(r6, l3, a5) : null === l3.memoizedState && (a5 && 8192 & l3.flags ? y3(l3, aa, r6, l3) : 33554432 & l3.subtreeFlags && y3(l3, la, r6, l3, a5)), n7 = n7.sibling;
      }
    }
    function aa(e4, n7) {
      var t5 = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2];
      U(true);
      try {
        rl(n7), t5 && Sl(n7), al(e4, n7.alternate, n7, false), t5 && dl(e4, n7, 0, null, false);
      } finally {
        U(false);
      }
    }
    function oa(e4) {
      var n7 = true;
      24 & e4.current.mode || (n7 = false), la(e4, e4.current, n7);
    }
    function ua(e4) {
      if ((sf & Zc) === Xc) {
        var n7 = e4.tag;
        if (3 === n7 || 1 === n7 || 0 === n7 || 11 === n7 || 14 === n7 || 15 === n7) {
          if (n7 = c4(e4) || "ReactComponent", null !== ad) {
            if (ad.has(n7)) return;
            ad.add(n7);
          } else ad = /* @__PURE__ */ new Set([n7]);
          y3(e4, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function ia(e4, n7) {
      _u && e4.memoizedUpdaters.forEach(function(t5) {
        T(e4, t5, n7);
      });
    }
    function sa(e4, n7, t5, r6) {
      this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n7, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = false, this._debugHookTypes = null, id || "function" != typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function ca(e4) {
      return !(!(e4 = e4.prototype) || !e4.isReactComponent);
    }
    function fa(e4, n7) {
      var r6 = e4.alternate;
      switch (null === r6 ? ((r6 = t4(e4.tag, n7, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6._debugOwner = e4._debugOwner, r6._debugHookTypes = e4._debugHookTypes, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n7, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null, r6.actualDuration = -0, r6.actualStartTime = -1.1), r6.flags = 31457280 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n7 = e4.dependencies, r6.dependencies = null === n7 ? null : { lanes: n7.lanes, firstContext: n7.firstContext, _debugThenableState: n7._debugThenableState }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6.selfBaseDuration = e4.selfBaseDuration, r6.treeBaseDuration = e4.treeBaseDuration, r6._debugInfo = e4._debugInfo, r6._debugNeedsRemount = e4._debugNeedsRemount, r6.tag) {
        case 0:
        case 15:
        case 1:
        case 11:
          r6.type = e4.type;
      }
      return r6;
    }
    function da(e4, n7) {
      e4.flags &= 31457282;
      var t5 = e4.alternate;
      return null === t5 ? (e4.childLanes = 0, e4.lanes = n7, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null, e4.selfBaseDuration = 0, e4.treeBaseDuration = 0) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n7 = t5.dependencies, e4.dependencies = null === n7 ? null : { lanes: n7.lanes, firstContext: n7.firstContext, _debugThenableState: n7._debugThenableState }, e4.selfBaseDuration = t5.selfBaseDuration, e4.treeBaseDuration = t5.treeBaseDuration), e4;
    }
    function pa(e4, n7, r6, l3, a5, o3) {
      var u4 = 0, i5 = e4;
      if ("function" == typeof e4) ca(e4) && (u4 = 1);
      else if ("string" == typeof e4) u4 = 5;
      else e: switch (e4) {
        case Ia:
          return ha(r6.children, a5, o3, n7);
        case Fa:
          u4 = 8, a5 |= 24;
          break;
        case Ma:
          return l3 = a5, "string" != typeof (e4 = r6).id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e4.id), (n7 = t4(12, e4, n7, 2 | l3)).elementType = Ma, n7.lanes = o3, n7.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, n7;
        case Qa:
          return (n7 = t4(13, r6, n7, a5)).elementType = Qa, n7.lanes = o3, n7;
        case Oa:
          return (n7 = t4(19, r6, n7, a5)).elementType = Oa, n7.lanes = o3, n7;
        case $a:
          return ga(r6, a5, o3, n7);
        default:
          if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
            case Wa:
            case ja:
              u4 = 10;
              break e;
            case Ha:
              u4 = 9;
              break e;
            case Aa:
              u4 = 11;
              break e;
            case Ba:
              u4 = 14;
              break e;
            case Va:
              u4 = 16, i5 = null;
              break e;
          }
          i5 = "", (void 0 === e4 || "object" == typeof e4 && null !== e4 && 0 === Object.keys(e4).length) && (i5 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), null === e4 ? r6 = "null" : lo(e4) ? r6 = "array" : void 0 !== e4 && e4.$$typeof === Ua ? (r6 = "<" + (s2(e4.type) || "Unknown") + " />", i5 = " Did you accidentally export a JSX literal instead of a component?") : r6 = typeof e4, (u4 = l3 ? "number" == typeof l3.tag ? c4(l3) : "string" == typeof l3.name ? l3.name : null : null) && (i5 += "\n\nCheck the render method of `" + u4 + "`."), u4 = 29, r6 = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + r6 + "." + i5), i5 = null;
      }
      return (n7 = t4(u4, r6, n7, a5)).elementType = e4, n7.type = i5, n7.lanes = o3, n7._debugOwner = l3, n7;
    }
    function ma(e4, n7, t5) {
      return (n7 = pa(e4.type, e4.key, e4.props, e4._owner, n7, t5))._debugOwner = e4._owner, n7;
    }
    function ha(e4, n7, r6, l3) {
      return (e4 = t4(7, e4, l3, n7)).lanes = r6, e4;
    }
    function ga(e4, n7, r6, l3) {
      (e4 = t4(22, e4, l3, n7)).elementType = $a, e4.lanes = r6;
      var a5 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function() {
        var e5 = a5, n8 = e5._current;
        if (null === n8) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 == (2 & e5._pendingVisibility)) {
          var t5 = $(n8, 2);
          null !== t5 && (e5._pendingVisibility |= 2, Cl(t5, n8, 2));
        }
      }, attach: function() {
        var e5 = a5, n8 = e5._current;
        if (null === n8) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 != (2 & e5._pendingVisibility)) {
          var t5 = $(n8, 2);
          null !== t5 && (e5._pendingVisibility &= -3, Cl(t5, n8, 2));
        }
      } };
      return e4.stateNode = a5, e4;
    }
    function ya(e4, n7, r6) {
      return (e4 = t4(6, e4, null, n7)).lanes = r6, e4;
    }
    function ba(e4, n7, r6) {
      return (n7 = t4(4, null !== e4.children ? e4.children : [], e4.key, n7)).lanes = r6, n7.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n7;
    }
    function va(e4, n7, t5, r6, l3, a5, o3, u4) {
      for (this.tag = 1, this.containerInfo = e4, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = bo, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = E(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = E(0), this.hiddenUpdates = E(null), this.identifierPrefix = r6, this.onUncaughtError = l3, this.onCaughtError = a5, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u4, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), e4 = this.pendingUpdatersLaneMap = [], n7 = 0; 31 > n7; n7++) e4.push(/* @__PURE__ */ new Set());
      this._debugRootType = t5 ? "hydrateRoot()" : "createRoot()";
    }
    function Sa(e4, n7, t5, r6, l3, a5) {
      l3 = function(e5) {
        return e5 ? e5 = su : su;
      }(l3), null === r6.context ? r6.context = l3 : r6.pendingContext = l3, ro && null !== to && !cd && (cd = true, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", c4(to) || "Unknown")), (r6 = ge(n7)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && ("function" != typeof a5 && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", a5), r6.callback = a5), null !== (t5 = ye(e4, r6, n7)) && (Cl(t5, e4, n7), be(t5, e4, n7));
    }
    var ka, wa, xa, za, Ca, Ea, Pa, _a = {}, Ra = import_react.default, Ta = u, Na = Object.assign, La = Symbol.for("react.element"), Ua = Symbol.for("react.transitional.element"), Da = Symbol.for("react.portal"), Ia = Symbol.for("react.fragment"), Fa = Symbol.for("react.strict_mode"), Ma = Symbol.for("react.profiler"), Wa = Symbol.for("react.provider"), Ha = Symbol.for("react.consumer"), ja = Symbol.for("react.context"), Aa = Symbol.for("react.forward_ref"), Qa = Symbol.for("react.suspense"), Oa = Symbol.for("react.suspense_list"), Ba = Symbol.for("react.memo"), Va = Symbol.for("react.lazy"), $a = Symbol.for("react.offscreen"), qa = Symbol.for("react.memo_cache_sentinel"), Ya = Symbol.iterator, Ga = Symbol.for("react.client.reference"), Ja = Ra.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ka = 0;
    f3.__reactDisabledLog = true;
    var Xa, Za, eo = false, no = new ("function" == typeof WeakMap ? WeakMap : Map)(), to = null, ro = false, lo = Array.isArray, ao = n6.getPublicInstance, oo = n6.getRootHostContext, uo = n6.getChildHostContext, io = n6.prepareForCommit, so = n6.resetAfterCommit, co = n6.createInstance, fo = n6.appendInitialChild, po = n6.finalizeInitialChildren, mo = n6.shouldSetTextContent, ho = n6.createTextInstance, go = null, yo = null, bo = n6.noTimeout, vo = true, So = null, ko = null, wo = n6.setCurrentUpdatePriority, xo = n6.getCurrentUpdatePriority, zo = n6.resolveUpdatePriority;
    n6.resolveEventType, n6.resolveEventTimeStamp;
    var Co = n6.shouldAttemptEagerTransition, Eo = n6.detachDeletedInstance;
    n6.requestPostPaintCallback;
    var Po = n6.maySuspendCommit, _o = null, Ro = null, To = null, No = null, Lo = null, Uo = null, Do = null, Io = n6.appendChild, Fo = n6.appendChildToContainer, Mo = n6.commitTextUpdate, Wo = null, Ho = n6.commitUpdate, jo = n6.insertBefore, Ao = null, Qo = n6.removeChild, Oo = n6.removeChildFromContainer, Bo = n6.resetTextContent, Vo = null, $o = null, qo = null, Yo = null, Go = n6.clearContainer, Jo = null, Ko = null, Xo = null, Zo = null, eu = null, nu = null, tu = null, ru = null, lu = null, au = null, ou = [], uu = [], iu = -1, su = {};
    Object.freeze(su);
    var cu = Math.clz32 ? Math.clz32 : function(e4) {
      return 0 == (e4 >>>= 0) ? 32 : 31 - (fu(e4) / du | 0) | 0;
    }, fu = Math.log, du = Math.LN2, pu = 128, mu = 4194304, hu = Ta.unstable_scheduleCallback, gu = Ta.unstable_cancelCallback, yu = Ta.unstable_shouldYield, bu = Ta.unstable_requestPaint, vu = Ta.unstable_now, Su = Ta.unstable_ImmediatePriority, ku = Ta.unstable_UserBlockingPriority, wu = Ta.unstable_NormalPriority, xu = Ta.unstable_IdlePriority, zu = Ta.log, Cu = Ta.unstable_setDisableYieldValue, Eu = null, Pu = null, _u = "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, Ru = "function" == typeof Object.is ? Object.is : function(e4, n7) {
      return e4 === n7 && (0 !== e4 || 1 / e4 == 1 / n7) || e4 != e4 && n7 != n7;
    }, Tu = /* @__PURE__ */ new WeakMap(), Nu = [], Lu = 0, Uu = null, Du = 0, Iu = [], Fu = 0, Mu = null, Wu = 1, Hu = "", ju = b3(null), Au = b3(null), Qu = b3(null), Ou = b3(null), Bu = false, Vu = null, $u = 0, qu = [], Yu = 0, Gu = 0, Ju = Ta.unstable_now, Ku = -0, Xu = -1.1, Zu = -0, ei = false, ni = false, ti = null, ri = null, li = false, ai = false, oi = false, ui = false, ii = 0, si = {}, ci = null, fi = 0, di = 0, pi = null, mi = 0, hi = 1, gi = 2, yi = 3, bi = false, vi = false, Si = null, ki = false, wi = Object.prototype.hasOwnProperty, xi = { recordUnsafeLifecycleWarnings: function() {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function() {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } }, zi = [], Ci = [], Ei = [], Pi = [], _i = [], Ri = [], Ti = /* @__PURE__ */ new Set();
    xi.recordUnsafeLifecycleWarnings = function(e4, n7) {
      Ti.has(e4.type) || ("function" == typeof n7.componentWillMount && true !== n7.componentWillMount.__suppressDeprecationWarning && zi.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillMount && Ci.push(e4), "function" == typeof n7.componentWillReceiveProps && true !== n7.componentWillReceiveProps.__suppressDeprecationWarning && Ei.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillReceiveProps && Pi.push(e4), "function" == typeof n7.componentWillUpdate && true !== n7.componentWillUpdate.__suppressDeprecationWarning && _i.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillUpdate && Ri.push(e4));
    }, xi.flushPendingUnsafeLifecycleWarnings = function() {
      var e4 = /* @__PURE__ */ new Set();
      0 < zi.length && (zi.forEach(function(n8) {
        e4.add(c4(n8) || "Component"), Ti.add(n8.type);
      }), zi = []);
      var n7 = /* @__PURE__ */ new Set();
      0 < Ci.length && (Ci.forEach(function(e5) {
        n7.add(c4(e5) || "Component"), Ti.add(e5.type);
      }), Ci = []);
      var t5 = /* @__PURE__ */ new Set();
      0 < Ei.length && (Ei.forEach(function(e5) {
        t5.add(c4(e5) || "Component"), Ti.add(e5.type);
      }), Ei = []);
      var r6 = /* @__PURE__ */ new Set();
      0 < Pi.length && (Pi.forEach(function(e5) {
        r6.add(c4(e5) || "Component"), Ti.add(e5.type);
      }), Pi = []);
      var l3 = /* @__PURE__ */ new Set();
      0 < _i.length && (_i.forEach(function(e5) {
        l3.add(c4(e5) || "Component"), Ti.add(e5.type);
      }), _i = []);
      var a5 = /* @__PURE__ */ new Set();
      if (0 < Ri.length && (Ri.forEach(function(e5) {
        a5.add(c4(e5) || "Component"), Ti.add(e5.type);
      }), Ri = []), 0 < n7.size) {
        var u4 = o2(n7);
        console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", u4);
      }
      0 < r6.size && (u4 = o2(r6), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", u4)), 0 < a5.size && (u4 = o2(a5), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", u4)), 0 < e4.size && (u4 = o2(e4), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4)), 0 < t5.size && (u4 = o2(t5), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4)), 0 < l3.size && (u4 = o2(l3), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4));
    };
    var Ni = /* @__PURE__ */ new Map(), Li = /* @__PURE__ */ new Set();
    xi.recordLegacyContextWarning = function(e4, n7) {
      for (var t5 = null, r6 = e4; null !== r6; ) 8 & r6.mode && (t5 = r6), r6 = r6.return;
      null === t5 ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !Li.has(e4.type) && (r6 = Ni.get(t5), null != e4.type.contextTypes || null != e4.type.childContextTypes || null !== n7 && "function" == typeof n7.getChildContext) && (void 0 === r6 && (r6 = [], Ni.set(t5, r6)), r6.push(e4));
    }, xi.flushLegacyContextWarning = function() {
      Ni.forEach(function(e4) {
        if (0 !== e4.length) {
          var n7 = e4[0], t5 = /* @__PURE__ */ new Set();
          e4.forEach(function(e5) {
            t5.add(c4(e5) || "Component"), Li.add(e5.type);
          });
          var r6 = o2(t5);
          y3(n7, function() {
            console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", r6);
          });
        }
      });
    }, xi.discardPendingWarnings = function() {
      zi = [], Ci = [], Ei = [], Pi = [], _i = [], Ri = [], Ni = /* @__PURE__ */ new Map();
    };
    var Ui, Di = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"), Ii = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), Fi = { then: function() {
      console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
    } }, Mi = null, Wi = false, Hi = { "react-stack-bottom-frame": function(e4, n7, t5) {
      var r6 = ro;
      ro = true;
      try {
        return e4(n7, t5);
      } finally {
        ro = r6;
      }
    } }, ji = Hi["react-stack-bottom-frame"].bind(Hi), Ai = { "react-stack-bottom-frame": function(e4) {
      var n7 = ro;
      ro = true;
      try {
        return e4.render();
      } finally {
        ro = n7;
      }
    } }, Qi = Ai["react-stack-bottom-frame"].bind(Ai), Oi = { "react-stack-bottom-frame": function(e4, n7) {
      try {
        n7.componentDidMount();
      } catch (n8) {
        Xl(e4, e4.return, n8);
      }
    } }, Bi = Oi["react-stack-bottom-frame"].bind(Oi), Vi = { "react-stack-bottom-frame": function(e4, n7, t5, r6, l3) {
      try {
        n7.componentDidUpdate(t5, r6, l3);
      } catch (n8) {
        Xl(e4, e4.return, n8);
      }
    } }, $i = Vi["react-stack-bottom-frame"].bind(Vi), qi = { "react-stack-bottom-frame": function(e4, n7) {
      var t5 = n7.stack;
      e4.componentDidCatch(n7.value, { componentStack: null !== t5 ? t5 : "" });
    } }, Yi = qi["react-stack-bottom-frame"].bind(qi), Gi = { "react-stack-bottom-frame": function(e4, n7, t5) {
      try {
        t5.componentWillUnmount();
      } catch (t6) {
        Xl(e4, n7, t6);
      }
    } }, Ji = Gi["react-stack-bottom-frame"].bind(Gi), Ki = { "react-stack-bottom-frame": function(e4) {
      var n7 = e4.create;
      return e4 = e4.inst, n7 = n7(), e4.destroy = n7;
    } }, Xi = Ki["react-stack-bottom-frame"].bind(Ki), Zi = { "react-stack-bottom-frame": function(e4, n7, t5) {
      try {
        t5();
      } catch (t6) {
        Xl(e4, n7, t6);
      }
    } }, es = Zi["react-stack-bottom-frame"].bind(Zi), ns = { "react-stack-bottom-frame": function(e4) {
      return (0, e4._init)(e4._payload);
    } }, ts = ns["react-stack-bottom-frame"].bind(ns), rs = null, ls = 0, as = null, os = Ui = false, us = {}, is = {}, ss = {};
    a4 = function(e4, n7, t5) {
      if (null !== t5 && "object" == typeof t5 && t5._store && (!t5._store.validated && null == t5.key || 2 === t5._store.validated)) {
        if ("object" != typeof t5._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        t5._store.validated = 1;
        var r6 = c4(e4), l3 = r6 || "null";
        if (!us[l3]) {
          us[l3] = true, t5 = t5._owner, e4 = e4._debugOwner;
          var a5 = "";
          e4 && "number" == typeof e4.tag && (l3 = c4(e4)) && (a5 = "\n\nCheck the render method of `" + l3 + "`."), a5 || r6 && (a5 = "\n\nCheck the top-level render call using <" + r6 + ">.");
          var o3 = "";
          null != t5 && e4 !== t5 && (r6 = null, "number" == typeof t5.tag ? r6 = c4(t5) : "string" == typeof t5.name && (r6 = t5.name), r6 && (o3 = " It was passed a child from " + r6 + ".")), y3(n7, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', a5, o3);
          });
        }
      }
    };
    var cs, fs2 = We(true), ds = We(false), ps = b3(null), ms = b3(0), hs = b3(null), gs = null, ys = 1, bs = 2, vs = b3(0), Ss = 0, ks = 1, ws = 2, xs = 4, zs = 8, Cs = /* @__PURE__ */ new Set(), Es = /* @__PURE__ */ new Set(), Ps = /* @__PURE__ */ new Set(), _s = /* @__PURE__ */ new Set(), Rs = 0, Ts = null, Ns = null, Ls = null, Us = false, Ds = false, Is = false, Fs = 0, Ms = 0, Ws = null, Hs = 0, js = 25, As = null, Qs = null, Os = -1, Bs = false, Vs = function() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }, $s = { readContext: sr, use: cn, useCallback: Ke, useContext: Ke, useEffect: Ke, useImperativeHandle: Ke, useLayoutEffect: Ke, useInsertionEffect: Ke, useMemo: Ke, useReducer: Ke, useRef: Ke, useState: Ke, useDebugValue: Ke, useDeferredValue: Ke, useTransition: Ke, useSyncExternalStore: Ke, useId: Ke };
    $s.useCacheRefresh = Ke, $s.useMemoCache = Ke, $s.useHostTransitionStatus = Ke, $s.useFormState = Ke, $s.useActionState = Ke, $s.useOptimistic = Ke;
    var qs = null, Ys = null, Gs = null, Js = null, Ks = null, Xs = null, Zs = null;
    (qs = { readContext: function(e4) {
      return sr(e4);
    }, use: cn, useCallback: function(e4, n7) {
      return As = "useCallback", qe(), Ge(n7), Kn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", qe(), sr(e4);
    }, useEffect: function(e4, n7) {
      return As = "useEffect", qe(), Ge(n7), $n(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", qe(), Ge(t5), Gn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      As = "useInsertionEffect", qe(), Ge(n7), Bn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", qe(), Ge(n7), qn(e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", qe(), Ge(n7);
      var t5 = Ja.H;
      Ja.H = Ks;
      try {
        return Zn(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", qe();
      var r6 = Ja.H;
      Ja.H = Ks;
      try {
        return pn(e4, n7, t5);
      } finally {
        Ja.H = r6;
      }
    }, useRef: function(e4) {
      return As = "useRef", qe(), On(e4);
    }, useState: function(e4) {
      As = "useState", qe();
      var n7 = Ja.H;
      Ja.H = Ks;
      try {
        return Cn(e4);
      } finally {
        Ja.H = n7;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", qe();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", qe(), nt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", qe(), ut();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", qe(), yn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", qe(), ft();
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", qe(), dt();
    } }).useMemoCache = fn, qs.useHostTransitionStatus = ct, qs.useFormState = function(e4, n7) {
      return As = "useFormState", qe(), Je(), Mn(e4, n7);
    }, qs.useActionState = function(e4, n7) {
      return As = "useActionState", qe(), Mn(e4, n7);
    }, qs.useOptimistic = function(e4) {
      return As = "useOptimistic", qe(), En(e4);
    }, (Ys = { readContext: function(e4) {
      return sr(e4);
    }, use: cn, useCallback: function(e4, n7) {
      return As = "useCallback", Ye(), Kn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", Ye(), sr(e4);
    }, useEffect: function(e4, n7) {
      return As = "useEffect", Ye(), $n(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", Ye(), Gn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      As = "useInsertionEffect", Ye(), Bn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", Ye(), qn(e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", Ye();
      var t5 = Ja.H;
      Ja.H = Ks;
      try {
        return Zn(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", Ye();
      var r6 = Ja.H;
      Ja.H = Ks;
      try {
        return pn(e4, n7, t5);
      } finally {
        Ja.H = r6;
      }
    }, useRef: function(e4) {
      return As = "useRef", Ye(), On(e4);
    }, useState: function(e4) {
      As = "useState", Ye();
      var n7 = Ja.H;
      Ja.H = Ks;
      try {
        return Cn(e4);
      } finally {
        Ja.H = n7;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", Ye();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", Ye(), nt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", Ye(), ut();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", Ye(), yn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", Ye(), ft();
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", Ye(), dt();
    } }).useMemoCache = fn, Ys.useHostTransitionStatus = ct, Ys.useFormState = function(e4, n7) {
      return As = "useFormState", Ye(), Je(), Mn(e4, n7);
    }, Ys.useActionState = function(e4, n7) {
      return As = "useActionState", Ye(), Mn(e4, n7);
    }, Ys.useOptimistic = function(e4) {
      return As = "useOptimistic", Ye(), En(e4);
    }, (Gs = { readContext: function(e4) {
      return sr(e4);
    }, use: cn, useCallback: function(e4, n7) {
      return As = "useCallback", Ye(), Xn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", Ye(), sr(e4);
    }, useEffect: function(e4, n7) {
      As = "useEffect", Ye(), Vn(2048, zs, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", Ye(), Jn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return As = "useInsertionEffect", Ye(), Vn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", Ye(), Vn(4, xs, e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", Ye();
      var t5 = Ja.H;
      Ja.H = Xs;
      try {
        return et(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", Ye();
      var r6 = Ja.H;
      Ja.H = Xs;
      try {
        return mn(e4);
      } finally {
        Ja.H = r6;
      }
    }, useRef: function() {
      return As = "useRef", Ye(), un().memoizedState;
    }, useState: function() {
      As = "useState", Ye();
      var e4 = Ja.H;
      Ja.H = Xs;
      try {
        return mn(dn);
      } finally {
        Ja.H = e4;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", Ye();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", Ye(), tt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", Ye(), it();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", Ye(), bn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", Ye(), un().memoizedState;
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", Ye(), un().memoizedState;
    } }).useMemoCache = fn, Gs.useHostTransitionStatus = ct, Gs.useFormState = function(e4) {
      return As = "useFormState", Ye(), Je(), Wn(e4);
    }, Gs.useActionState = function(e4) {
      return As = "useActionState", Ye(), Wn(e4);
    }, Gs.useOptimistic = function(e4, n7) {
      return As = "useOptimistic", Ye(), Pn(e4, n7);
    }, (Js = { readContext: function(e4) {
      return sr(e4);
    }, use: cn, useCallback: function(e4, n7) {
      return As = "useCallback", Ye(), Xn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", Ye(), sr(e4);
    }, useEffect: function(e4, n7) {
      As = "useEffect", Ye(), Vn(2048, zs, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", Ye(), Jn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return As = "useInsertionEffect", Ye(), Vn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", Ye(), Vn(4, xs, e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", Ye();
      var t5 = Ja.H;
      Ja.H = Zs;
      try {
        return et(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", Ye();
      var r6 = Ja.H;
      Ja.H = Zs;
      try {
        return gn(e4);
      } finally {
        Ja.H = r6;
      }
    }, useRef: function() {
      return As = "useRef", Ye(), un().memoizedState;
    }, useState: function() {
      As = "useState", Ye();
      var e4 = Ja.H;
      Ja.H = Zs;
      try {
        return gn(dn);
      } finally {
        Ja.H = e4;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", Ye();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", Ye(), rt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", Ye(), st();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", Ye(), bn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", Ye(), un().memoizedState;
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", Ye(), un().memoizedState;
    } }).useMemoCache = fn, Js.useHostTransitionStatus = ct, Js.useFormState = function(e4) {
      return As = "useFormState", Ye(), Je(), An(e4);
    }, Js.useActionState = function(e4) {
      return As = "useActionState", Ye(), An(e4);
    }, Js.useOptimistic = function(e4, n7) {
      return As = "useOptimistic", Ye(), Rn(e4, n7);
    }, (Ks = { readContext: function(e4) {
      return l2(), sr(e4);
    }, use: function(e4) {
      return r5(), cn(e4);
    }, useCallback: function(e4, n7) {
      return As = "useCallback", r5(), qe(), Kn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", r5(), qe(), sr(e4);
    }, useEffect: function(e4, n7) {
      return As = "useEffect", r5(), qe(), $n(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", r5(), qe(), Gn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      As = "useInsertionEffect", r5(), qe(), Bn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", r5(), qe(), qn(e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", r5(), qe();
      var t5 = Ja.H;
      Ja.H = Ks;
      try {
        return Zn(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", r5(), qe();
      var l3 = Ja.H;
      Ja.H = Ks;
      try {
        return pn(e4, n7, t5);
      } finally {
        Ja.H = l3;
      }
    }, useRef: function(e4) {
      return As = "useRef", r5(), qe(), On(e4);
    }, useState: function(e4) {
      As = "useState", r5(), qe();
      var n7 = Ja.H;
      Ja.H = Ks;
      try {
        return Cn(e4);
      } finally {
        Ja.H = n7;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", r5(), qe();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", r5(), qe(), nt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", r5(), qe(), ut();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", r5(), qe(), yn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", r5(), qe(), ft();
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", qe(), dt();
    }, useMemoCache: function(e4) {
      return r5(), fn(e4);
    } }).useHostTransitionStatus = ct, Ks.useFormState = function(e4, n7) {
      return As = "useFormState", r5(), qe(), Mn(e4, n7);
    }, Ks.useActionState = function(e4, n7) {
      return As = "useActionState", r5(), qe(), Mn(e4, n7);
    }, Ks.useOptimistic = function(e4) {
      return As = "useOptimistic", r5(), qe(), En(e4);
    }, (Xs = { readContext: function(e4) {
      return l2(), sr(e4);
    }, use: function(e4) {
      return r5(), cn(e4);
    }, useCallback: function(e4, n7) {
      return As = "useCallback", r5(), Ye(), Xn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", r5(), Ye(), sr(e4);
    }, useEffect: function(e4, n7) {
      As = "useEffect", r5(), Ye(), Vn(2048, zs, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", r5(), Ye(), Jn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return As = "useInsertionEffect", r5(), Ye(), Vn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", r5(), Ye(), Vn(4, xs, e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", r5(), Ye();
      var t5 = Ja.H;
      Ja.H = Xs;
      try {
        return et(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", r5(), Ye();
      var l3 = Ja.H;
      Ja.H = Xs;
      try {
        return mn(e4);
      } finally {
        Ja.H = l3;
      }
    }, useRef: function() {
      return As = "useRef", r5(), Ye(), un().memoizedState;
    }, useState: function() {
      As = "useState", r5(), Ye();
      var e4 = Ja.H;
      Ja.H = Xs;
      try {
        return mn(dn);
      } finally {
        Ja.H = e4;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", r5(), Ye();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", r5(), Ye(), tt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", r5(), Ye(), it();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", r5(), Ye(), bn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", r5(), Ye(), un().memoizedState;
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", Ye(), un().memoizedState;
    }, useMemoCache: function(e4) {
      return r5(), fn(e4);
    } }).useHostTransitionStatus = ct, Xs.useFormState = function(e4) {
      return As = "useFormState", r5(), Ye(), Wn(e4);
    }, Xs.useActionState = function(e4) {
      return As = "useActionState", r5(), Ye(), Wn(e4);
    }, Xs.useOptimistic = function(e4, n7) {
      return As = "useOptimistic", r5(), Ye(), Pn(e4, n7);
    }, (Zs = { readContext: function(e4) {
      return l2(), sr(e4);
    }, use: function(e4) {
      return r5(), cn(e4);
    }, useCallback: function(e4, n7) {
      return As = "useCallback", r5(), Ye(), Xn(e4, n7);
    }, useContext: function(e4) {
      return As = "useContext", r5(), Ye(), sr(e4);
    }, useEffect: function(e4, n7) {
      As = "useEffect", r5(), Ye(), Vn(2048, zs, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return As = "useImperativeHandle", r5(), Ye(), Jn(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return As = "useInsertionEffect", r5(), Ye(), Vn(4, ws, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return As = "useLayoutEffect", r5(), Ye(), Vn(4, xs, e4, n7);
    }, useMemo: function(e4, n7) {
      As = "useMemo", r5(), Ye();
      var t5 = Ja.H;
      Ja.H = Xs;
      try {
        return et(e4, n7);
      } finally {
        Ja.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      As = "useReducer", r5(), Ye();
      var l3 = Ja.H;
      Ja.H = Xs;
      try {
        return gn(e4);
      } finally {
        Ja.H = l3;
      }
    }, useRef: function() {
      return As = "useRef", r5(), Ye(), un().memoizedState;
    }, useState: function() {
      As = "useState", r5(), Ye();
      var e4 = Ja.H;
      Ja.H = Xs;
      try {
        return gn(dn);
      } finally {
        Ja.H = e4;
      }
    }, useDebugValue: function() {
      As = "useDebugValue", r5(), Ye();
    }, useDeferredValue: function(e4, n7) {
      return As = "useDeferredValue", r5(), Ye(), rt(e4, n7);
    }, useTransition: function() {
      return As = "useTransition", r5(), Ye(), st();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return As = "useSyncExternalStore", r5(), Ye(), bn(e4, n7, t5);
    }, useId: function() {
      return As = "useId", r5(), Ye(), un().memoizedState;
    }, useCacheRefresh: function() {
      return As = "useCacheRefresh", Ye(), un().memoizedState;
    }, useMemoCache: function(e4) {
      return r5(), fn(e4);
    } }).useHostTransitionStatus = ct, Zs.useFormState = function(e4) {
      return As = "useFormState", r5(), Ye(), An(e4);
    }, Zs.useActionState = function(e4) {
      return As = "useActionState", r5(), Ye(), An(e4);
    }, Zs.useOptimistic = function(e4, n7) {
      return As = "useOptimistic", r5(), Ye(), Rn(e4, n7);
    };
    var ec = {}, nc = /* @__PURE__ */ new Set(), tc = /* @__PURE__ */ new Set(), rc = /* @__PURE__ */ new Set(), lc = /* @__PURE__ */ new Set(), ac = /* @__PURE__ */ new Set(), oc = /* @__PURE__ */ new Set(), uc = /* @__PURE__ */ new Set(), ic = /* @__PURE__ */ new Set(), sc = /* @__PURE__ */ new Set(), cc = /* @__PURE__ */ new Set();
    Object.freeze(ec);
    var fc = { isMounted: function(e4) {
      var n7 = to;
      if (null !== n7 && ro && 1 === n7.tag) {
        var t5 = n7.stateNode;
        t5._warnedAboutRefsInRender || console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", c4(n7) || "A component"), t5._warnedAboutRefsInRender = true;
      }
      return !!(e4 = e4._reactInternals) && function(e5) {
        var n8 = e5, t6 = e5;
        if (e5.alternate) for (; n8.return; ) n8 = n8.return;
        else {
          e5 = n8;
          do {
            0 != (4098 & (n8 = e5).flags) && (t6 = n8.return), e5 = n8.return;
          } while (e5);
        }
        return 3 === n8.tag ? t6 : null;
      }(e4) === e4;
    }, enqueueSetState: function(e4, n7, t5) {
      var r6 = xl(e4 = e4._reactInternals), l3 = ge(r6);
      l3.payload = n7, null != t5 && (kt(t5), l3.callback = t5), null !== (n7 = ye(e4, l3, r6)) && (Cl(n7, e4, r6), be(n7, e4, r6));
    }, enqueueReplaceState: function(e4, n7, t5) {
      var r6 = xl(e4 = e4._reactInternals), l3 = ge(r6);
      l3.tag = hi, l3.payload = n7, null != t5 && (kt(t5), l3.callback = t5), null !== (n7 = ye(e4, l3, r6)) && (Cl(n7, e4, r6), be(n7, e4, r6));
    }, enqueueForceUpdate: function(e4, n7) {
      var t5 = xl(e4 = e4._reactInternals), r6 = ge(t5);
      r6.tag = gi, null != n7 && (kt(n7), r6.callback = n7), null !== (n7 = ye(e4, r6, t5)) && (Cl(n7, e4, t5), be(n7, e4, t5));
    } };
    "function" == typeof reportError && reportError;
    var dc = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), pc = false, mc = {}, hc = {}, gc = {}, yc = {}, bc = false, vc = {}, Sc = {}, kc = { dehydrated: null, treeContext: null, retryLane: 0 }, wc = false, xc = b3(null), zc = b3(null), Cc = {}, Ec = null, Pc = null, _c = null, Rc = false, Tc = "undefined" != typeof AbortController ? AbortController : function() {
      var e4 = [], n7 = this.signal = { aborted: false, addEventListener: function(n8, t5) {
        e4.push(t5);
      } };
      this.abort = function() {
        n7.aborted = true, e4.forEach(function(e5) {
          return e5();
        });
      };
    }, Nc = Ta.unstable_scheduleCallback, Lc = Ta.unstable_NormalPriority, Uc = { $$typeof: ja, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0, _currentRenderer: null, _currentRenderer2: null }, Dc = Ja.S;
    Ja.S = function(e4, n7) {
      "object" == typeof n7 && null !== n7 && "function" == typeof n7.then && function(e5, n8) {
        if (null === ci) {
          var t5 = ci = [];
          fi = 0, di = de(), pi = { status: "pending", value: void 0, then: function(e6) {
            t5.push(e6);
          } };
        }
        fi++, n8.then(pe, pe);
      }(0, n7), null !== Dc && Dc(e4, n7);
    };
    var Ic = b3(null), Fc = null;
    Fc = /* @__PURE__ */ new Set();
    var Mc = false, Wc = false, Hc = false, jc = "function" == typeof WeakSet ? WeakSet : Set, Ac = null, Qc = null, Oc = null, Bc = false, Vc = null, $c = false, qc = null, Yc = 8192, Gc = { getCacheForType: function(e4) {
      var n7 = sr(Uc), t5 = n7.data.get(e4);
      return void 0 === t5 && (t5 = e4(), n7.data.set(e4, t5)), t5;
    }, getOwner: function() {
      return to;
    } };
    if ("function" == typeof Symbol && Symbol.for) {
      var Jc = Symbol.for;
      Jc("selector.component"), Jc("selector.has_pseudo_class"), Jc("selector.role"), Jc("selector.test_id"), Jc("selector.text");
    }
    var Kc = "function" == typeof WeakMap ? WeakMap : Map, Xc = 0, Zc = 2, ef = 4, nf = 0, tf = 1, rf = 2, lf = 3, af = 4, of = 5, uf = 6, sf = Xc, cf = null, ff = null, df = 0, pf = 0, mf = 1, hf = 2, gf = 3, yf = 4, bf = 5, vf = 6, Sf = 7, kf = 8, wf = pf, xf = null, zf = false, Cf = false, Ef = 0, Pf = nf, _f = 0, Rf = 0, Tf = 0, Nf = 0, Lf = 0, Uf = null, Df = null, If = false, Ff = 0, Mf = 300, Wf = 1 / 0, Hf = 500, jf = null, Af = null, Qf = false, Of = null, Bf = 0, Vf = 0, $f = null, qf = 50, Yf = 0, Gf = null, Jf = false, Kf = false, Xf = 50, Zf = 0, ed = null, nd = false, td = 0, rd = 1, ld = 2, ad = null, od = false, ud = /* @__PURE__ */ new Set(), id = false;
    try {
      var sd = Object.preventExtensions({});
      /* @__PURE__ */ new Map([[sd, null]]), /* @__PURE__ */ new Set([sd]);
    } catch (e4) {
      id = true;
    }
    var cd = false;
    return _a.createContainer = function(e4, n7, r6, l3, a5, o3, u4, i5, s3, c5) {
      return function(e5, n8, r7, l4, a6, o4, u5, i6, s4, c6, f4, d3) {
        return e5 = new va(e5, n8, r7, u5, i6, s4, c6, null), n8 = 1, true === o4 && (n8 |= 24), _u && (n8 |= 2), o4 = t4(3, null, null, n8), e5.current = o4, o4.stateNode = e5, pr(n8 = dr()), e5.pooledCache = n8, pr(n8), o4.memoizedState = { element: l4, isDehydrated: r7, cache: n8 }, me(o4), e5;
      }(e4, n7, false, null, 0, l3, o3, u4, i5, s3);
    }, _a.flushSyncWork = function() {
      return (sf & (Zc | ef)) !== Xc || (ae(0), false);
    }, _a.updateContainer = function(e4, n7, t5, r6) {
      var l3 = n7.current, a5 = xl(l3);
      return Sa(l3, a5, e4, n7, t5, r6), a5;
    }, _a.updateContainerSync = function(e4, n7, t5, r6) {
      return 0 === n7.tag && Jl(), Sa(n7.current, 2, e4, n7, t5, r6), 2;
    }, _a;
  }, n5.exports.default = n5.exports, Object.defineProperty(n5.exports, "__esModule", { value: true })), c.exports;
  var n5;
}();
var d = t(a.exports);
var p = { exports: {} };
var h;
var g = {};
false ? p.exports = (f || (f = 1, m.ConcurrentRoot = 1, m.ContinuousEventPriority = 8, m.DefaultEventPriority = 32, m.DiscreteEventPriority = 2, m.IdleEventPriority = 268435456, m.LegacyRoot = 0, m.NoEventPriority = 0), m) : p.exports = (h || (h = 1, g.ConcurrentRoot = 1, g.ContinuousEventPriority = 8, g.DefaultEventPriority = 32, g.DiscreteEventPriority = 2, g.IdleEventPriority = 268435456, g.LegacyRoot = 0, g.NoEventPriority = 0), g);
var y = p.exports;
var b = (e4, n5) => {
  const t4 = Object.keys(e4), r5 = Object.keys(n5);
  if (t4.length !== r5.length) return false;
  for (let r6 = 0; r6 < t4.length; r6 += 1) {
    const l2 = t4[r6];
    if ("render" === l2 && !e4[l2] != !n5[l2]) return false;
    if ("children" !== l2 && e4[l2] !== n5[l2]) {
      if ("object" == typeof e4[l2] && "object" == typeof n5[l2] && b(e4[l2], n5[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e4[l2] || "string" == typeof n5[l2])) return e4[l2] === n5[l2];
  }
  return true;
};
var v = {};
var S = console.error;
var k = ({ appendChild: e4, appendChildToContainer: n5, commitTextUpdate: t4, commitUpdate: r5, createInstance: l2, createTextInstance: a4, insertBefore: o2, removeChild: u4, removeChildFromContainer: i4, resetAfterCommit: s2 }) => {
  const c4 = d({ appendChild: e4, appendChildToContainer: n5, appendInitialChild: e4, createInstance: l2, createTextInstance: a4, insertBefore: o2, commitUpdate: (e5, n6, t5, l3) => {
    b(t5, l3) || r5(e5, null, n6, t5, l3);
  }, commitTextUpdate: t4, removeChild: u4, removeChildFromContainer: i4, resetAfterCommit: s2, noTimeout: -1, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e5) => e5, getRootHostContext: () => v, getChildHostContext: () => v, prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: () => y.DefaultEventPriority, maySuspendCommit: () => false, requestPostPaintCallback: () => {
  }, resolveUpdatePriority: () => y.DefaultEventPriority, setCurrentUpdatePriority: () => {
  }, shouldAttemptEagerTransition: () => false, detachDeletedInstance: () => {
  } });
  return { createContainer: (e5) => c4.createContainer(e5, y.ConcurrentRoot, null, false, null, "", S, S, S, null), updateContainer: (e5, n6, t5, r6) => {
    c4.updateContainerSync(e5, n6, t5, r6), c4.flushSyncWork();
  } };
};

// node_modules/@react-pdf/reconciler/lib/reconciler-33.js
var import_react2 = __toESM(require_react(), 1);
var n2 = __toESM(require_scheduler(), 1);
function t2(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
function r3(e4) {
  if (e4.__esModule) return e4;
  var n5 = e4.default;
  if ("function" == typeof n5) {
    var t4 = function e5() {
      return this instanceof e5 ? Reflect.construct(n5, arguments, this.constructor) : n5.apply(this, arguments);
    };
    t4.prototype = n5.prototype;
  } else t4 = {};
  return Object.defineProperty(t4, "__esModule", { value: true }), Object.keys(e4).forEach(function(n6) {
    var r5 = Object.getOwnPropertyDescriptor(e4, n6);
    Object.defineProperty(t4, n6, r5.get ? r5 : { enumerable: true, get: function() {
      return e4[n6];
    } });
  }), t4;
}
var a2 = { exports: {} };
var u2 = r3(n2);
var i2;
var c2 = { exports: {} };
false ? a2.exports = (l || (l = 1, (s = o).exports = function(n5) {
  function t4(e4, n6, t5, r6) {
    return new tl(e4, n6, t5, r6);
  }
  function r5(e4) {
    var n6 = "https://react.dev/errors/" + e4;
    if (1 < arguments.length) {
      n6 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t5 = 2; t5 < arguments.length; t5++) n6 += "&args[]=" + encodeURIComponent(arguments[t5]);
    }
    return "Minified React error #" + e4 + "; visit " + n6 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l2(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = Nl && e4[Nl] || e4["@@iterator"]) ? e4 : null;
  }
  function a4(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.$$typeof === Ll ? null : e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case vl:
        return "Fragment";
      case kl:
        return "Profiler";
      case Sl:
        return "StrictMode";
      case El:
        return "Suspense";
      case Cl:
        return "SuspenseList";
      case Tl:
        return "Activity";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case bl:
        return "Portal";
      case zl:
        return e4.displayName || "Context";
      case wl:
        return (e4._context.displayName || "Context") + ".Consumer";
      case xl:
        var n6 = e4.render;
        return (e4 = e4.displayName) || (e4 = "" !== (e4 = n6.displayName || n6.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
      case Pl:
        return null !== (n6 = e4.displayName || null) ? n6 : a4(e4.type) || "Memo";
      case _l:
        n6 = e4._payload, e4 = e4._init;
        try {
          return a4(e4(n6));
        } catch (e5) {
        }
    }
    return null;
  }
  function o2(e4) {
    return { current: e4 };
  }
  function i4(e4) {
    0 > Ma || (e4.current = Oa[Ma], Oa[Ma] = null, Ma--);
  }
  function s2(e4, n6) {
    Ma++, Oa[Ma] = e4.current, e4.current = n6;
  }
  function c4(e4) {
    var n6 = 42 & e4;
    if (0 !== n6) return n6;
    switch (e4 & -e4) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return 261888 & e4;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 3932160 & e4;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e4;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e4;
    }
  }
  function d2(e4, n6, t5) {
    var r6 = e4.pendingLanes;
    if (0 === r6) return 0;
    var l3 = 0, a5 = e4.suspendedLanes, o3 = e4.pingedLanes;
    e4 = e4.warmLanes;
    var u4 = 134217727 & r6;
    return 0 !== u4 ? 0 != (r6 = u4 & ~a5) ? l3 = c4(r6) : 0 != (o3 &= u4) ? l3 = c4(o3) : t5 || 0 != (t5 = u4 & ~e4) && (l3 = c4(t5)) : 0 != (u4 = r6 & ~a5) ? l3 = c4(u4) : 0 !== o3 ? l3 = c4(o3) : t5 || 0 != (t5 = r6 & ~e4) && (l3 = c4(t5)), 0 === l3 ? 0 : 0 !== n6 && n6 !== l3 && 0 == (n6 & a5) && ((a5 = l3 & -l3) >= (t5 = n6 & -n6) || 32 === a5 && 0 != (4194048 & t5)) ? n6 : l3;
  }
  function f3(e4, n6) {
    return 0 == (e4.pendingLanes & ~(e4.suspendedLanes & ~e4.pingedLanes) & n6);
  }
  function p3(e4, n6) {
    switch (e4) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return n6 + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n6 + 5e3;
      default:
        return -1;
    }
  }
  function m() {
    var e4 = Ya;
    return 0 == (62914560 & (Ya <<= 1)) && (Ya = 4194304), e4;
  }
  function h3(e4) {
    for (var n6 = [], t5 = 0; 31 > t5; t5++) n6.push(e4);
    return n6;
  }
  function g3(e4, n6) {
    e4.pendingLanes |= n6, 268435456 !== n6 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
  }
  function y3(e4, n6, t5) {
    e4.pendingLanes |= n6, e4.suspendedLanes &= ~n6;
    var r6 = 31 - Qa(n6);
    e4.entangledLanes |= n6, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 261930 & t5;
  }
  function b3(e4, n6) {
    var t5 = e4.entangledLanes |= n6;
    for (e4 = e4.entanglements; t5; ) {
      var r6 = 31 - Qa(t5), l3 = 1 << r6;
      l3 & n6 | e4[r6] & n6 && (e4[r6] |= n6), t5 &= ~l3;
    }
  }
  function v3(e4, n6) {
    var t5 = n6 & -n6;
    return 0 != ((t5 = 0 != (42 & t5) ? 1 : function(e5) {
      switch (e5) {
        case 2:
          e5 = 1;
          break;
        case 8:
          e5 = 4;
          break;
        case 32:
          e5 = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          e5 = 128;
          break;
        case 268435456:
          e5 = 134217728;
          break;
        default:
          e5 = 0;
      }
      return e5;
    }(t5)) & (e4.suspendedLanes | n6)) ? 0 : t5;
  }
  function S3(e4) {
    return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
  }
  function k3(e4) {
    "function" == typeof lo && ao(e4);
  }
  function w(e4) {
    if (void 0 === io) try {
      throw Error();
    } catch (e5) {
      var n6 = e5.stack.trim().match(/\n( *(at )?)/);
      io = n6 && n6[1] || "", so = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + io + e4 + so;
  }
  function z(e4, n6) {
    if (!e4 || fo) return "";
    fo = true;
    var t5 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r6 = { DetermineComponentFrameRoot: function() {
        try {
          if (n6) {
            var t6 = function() {
              throw Error();
            };
            if (Object.defineProperty(t6.prototype, "props", { set: function() {
              throw Error();
            } }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t6, []);
              } catch (e5) {
                var r7 = e5;
              }
              Reflect.construct(e4, [], t6);
            } else {
              try {
                t6.call();
              } catch (e5) {
                r7 = e5;
              }
              e4.call(t6.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e5) {
              r7 = e5;
            }
            (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
            });
          }
        } catch (e5) {
          if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
        }
        return [null, null];
      } };
      r6.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l3 = Object.getOwnPropertyDescriptor(r6.DetermineComponentFrameRoot, "name");
      l3 && l3.configurable && Object.defineProperty(r6.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a5 = r6.DetermineComponentFrameRoot(), o3 = a5[0], u4 = a5[1];
      if (o3 && u4) {
        var i5 = o3.split("\n"), s3 = u4.split("\n");
        for (l3 = r6 = 0; r6 < i5.length && !i5[r6].includes("DetermineComponentFrameRoot"); ) r6++;
        for (; l3 < s3.length && !s3[l3].includes("DetermineComponentFrameRoot"); ) l3++;
        if (r6 === i5.length || l3 === s3.length) for (r6 = i5.length - 1, l3 = s3.length - 1; 1 <= r6 && 0 <= l3 && i5[r6] !== s3[l3]; ) l3--;
        for (; 1 <= r6 && 0 <= l3; r6--, l3--) if (i5[r6] !== s3[l3]) {
          if (1 !== r6 || 1 !== l3) do {
            if (r6--, 0 > --l3 || i5[r6] !== s3[l3]) {
              var c5 = "\n" + i5[r6].replace(" at new ", " at ");
              return e4.displayName && c5.includes("<anonymous>") && (c5 = c5.replace("<anonymous>", e4.displayName)), c5;
            }
          } while (1 <= r6 && 0 <= l3);
          break;
        }
      }
    } finally {
      fo = false, Error.prepareStackTrace = t5;
    }
    return (t5 = e4 ? e4.displayName || e4.name : "") ? w(t5) : "";
  }
  function x(e4, n6) {
    switch (e4.tag) {
      case 26:
      case 27:
      case 5:
        return w(e4.type);
      case 16:
        return w("Lazy");
      case 13:
        return e4.child !== n6 && null !== n6 ? w("Suspense Fallback") : w("Suspense");
      case 19:
        return w("SuspenseList");
      case 0:
      case 15:
        return z(e4.type, false);
      case 11:
        return z(e4.type.render, false);
      case 1:
        return z(e4.type, true);
      case 31:
        return w("Activity");
      default:
        return "";
    }
  }
  function E(e4) {
    try {
      var n6 = "", t5 = null;
      do {
        n6 += x(e4, t5), t5 = e4, e4 = e4.return;
      } while (e4);
      return n6;
    } catch (e5) {
      return "\nError generating stack: " + e5.message + "\n" + e5.stack;
    }
  }
  function C(e4, n6) {
    if ("object" == typeof e4 && null !== e4) {
      var t5 = po.get(e4);
      return void 0 !== t5 ? t5 : (n6 = { value: e4, source: n6, stack: E(n6) }, po.set(e4, n6), n6);
    }
    return { value: e4, source: n6, stack: E(n6) };
  }
  function P(e4) {
    for (; e4 === go; ) go = mo[--ho], mo[ho] = null, mo[--ho], mo[ho] = null;
    for (; e4 === vo; ) vo = yo[--bo], yo[bo] = null, yo[--bo], yo[bo] = null, yo[--bo], yo[bo] = null;
  }
  function _(e4, n6) {
    s2(wo, n6), s2(ko, e4), s2(So, null), e4 = Fl(n6), i4(So), s2(So, e4);
  }
  function T() {
    i4(So), i4(ko), i4(wo);
  }
  function R(e4) {
    null !== e4.memoizedState && s2(zo, e4);
    var n6 = So.current, t5 = jl(n6, e4.type);
    n6 !== t5 && (s2(ko, e4), s2(So, t5));
  }
  function N(e4) {
    ko.current === e4 && (i4(So), i4(ko)), zo.current === e4 && (i4(zo), ca._currentValue2 = sa);
  }
  function L() {
    var e4 = Eo;
    return null !== e4 && (null === li ? li = e4 : li.push.apply(li, e4), Eo = null), e4;
  }
  function U(e4, n6, t5) {
    s2(Co, n6._currentValue2), n6._currentValue2 = t5;
  }
  function D(e4) {
    var n6 = Co.current;
    e4._currentValue2 = n6, i4(Co);
  }
  function I(e4, n6, t5) {
    for (; null !== e4; ) {
      var r6 = e4.alternate;
      if ((e4.childLanes & n6) !== n6 ? (e4.childLanes |= n6, null !== r6 && (r6.childLanes |= n6)) : null !== r6 && (r6.childLanes & n6) !== n6 && (r6.childLanes |= n6), e4 === t5) break;
      e4 = e4.return;
    }
  }
  function F(e4, n6, t5, l3) {
    var a5 = e4.child;
    for (null !== a5 && (a5.return = e4); null !== a5; ) {
      var o3 = a5.dependencies;
      if (null !== o3) {
        var u4 = a5.child;
        o3 = o3.firstContext;
        e: for (; null !== o3; ) {
          var i5 = o3;
          o3 = a5;
          for (var s3 = 0; s3 < n6.length; s3++) if (i5.context === n6[s3]) {
            o3.lanes |= t5, null !== (i5 = o3.alternate) && (i5.lanes |= t5), I(o3.return, t5, e4), l3 || (u4 = null);
            break e;
          }
          o3 = i5.next;
        }
      } else if (18 === a5.tag) {
        if (null === (u4 = a5.return)) throw Error(r5(341));
        u4.lanes |= t5, null !== (o3 = u4.alternate) && (o3.lanes |= t5), I(u4, t5, e4), u4 = null;
      } else u4 = a5.child;
      if (null !== u4) u4.return = a5;
      else for (u4 = a5; null !== u4; ) {
        if (u4 === e4) {
          u4 = null;
          break;
        }
        if (null !== (a5 = u4.sibling)) {
          a5.return = u4.return, u4 = a5;
          break;
        }
        u4 = u4.return;
      }
      a5 = u4;
    }
  }
  function j(e4, n6, t5, l3) {
    e4 = null;
    for (var a5 = n6, o3 = false; null !== a5; ) {
      if (!o3) {
        if (0 != (524288 & a5.flags)) o3 = true;
        else if (0 != (262144 & a5.flags)) break;
      }
      if (10 === a5.tag) {
        var u4 = a5.alternate;
        if (null === u4) throw Error(r5(387));
        if (null !== (u4 = u4.memoizedProps)) {
          var i5 = a5.type;
          uo(a5.pendingProps.value, u4.value) || (null !== e4 ? e4.push(i5) : e4 = [i5]);
        }
      } else if (a5 === zo.current) {
        if (null === (u4 = a5.alternate)) throw Error(r5(387));
        u4.memoizedState.memoizedState !== a5.memoizedState.memoizedState && (null !== e4 ? e4.push(ca) : e4 = [ca]);
      }
      a5 = a5.return;
    }
    null !== e4 && F(n6, e4, t5, l3), n6.flags |= 262144;
  }
  function A(e4) {
    for (e4 = e4.firstContext; null !== e4; ) {
      var n6 = e4.context;
      if (!uo(n6._currentValue2, e4.memoizedValue)) return true;
      e4 = e4.next;
    }
    return false;
  }
  function H(e4) {
    Po = e4, _o = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
  }
  function O(e4) {
    return W(Po, e4);
  }
  function M(e4, n6) {
    return null === Po && H(e4), W(e4, n6);
  }
  function W(e4, n6) {
    var t5 = n6._currentValue2;
    if (n6 = { context: n6, memoizedValue: t5, next: null }, null === _o) {
      if (null === e4) throw Error(r5(308));
      _o = n6, e4.dependencies = { lanes: 0, firstContext: n6 }, e4.flags |= 524288;
    } else _o = _o.next = n6;
    return t5;
  }
  function Q() {
    return { controller: new To(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  function B(e4) {
    e4.refCount--, 0 === e4.refCount && Ro(No, function() {
      e4.controller.abort();
    });
  }
  function $() {
  }
  function V(e4) {
    e4 !== Do && null === e4.next && (null === Do ? Uo = Do = e4 : Do = Do.next = e4), Fo = true, Io || (Io = true, Ga(eo, Y));
  }
  function q(e4, n6) {
    if (!jo && Fo) {
      jo = true;
      do {
        for (var t5 = false, r6 = Uo; null !== r6; ) {
          if (0 !== e4) {
            var l3 = r6.pendingLanes;
            if (0 === l3) var a5 = 0;
            else {
              var o3 = r6.suspendedLanes, u4 = r6.pingedLanes;
              a5 = (1 << 31 - Qa(42 | e4) + 1) - 1, a5 = 201326741 & (a5 &= l3 & ~(o3 & ~u4)) ? 201326741 & a5 | 1 : a5 ? 2 | a5 : 0;
            }
            0 !== a5 && (t5 = true, K(r6, a5));
          } else a5 = Bu, 0 == (3 & (a5 = d2(r6, r6 === Wu ? a5 : 0, null !== r6.cancelPendingCommit || r6.timeoutHandle !== ql))) || f3(r6, a5) || (t5 = true, K(r6, a5));
          r6 = r6.next;
        }
      } while (t5);
      jo = false;
    }
  }
  function Y() {
    !function() {
      Fo = Io = false;
      var e4 = 0;
      0 !== Ao && ea() && (e4 = Ao);
      for (var n6 = Za(), t5 = null, r6 = Uo; null !== r6; ) {
        var l3 = r6.next, a5 = G2(r6, n6);
        0 === a5 ? (r6.next = null, null === t5 ? Uo = l3 : t5.next = l3, null === l3 && (Do = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (Fo = true)), r6 = l3;
      }
      0 !== di && 5 !== di || q(e4), 0 !== Ao && (Ao = 0);
    }();
  }
  function G2(e4, n6) {
    for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l3 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
      var o3 = 31 - Qa(a5), u4 = 1 << o3, i5 = l3[o3];
      -1 === i5 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l3[o3] = p3(u4, n6)) : i5 <= n6 && (e4.expiredLanes |= u4), a5 &= ~u4;
    }
    if (t5 = Bu, t5 = d2(e4, e4 === (n6 = Wu) ? t5 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== ql), r6 = e4.callbackNode, 0 === t5 || e4 === n6 && (2 === $u || 9 === $u) || null !== e4.cancelPendingCommit) return null !== r6 && null !== r6 && Ja(r6), e4.callbackNode = null, e4.callbackPriority = 0;
    if (0 == (3 & t5) || f3(e4, t5)) {
      if ((n6 = t5 & -t5) === e4.callbackPriority) return n6;
      switch (null !== r6 && Ja(r6), S3(t5)) {
        case 2:
        case 8:
          t5 = no;
          break;
        case 32:
        default:
          t5 = to;
          break;
        case 268435456:
          t5 = ro;
      }
      return r6 = J.bind(null, e4), t5 = Ga(t5, r6), e4.callbackPriority = n6, e4.callbackNode = t5, n6;
    }
    return null !== r6 && null !== r6 && Ja(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
  }
  function J(e4, n6) {
    if (0 !== di && 5 !== di) return e4.callbackNode = null, e4.callbackPriority = 0, null;
    var t5 = e4.callbackNode;
    if (qr() && e4.callbackNode !== t5) return null;
    var r6 = Bu;
    return 0 === (r6 = d2(e4, e4 === Wu ? r6 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== ql)) ? null : (xr(e4, r6, n6), G2(e4, Za()), null != e4.callbackNode && e4.callbackNode === t5 ? J.bind(null, e4) : null);
  }
  function K(e4, n6) {
    if (qr()) return null;
    xr(e4, n6, true);
  }
  function X() {
    if (0 === Ao) {
      var e4 = Mo;
      0 === e4 && (e4 = Va, 0 == (261888 & (Va <<= 1)) && (Va = 256)), Ao = e4;
    }
    return Ao;
  }
  function Z() {
    if (0 == --Oo && null !== Ho) {
      null !== Wo && (Wo.status = "fulfilled");
      var e4 = Ho;
      Ho = null, Mo = 0, Wo = null;
      for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
    }
  }
  function ee() {
    var e4 = Bo.current;
    return null !== e4 ? e4 : Wu.pooledCache;
  }
  function ne(e4, n6) {
    s2(Bo, null === n6 ? Bo.current : n6.pool);
  }
  function te() {
    var e4 = ee();
    return null === e4 ? null : { parent: Lo._currentValue2, pool: e4 };
  }
  function re(e4, n6) {
    if (uo(e4, n6)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof n6 || null === n6) return false;
    var t5 = Object.keys(e4), r6 = Object.keys(n6);
    if (t5.length !== r6.length) return false;
    for (r6 = 0; r6 < t5.length; r6++) {
      var l3 = t5[r6];
      if (!co.call(n6, l3) || !uo(e4[l3], n6[l3])) return false;
    }
    return true;
  }
  function le(e4) {
    return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
  }
  function ae(e4, n6, t5) {
    switch (void 0 === (t5 = e4[t5]) ? e4.push(n6) : t5 !== n6 && (n6.then($, $), n6 = t5), n6.status) {
      case "fulfilled":
        return n6.value;
      case "rejected":
        throw ie(e4 = n6.reason), e4;
      default:
        if ("string" == typeof n6.status) n6.then($, $);
        else {
          if (null !== (e4 = Wu) && 100 < e4.shellSuspendCounter) throw Error(r5(482));
          (e4 = n6).status = "pending", e4.then(function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "fulfilled", t6.value = e5;
            }
          }, function(e5) {
            if ("pending" === n6.status) {
              var t6 = n6;
              t6.status = "rejected", t6.reason = e5;
            }
          });
        }
        switch (n6.status) {
          case "fulfilled":
            return n6.value;
          case "rejected":
            throw ie(e4 = n6.reason), e4;
        }
        throw Go = n6, $o;
    }
  }
  function oe(e4) {
    try {
      return (0, e4._init)(e4._payload);
    } catch (e5) {
      if (null !== e5 && "object" == typeof e5 && "function" == typeof e5.then) throw Go = e5, $o;
      throw e5;
    }
  }
  function ue() {
    if (null === Go) throw Error(r5(459));
    var e4 = Go;
    return Go = null, e4;
  }
  function ie(e4) {
    if (e4 === $o || e4 === qo) throw Error(r5(483));
  }
  function se(e4) {
    var n6 = Ko;
    return Ko += 1, null === Jo && (Jo = []), ae(Jo, e4, n6);
  }
  function ce(e4, n6) {
    n6 = n6.props.ref, e4.ref = void 0 !== n6 ? n6 : null;
  }
  function de(e4, n6) {
    if (n6.$$typeof === gl) throw Error(r5(525));
    throw e4 = Object.prototype.toString.call(n6), Error(r5(31, "[object Object]" === e4 ? "object with keys {" + Object.keys(n6).join(", ") + "}" : e4));
  }
  function fe(e4) {
    function n6(n7, t5) {
      if (e4) {
        var r6 = n7.deletions;
        null === r6 ? (n7.deletions = [t5], n7.flags |= 16) : r6.push(t5);
      }
    }
    function a5(t5, r6) {
      if (!e4) return null;
      for (; null !== r6; ) n6(t5, r6), r6 = r6.sibling;
      return null;
    }
    function o3(e5) {
      for (var n7 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n7.set(e5.key, e5) : n7.set(e5.index, e5), e5 = e5.sibling;
      return n7;
    }
    function u4(e5, n7) {
      return (e5 = ll(e5, n7)).index = 0, e5.sibling = null, e5;
    }
    function i5(n7, t5, r6) {
      return n7.index = r6, e4 ? null !== (r6 = n7.alternate) ? (r6 = r6.index) < t5 ? (n7.flags |= 67108866, t5) : r6 : (n7.flags |= 67108866, t5) : (n7.flags |= 1048576, t5);
    }
    function s3(n7) {
      return e4 && null === n7.alternate && (n7.flags |= 67108866), n7;
    }
    function c5(e5, n7, t5, r6) {
      return null === n7 || 6 !== n7.tag ? ((n7 = il(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    function d3(e5, n7, t5, r6) {
      var l3 = t5.type;
      return l3 === vl ? p4(e5, n7, t5.props.children, r6, t5.key) : null !== n7 && (n7.elementType === l3 || "object" == typeof l3 && null !== l3 && l3.$$typeof === _l && oe(l3) === n7.type) ? (ce(n7 = u4(n7, t5.props), t5), n7.return = e5, n7) : (ce(n7 = ol(t5.type, t5.key, t5.props, null, e5.mode, r6), t5), n7.return = e5, n7);
    }
    function f4(e5, n7, t5, r6) {
      return null === n7 || 4 !== n7.tag || n7.stateNode.containerInfo !== t5.containerInfo || n7.stateNode.implementation !== t5.implementation ? ((n7 = sl(t5, e5.mode, r6)).return = e5, n7) : ((n7 = u4(n7, t5.children || [])).return = e5, n7);
    }
    function p4(e5, n7, t5, r6, l3) {
      return null === n7 || 7 !== n7.tag ? ((n7 = ul(t5, e5.mode, r6, l3)).return = e5, n7) : ((n7 = u4(n7, t5)).return = e5, n7);
    }
    function m2(e5, n7, t5) {
      if ("string" == typeof n7 && "" !== n7 || "number" == typeof n7 || "bigint" == typeof n7) return (n7 = il("" + n7, e5.mode, t5)).return = e5, n7;
      if ("object" == typeof n7 && null !== n7) {
        switch (n7.$$typeof) {
          case yl:
            return ce(t5 = ol(n7.type, n7.key, n7.props, null, e5.mode, t5), n7), t5.return = e5, t5;
          case bl:
            return (n7 = sl(n7, e5.mode, t5)).return = e5, n7;
          case _l:
            return m2(e5, n7 = oe(n7), t5);
        }
        if (Ul(n7) || l2(n7)) return (n7 = ul(n7, e5.mode, t5, null)).return = e5, n7;
        if ("function" == typeof n7.then) return m2(e5, se(n7), t5);
        if (n7.$$typeof === zl) return m2(e5, M(e5, n7), t5);
        de(e5, n7);
      }
      return null;
    }
    function h4(e5, n7, t5, r6) {
      var a6 = null !== n7 ? n7.key : null;
      if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== a6 ? null : c5(e5, n7, "" + t5, r6);
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case yl:
            return t5.key === a6 ? d3(e5, n7, t5, r6) : null;
          case bl:
            return t5.key === a6 ? f4(e5, n7, t5, r6) : null;
          case _l:
            return h4(e5, n7, t5 = oe(t5), r6);
        }
        if (Ul(t5) || l2(t5)) return null !== a6 ? null : p4(e5, n7, t5, r6, null);
        if ("function" == typeof t5.then) return h4(e5, n7, se(t5), r6);
        if (t5.$$typeof === zl) return h4(e5, n7, M(e5, t5), r6);
        de(e5, t5);
      }
      return null;
    }
    function g4(e5, n7, t5, r6, a6) {
      if ("string" == typeof r6 && "" !== r6 || "number" == typeof r6 || "bigint" == typeof r6) return c5(n7, e5 = e5.get(t5) || null, "" + r6, a6);
      if ("object" == typeof r6 && null !== r6) {
        switch (r6.$$typeof) {
          case yl:
            return d3(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case bl:
            return f4(n7, e5 = e5.get(null === r6.key ? t5 : r6.key) || null, r6, a6);
          case _l:
            return g4(e5, n7, t5, r6 = oe(r6), a6);
        }
        if (Ul(r6) || l2(r6)) return p4(n7, e5 = e5.get(t5) || null, r6, a6, null);
        if ("function" == typeof r6.then) return g4(e5, n7, t5, se(r6), a6);
        if (r6.$$typeof === zl) return g4(e5, n7, t5, M(n7, r6), a6);
        de(n7, r6);
      }
      return null;
    }
    function y4(t5, c6, d4, f5) {
      if ("object" == typeof d4 && null !== d4 && d4.type === vl && null === d4.key && (d4 = d4.props.children), "object" == typeof d4 && null !== d4) {
        switch (d4.$$typeof) {
          case yl:
            e: {
              for (var p5 = d4.key; null !== c6; ) {
                if (c6.key === p5) {
                  if ((p5 = d4.type) === vl) {
                    if (7 === c6.tag) {
                      a5(t5, c6.sibling), (f5 = u4(c6, d4.props.children)).return = t5, t5 = f5;
                      break e;
                    }
                  } else if (c6.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === _l && oe(p5) === c6.type) {
                    a5(t5, c6.sibling), ce(f5 = u4(c6, d4.props), d4), f5.return = t5, t5 = f5;
                    break e;
                  }
                  a5(t5, c6);
                  break;
                }
                n6(t5, c6), c6 = c6.sibling;
              }
              d4.type === vl ? ((f5 = ul(d4.props.children, t5.mode, f5, d4.key)).return = t5, t5 = f5) : (ce(f5 = ol(d4.type, d4.key, d4.props, null, t5.mode, f5), d4), f5.return = t5, t5 = f5);
            }
            return s3(t5);
          case bl:
            e: {
              for (p5 = d4.key; null !== c6; ) {
                if (c6.key === p5) {
                  if (4 === c6.tag && c6.stateNode.containerInfo === d4.containerInfo && c6.stateNode.implementation === d4.implementation) {
                    a5(t5, c6.sibling), (f5 = u4(c6, d4.children || [])).return = t5, t5 = f5;
                    break e;
                  }
                  a5(t5, c6);
                  break;
                }
                n6(t5, c6), c6 = c6.sibling;
              }
              (f5 = sl(d4, t5.mode, f5)).return = t5, t5 = f5;
            }
            return s3(t5);
          case _l:
            return y4(t5, c6, d4 = oe(d4), f5);
        }
        if (Ul(d4)) return function(t6, r6, l3, u5) {
          for (var s4 = null, c7 = null, d5 = r6, f6 = r6 = 0, p6 = null; null !== d5 && f6 < l3.length; f6++) {
            d5.index > f6 ? (p6 = d5, d5 = null) : p6 = d5.sibling;
            var y5 = h4(t6, d5, l3[f6], u5);
            if (null === y5) {
              null === d5 && (d5 = p6);
              break;
            }
            e4 && d5 && null === y5.alternate && n6(t6, d5), r6 = i5(y5, r6, f6), null === c7 ? s4 = y5 : c7.sibling = y5, c7 = y5, d5 = p6;
          }
          if (f6 === l3.length) return a5(t6, d5), s4;
          if (null === d5) {
            for (; f6 < l3.length; f6++) null !== (d5 = m2(t6, l3[f6], u5)) && (r6 = i5(d5, r6, f6), null === c7 ? s4 = d5 : c7.sibling = d5, c7 = d5);
            return s4;
          }
          for (d5 = o3(d5); f6 < l3.length; f6++) null !== (p6 = g4(d5, t6, f6, l3[f6], u5)) && (e4 && null !== p6.alternate && d5.delete(null === p6.key ? f6 : p6.key), r6 = i5(p6, r6, f6), null === c7 ? s4 = p6 : c7.sibling = p6, c7 = p6);
          return e4 && d5.forEach(function(e5) {
            return n6(t6, e5);
          }), s4;
        }(t5, c6, d4, f5);
        if (l2(d4)) {
          if ("function" != typeof (p5 = l2(d4))) throw Error(r5(150));
          return function(t6, l3, u5, s4) {
            if (null == u5) throw Error(r5(151));
            for (var c7 = null, d5 = null, f6 = l3, p6 = l3 = 0, y5 = null, b4 = u5.next(); null !== f6 && !b4.done; p6++, b4 = u5.next()) {
              f6.index > p6 ? (y5 = f6, f6 = null) : y5 = f6.sibling;
              var v4 = h4(t6, f6, b4.value, s4);
              if (null === v4) {
                null === f6 && (f6 = y5);
                break;
              }
              e4 && f6 && null === v4.alternate && n6(t6, f6), l3 = i5(v4, l3, p6), null === d5 ? c7 = v4 : d5.sibling = v4, d5 = v4, f6 = y5;
            }
            if (b4.done) return a5(t6, f6), c7;
            if (null === f6) {
              for (; !b4.done; p6++, b4 = u5.next()) null !== (b4 = m2(t6, b4.value, s4)) && (l3 = i5(b4, l3, p6), null === d5 ? c7 = b4 : d5.sibling = b4, d5 = b4);
              return c7;
            }
            for (f6 = o3(f6); !b4.done; p6++, b4 = u5.next()) null !== (b4 = g4(f6, t6, p6, b4.value, s4)) && (e4 && null !== b4.alternate && f6.delete(null === b4.key ? p6 : b4.key), l3 = i5(b4, l3, p6), null === d5 ? c7 = b4 : d5.sibling = b4, d5 = b4);
            return e4 && f6.forEach(function(e5) {
              return n6(t6, e5);
            }), c7;
          }(t5, c6, d4 = p5.call(d4), f5);
        }
        if ("function" == typeof d4.then) return y4(t5, c6, se(d4), f5);
        if (d4.$$typeof === zl) return y4(t5, c6, M(t5, d4), f5);
        de(t5, d4);
      }
      return "string" == typeof d4 && "" !== d4 || "number" == typeof d4 || "bigint" == typeof d4 ? (d4 = "" + d4, null !== c6 && 6 === c6.tag ? (a5(t5, c6.sibling), (f5 = u4(c6, d4)).return = t5, t5 = f5) : (a5(t5, c6), (f5 = il(d4, t5.mode, f5)).return = t5, t5 = f5), s3(t5)) : a5(t5, c6);
    }
    return function(e5, n7, r6, l3) {
      try {
        Ko = 0;
        var a6 = y4(e5, n7, r6, l3);
        return Jo = null, a6;
      } catch (n8) {
        if (n8 === $o || n8 === qo) throw n8;
        var o4 = t4(29, n8, null, e5.mode);
        return o4.lanes = l3, o4.return = e5, o4;
      }
    };
  }
  function pe() {
    for (var e4 = nu, n6 = tu = nu = 0; n6 < e4; ) {
      var t5 = eu[n6];
      eu[n6++] = null;
      var r6 = eu[n6];
      eu[n6++] = null;
      var l3 = eu[n6];
      eu[n6++] = null;
      var a5 = eu[n6];
      if (eu[n6++] = null, null !== r6 && null !== l3) {
        var o3 = r6.pending;
        null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r6.pending = l3;
      }
      0 !== a5 && ye(t5, l3, a5);
    }
  }
  function me(e4, n6, t5, r6) {
    eu[nu++] = e4, eu[nu++] = n6, eu[nu++] = t5, eu[nu++] = r6, tu |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
  }
  function he(e4, n6, t5, r6) {
    return me(e4, n6, t5, r6), be(e4);
  }
  function ge(e4, n6) {
    return me(e4, null, null, n6), be(e4);
  }
  function ye(e4, n6, t5) {
    e4.lanes |= t5;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= t5);
    for (var l3 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || 1 & e4._visibility || (l3 = true)), e4 = a5, a5 = a5.return;
    return 3 === e4.tag ? (a5 = e4.stateNode, l3 && null !== n6 && (l3 = 31 - Qa(t5), null === (r6 = (e4 = a5.hiddenUpdates)[l3]) ? e4[l3] = [n6] : r6.push(n6), n6.lane = 536870912 | t5), a5) : null;
  }
  function be(e4) {
    if (50 < bi) throw bi = 0, vi = null, Error(r5(185));
    for (var n6 = e4.return; null !== n6; ) n6 = (e4 = n6).return;
    return 3 === e4.tag ? e4.stateNode : null;
  }
  function ve(e4) {
    e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  function Se(e4, n6) {
    e4 = e4.updateQueue, n6.updateQueue === e4 && (n6.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
  }
  function ke(e4) {
    return { lane: e4, tag: 0, payload: null, callback: null, next: null };
  }
  function we(e4, n6, t5) {
    var r6 = e4.updateQueue;
    if (null === r6) return null;
    if (r6 = r6.shared, 0 != (2 & Mu)) {
      var l3 = r6.pending;
      return null === l3 ? n6.next = n6 : (n6.next = l3.next, l3.next = n6), r6.pending = n6, n6 = be(e4), ye(e4, null, t5), n6;
    }
    return me(e4, r6, n6, t5), be(e4);
  }
  function ze(e4, n6, t5) {
    if (null !== (n6 = n6.updateQueue) && (n6 = n6.shared, 0 != (4194048 & t5))) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, b3(e4, t5);
    }
  }
  function xe(e4, n6) {
    var t5 = e4.updateQueue, r6 = e4.alternate;
    if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
      var l3 = null, a5 = null;
      if (null !== (t5 = t5.firstBaseUpdate)) {
        do {
          var o3 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
          null === a5 ? l3 = a5 = o3 : a5 = a5.next = o3, t5 = t5.next;
        } while (null !== t5);
        null === a5 ? l3 = a5 = n6 : a5 = a5.next = n6;
      } else l3 = a5 = n6;
      return t5 = { baseState: r6.baseState, firstBaseUpdate: l3, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
    }
    null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n6 : e4.next = n6, t5.lastBaseUpdate = n6;
  }
  function Ee() {
    if (lu && null !== Wo) throw Wo;
  }
  function Ce(e4, n6, t5, r6) {
    lu = false;
    var l3 = e4.updateQueue;
    ru = false;
    var a5 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u4 = l3.shared.pending;
    if (null !== u4) {
      l3.shared.pending = null;
      var i5 = u4, s3 = i5.next;
      i5.next = null, null === o3 ? a5 = s3 : o3.next = s3, o3 = i5;
      var c5 = e4.alternate;
      null !== c5 && (u4 = (c5 = c5.updateQueue).lastBaseUpdate) !== o3 && (null === u4 ? c5.firstBaseUpdate = s3 : u4.next = s3, c5.lastBaseUpdate = i5);
    }
    if (null !== a5) {
      var d3 = l3.baseState;
      for (o3 = 0, c5 = s3 = i5 = null, u4 = a5; ; ) {
        var f4 = -536870913 & u4.lane, p4 = f4 !== u4.lane;
        if (p4 ? (Bu & f4) === f4 : (r6 & f4) === f4) {
          0 !== f4 && f4 === Mo && (lu = true), null !== c5 && (c5 = c5.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
          e: {
            var m2 = e4, h4 = u4;
            f4 = n6;
            var g4 = t5;
            switch (h4.tag) {
              case 1:
                if ("function" == typeof (m2 = h4.payload)) {
                  d3 = m2.call(g4, d3, f4);
                  break e;
                }
                d3 = m2;
                break e;
              case 3:
                m2.flags = -65537 & m2.flags | 128;
              case 0:
                if (null == (f4 = "function" == typeof (m2 = h4.payload) ? m2.call(g4, d3, f4) : m2)) break e;
                d3 = hl({}, d3, f4);
                break e;
              case 2:
                ru = true;
            }
          }
          null !== (f4 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l3.callbacks) ? l3.callbacks = [f4] : p4.push(f4));
        } else p4 = { lane: f4, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c5 ? (s3 = c5 = p4, i5 = d3) : c5 = c5.next = p4, o3 |= f4;
        if (null === (u4 = u4.next)) {
          if (null === (u4 = l3.shared.pending)) break;
          u4 = (p4 = u4).next, p4.next = null, l3.lastBaseUpdate = p4, l3.shared.pending = null;
        }
      }
      null === c5 && (i5 = d3), l3.baseState = i5, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c5, null === a5 && (l3.shared.lanes = 0), Xu |= o3, e4.lanes = o3, e4.memoizedState = d3;
    }
  }
  function Pe(e4, n6) {
    if ("function" != typeof e4) throw Error(r5(191, e4));
    e4.call(n6);
  }
  function _e(e4, n6) {
    var t5 = e4.callbacks;
    if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) Pe(t5[e4], n6);
  }
  function Te(e4, n6) {
    s2(ou, e4 = Ju), s2(au, n6), Ju = e4 | n6.baseLanes;
  }
  function Re() {
    s2(ou, Ju), s2(au, au.current);
  }
  function Ne() {
    Ju = ou.current, i4(au), i4(ou);
  }
  function Le(e4) {
    var n6 = e4.alternate;
    s2(su, 1 & su.current), s2(uu, e4), null === iu && (null === n6 || null !== au.current || null !== n6.memoizedState) && (iu = e4);
  }
  function Ue(e4) {
    s2(su, su.current), s2(uu, e4), null === iu && (iu = e4);
  }
  function De(e4) {
    22 === e4.tag ? (s2(su, su.current), s2(uu, e4), null === iu && (iu = e4)) : Ie();
  }
  function Ie() {
    s2(su, su.current), s2(uu, uu.current);
  }
  function Fe(e4) {
    i4(uu), iu === e4 && (iu = null), i4(su);
  }
  function je(e4) {
    for (var n6 = e4; null !== n6; ) {
      if (13 === n6.tag) {
        var t5 = n6.memoizedState;
        if (null !== t5 && (null === (t5 = t5.dehydrated) || Pa(t5) || _a(t5))) return n6;
      } else if (19 !== n6.tag || "forwards" !== n6.memoizedProps.revealOrder && "backwards" !== n6.memoizedProps.revealOrder && "unstable_legacy-backwards" !== n6.memoizedProps.revealOrder && "together" !== n6.memoizedProps.revealOrder) {
        if (null !== n6.child) {
          n6.child.return = n6, n6 = n6.child;
          continue;
        }
      } else if (0 != (128 & n6.flags)) return n6;
      if (n6 === e4) break;
      for (; null === n6.sibling; ) {
        if (null === n6.return || n6.return === e4) return null;
        n6 = n6.return;
      }
      n6.sibling.return = n6.return, n6 = n6.sibling;
    }
    return null;
  }
  function Ae() {
    throw Error(r5(321));
  }
  function He(e4, n6) {
    if (null === n6) return false;
    for (var t5 = 0; t5 < n6.length && t5 < e4.length; t5++) if (!uo(e4[t5], n6[t5])) return false;
    return true;
  }
  function Oe(e4, n6, t5, r6, l3, a5) {
    return cu = a5, du = n6, n6.memoizedState = null, n6.updateQueue = null, n6.lanes = 0, Dl.H = null === e4 || null === e4.memoizedState ? wu : zu, gu = false, a5 = t5(r6, l3), gu = false, hu && (a5 = We(n6, t5, r6, l3)), Me(e4), a5;
  }
  function Me(e4) {
    Dl.H = ku;
    var n6 = null !== fu && null !== fu.next;
    if (cu = 0, pu = fu = du = null, mu = false, bu = 0, vu = null, n6) throw Error(r5(300));
    null === e4 || Pu || null !== (e4 = e4.dependencies) && A(e4) && (Pu = true);
  }
  function We(e4, n6, t5, l3) {
    du = e4;
    var a5 = 0;
    do {
      if (hu && (vu = null), bu = 0, hu = false, 25 <= a5) throw Error(r5(301));
      if (a5 += 1, pu = fu = null, null != e4.updateQueue) {
        var o3 = e4.updateQueue;
        o3.lastEffect = null, o3.events = null, o3.stores = null, null != o3.memoCache && (o3.memoCache.index = 0);
      }
      Dl.H = xu, o3 = n6(t5, l3);
    } while (hu);
    return o3;
  }
  function Qe() {
    var e4 = Dl.H, n6 = e4.useState()[0];
    return n6 = "function" == typeof n6.then ? Ge(n6) : n6, e4 = e4.useState()[0], (null !== fu ? fu.memoizedState : null) !== e4 && (du.flags |= 1024), n6;
  }
  function Be() {
    var e4 = 0 !== yu;
    return yu = 0, e4;
  }
  function $e(e4, n6, t5) {
    n6.updateQueue = e4.updateQueue, n6.flags &= -2053, e4.lanes &= ~t5;
  }
  function Ve(e4) {
    if (mu) {
      for (e4 = e4.memoizedState; null !== e4; ) {
        var n6 = e4.queue;
        null !== n6 && (n6.pending = null), e4 = e4.next;
      }
      mu = false;
    }
    cu = 0, pu = fu = du = null, hu = false, bu = yu = 0, vu = null;
  }
  function qe() {
    var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === pu ? du.memoizedState = pu = e4 : pu = pu.next = e4, pu;
  }
  function Ye() {
    if (null === fu) {
      var e4 = du.alternate;
      e4 = null !== e4 ? e4.memoizedState : null;
    } else e4 = fu.next;
    var n6 = null === pu ? du.memoizedState : pu.next;
    if (null !== n6) pu = n6, fu = e4;
    else {
      if (null === e4) {
        if (null === du.alternate) throw Error(r5(467));
        throw Error(r5(310));
      }
      e4 = { memoizedState: (fu = e4).memoizedState, baseState: fu.baseState, baseQueue: fu.baseQueue, queue: fu.queue, next: null }, null === pu ? du.memoizedState = pu = e4 : pu = pu.next = e4;
    }
    return pu;
  }
  function Ge(e4) {
    var n6 = bu;
    return bu += 1, null === vu && (vu = []), e4 = ae(vu, e4, n6), n6 = du, null === (null === pu ? n6.memoizedState : pu.next) && (n6 = n6.alternate, Dl.H = null === n6 || null === n6.memoizedState ? wu : zu), e4;
  }
  function Je(e4) {
    if (null !== e4 && "object" == typeof e4) {
      if ("function" == typeof e4.then) return Ge(e4);
      if (e4.$$typeof === zl) return O(e4);
    }
    throw Error(r5(438, String(e4)));
  }
  function Ke(e4) {
    var n6 = null, t5 = du.updateQueue;
    if (null !== t5 && (n6 = t5.memoCache), null == n6) {
      var r6 = du.alternate;
      null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n6 = { data: r6.data.map(function(e5) {
        return e5.slice();
      }), index: 0 });
    }
    if (null == n6 && (n6 = { data: [], index: 0 }), null === t5 && (t5 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = t5), t5.memoCache = n6, void 0 === (t5 = n6.data[n6.index])) for (t5 = n6.data[n6.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = Rl;
    return n6.index++, t5;
  }
  function Xe(e4, n6) {
    return "function" == typeof n6 ? n6(e4) : n6;
  }
  function Ze(e4) {
    return en(Ye(), fu, e4);
  }
  function en(e4, n6, t5) {
    var l3 = e4.queue;
    if (null === l3) throw Error(r5(311));
    l3.lastRenderedReducer = t5;
    var a5 = e4.baseQueue, o3 = l3.pending;
    if (null !== o3) {
      if (null !== a5) {
        var u4 = a5.next;
        a5.next = o3.next, o3.next = u4;
      }
      n6.baseQueue = a5 = o3, l3.pending = null;
    }
    if (o3 = e4.baseState, null === a5) e4.memoizedState = o3;
    else {
      var i5 = u4 = null, s3 = null, c5 = n6 = a5.next, d3 = false;
      do {
        var f4 = -536870913 & c5.lane;
        if (f4 !== c5.lane ? (Bu & f4) === f4 : (cu & f4) === f4) {
          var p4 = c5.revertLane;
          if (0 === p4) null !== s3 && (s3 = s3.next = { lane: 0, revertLane: 0, gesture: null, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }), f4 === Mo && (d3 = true);
          else {
            if ((cu & p4) === p4) {
              c5 = c5.next, p4 === Mo && (d3 = true);
              continue;
            }
            f4 = { lane: 0, revertLane: c5.revertLane, gesture: null, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }, null === s3 ? (i5 = s3 = f4, u4 = o3) : s3 = s3.next = f4, du.lanes |= p4, Xu |= p4;
          }
          f4 = c5.action, gu && t5(o3, f4), o3 = c5.hasEagerState ? c5.eagerState : t5(o3, f4);
        } else p4 = { lane: f4, revertLane: c5.revertLane, gesture: c5.gesture, action: c5.action, hasEagerState: c5.hasEagerState, eagerState: c5.eagerState, next: null }, null === s3 ? (i5 = s3 = p4, u4 = o3) : s3 = s3.next = p4, du.lanes |= f4, Xu |= f4;
        c5 = c5.next;
      } while (null !== c5 && c5 !== n6);
      if (null === s3 ? u4 = o3 : s3.next = i5, !uo(o3, e4.memoizedState) && (Pu = true, d3 && null !== (t5 = Wo))) throw t5;
      e4.memoizedState = o3, e4.baseState = u4, e4.baseQueue = s3, l3.lastRenderedState = o3;
    }
    return null === a5 && (l3.lanes = 0), [e4.memoizedState, l3.dispatch];
  }
  function nn(e4) {
    var n6 = Ye(), t5 = n6.queue;
    if (null === t5) throw Error(r5(311));
    t5.lastRenderedReducer = e4;
    var l3 = t5.dispatch, a5 = t5.pending, o3 = n6.memoizedState;
    if (null !== a5) {
      t5.pending = null;
      var u4 = a5 = a5.next;
      do {
        o3 = e4(o3, u4.action), u4 = u4.next;
      } while (u4 !== a5);
      uo(o3, n6.memoizedState) || (Pu = true), n6.memoizedState = o3, null === n6.baseQueue && (n6.baseState = o3), t5.lastRenderedState = o3;
    }
    return [o3, l3];
  }
  function tn(e4, n6, t5) {
    var l3 = du, a5 = Ye();
    t5 = n6();
    var o3 = !uo((fu || a5).memoizedState, t5);
    if (o3 && (a5.memoizedState = t5, Pu = true), a5 = a5.queue, _n(an.bind(null, l3, a5, e4), [e4]), a5.getSnapshot !== n6 || o3 || null !== pu && 1 & pu.memoizedState.tag) {
      if (l3.flags |= 2048, zn(9, { destroy: void 0 }, ln.bind(null, l3, a5, t5, n6), null), null === Wu) throw Error(r5(349));
      0 != (127 & cu) || rn(l3, n6, t5);
    }
    return t5;
  }
  function rn(e4, n6, t5) {
    e4.flags |= 16384, e4 = { getSnapshot: n6, value: t5 }, null === (n6 = du.updateQueue) ? (n6 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n6, n6.stores = [e4]) : null === (t5 = n6.stores) ? n6.stores = [e4] : t5.push(e4);
  }
  function ln(e4, n6, t5, r6) {
    n6.value = t5, n6.getSnapshot = r6, on3(n6) && un(e4);
  }
  function an(e4, n6, t5) {
    return t5(function() {
      on3(n6) && un(e4);
    });
  }
  function on3(e4) {
    var n6 = e4.getSnapshot;
    e4 = e4.value;
    try {
      var t5 = n6();
      return !uo(e4, t5);
    } catch (e5) {
      return true;
    }
  }
  function un(e4) {
    var n6 = ge(e4, 2);
    null !== n6 && zr(n6, 0, 2);
  }
  function sn(e4) {
    var n6 = qe();
    if ("function" == typeof e4) {
      var t5 = e4;
      if (e4 = t5(), gu) {
        k3(true);
        try {
          t5();
        } finally {
          k3(false);
        }
      }
    }
    return n6.memoizedState = n6.baseState = e4, n6.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Xe, lastRenderedState: e4 }, n6;
  }
  function cn(e4, n6, t5, r6) {
    return e4.baseState = t5, en(e4, fu, "function" == typeof r6 ? r6 : Xe);
  }
  function dn(e4, n6, t5, l3, a5) {
    if (Yn(e4)) throw Error(r5(485));
    if (null !== (e4 = n6.action)) {
      var o3 = { payload: a5, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e5) {
        o3.listeners.push(e5);
      } };
      null !== Dl.T ? t5(true) : o3.isTransition = false, l3(o3), null === (t5 = n6.pending) ? (o3.next = n6.pending = o3, fn(n6, o3)) : (o3.next = t5.next, n6.pending = t5.next = o3);
    }
  }
  function fn(e4, n6) {
    var t5 = n6.action, r6 = n6.payload, l3 = e4.state;
    if (n6.isTransition) {
      var a5 = Dl.T, o3 = {};
      Dl.T = o3;
      try {
        var u4 = t5(l3, r6), i5 = Dl.S;
        null !== i5 && i5(o3, u4), pn(e4, n6, u4);
      } catch (t6) {
        hn(e4, n6, t6);
      } finally {
        null !== a5 && null !== o3.types && (a5.types = o3.types), Dl.T = a5;
      }
    } else try {
      pn(e4, n6, a5 = t5(l3, r6));
    } catch (t6) {
      hn(e4, n6, t6);
    }
  }
  function pn(e4, n6, t5) {
    null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? t5.then(function(t6) {
      mn(e4, n6, t6);
    }, function(t6) {
      return hn(e4, n6, t6);
    }) : mn(e4, n6, t5);
  }
  function mn(e4, n6, t5) {
    n6.status = "fulfilled", n6.value = t5, gn(n6), e4.state = t5, null !== (n6 = e4.pending) && ((t5 = n6.next) === n6 ? e4.pending = null : (t5 = t5.next, n6.next = t5, fn(e4, t5)));
  }
  function hn(e4, n6, t5) {
    var r6 = e4.pending;
    if (e4.pending = null, null !== r6) {
      r6 = r6.next;
      do {
        n6.status = "rejected", n6.reason = t5, gn(n6), n6 = n6.next;
      } while (n6 !== r6);
    }
    e4.action = null;
  }
  function gn(e4) {
    e4 = e4.listeners;
    for (var n6 = 0; n6 < e4.length; n6++) (0, e4[n6])();
  }
  function yn(e4, n6) {
    return n6;
  }
  function bn(e4, n6) {
    var t5, r6, l3;
    (t5 = qe()).memoizedState = t5.baseState = n6, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: yn, lastRenderedState: n6 }, t5.queue = r6, t5 = $n.bind(null, du, r6), r6.dispatch = t5, r6 = sn(false);
    var a5 = qn.bind(null, du, false, r6.queue);
    return l3 = { state: n6, dispatch: null, action: e4, pending: null }, (r6 = qe()).queue = l3, t5 = dn.bind(null, du, l3, a5, t5), l3.dispatch = t5, r6.memoizedState = e4, [n6, t5, false];
  }
  function vn(e4) {
    return Sn(Ye(), fu, e4);
  }
  function Sn(e4, n6, t5) {
    if (n6 = en(e4, n6, yn)[0], e4 = Ze(Xe)[0], "object" == typeof n6 && null !== n6 && "function" == typeof n6.then) try {
      var r6 = Ge(n6);
    } catch (e5) {
      if (e5 === $o) throw qo;
      throw e5;
    }
    else r6 = n6;
    var l3 = (n6 = Ye()).queue, a5 = l3.dispatch;
    return t5 !== n6.memoizedState && (du.flags |= 2048, zn(9, { destroy: void 0 }, kn.bind(null, l3, t5), null)), [r6, a5, e4];
  }
  function kn(e4, n6) {
    e4.action = n6;
  }
  function wn(e4) {
    var n6 = Ye(), t5 = fu;
    if (null !== t5) return Sn(n6, t5, e4);
    Ye(), n6 = n6.memoizedState;
    var r6 = (t5 = Ye()).queue.dispatch;
    return t5.memoizedState = e4, [n6, r6, false];
  }
  function zn(e4, n6, t5, r6) {
    return e4 = { tag: e4, create: t5, deps: r6, inst: n6, next: null }, null === (n6 = du.updateQueue) && (n6 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n6), null === (t5 = n6.lastEffect) ? n6.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n6.lastEffect = e4), e4;
  }
  function xn() {
    return Ye().memoizedState;
  }
  function En(e4, n6, t5, r6) {
    var l3 = qe();
    du.flags |= e4, l3.memoizedState = zn(1 | n6, { destroy: void 0 }, t5, void 0 === r6 ? null : r6);
  }
  function Cn(e4, n6, t5, r6) {
    var l3 = Ye();
    r6 = void 0 === r6 ? null : r6;
    var a5 = l3.memoizedState.inst;
    null !== fu && null !== r6 && He(r6, fu.memoizedState.deps) ? l3.memoizedState = zn(n6, a5, t5, r6) : (du.flags |= e4, l3.memoizedState = zn(1 | n6, a5, t5, r6));
  }
  function Pn(e4, n6) {
    En(8390656, 8, e4, n6);
  }
  function _n(e4, n6) {
    Cn(2048, 8, e4, n6);
  }
  function Tn(e4) {
    var n6 = Ye().memoizedState;
    return function(e5) {
      du.flags |= 4;
      var n7 = du.updateQueue;
      if (null === n7) n7 = { lastEffect: null, events: null, stores: null, memoCache: null }, du.updateQueue = n7, n7.events = [e5];
      else {
        var t5 = n7.events;
        null === t5 ? n7.events = [e5] : t5.push(e5);
      }
    }({ ref: n6, nextImpl: e4 }), function() {
      if (0 != (2 & Mu)) throw Error(r5(440));
      return n6.impl.apply(void 0, arguments);
    };
  }
  function Rn(e4, n6) {
    return Cn(4, 2, e4, n6);
  }
  function Nn(e4, n6) {
    return Cn(4, 4, e4, n6);
  }
  function Ln(e4, n6) {
    if ("function" == typeof n6) {
      e4 = e4();
      var t5 = n6(e4);
      return function() {
        "function" == typeof t5 ? t5() : n6(null);
      };
    }
    if (null != n6) return e4 = e4(), n6.current = e4, function() {
      n6.current = null;
    };
  }
  function Un(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, Cn(4, 4, Ln.bind(null, n6, e4), t5);
  }
  function Dn() {
  }
  function In(e4, n6) {
    var t5 = Ye();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    return null !== n6 && He(n6, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n6], e4);
  }
  function Fn(e4, n6) {
    var t5 = Ye();
    n6 = void 0 === n6 ? null : n6;
    var r6 = t5.memoizedState;
    if (null !== n6 && He(n6, r6[1])) return r6[0];
    if (r6 = e4(), gu) {
      k3(true);
      try {
        e4();
      } finally {
        k3(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }
  function jn(e4, n6, t5) {
    return void 0 === t5 || 0 != (1073741824 & cu) && 0 == (261930 & Bu) ? e4.memoizedState = n6 : (e4.memoizedState = t5, e4 = wr(), du.lanes |= e4, Xu |= e4, t5);
  }
  function An(e4, n6, t5, r6) {
    return uo(t5, n6) ? t5 : null !== au.current ? (e4 = jn(e4, t5, r6), uo(e4, n6) || (Pu = true), e4) : 0 == (42 & cu) || 0 != (1073741824 & cu) && 0 == (261930 & Bu) ? (Pu = true, e4.memoizedState = t5) : (e4 = wr(), du.lanes |= e4, Xu |= e4, n6);
  }
  function Hn(e4, n6, t5, r6, l3) {
    var a5 = Xl();
    Kl(0 !== a5 && 8 > a5 ? a5 : 8);
    var o3, u4, i5, s3 = Dl.T, c5 = {};
    Dl.T = c5, qn(e4, false, n6, t5);
    try {
      var d3 = l3(), f4 = Dl.S;
      null !== f4 && f4(c5, d3), null !== d3 && "object" == typeof d3 && "function" == typeof d3.then ? Vn(e4, n6, (o3 = r6, u4 = [], i5 = { status: "pending", value: null, reason: null, then: function(e5) {
        u4.push(e5);
      } }, d3.then(function() {
        i5.status = "fulfilled", i5.value = o3;
        for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o3);
      }, function(e5) {
        for (i5.status = "rejected", i5.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
      }), i5), kr()) : Vn(e4, n6, r6, kr());
    } catch (t6) {
      Vn(e4, n6, { then: function() {
      }, status: "rejected", reason: t6 }, kr());
    } finally {
      Kl(a5), null !== s3 && null !== c5.types && (s3.types = c5.types), Dl.T = s3;
    }
  }
  function On() {
    return O(ca);
  }
  function Mn() {
    return Ye().memoizedState;
  }
  function Wn() {
    return Ye().memoizedState;
  }
  function Qn(e4) {
    for (var n6 = e4.return; null !== n6; ) {
      switch (n6.tag) {
        case 24:
        case 3:
          var t5 = kr(), r6 = we(n6, e4 = ke(t5), t5);
          return null !== r6 && (zr(r6, 0, t5), ze(r6, n6, t5)), n6 = { cache: Q() }, void (e4.payload = n6);
      }
      n6 = n6.return;
    }
  }
  function Bn(e4, n6, t5) {
    var r6 = kr();
    t5 = { lane: r6, revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null }, Yn(e4) ? Gn(n6, t5) : null !== (t5 = he(e4, n6, t5, r6)) && (zr(t5, 0, r6), Jn(t5, n6, r6));
  }
  function $n(e4, n6, t5) {
    Vn(e4, n6, t5, kr());
  }
  function Vn(e4, n6, t5, r6) {
    var l3 = { lane: r6, revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null };
    if (Yn(e4)) Gn(n6, l3);
    else {
      var a5 = e4.alternate;
      if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n6.lastRenderedReducer)) try {
        var o3 = n6.lastRenderedState, u4 = a5(o3, t5);
        if (l3.hasEagerState = true, l3.eagerState = u4, uo(u4, o3)) return me(e4, n6, l3, 0), null === Wu && pe(), false;
      } catch (e5) {
      }
      if (null !== (t5 = he(e4, n6, l3, r6))) return zr(t5, 0, r6), Jn(t5, n6, r6), true;
    }
    return false;
  }
  function qn(e4, n6, t5, l3) {
    if (l3 = { lane: 2, revertLane: X(), gesture: null, action: l3, hasEagerState: false, eagerState: null, next: null }, Yn(e4)) {
      if (n6) throw Error(r5(479));
    } else null !== (n6 = he(e4, t5, l3, 2)) && zr(n6, 0, 2);
  }
  function Yn(e4) {
    var n6 = e4.alternate;
    return e4 === du || null !== n6 && n6 === du;
  }
  function Gn(e4, n6) {
    hu = mu = true;
    var t5 = e4.pending;
    null === t5 ? n6.next = n6 : (n6.next = t5.next, t5.next = n6), e4.pending = n6;
  }
  function Jn(e4, n6, t5) {
    if (0 != (4194048 & t5)) {
      var r6 = n6.lanes;
      t5 |= r6 &= e4.pendingLanes, n6.lanes = t5, b3(e4, t5);
    }
  }
  function Kn(e4, n6, t5, r6) {
    t5 = null == (t5 = t5(r6, n6 = e4.memoizedState)) ? n6 : hl({}, n6, t5), e4.memoizedState = t5, 0 === e4.lanes && (e4.updateQueue.baseState = t5);
  }
  function Xn(e4, n6, t5, r6, l3, a5, o3) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, a5, o3) : !(n6.prototype && n6.prototype.isPureReactComponent && re(t5, r6) && re(l3, a5));
  }
  function Zn(e4, n6, t5, r6) {
    e4 = n6.state, "function" == typeof n6.componentWillReceiveProps && n6.componentWillReceiveProps(t5, r6), "function" == typeof n6.UNSAFE_componentWillReceiveProps && n6.UNSAFE_componentWillReceiveProps(t5, r6), n6.state !== e4 && Eu.enqueueReplaceState(n6, n6.state, null);
  }
  function et(e4, n6) {
    var t5 = n6;
    if ("ref" in n6) for (var r6 in t5 = {}, n6) "ref" !== r6 && (t5[r6] = n6[r6]);
    if (e4 = e4.defaultProps) for (var l3 in t5 === n6 && (t5 = hl({}, t5)), e4) void 0 === t5[l3] && (t5[l3] = e4[l3]);
    return t5;
  }
  function nt(e4, n6) {
    try {
      (0, e4.onUncaughtError)(n6.value, { componentStack: n6.stack });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  function tt(e4, n6, t5) {
    try {
      (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n6.tag ? n6.stateNode : null });
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  function rt(e4, n6, t5) {
    return (t5 = ke(t5)).tag = 3, t5.payload = { element: null }, t5.callback = function() {
      nt(e4, n6);
    }, t5;
  }
  function lt(e4) {
    return (e4 = ke(e4)).tag = 3, e4;
  }
  function at(e4, n6, t5, r6) {
    var l3 = t5.type.getDerivedStateFromError;
    if ("function" == typeof l3) {
      var a5 = r6.value;
      e4.payload = function() {
        return l3(a5);
      }, e4.callback = function() {
        tt(n6, t5, r6);
      };
    }
    var o3 = t5.stateNode;
    null !== o3 && "function" == typeof o3.componentDidCatch && (e4.callback = function() {
      tt(n6, t5, r6), "function" != typeof l3 && (null === ci ? ci = /* @__PURE__ */ new Set([this]) : ci.add(this));
      var e5 = r6.stack;
      this.componentDidCatch(r6.value, { componentStack: null !== e5 ? e5 : "" });
    });
  }
  function ot(e4, n6, t5, r6) {
    n6.child = null === e4 ? Zo(n6, null, t5, r6) : Xo(n6, e4.child, t5, r6);
  }
  function ut(e4, n6, t5, r6, l3) {
    t5 = t5.render;
    var a5 = n6.ref;
    if ("ref" in r6) {
      var o3 = {};
      for (var u4 in r6) "ref" !== u4 && (o3[u4] = r6[u4]);
    } else o3 = r6;
    return H(n6), r6 = Oe(e4, n6, t5, o3, a5, l3), u4 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, r6, l3), n6.child) : ($e(e4, n6, l3), _t(e4, n6, l3));
  }
  function it(e4, n6, t5, r6, l3) {
    if (null === e4) {
      var a5 = t5.type;
      return "function" != typeof a5 || rl(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = ol(t5.type, null, r6, n6, n6.mode, l3)).ref = n6.ref, e4.return = n6, n6.child = e4) : (n6.tag = 15, n6.type = a5, st(e4, n6, a5, r6, l3));
    }
    if (a5 = e4.child, !Tt(e4, l3)) {
      var o3 = a5.memoizedProps;
      if ((t5 = null !== (t5 = t5.compare) ? t5 : re)(o3, r6) && e4.ref === n6.ref) return _t(e4, n6, l3);
    }
    return n6.flags |= 1, (e4 = ll(a5, r6)).ref = n6.ref, e4.return = n6, n6.child = e4;
  }
  function st(e4, n6, t5, r6, l3) {
    if (null !== e4) {
      var a5 = e4.memoizedProps;
      if (re(a5, r6) && e4.ref === n6.ref) {
        if (Pu = false, n6.pendingProps = r6 = a5, !Tt(e4, l3)) return n6.lanes = e4.lanes, _t(e4, n6, l3);
        0 != (131072 & e4.flags) && (Pu = true);
      }
    }
    return gt(e4, n6, t5, r6, l3);
  }
  function ct(e4, n6, t5, r6) {
    var l3 = r6.children, a5 = null !== e4 ? e4.memoizedState : null;
    if (null === e4 && null === n6.stateNode && (n6.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), "hidden" === r6.mode) {
      if (0 != (128 & n6.flags)) {
        if (a5 = null !== a5 ? a5.baseLanes | t5 : t5, null !== e4) {
          for (r6 = n6.child = e4.child, l3 = 0; null !== r6; ) l3 = l3 | r6.lanes | r6.childLanes, r6 = r6.sibling;
          r6 = l3 & ~a5;
        } else r6 = 0, n6.child = null;
        return ft(e4, n6, a5, t5, r6);
      }
      if (0 == (536870912 & t5)) return r6 = n6.lanes = 536870912, ft(e4, n6, null !== a5 ? a5.baseLanes | t5 : t5, t5, r6);
      n6.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && ne(0, null !== a5 ? a5.cachePool : null), null !== a5 ? Te(n6, a5) : Re(), De(n6);
    } else null !== a5 ? (ne(0, a5.cachePool), Te(n6, a5), Ie(), n6.memoizedState = null) : (null !== e4 && ne(0, null), Re(), Ie());
    return ot(e4, n6, l3, t5), n6.child;
  }
  function dt(e4, n6) {
    return null !== e4 && 22 === e4.tag || null !== n6.stateNode || (n6.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), n6.sibling;
  }
  function ft(e4, n6, t5, r6, l3) {
    var a5 = ee();
    return a5 = null === a5 ? null : { parent: Lo._currentValue2, pool: a5 }, n6.memoizedState = { baseLanes: t5, cachePool: a5 }, null !== e4 && ne(0, null), Re(), De(n6), null !== e4 && j(e4, n6, r6, true), n6.childLanes = l3, null;
  }
  function pt(e4, n6) {
    return (n6 = zt({ mode: n6.mode, children: n6.children }, e4.mode)).ref = e4.ref, e4.child = n6, n6.return = e4, n6;
  }
  function mt(e4, n6, t5) {
    return Xo(n6, e4.child, null, t5), (e4 = pt(n6, n6.pendingProps)).flags |= 2, Fe(n6), n6.memoizedState = null, e4;
  }
  function ht(e4, n6) {
    var t5 = n6.ref;
    if (null === t5) null !== e4 && null !== e4.ref && (n6.flags |= 4194816);
    else {
      if ("function" != typeof t5 && "object" != typeof t5) throw Error(r5(284));
      null !== e4 && e4.ref === t5 || (n6.flags |= 4194816);
    }
  }
  function gt(e4, n6, t5, r6, l3) {
    return H(n6), t5 = Oe(e4, n6, t5, r6, void 0, l3), r6 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, t5, l3), n6.child) : ($e(e4, n6, l3), _t(e4, n6, l3));
  }
  function yt(e4, n6, t5, r6, l3, a5) {
    return H(n6), n6.updateQueue = null, t5 = We(n6, r6, t5, l3), Me(e4), r6 = Be(), null === e4 || Pu ? (n6.flags |= 1, ot(e4, n6, t5, a5), n6.child) : ($e(e4, n6, a5), _t(e4, n6, a5));
  }
  function bt(e4, n6, t5, r6, l3) {
    if (H(n6), null === n6.stateNode) {
      var a5 = Wa, o3 = t5.contextType;
      "object" == typeof o3 && null !== o3 && (a5 = O(o3)), a5 = new t5(r6, a5), n6.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = Eu, n6.stateNode = a5, a5._reactInternals = n6, (a5 = n6.stateNode).props = r6, a5.state = n6.memoizedState, a5.refs = {}, ve(n6), o3 = t5.contextType, a5.context = "object" == typeof o3 && null !== o3 ? O(o3) : Wa, a5.state = n6.memoizedState, "function" == typeof (o3 = t5.getDerivedStateFromProps) && (Kn(n6, t5, o3, r6), a5.state = n6.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o3 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o3 !== a5.state && Eu.enqueueReplaceState(a5, a5.state, null), Ce(n6, r6, a5, l3), Ee(), a5.state = n6.memoizedState), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = true;
    } else if (null === e4) {
      a5 = n6.stateNode;
      var u4 = n6.memoizedProps, i5 = et(t5, u4);
      a5.props = i5;
      var s3 = a5.context, c5 = t5.contextType;
      o3 = Wa, "object" == typeof c5 && null !== c5 && (o3 = O(c5));
      var d3 = t5.getDerivedStateFromProps;
      c5 = "function" == typeof d3 || "function" == typeof a5.getSnapshotBeforeUpdate, u4 = n6.pendingProps !== u4, c5 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 || s3 !== o3) && Zn(n6, a5, r6, o3), ru = false;
      var f4 = n6.memoizedState;
      a5.state = f4, Ce(n6, r6, a5, l3), Ee(), s3 = n6.memoizedState, u4 || f4 !== s3 || ru ? ("function" == typeof d3 && (Kn(n6, t5, d3, r6), s3 = n6.memoizedState), (i5 = ru || Xn(n6, t5, i5, r6, f4, s3, o3)) ? (c5 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n6.flags |= 4194308)) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), n6.memoizedProps = r6, n6.memoizedState = s3), a5.props = r6, a5.state = s3, a5.context = o3, r6 = i5) : ("function" == typeof a5.componentDidMount && (n6.flags |= 4194308), r6 = false);
    } else {
      a5 = n6.stateNode, Se(e4, n6), c5 = et(t5, o3 = n6.memoizedProps), a5.props = c5, d3 = n6.pendingProps, f4 = a5.context, s3 = t5.contextType, i5 = Wa, "object" == typeof s3 && null !== s3 && (i5 = O(s3)), (s3 = "function" == typeof (u4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o3 !== d3 || f4 !== i5) && Zn(n6, a5, r6, i5), ru = false, f4 = n6.memoizedState, a5.state = f4, Ce(n6, r6, a5, l3), Ee();
      var p4 = n6.memoizedState;
      o3 !== d3 || f4 !== p4 || ru || null !== e4 && null !== e4.dependencies && A(e4.dependencies) ? ("function" == typeof u4 && (Kn(n6, t5, u4, r6), p4 = n6.memoizedState), (c5 = ru || Xn(n6, t5, c5, r6, f4, p4, i5) || null !== e4 && null !== e4.dependencies && A(e4.dependencies)) ? (s3 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, p4, i5), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, p4, i5)), "function" == typeof a5.componentDidUpdate && (n6.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n6.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && f4 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && f4 === e4.memoizedState || (n6.flags |= 1024), n6.memoizedProps = r6, n6.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = i5, r6 = c5) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && f4 === e4.memoizedState || (n6.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && f4 === e4.memoizedState || (n6.flags |= 1024), r6 = false);
    }
    return a5 = r6, ht(e4, n6), r6 = 0 != (128 & n6.flags), a5 || r6 ? (a5 = n6.stateNode, t5 = r6 && "function" != typeof t5.getDerivedStateFromError ? null : a5.render(), n6.flags |= 1, null !== e4 && r6 ? (n6.child = Xo(n6, e4.child, null, l3), n6.child = Xo(n6, null, t5, l3)) : ot(e4, n6, t5, l3), n6.memoizedState = a5.state, e4 = n6.child) : e4 = _t(e4, n6, l3), e4;
  }
  function vt(e4) {
    return { baseLanes: e4, cachePool: te() };
  }
  function St(e4, n6, t5) {
    return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n6 && (e4 |= ni), e4;
  }
  function kt(e4, n6, t5) {
    var l3, a5 = n6.pendingProps, o3 = false, u4 = 0 != (128 & n6.flags);
    if ((l3 = u4) || (l3 = (null === e4 || null !== e4.memoizedState) && 0 != (2 & su.current)), l3 && (o3 = true, n6.flags &= -129), l3 = 0 != (32 & n6.flags), n6.flags &= -33, null === e4) {
      var i5 = a5.children;
      return a5 = a5.fallback, o3 ? (Ie(), i5 = zt({ mode: "hidden", children: i5 }, o3 = n6.mode), a5 = ul(a5, o3, t5, null), i5.return = n6, a5.return = n6, i5.sibling = a5, n6.child = i5, (a5 = n6.child).memoizedState = vt(t5), a5.childLanes = St(e4, l3, t5), n6.memoizedState = _u, dt(null, a5)) : (Le(n6), wt(n6, i5));
    }
    var s3, c5 = e4.memoizedState;
    if (null !== c5 && null !== (i5 = c5.dehydrated)) {
      if (u4) 256 & n6.flags ? (Le(n6), n6.flags &= -257, n6 = xt(e4, n6, t5)) : null !== n6.memoizedState ? (Ie(), n6.child = e4.child, n6.flags |= 128, n6 = null) : (Ie(), i5 = a5.fallback, o3 = n6.mode, a5 = zt({ mode: "visible", children: a5.children }, o3), (i5 = ul(i5, o3, t5, null)).flags |= 2, a5.return = n6, i5.return = n6, a5.sibling = i5, n6.child = a5, Xo(n6, e4.child, null, t5), (a5 = n6.child).memoizedState = vt(t5), a5.childLanes = St(e4, l3, t5), n6.memoizedState = _u, n6 = dt(null, a5));
      else if (Le(n6), _a(i5)) l3 = Ta(i5).digest, (a5 = Error(r5(419))).stack = "", a5.digest = l3, s3 = { value: a5, source: null, stack: null }, null === Eo ? Eo = [s3] : Eo.push(s3), n6 = xt(e4, n6, t5);
      else if (Pu || j(e4, n6, t5, false), l3 = 0 != (t5 & e4.childLanes), Pu || l3) {
        if (null !== (l3 = Wu) && 0 !== (a5 = v3(l3, t5)) && a5 !== c5.retryLane) throw c5.retryLane = a5, ge(e4, a5), zr(l3, 0, a5), Cu;
        Pa(i5) || Ur(), n6 = xt(e4, n6, t5);
      } else Pa(i5) ? (n6.flags |= 192, n6.child = e4.child, n6 = null) : (e4 = c5.treeContext, (n6 = wt(n6, a5.children)).flags |= 4096);
      return n6;
    }
    return o3 ? (Ie(), i5 = a5.fallback, o3 = n6.mode, u4 = (c5 = e4.child).sibling, (a5 = ll(c5, { mode: "hidden", children: a5.children })).subtreeFlags = 65011712 & c5.subtreeFlags, null !== u4 ? i5 = ll(u4, i5) : (i5 = ul(i5, o3, t5, null)).flags |= 2, i5.return = n6, a5.return = n6, a5.sibling = i5, n6.child = a5, dt(null, a5), a5 = n6.child, null === (i5 = e4.child.memoizedState) ? i5 = vt(t5) : (null !== (o3 = i5.cachePool) ? (c5 = Lo._currentValue2, o3 = o3.parent !== c5 ? { parent: c5, pool: c5 } : o3) : o3 = te(), i5 = { baseLanes: i5.baseLanes | t5, cachePool: o3 }), a5.memoizedState = i5, a5.childLanes = St(e4, l3, t5), n6.memoizedState = _u, dt(e4.child, a5)) : (Le(n6), e4 = (t5 = e4.child).sibling, (t5 = ll(t5, { mode: "visible", children: a5.children })).return = n6, t5.sibling = null, null !== e4 && (null === (l3 = n6.deletions) ? (n6.deletions = [e4], n6.flags |= 16) : l3.push(e4)), n6.child = t5, n6.memoizedState = null, t5);
  }
  function wt(e4, n6) {
    return (n6 = zt({ mode: "visible", children: n6 }, e4.mode)).return = e4, e4.child = n6;
  }
  function zt(e4, n6) {
    return (e4 = t4(22, e4, null, n6)).lanes = 0, e4;
  }
  function xt(e4, n6, t5) {
    return Xo(n6, e4.child, null, t5), (e4 = wt(n6, n6.pendingProps.children)).flags |= 2, n6.memoizedState = null, e4;
  }
  function Et(e4, n6, t5) {
    e4.lanes |= n6;
    var r6 = e4.alternate;
    null !== r6 && (r6.lanes |= n6), I(e4.return, n6, t5);
  }
  function Ct(e4, n6, t5, r6, l3, a5) {
    var o3 = e4.memoizedState;
    null === o3 ? e4.memoizedState = { isBackwards: n6, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l3, treeForkCount: a5 } : (o3.isBackwards = n6, o3.rendering = null, o3.renderingStartTime = 0, o3.last = r6, o3.tail = t5, o3.tailMode = l3, o3.treeForkCount = a5);
  }
  function Pt(e4, n6, t5) {
    var r6 = n6.pendingProps, l3 = r6.revealOrder, a5 = r6.tail;
    r6 = r6.children;
    var o3 = su.current, u4 = 0 != (2 & o3);
    if (u4 ? (o3 = 1 & o3 | 2, n6.flags |= 128) : o3 &= 1, s2(su, o3), ot(e4, n6, r6, t5), r6 = 0, !u4 && null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n6.child; null !== e4; ) {
      if (13 === e4.tag) null !== e4.memoizedState && Et(e4, t5, n6);
      else if (19 === e4.tag) Et(e4, t5, n6);
      else if (null !== e4.child) {
        e4.child.return = e4, e4 = e4.child;
        continue;
      }
      if (e4 === n6) break e;
      for (; null === e4.sibling; ) {
        if (null === e4.return || e4.return === n6) break e;
        e4 = e4.return;
      }
      e4.sibling.return = e4.return, e4 = e4.sibling;
    }
    switch (l3) {
      case "forwards":
        for (t5 = n6.child, l3 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === je(e4) && (l3 = t5), t5 = t5.sibling;
        null === (t5 = l3) ? (l3 = n6.child, n6.child = null) : (l3 = t5.sibling, t5.sibling = null), Ct(n6, false, l3, t5, a5, r6);
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (t5 = null, l3 = n6.child, n6.child = null; null !== l3; ) {
          if (null !== (e4 = l3.alternate) && null === je(e4)) {
            n6.child = l3;
            break;
          }
          e4 = l3.sibling, l3.sibling = t5, t5 = l3, l3 = e4;
        }
        Ct(n6, true, t5, null, a5, r6);
        break;
      case "together":
        Ct(n6, false, null, null, void 0, r6);
        break;
      default:
        n6.memoizedState = null;
    }
    return n6.child;
  }
  function _t(e4, n6, t5) {
    if (null !== e4 && (n6.dependencies = e4.dependencies), Xu |= n6.lanes, 0 == (t5 & n6.childLanes)) {
      if (null === e4) return null;
      if (j(e4, n6, t5, false), 0 == (t5 & n6.childLanes)) return null;
    }
    if (null !== e4 && n6.child !== e4.child) throw Error(r5(153));
    if (null !== n6.child) {
      for (t5 = ll(e4 = n6.child, e4.pendingProps), n6.child = t5, t5.return = n6; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = ll(e4, e4.pendingProps)).return = n6;
      t5.sibling = null;
    }
    return n6.child;
  }
  function Tt(e4, n6) {
    return 0 != (e4.lanes & n6) || !(null === (e4 = e4.dependencies) || !A(e4));
  }
  function Rt(e4, n6, t5) {
    if (null !== e4) if (e4.memoizedProps !== n6.pendingProps) Pu = true;
    else {
      if (!Tt(e4, t5) && 0 == (128 & n6.flags)) return Pu = false, function(e5, n7, t6) {
        switch (n7.tag) {
          case 3:
            _(n7, n7.stateNode.containerInfo), U(0, Lo, e5.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n7);
            break;
          case 4:
            _(n7, n7.stateNode.containerInfo);
            break;
          case 10:
            U(0, n7.type, n7.memoizedProps.value);
            break;
          case 31:
            if (null !== n7.memoizedState) return n7.flags |= 128, Ue(n7), null;
            break;
          case 13:
            var r6 = n7.memoizedState;
            if (null !== r6) return null !== r6.dehydrated ? (Le(n7), n7.flags |= 128, null) : 0 != (t6 & n7.child.childLanes) ? kt(e5, n7, t6) : (Le(n7), null !== (e5 = _t(e5, n7, t6)) ? e5.sibling : null);
            Le(n7);
            break;
          case 19:
            var l4 = 0 != (128 & e5.flags);
            if ((r6 = 0 != (t6 & n7.childLanes)) || (j(e5, n7, t6, false), r6 = 0 != (t6 & n7.childLanes)), l4) {
              if (r6) return Pt(e5, n7, t6);
              n7.flags |= 128;
            }
            if (null !== (l4 = n7.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), s2(su, su.current), r6) break;
            return null;
          case 22:
            return n7.lanes = 0, ct(e5, n7, t6, n7.pendingProps);
          case 24:
            U(0, Lo, e5.memoizedState.cache);
        }
        return _t(e5, n7, t6);
      }(e4, n6, t5);
      Pu = 0 != (131072 & e4.flags);
    }
    else Pu = false;
    switch (n6.lanes = 0, n6.tag) {
      case 16:
        e: {
          var l3 = n6.pendingProps;
          if (e4 = oe(n6.elementType), n6.type = e4, "function" != typeof e4) {
            if (null != e4) {
              var o3 = e4.$$typeof;
              if (o3 === xl) {
                n6.tag = 11, n6 = ut(null, n6, e4, l3, t5);
                break e;
              }
              if (o3 === Pl) {
                n6.tag = 14, n6 = it(null, n6, e4, l3, t5);
                break e;
              }
            }
            throw n6 = a4(e4) || e4, Error(r5(306, n6, ""));
          }
          rl(e4) ? (l3 = et(e4, l3), n6.tag = 1, n6 = bt(null, n6, e4, l3, t5)) : (n6.tag = 0, n6 = gt(null, n6, e4, l3, t5));
        }
        return n6;
      case 0:
        return gt(e4, n6, n6.type, n6.pendingProps, t5);
      case 1:
        return bt(e4, n6, l3 = n6.type, o3 = et(l3, n6.pendingProps), t5);
      case 3:
        if (_(n6, n6.stateNode.containerInfo), null === e4) throw Error(r5(387));
        var u4 = n6.pendingProps;
        l3 = (o3 = n6.memoizedState).element, Se(e4, n6), Ce(n6, u4, null, t5);
        var i5 = n6.memoizedState;
        return u4 = i5.cache, U(0, Lo, u4), u4 !== o3.cache && F(n6, [Lo], t5, true), Ee(), (u4 = i5.element) !== l3 ? (ot(e4, n6, u4, t5), n6 = n6.child) : n6 = _t(e4, n6, t5), n6;
      case 26:
      case 27:
      case 5:
        return R(n6), o3 = n6.type, u4 = n6.pendingProps, i5 = null !== e4 ? e4.memoizedProps : null, l3 = u4.children, Ql(o3, u4) ? l3 = null : null !== i5 && Ql(o3, i5) && (n6.flags |= 32), null !== n6.memoizedState && (o3 = Oe(e4, n6, Qe, null, null, t5), ca._currentValue2 = o3), ht(e4, n6), ot(e4, n6, l3, t5), n6.child;
      case 6:
        return null;
      case 13:
        return kt(e4, n6, t5);
      case 4:
        return _(n6, n6.stateNode.containerInfo), l3 = n6.pendingProps, null === e4 ? n6.child = Xo(n6, null, l3, t5) : ot(e4, n6, l3, t5), n6.child;
      case 11:
        return ut(e4, n6, n6.type, n6.pendingProps, t5);
      case 7:
        return ot(e4, n6, n6.pendingProps, t5), n6.child;
      case 8:
      case 12:
        return ot(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 10:
        return l3 = n6.pendingProps, U(0, n6.type, l3.value), ot(e4, n6, l3.children, t5), n6.child;
      case 9:
        return o3 = n6.type._context, l3 = n6.pendingProps.children, H(n6), l3 = l3(o3 = O(o3)), n6.flags |= 1, ot(e4, n6, l3, t5), n6.child;
      case 14:
        return it(e4, n6, n6.type, n6.pendingProps, t5);
      case 15:
        return st(e4, n6, n6.type, n6.pendingProps, t5);
      case 19:
        return Pt(e4, n6, t5);
      case 31:
        return function(e5, n7, t6) {
          var l4 = n7.pendingProps, a5 = 0 != (128 & n7.flags);
          if (n7.flags &= -129, null === e5) return pt(n7, l4);
          var o4 = e5.memoizedState;
          if (null !== o4) {
            var u5 = o4.dehydrated;
            if (Ue(n7), a5) if (256 & n7.flags) n7.flags &= -257, n7 = mt(e5, n7, t6);
            else {
              if (null === n7.memoizedState) throw Error(r5(558));
              n7.child = e5.child, n7.flags |= 128, n7 = null;
            }
            else if (Pu || j(e5, n7, t6, false), a5 = 0 != (t6 & e5.childLanes), Pu || a5) {
              if (null !== (l4 = Wu) && 0 !== (u5 = v3(l4, t6)) && u5 !== o4.retryLane) throw o4.retryLane = u5, ge(e5, u5), zr(l4, 0, u5), Cu;
              Ur(), n7 = mt(e5, n7, t6);
            } else e5 = o4.treeContext, (n7 = pt(n7, l4)).flags |= 4096;
            return n7;
          }
          return (e5 = ll(e5.child, { mode: l4.mode, children: l4.children })).ref = n7.ref, n7.child = e5, e5.return = n7, e5;
        }(e4, n6, t5);
      case 22:
        return ct(e4, n6, t5, n6.pendingProps);
      case 24:
        return H(n6), l3 = O(Lo), null === e4 ? (null === (o3 = ee()) && (o3 = Wu, u4 = Q(), o3.pooledCache = u4, u4.refCount++, null !== u4 && (o3.pooledCacheLanes |= t5), o3 = u4), n6.memoizedState = { parent: l3, cache: o3 }, ve(n6), U(0, Lo, o3)) : (0 != (e4.lanes & t5) && (Se(e4, n6), Ce(n6, null, null, t5), Ee()), o3 = e4.memoizedState, u4 = n6.memoizedState, o3.parent !== l3 ? (o3 = { parent: l3, cache: l3 }, n6.memoizedState = o3, 0 === n6.lanes && (n6.memoizedState = n6.updateQueue.baseState = o3), U(0, Lo, l3)) : (l3 = u4.cache, U(0, Lo, l3), l3 !== o3.cache && F(n6, [Lo], t5, true))), ot(e4, n6, n6.pendingProps.children, t5), n6.child;
      case 29:
        throw n6.pendingProps;
    }
    throw Error(r5(156, n6.tag));
  }
  function Nt(e4) {
    e4.flags |= 4;
  }
  function Lt(e4, n6, t5, r6, l3) {
    if (0 != (32 & e4.mode) && (null === t5 ? ta(n6, r6) : ra(n6, t5, r6))) {
      if (e4.flags |= 16777216, (335544128 & l3) === l3 || la(n6, r6)) if (aa(e4.stateNode, n6, r6)) e4.flags |= 8192;
      else {
        if (null !== (a5 = uu.current) && ((4194048 & Bu) === Bu ? null !== iu : (62914560 & Bu) !== Bu && 0 == (536870912 & Bu) || a5 !== iu)) throw Go = Yo, Vo;
        e4.flags |= 8192;
      }
    } else e4.flags &= -16777217;
    var a5;
  }
  function Ut(e4, n6) {
    null !== n6 && (e4.flags |= 4), 16384 & e4.flags && (n6 = 22 !== e4.tag ? m() : 536870912, e4.lanes |= n6, ti |= n6);
  }
  function Dt(e4, n6) {
    switch (e4.tailMode) {
      case "hidden":
        n6 = e4.tail;
        for (var t5 = null; null !== n6; ) null !== n6.alternate && (t5 = n6), n6 = n6.sibling;
        null === t5 ? e4.tail = null : t5.sibling = null;
        break;
      case "collapsed":
        t5 = e4.tail;
        for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
        null === r6 ? n6 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  function It(e4) {
    var n6 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
    if (n6) for (var l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= 65011712 & l3.subtreeFlags, r6 |= 65011712 & l3.flags, l3.return = e4, l3 = l3.sibling;
    else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= l3.subtreeFlags, r6 |= l3.flags, l3.return = e4, l3 = l3.sibling;
    return e4.subtreeFlags |= r6, e4.childLanes = t5, n6;
  }
  function Ft(e4, n6, t5) {
    var l3 = n6.pendingProps;
    switch (P(n6), n6.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return It(n6), null;
      case 3:
        return t5 = n6.stateNode, l3 = null, null !== e4 && (l3 = e4.memoizedState.cache), n6.memoizedState.cache !== l3 && (n6.flags |= 2048), D(Lo), T(), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n6.flags) || (n6.flags |= 1024, L()), It(n6), null;
      case 26:
        var a5, o3;
      case 27:
      case 5:
        if (N(n6), a5 = n6.type, null !== e4 && null != n6.stateNode) !function(e5, n7, t6, r6) {
          e5.memoizedProps !== r6 && Nt(n7);
        }(e4, n6, 0, l3);
        else {
          if (!l3) {
            if (null === n6.stateNode) throw Error(r5(166));
            return It(n6), null;
          }
          o3 = So.current;
          var u4 = Ol(a5, l3, wo.current, o3, n6);
          !function(e5, n7, t6, r6) {
            for (t6 = n7.child; null !== t6; ) {
              if (5 === t6.tag || 6 === t6.tag) Ml(e5, t6.stateNode);
              else if (4 !== t6.tag && !Ha && null !== t6.child) {
                t6.child.return = t6, t6 = t6.child;
                continue;
              }
              if (t6 === n7) break;
              for (; null === t6.sibling; ) {
                if (null === t6.return || t6.return === n7) return;
                t6 = t6.return;
              }
              t6.sibling.return = t6.return, t6 = t6.sibling;
            }
          }(u4, n6, false), n6.stateNode = u4, Wl(u4, a5, l3, o3) && Nt(n6);
        }
        return It(n6), Lt(n6, n6.type, null === e4 ? null : e4.memoizedProps, n6.pendingProps, t5), null;
      case 6:
        if (e4 && null != n6.stateNode) (t5 = e4.memoizedProps) !== l3 && Nt(n6);
        else {
          if ("string" != typeof l3 && null === n6.stateNode) throw Error(r5(166));
          e4 = wo.current, t5 = So.current, n6.stateNode = Bl(l3, e4, t5, n6);
        }
        return It(n6), null;
      case 31:
        if (t5 = n6.memoizedState, null === e4 || null !== e4.memoizedState) {
          if (l3 = false, null !== t5) {
            if (null === e4) {
              if (!l3) throw Error(r5(318));
              throw Error(r5(556));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, It(n6), e4 = false;
          } else t5 = L(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = t5), e4 = true;
          if (!e4) return 256 & n6.flags ? (Fe(n6), n6) : (Fe(n6), null);
          if (0 != (128 & n6.flags)) throw Error(r5(558));
        }
        return It(n6), null;
      case 13:
        if (l3 = n6.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
          if (a5 = false, null !== l3 && null !== l3.dehydrated) {
            if (null === e4) {
              if (!a5) throw Error(r5(318));
              throw Error(r5(344));
            }
            0 == (128 & n6.flags) && (n6.memoizedState = null), n6.flags |= 4, It(n6), a5 = false;
          } else a5 = L(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = a5), a5 = true;
          if (!a5) return 256 & n6.flags ? (Fe(n6), n6) : (Fe(n6), null);
        }
        return Fe(n6), 0 != (128 & n6.flags) ? (n6.lanes = t5, n6) : (t5 = null !== l3, e4 = null !== e4 && null !== e4.memoizedState, t5 && (a5 = null, null !== (l3 = n6.child).alternate && null !== l3.alternate.memoizedState && null !== l3.alternate.memoizedState.cachePool && (a5 = l3.alternate.memoizedState.cachePool.pool), o3 = null, null !== l3.memoizedState && null !== l3.memoizedState.cachePool && (o3 = l3.memoizedState.cachePool.pool), o3 !== a5 && (l3.flags |= 2048)), t5 !== e4 && t5 && (n6.child.flags |= 8192), Ut(n6, n6.updateQueue), It(n6), null);
      case 4:
        return T(), null === e4 && Jl(n6.stateNode.containerInfo), It(n6), null;
      case 10:
        return D(n6.type), It(n6), null;
      case 19:
        if (i4(su), null === (l3 = n6.memoizedState)) return It(n6), null;
        if (a5 = 0 != (128 & n6.flags), null === (o3 = l3.rendering)) if (a5) Dt(l3, false);
        else {
          if (0 !== Ku || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n6.child; null !== e4; ) {
            if (null !== (o3 = je(e4))) {
              for (n6.flags |= 128, Dt(l3, false), e4 = o3.updateQueue, n6.updateQueue = e4, Ut(n6, e4), n6.subtreeFlags = 0, e4 = t5, t5 = n6.child; null !== t5; ) al(t5, e4), t5 = t5.sibling;
              return s2(su, 1 & su.current | 2), n6.child;
            }
            e4 = e4.sibling;
          }
          null !== l3.tail && Za() > ii && (n6.flags |= 128, a5 = true, Dt(l3, false), n6.lanes = 4194304);
        }
        else {
          if (!a5) if (null !== (e4 = je(o3))) {
            if (n6.flags |= 128, a5 = true, e4 = e4.updateQueue, n6.updateQueue = e4, Ut(n6, e4), Dt(l3, true), null === l3.tail && "hidden" === l3.tailMode && !o3.alternate) return It(n6), null;
          } else 2 * Za() - l3.renderingStartTime > ii && 536870912 !== t5 && (n6.flags |= 128, a5 = true, Dt(l3, false), n6.lanes = 4194304);
          l3.isBackwards ? (o3.sibling = n6.child, n6.child = o3) : (null !== (e4 = l3.last) ? e4.sibling = o3 : n6.child = o3, l3.last = o3);
        }
        return null !== l3.tail ? (e4 = l3.tail, l3.rendering = e4, l3.tail = e4.sibling, l3.renderingStartTime = Za(), e4.sibling = null, t5 = su.current, s2(su, a5 ? 1 & t5 | 2 : 1 & t5), e4) : (It(n6), null);
      case 22:
      case 23:
        return Fe(n6), Ne(), l3 = null !== n6.memoizedState, null !== e4 ? null !== e4.memoizedState !== l3 && (n6.flags |= 8192) : l3 && (n6.flags |= 8192), l3 ? 0 != (536870912 & t5) && 0 == (128 & n6.flags) && (It(n6), 6 & n6.subtreeFlags && (n6.flags |= 8192)) : It(n6), null !== (t5 = n6.updateQueue) && Ut(n6, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), l3 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (l3 = n6.memoizedState.cachePool.pool), l3 !== t5 && (n6.flags |= 2048), null !== e4 && i4(Bo), null;
      case 24:
        return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n6.memoizedState.cache !== t5 && (n6.flags |= 2048), D(Lo), It(n6), null;
      case 25:
      case 30:
        return null;
    }
    throw Error(r5(156, n6.tag));
  }
  function jt(e4, n6) {
    switch (P(n6), n6.tag) {
      case 1:
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 3:
        return D(Lo), T(), 0 != (65536 & (e4 = n6.flags)) && 0 == (128 & e4) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 26:
      case 27:
      case 5:
        return N(n6), null;
      case 31:
        if (null !== n6.memoizedState && (Fe(n6), null === n6.alternate)) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 13:
        if (Fe(n6), null !== (e4 = n6.memoizedState) && null !== e4.dehydrated && null === n6.alternate) throw Error(r5(340));
        return 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 19:
        return i4(su), null;
      case 4:
        return T(), null;
      case 10:
        return D(n6.type), null;
      case 22:
      case 23:
        return Fe(n6), Ne(), null !== e4 && i4(Bo), 65536 & (e4 = n6.flags) ? (n6.flags = -65537 & e4 | 128, n6) : null;
      case 24:
        return D(Lo), null;
      default:
        return null;
    }
  }
  function At(e4, n6) {
    switch (P(n6), n6.tag) {
      case 3:
        D(Lo), T();
        break;
      case 26:
      case 27:
      case 5:
        N(n6);
        break;
      case 4:
        T();
        break;
      case 31:
        null !== n6.memoizedState && Fe(n6);
        break;
      case 13:
        Fe(n6);
        break;
      case 19:
        i4(su);
        break;
      case 10:
        D(n6.type);
        break;
      case 22:
      case 23:
        Fe(n6), Ne(), null !== e4 && i4(Bo);
        break;
      case 24:
        D(Lo);
    }
  }
  function Ht(e4, n6) {
    try {
      var t5 = n6.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
      if (null !== r6) {
        var l3 = r6.next;
        t5 = l3;
        do {
          if ((t5.tag & e4) === e4) {
            r6 = void 0;
            var a5 = t5.create, o3 = t5.inst;
            r6 = a5(), o3.destroy = r6;
          }
          t5 = t5.next;
        } while (t5 !== l3);
      }
    } catch (e5) {
      Jr(n6, n6.return, e5);
    }
  }
  function Ot(e4, n6, t5) {
    try {
      var r6 = n6.updateQueue, l3 = null !== r6 ? r6.lastEffect : null;
      if (null !== l3) {
        var a5 = l3.next;
        r6 = a5;
        do {
          if ((r6.tag & e4) === e4) {
            var o3 = r6.inst, u4 = o3.destroy;
            if (void 0 !== u4) {
              o3.destroy = void 0, l3 = n6;
              var i5 = t5, s3 = u4;
              try {
                s3();
              } catch (e5) {
                Jr(l3, i5, e5);
              }
            }
          }
          r6 = r6.next;
        } while (r6 !== a5);
      }
    } catch (e5) {
      Jr(n6, n6.return, e5);
    }
  }
  function Mt(e4) {
    var n6 = e4.updateQueue;
    if (null !== n6) {
      var t5 = e4.stateNode;
      try {
        _e(n6, t5);
      } catch (n7) {
        Jr(e4, e4.return, n7);
      }
    }
  }
  function Wt(e4, n6, t5) {
    t5.props = et(e4.type, e4.memoizedProps), t5.state = e4.memoizedState;
    try {
      t5.componentWillUnmount();
    } catch (t6) {
      Jr(e4, n6, t6);
    }
  }
  function Qt(e4, n6) {
    try {
      var t5 = e4.ref;
      if (null !== t5) {
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            var r6 = Il(e4.stateNode);
            break;
          default:
            r6 = e4.stateNode;
        }
        "function" == typeof t5 ? e4.refCleanup = t5(r6) : t5.current = r6;
      }
    } catch (t6) {
      Jr(e4, n6, t6);
    }
  }
  function Bt(e4, n6) {
    var t5 = e4.ref, r6 = e4.refCleanup;
    if (null !== t5) if ("function" == typeof r6) try {
      r6();
    } catch (t6) {
      Jr(e4, n6, t6);
    } finally {
      e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
    }
    else if ("function" == typeof t5) try {
      t5(null);
    } catch (t6) {
      Jr(e4, n6, t6);
    }
    else t5.current = null;
  }
  function $t(e4) {
    var n6 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
    try {
      ha(r6, n6, t5, e4);
    } catch (n7) {
      Jr(e4, e4.return, n7);
    }
  }
  function Vt(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  function qt(e4) {
    e: for (; ; ) {
      for (; null === e4.sibling; ) {
        if (null === e4.return || Vt(e4.return)) return null;
        e4 = e4.return;
      }
      for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
        if (2 & e4.flags) continue e;
        if (null === e4.child || 4 === e4.tag) continue e;
        e4.child.return = e4, e4 = e4.child;
      }
      if (!(2 & e4.flags)) return e4.stateNode;
    }
  }
  function Yt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ba(t5, e4, n6) : pa(t5, e4);
    else if (4 !== r6 && null !== (e4 = e4.child)) for (Yt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) Yt(e4, n6, t5), e4 = e4.sibling;
  }
  function Gt(e4, n6, t5) {
    var r6 = e4.tag;
    if (5 === r6 || 6 === r6) e4 = e4.stateNode, n6 ? ya(t5, e4, n6) : fa(t5, e4);
    else if (4 !== r6 && null !== (e4 = e4.child)) for (Gt(e4, n6, t5), e4 = e4.sibling; null !== e4; ) Gt(e4, n6, t5), e4 = e4.sibling;
  }
  function Jt(e4, n6, t5) {
    var r6 = t5.flags;
    switch (t5.tag) {
      case 0:
      case 11:
      case 15:
        ar(e4, t5), 4 & r6 && Ht(5, t5);
        break;
      case 1:
        if (ar(e4, t5), 4 & r6) if (e4 = t5.stateNode, null === n6) try {
          e4.componentDidMount();
        } catch (e5) {
          Jr(t5, t5.return, e5);
        }
        else {
          var l3 = et(t5.type, n6.memoizedProps);
          n6 = n6.memoizedState;
          try {
            e4.componentDidUpdate(l3, n6, e4.__reactInternalSnapshotBeforeUpdate);
          } catch (e5) {
            Jr(t5, t5.return, e5);
          }
        }
        64 & r6 && Mt(t5), 512 & r6 && Qt(t5, t5.return);
        break;
      case 3:
        if (ar(e4, t5), 64 & r6 && null !== (r6 = t5.updateQueue)) {
          if (e4 = null, null !== t5.child) switch (t5.child.tag) {
            case 27:
            case 5:
              e4 = Il(t5.child.stateNode);
              break;
            case 1:
              e4 = t5.child.stateNode;
          }
          try {
            _e(r6, e4);
          } catch (e5) {
            Jr(t5, t5.return, e5);
          }
        }
        break;
      case 27:
      case 26:
      case 5:
        if (ar(e4, t5), null === n6) {
          if (4 & r6) $t(t5);
          else if (64 & r6) {
            e4 = t5.type, n6 = t5.memoizedProps, l3 = t5.stateNode;
            try {
              Na(l3, e4, n6, t5);
            } catch (e5) {
              Jr(t5, t5.return, e5);
            }
          }
        }
        512 & r6 && Qt(t5, t5.return);
        break;
      case 12:
      case 31:
      default:
        ar(e4, t5);
        break;
      case 13:
        ar(e4, t5), 64 & r6 && null !== (r6 = t5.memoizedState) && null !== (r6 = r6.dehydrated) && (t5 = el.bind(null, t5), Ra(r6, t5));
        break;
      case 22:
        if (!(r6 = null !== t5.memoizedState || Tu)) {
          n6 = null !== n6 && null !== n6.memoizedState || Ru, l3 = Tu;
          var a5 = Ru;
          Tu = r6, (Ru = n6) && !a5 ? ur(e4, t5, 0 != (8772 & t5.subtreeFlags)) : ar(e4, t5), Tu = l3, Ru = a5;
        }
      case 30:
    }
  }
  function Kt(e4) {
    var n6 = e4.alternate;
    null !== n6 && (e4.alternate = null, Kt(n6)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n6 = e4.stateNode) && na(n6), e4.stateNode = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
  }
  function Xt(e4, n6, t5) {
    for (t5 = t5.child; null !== t5; ) Zt(e4, n6, t5), t5 = t5.sibling;
  }
  function Zt(e4, n6, t5) {
    switch (t5.tag) {
      case 26:
      case 27:
        var r6, l3;
      case 5:
        Ru || Bt(t5, n6);
      case 6:
        if (r6 = Du, l3 = Iu, Du = null, Xt(e4, n6, t5), Iu = l3, null !== (Du = r6)) if (Iu) try {
          Sa(Du, t5.stateNode);
        } catch (e5) {
          Jr(t5, n6, e5);
        }
        else try {
          va(Du, t5.stateNode);
        } catch (e5) {
          Jr(t5, n6, e5);
        }
        break;
      case 18:
        null !== Du && (Iu ? Ua(Du, t5.stateNode) : La(Du, t5.stateNode));
        break;
      case 4:
        r6 = Du, l3 = Iu, Du = t5.stateNode.containerInfo, Iu = true, Xt(e4, n6, t5), Du = r6, Iu = l3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ot(2, t5, n6), Ru || Ot(4, t5, n6), Xt(e4, n6, t5);
        break;
      case 1:
        Ru || (Bt(t5, n6), "function" == typeof (r6 = t5.stateNode).componentWillUnmount && Wt(t5, n6, r6)), Xt(e4, n6, t5);
        break;
      case 21:
        Xt(e4, n6, t5);
        break;
      case 22:
        Ru = (r6 = Ru) || null !== t5.memoizedState, Xt(e4, n6, t5), Ru = r6;
        break;
      default:
        Xt(e4, n6, t5);
    }
  }
  function er(e4, n6) {
    var t5 = function(e5) {
      switch (e5.tag) {
        case 31:
        case 13:
        case 19:
          var n7 = e5.stateNode;
          return null === n7 && (n7 = e5.stateNode = new Lu()), n7;
        case 22:
          return null === (n7 = (e5 = e5.stateNode)._retryCache) && (n7 = e5._retryCache = new Lu()), n7;
        default:
          throw Error(r5(435, e5.tag));
      }
    }(e4);
    n6.forEach(function(n7) {
      if (!t5.has(n7)) {
        t5.add(n7);
        var r6 = nl.bind(null, e4, n7);
        n7.then(r6, r6);
      }
    });
  }
  function nr(e4, n6) {
    var t5 = n6.deletions;
    if (null !== t5) for (var l3 = 0; l3 < t5.length; l3++) {
      var a5 = t5[l3], o3 = e4, u4 = n6, i5 = u4;
      e: for (; null !== i5; ) {
        switch (i5.tag) {
          case 27:
          case 5:
            Du = i5.stateNode, Iu = false;
            break e;
          case 3:
          case 4:
            Du = i5.stateNode.containerInfo, Iu = true;
            break e;
        }
        i5 = i5.return;
      }
      if (null === Du) throw Error(r5(160));
      Zt(o3, u4, a5), Du = null, Iu = false, null !== (o3 = a5.alternate) && (o3.return = null), a5.return = null;
    }
    if (13886 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) tr(n6, e4), n6 = n6.sibling;
  }
  function tr(e4, n6) {
    var t5 = e4.alternate, l3 = e4.flags;
    switch (e4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        nr(n6, e4), rr(e4), 4 & l3 && (Ot(3, e4, e4.return), Ht(3, e4), Ot(5, e4, e4.return));
        break;
      case 1:
        nr(n6, e4), rr(e4), 512 & l3 && (Ru || null === t5 || Bt(t5, t5.return)), 64 & l3 && Tu && null !== (e4 = e4.updateQueue) && null !== (l3 = e4.callbacks) && (t5 = e4.shared.hiddenCallbacks, e4.shared.hiddenCallbacks = null === t5 ? l3 : t5.concat(l3));
        break;
      case 26:
        var a5, o3;
      case 27:
      case 5:
        if (nr(n6, e4), rr(e4), 512 & l3 && (Ru || null === t5 || Bt(t5, t5.return)), 32 & e4.flags) {
          a5 = e4.stateNode;
          try {
            ka(a5);
          } catch (n7) {
            Jr(e4, e4.return, n7);
          }
        }
        4 & l3 && null != e4.stateNode && function(e5, n7, t6) {
          try {
            ga(e5.stateNode, e5.type, t6, n7, e5);
          } catch (n8) {
            Jr(e5, e5.return, n8);
          }
        }(e4, a5 = e4.memoizedProps, null !== t5 ? t5.memoizedProps : a5), 1024 & l3 && (Nu = true);
        break;
      case 6:
        if (nr(n6, e4), rr(e4), 4 & l3 && Yl) {
          if (null === e4.stateNode) throw Error(r5(162));
          l3 = e4.memoizedProps, t5 = null !== t5 ? t5.memoizedProps : l3, a5 = e4.stateNode;
          try {
            ma(a5, t5, l3);
          } catch (n7) {
            Jr(e4, e4.return, n7);
          }
        }
        break;
      case 3:
        nr(n6, e4), rr(e4), Nu && (Nu = false, lr(e4));
        break;
      case 4:
      case 12:
        nr(n6, e4), rr(e4);
        break;
      case 31:
        nr(n6, e4), rr(e4), 4 & l3 && null !== (l3 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l3));
        break;
      case 13:
        nr(n6, e4), rr(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== t5 && null !== t5.memoizedState) && (oi = Za()), 4 & l3 && null !== (l3 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l3));
        break;
      case 22:
        a5 = null !== e4.memoizedState;
        var u4 = null !== t5 && null !== t5.memoizedState, i5 = Tu, s3 = Ru;
        if (Tu = i5 || a5, Ru = s3 || u4, nr(n6, e4), Ru = s3, Tu = i5, rr(e4), 8192 & l3 && ((n6 = e4.stateNode)._visibility = a5 ? -2 & n6._visibility : 1 | n6._visibility, a5 && (null === t5 || u4 || Tu || Ru || or(e4)), Yl)) {
          e: if (t5 = null, Yl) for (n6 = e4; ; ) {
            if (5 === n6.tag || Fa) {
              if (null === t5) {
                u4 = t5 = n6;
                try {
                  o3 = u4.stateNode, a5 ? wa(o3) : xa(u4.stateNode, u4.memoizedProps);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if (6 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var c5 = u4.stateNode;
                  a5 ? za(c5) : Ea(c5, u4.memoizedProps);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if (18 === n6.tag) {
              if (null === t5) {
                u4 = n6;
                try {
                  var d3 = u4.stateNode;
                  a5 ? Da(d3) : Ia(u4.stateNode);
                } catch (e5) {
                  Jr(u4, u4.return, e5);
                }
              }
            } else if ((22 !== n6.tag && 23 !== n6.tag || null === n6.memoizedState || n6 === e4) && null !== n6.child) {
              n6.child.return = n6, n6 = n6.child;
              continue;
            }
            if (n6 === e4) break e;
            for (; null === n6.sibling; ) {
              if (null === n6.return || n6.return === e4) break e;
              t5 === n6 && (t5 = null), n6 = n6.return;
            }
            t5 === n6 && (t5 = null), n6.sibling.return = n6.return, n6 = n6.sibling;
          }
        }
        4 & l3 && null !== (l3 = e4.updateQueue) && null !== (t5 = l3.retryQueue) && (l3.retryQueue = null, er(e4, t5));
        break;
      case 19:
        nr(n6, e4), rr(e4), 4 & l3 && null !== (l3 = e4.updateQueue) && (e4.updateQueue = null, er(e4, l3));
        break;
      case 30:
      case 21:
        break;
      default:
        nr(n6, e4), rr(e4);
    }
  }
  function rr(e4) {
    var n6 = e4.flags;
    if (2 & n6) {
      try {
        for (var t5, l3 = e4.return; null !== l3; ) {
          if (Vt(l3)) {
            t5 = l3;
            break;
          }
          l3 = l3.return;
        }
        if (Yl) {
          if (null == t5) throw Error(r5(160));
          switch (t5.tag) {
            case 27:
            case 5:
              var a5 = t5.stateNode;
              32 & t5.flags && (ka(a5), t5.flags &= -33), Gt(e4, qt(e4), a5);
              break;
            case 3:
            case 4:
              var o3 = t5.stateNode.containerInfo;
              Yt(e4, qt(e4), o3);
              break;
            default:
              throw Error(r5(161));
          }
        }
      } catch (n7) {
        Jr(e4, e4.return, n7);
      }
      e4.flags &= -3;
    }
    4096 & n6 && (e4.flags &= -4097);
  }
  function lr(e4) {
    if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      lr(n6), 5 === n6.tag && 1024 & n6.flags && da(n6.stateNode), e4 = e4.sibling;
    }
  }
  function ar(e4, n6) {
    if (8772 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) Jt(e4, n6.alternate, n6), n6 = n6.sibling;
  }
  function or(e4) {
    for (e4 = e4.child; null !== e4; ) {
      var n6 = e4;
      switch (n6.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ot(4, n6, n6.return), or(n6);
          break;
        case 1:
          Bt(n6, n6.return);
          var t5 = n6.stateNode;
          "function" == typeof t5.componentWillUnmount && Wt(n6, n6.return, t5), or(n6);
          break;
        case 27:
        case 26:
        case 5:
          Bt(n6, n6.return), or(n6);
          break;
        case 22:
          null === n6.memoizedState && or(n6);
          break;
        default:
          or(n6);
      }
      e4 = e4.sibling;
    }
  }
  function ur(e4, n6, t5) {
    for (t5 = t5 && 0 != (8772 & n6.subtreeFlags), n6 = n6.child; null !== n6; ) {
      var r6 = n6.alternate, l3 = e4, a5 = n6, o3 = a5.flags;
      switch (a5.tag) {
        case 0:
        case 11:
        case 15:
          ur(l3, a5, t5), Ht(4, a5);
          break;
        case 1:
          if (ur(l3, a5, t5), "function" == typeof (l3 = (r6 = a5).stateNode).componentDidMount) try {
            l3.componentDidMount();
          } catch (e5) {
            Jr(r6, r6.return, e5);
          }
          if (null !== (l3 = (r6 = a5).updateQueue)) {
            var u4 = r6.stateNode;
            try {
              var i5 = l3.shared.hiddenCallbacks;
              if (null !== i5) for (l3.shared.hiddenCallbacks = null, l3 = 0; l3 < i5.length; l3++) Pe(i5[l3], u4);
            } catch (e5) {
              Jr(r6, r6.return, e5);
            }
          }
          t5 && 64 & o3 && Mt(a5), Qt(a5, a5.return);
          break;
        case 27:
        case 26:
        case 5:
          ur(l3, a5, t5), t5 && null === r6 && 4 & o3 && $t(a5), Qt(a5, a5.return);
          break;
        case 12:
        case 31:
        case 13:
        default:
          ur(l3, a5, t5);
          break;
        case 22:
          null === a5.memoizedState && ur(l3, a5, t5), Qt(a5, a5.return);
        case 30:
      }
      n6 = n6.sibling;
    }
  }
  function ir(e4, n6) {
    var t5 = null;
    null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n6.memoizedState && null !== n6.memoizedState.cachePool && (e4 = n6.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && e4.refCount++, null != t5 && B(t5));
  }
  function sr(e4, n6) {
    e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && B(e4));
  }
  function cr(e4, n6, t5, r6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) dr(e4, n6, t5, r6), n6 = n6.sibling;
  }
  function dr(e4, n6, t5, r6) {
    var l3 = n6.flags;
    switch (n6.tag) {
      case 0:
      case 11:
      case 15:
        cr(e4, n6, t5, r6), 2048 & l3 && Ht(9, n6);
        break;
      case 1:
      case 31:
      case 13:
      default:
        cr(e4, n6, t5, r6);
        break;
      case 3:
        cr(e4, n6, t5, r6), 2048 & l3 && (e4 = null, null !== n6.alternate && (e4 = n6.alternate.memoizedState.cache), (n6 = n6.memoizedState.cache) !== e4 && (n6.refCount++, null != e4 && B(e4)));
        break;
      case 12:
        if (2048 & l3) {
          cr(e4, n6, t5, r6), e4 = n6.stateNode;
          try {
            var a5 = n6.memoizedProps, o3 = a5.id, u4 = a5.onPostCommit;
            "function" == typeof u4 && u4(o3, null === n6.alternate ? "mount" : "update", e4.passiveEffectDuration, -0);
          } catch (e5) {
            Jr(n6, n6.return, e5);
          }
        } else cr(e4, n6, t5, r6);
        break;
      case 23:
        break;
      case 22:
        a5 = n6.stateNode, o3 = n6.alternate, null !== n6.memoizedState ? 2 & a5._visibility ? cr(e4, n6, t5, r6) : pr(e4, n6) : 2 & a5._visibility ? cr(e4, n6, t5, r6) : (a5._visibility |= 2, fr(e4, n6, t5, r6, 0 != (10256 & n6.subtreeFlags) || false)), 2048 & l3 && ir(o3, n6);
        break;
      case 24:
        cr(e4, n6, t5, r6), 2048 & l3 && sr(n6.alternate, n6);
    }
  }
  function fr(e4, n6, t5, r6, l3) {
    for (l3 = l3 && (0 != (10256 & n6.subtreeFlags) || false), n6 = n6.child; null !== n6; ) {
      var a5 = e4, o3 = n6, u4 = t5, i5 = r6, s3 = o3.flags;
      switch (o3.tag) {
        case 0:
        case 11:
        case 15:
          fr(a5, o3, u4, i5, l3), Ht(8, o3);
          break;
        case 23:
          break;
        case 22:
          var c5 = o3.stateNode;
          null !== o3.memoizedState ? 2 & c5._visibility ? fr(a5, o3, u4, i5, l3) : pr(a5, o3) : (c5._visibility |= 2, fr(a5, o3, u4, i5, l3)), l3 && 2048 & s3 && ir(o3.alternate, o3);
          break;
        case 24:
          fr(a5, o3, u4, i5, l3), l3 && 2048 & s3 && sr(o3.alternate, o3);
          break;
        default:
          fr(a5, o3, u4, i5, l3);
      }
      n6 = n6.sibling;
    }
  }
  function pr(e4, n6) {
    if (10256 & n6.subtreeFlags) for (n6 = n6.child; null !== n6; ) {
      var t5 = e4, r6 = n6, l3 = r6.flags;
      switch (r6.tag) {
        case 22:
          pr(t5, r6), 2048 & l3 && ir(r6.alternate, r6);
          break;
        case 24:
          pr(t5, r6), 2048 & l3 && sr(r6.alternate, r6);
          break;
        default:
          pr(t5, r6);
      }
      n6 = n6.sibling;
    }
  }
  function mr(e4, n6, t5) {
    if (e4.subtreeFlags & ju) for (e4 = e4.child; null !== e4; ) hr(e4, n6, t5), e4 = e4.sibling;
  }
  function hr(e4, n6, t5) {
    switch (e4.tag) {
      case 26:
        if (mr(e4, n6, t5), e4.flags & ju) if (null !== e4.memoizedState) Aa(t5, Fu, e4.memoizedState, e4.memoizedProps);
        else {
          var r6 = e4.stateNode, l3 = e4.type;
          e4 = e4.memoizedProps, ((335544128 & n6) === n6 || la(l3, e4)) && ua(t5, r6, l3, e4);
        }
        break;
      case 5:
        mr(e4, n6, t5), e4.flags & ju && (r6 = e4.stateNode, l3 = e4.type, e4 = e4.memoizedProps, ((335544128 & n6) === n6 || la(l3, e4)) && ua(t5, r6, l3, e4));
        break;
      case 3:
      case 4:
      default:
        mr(e4, n6, t5);
        break;
      case 22:
        null === e4.memoizedState && (null !== (r6 = e4.alternate) && null !== r6.memoizedState ? (r6 = ju, ju = 16777216, mr(e4, n6, t5), ju = r6) : mr(e4, n6, t5));
    }
  }
  function gr(e4) {
    var n6 = e4.alternate;
    if (null !== n6 && null !== (e4 = n6.child)) {
      n6.child = null;
      do {
        n6 = e4.sibling, e4.sibling = null, e4 = n6;
      } while (null !== e4);
    }
  }
  function yr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Uu = r6, Sr(r6, e4);
      }
      gr(e4);
    }
    if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) br(e4), e4 = e4.sibling;
  }
  function br(e4) {
    switch (e4.tag) {
      case 0:
      case 11:
      case 15:
        yr(e4), 2048 & e4.flags && Ot(9, e4, e4.return);
        break;
      case 3:
      case 12:
      default:
        yr(e4);
        break;
      case 22:
        var n6 = e4.stateNode;
        null !== e4.memoizedState && 2 & n6._visibility && (null === e4.return || 13 !== e4.return.tag) ? (n6._visibility &= -3, vr(e4)) : yr(e4);
    }
  }
  function vr(e4) {
    var n6 = e4.deletions;
    if (0 != (16 & e4.flags)) {
      if (null !== n6) for (var t5 = 0; t5 < n6.length; t5++) {
        var r6 = n6[t5];
        Uu = r6, Sr(r6, e4);
      }
      gr(e4);
    }
    for (e4 = e4.child; null !== e4; ) {
      switch ((n6 = e4).tag) {
        case 0:
        case 11:
        case 15:
          Ot(8, n6, n6.return), vr(n6);
          break;
        case 22:
          2 & (t5 = n6.stateNode)._visibility && (t5._visibility &= -3, vr(n6));
          break;
        default:
          vr(n6);
      }
      e4 = e4.sibling;
    }
  }
  function Sr(e4, n6) {
    for (; null !== Uu; ) {
      var t5 = Uu;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Ot(8, t5, n6);
          break;
        case 23:
        case 22:
          if (null !== t5.memoizedState && null !== t5.memoizedState.cachePool) {
            var r6 = t5.memoizedState.cachePool.pool;
            null != r6 && r6.refCount++;
          }
          break;
        case 24:
          B(t5.memoizedState.cache);
      }
      if (null !== (r6 = t5.child)) r6.return = t5, Uu = r6;
      else e: for (t5 = e4; null !== Uu; ) {
        var l3 = (r6 = Uu).sibling, a5 = r6.return;
        if (Kt(r6), r6 === t5) {
          Uu = null;
          break e;
        }
        if (null !== l3) {
          l3.return = a5, Uu = l3;
          break e;
        }
        Uu = a5;
      }
    }
  }
  function kr() {
    return 0 != (2 & Mu) && 0 !== Bu ? Bu & -Bu : null !== Dl.T ? X() : Zl();
  }
  function wr() {
    if (0 === ni) if (0 == (536870912 & Bu) || xo) {
      var e4 = qa;
      0 == (3932160 & (qa <<= 1)) && (qa = 262144), ni = e4;
    } else ni = 536870912;
    return null !== (e4 = uu.current) && (e4.flags |= 32), ni;
  }
  function zr(e4, n6, t5) {
    (e4 !== Wu || 2 !== $u && 9 !== $u) && null === e4.cancelPendingCommit || (Tr(e4, 0), Pr(e4, Bu, ni, false)), g3(e4, t5), 0 != (2 & Mu) && e4 === Wu || (e4 === Wu && (0 == (2 & Mu) && (Zu |= t5), 4 === Ku && Pr(e4, Bu, ni, false)), V(e4));
  }
  function xr(e4, n6, t5) {
    if (0 != (6 & Mu)) throw Error(r5(327));
    for (var l3 = !t5 && 0 == (127 & n6) && 0 == (n6 & e4.expiredLanes) || f3(e4, n6), a5 = l3 ? function(e5, n7) {
      var t6 = Mu;
      Mu |= 2;
      var l4 = Nr(), a6 = Lr();
      Wu !== e5 || Bu !== n7 ? (si = null, ii = Za() + 500, Tr(e5, n7)) : Yu = f3(e5, n7);
      e: for (; ; ) try {
        if (0 !== $u && null !== Qu) {
          n7 = Qu;
          var o4 = Vu;
          n: switch ($u) {
            case 1:
              $u = 0, Vu = null, Hr(e5, n7, o4, 1);
              break;
            case 2:
            case 9:
              if (le(o4)) {
                $u = 0, Vu = null, Ar(n7);
                break;
              }
              n7 = function() {
                2 !== $u && 9 !== $u || Wu !== e5 || ($u = 7), V(e5);
              }, o4.then(n7, n7);
              break e;
            case 3:
              $u = 7;
              break e;
            case 4:
              $u = 5;
              break e;
            case 7:
              le(o4) ? ($u = 0, Vu = null, Ar(n7)) : ($u = 0, Vu = null, Hr(e5, n7, o4, 7));
              break;
            case 5:
              var u5 = null;
              switch (Qu.tag) {
                case 26:
                  u5 = Qu.memoizedState;
                case 5:
                case 27:
                  var i6 = Qu, s4 = i6.type, c5 = i6.pendingProps;
                  if (u5 ? ja(u5) : aa(i6.stateNode, s4, c5)) {
                    $u = 0, Vu = null;
                    var d3 = i6.sibling;
                    if (null !== d3) Qu = d3;
                    else {
                      var p4 = i6.return;
                      null !== p4 ? (Qu = p4, Or(p4)) : Qu = null;
                    }
                    break n;
                  }
              }
              $u = 0, Vu = null, Hr(e5, n7, o4, 5);
              break;
            case 6:
              $u = 0, Vu = null, Hr(e5, n7, o4, 6);
              break;
            case 8:
              _r(), Ku = 6;
              break e;
            default:
              throw Error(r5(462));
          }
        }
        Fr();
        break;
      } catch (n8) {
        Rr(e5, n8);
      }
      return _o = Po = null, Dl.H = l4, Dl.A = a6, Mu = t6, null !== Qu ? 0 : (Wu = null, Bu = 0, pe(), Ku);
    }(e4, n6) : Dr(e4, n6, true), o3 = l3; ; ) {
      if (0 === a5) {
        Yu && !l3 && Pr(e4, n6, 0, false);
        break;
      }
      if (t5 = e4.current.alternate, !o3 || Cr(t5)) {
        if (2 === a5) {
          if (o3 = n6, e4.errorRecoveryDisabledLanes & o3) var u4 = 0;
          else u4 = 0 != (u4 = -536870913 & e4.pendingLanes) ? u4 : 536870912 & u4 ? 536870912 : 0;
          if (0 !== u4) {
            n6 = u4;
            e: {
              var i5 = e4;
              a5 = ri;
              var s3 = Gl;
              if (s3 && (Tr(i5, u4).flags |= 256), 2 !== (u4 = Dr(i5, u4, false))) {
                if (Gu && !s3) {
                  i5.errorRecoveryDisabledLanes |= o3, Zu |= o3, a5 = 4;
                  break e;
                }
                o3 = li, li = a5, null !== o3 && (null === li ? li = o3 : li.push.apply(li, o3));
              }
              a5 = u4;
            }
            if (o3 = false, 2 !== a5) continue;
          }
        }
        if (1 === a5) {
          Tr(e4, 0), Pr(e4, n6, 0, true);
          break;
        }
        e: {
          switch (l3 = e4, o3 = a5) {
            case 0:
            case 1:
              throw Error(r5(345));
            case 4:
              if ((4194048 & n6) !== n6) break;
            case 6:
              Pr(l3, n6, ni, !qu);
              break e;
            case 2:
              li = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r5(329));
          }
          if ((62914560 & n6) === n6 && 10 < (a5 = oi + 300 - Za())) {
            if (Pr(l3, n6, ni, !qu), 0 !== d2(l3, 0, true)) break e;
            mi = n6, l3.timeoutHandle = $l(Er.bind(null, l3, t5, li, si, ai, n6, ni, Zu, ti, qu, o3, "Throttled", -0, 0), a5);
          } else Er(l3, t5, li, si, ai, n6, ni, Zu, ti, qu, o3, null, -0, 0);
        }
        break;
      }
      a5 = Dr(e4, n6, false), o3 = false;
    }
    V(e4);
  }
  function Er(e4, n6, t5, r6, l3, a5, o3, u4, i5, s3, c5, d3, f4, p4) {
    if (e4.timeoutHandle = ql, 8192 & (d3 = n6.subtreeFlags) || 16785408 == (16785408 & d3)) {
      hr(n6, a5, d3 = oa());
      var m2 = (62914560 & a5) === a5 ? oi - Za() : (4194048 & a5) === a5 ? ui - Za() : 0;
      if (null !== (m2 = ia(d3, m2))) return mi = a5, e4.cancelPendingCommit = m2(Wr.bind(null, e4, n6, a5, t5, r6, l3, o3, u4, i5, c5, d3, null, f4, p4)), void Pr(e4, a5, o3, !s3);
    }
    Wr(e4, n6, a5, t5, r6, l3, o3, u4, i5);
  }
  function Cr(e4) {
    for (var n6 = e4; ; ) {
      var t5 = n6.tag;
      if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n6.flags && null !== (t5 = n6.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
        var l3 = t5[r6], a5 = l3.getSnapshot;
        l3 = l3.value;
        try {
          if (!uo(a5(), l3)) return false;
        } catch (e5) {
          return false;
        }
      }
      if (t5 = n6.child, 16384 & n6.subtreeFlags && null !== t5) t5.return = n6, n6 = t5;
      else {
        if (n6 === e4) break;
        for (; null === n6.sibling; ) {
          if (null === n6.return || n6.return === e4) return true;
          n6 = n6.return;
        }
        n6.sibling.return = n6.return, n6 = n6.sibling;
      }
    }
    return true;
  }
  function Pr(e4, n6, t5, r6) {
    n6 &= ~ei, n6 &= ~Zu, e4.suspendedLanes |= n6, e4.pingedLanes &= ~n6, r6 && (e4.warmLanes |= n6), r6 = e4.expirationTimes;
    for (var l3 = n6; 0 < l3; ) {
      var a5 = 31 - Qa(l3), o3 = 1 << a5;
      r6[a5] = -1, l3 &= ~o3;
    }
    0 !== t5 && y3(e4, t5, n6);
  }
  function _r() {
    if (null !== Qu) {
      if (0 === $u) var e4 = Qu.return;
      else _o = Po = null, Ve(e4 = Qu), Jo = null, Ko = 0, e4 = Qu;
      for (; null !== e4; ) At(e4.alternate, e4), e4 = e4.return;
      Qu = null;
    }
  }
  function Tr(e4, n6) {
    var t5 = e4.timeoutHandle;
    t5 !== ql && (e4.timeoutHandle = ql, Vl(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), mi = 0, _r(), Wu = e4, Qu = t5 = ll(e4.current, null), Bu = n6, $u = 0, Vu = null, qu = false, Yu = f3(e4, n6), Gu = false, ti = ni = ei = Zu = Xu = Ku = 0, li = ri = null, ai = false, 0 != (8 & n6) && (n6 |= 32 & n6);
    var r6 = e4.entangledLanes;
    if (0 !== r6) for (e4 = e4.entanglements, r6 &= n6; 0 < r6; ) {
      var l3 = 31 - Qa(r6), a5 = 1 << l3;
      n6 |= e4[l3], r6 &= ~a5;
    }
    return Ju = n6, pe(), t5;
  }
  function Rr(e4, n6) {
    du = null, Dl.H = ku, n6 === $o || n6 === qo ? (n6 = ue(), $u = 3) : n6 === Vo ? (n6 = ue(), $u = 4) : $u = n6 === Cu ? 8 : null !== n6 && "object" == typeof n6 && "function" == typeof n6.then ? 6 : 1, Vu = n6, null === Qu && (Ku = 1, nt(e4, C(n6, e4.current)));
  }
  function Nr() {
    var e4 = Dl.H;
    return Dl.H = ku, null === e4 ? ku : e4;
  }
  function Lr() {
    var e4 = Dl.A;
    return Dl.A = Au, e4;
  }
  function Ur() {
    Ku = 4, qu || (4194048 & Bu) !== Bu && null !== uu.current || (Yu = true), 0 == (134217727 & Xu) && 0 == (134217727 & Zu) || null === Wu || Pr(Wu, Bu, ni, false);
  }
  function Dr(e4, n6, t5) {
    var r6 = Mu;
    Mu |= 2;
    var l3 = Nr(), a5 = Lr();
    Wu === e4 && Bu === n6 || (si = null, Tr(e4, n6)), n6 = false;
    var o3 = Ku;
    e: for (; ; ) try {
      if (0 !== $u && null !== Qu) {
        var u4 = Qu, i5 = Vu;
        switch ($u) {
          case 8:
            _r(), o3 = 6;
            break e;
          case 3:
          case 2:
          case 9:
          case 6:
            null === uu.current && (n6 = true);
            var s3 = $u;
            if ($u = 0, Vu = null, Hr(e4, u4, i5, s3), t5 && Yu) {
              o3 = 0;
              break e;
            }
            break;
          default:
            s3 = $u, $u = 0, Vu = null, Hr(e4, u4, i5, s3);
        }
      }
      Ir(), o3 = Ku;
      break;
    } catch (n7) {
      Rr(e4, n7);
    }
    return n6 && e4.shellSuspendCounter++, _o = Po = null, Mu = r6, Dl.H = l3, Dl.A = a5, null === Qu && (Wu = null, Bu = 0, pe()), o3;
  }
  function Ir() {
    for (; null !== Qu; ) jr(Qu);
  }
  function Fr() {
    for (; null !== Qu && !Ka(); ) jr(Qu);
  }
  function jr(e4) {
    var n6 = Rt(e4.alternate, e4, Ju);
    e4.memoizedProps = e4.pendingProps, null === n6 ? Or(e4) : Qu = n6;
  }
  function Ar(e4) {
    var n6 = e4, t5 = n6.alternate;
    switch (n6.tag) {
      case 15:
      case 0:
        n6 = yt(t5, n6, n6.pendingProps, n6.type, void 0, Bu);
        break;
      case 11:
        n6 = yt(t5, n6, n6.pendingProps, n6.type.render, n6.ref, Bu);
        break;
      case 5:
        Ve(n6);
      default:
        At(t5, n6), n6 = Rt(t5, n6 = Qu = al(n6, Ju), Ju);
    }
    e4.memoizedProps = e4.pendingProps, null === n6 ? Or(e4) : Qu = n6;
  }
  function Hr(e4, n6, t5, l3) {
    _o = Po = null, Ve(n6), Jo = null, Ko = 0;
    var a5 = n6.return;
    try {
      if (function(e5, n7, t6, l4, a6) {
        if (t6.flags |= 32768, null !== l4 && "object" == typeof l4 && "function" == typeof l4.then) {
          if (null !== (n7 = t6.alternate) && j(n7, t6, a6, true), null !== (t6 = uu.current)) {
            switch (t6.tag) {
              case 31:
              case 13:
                return null === iu ? Ur() : null === t6.alternate && 0 === Ku && (Ku = 3), t6.flags &= -257, t6.flags |= 65536, t6.lanes = a6, l4 === Yo ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([l4]) : n7.add(l4), Kr(e5, l4, a6)), false;
              case 22:
                return t6.flags |= 65536, l4 === Yo ? t6.flags |= 16384 : (null === (n7 = t6.updateQueue) ? (n7 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l4]) }, t6.updateQueue = n7) : null === (t6 = n7.retryQueue) ? n7.retryQueue = /* @__PURE__ */ new Set([l4]) : t6.add(l4), Kr(e5, l4, a6)), false;
            }
            throw Error(r5(435, t6.tag));
          }
          return Kr(e5, l4, a6), Ur(), false;
        }
        var o3 = Error(r5(520), { cause: l4 });
        if (o3 = C(o3, t6), null === ri ? ri = [o3] : ri.push(o3), 4 !== Ku && (Ku = 2), null === n7) return true;
        l4 = C(l4, t6), t6 = n7;
        do {
          switch (t6.tag) {
            case 3:
              return t6.flags |= 65536, e5 = a6 & -a6, t6.lanes |= e5, xe(t6, e5 = rt(t6.stateNode, l4, e5)), false;
            case 1:
              if (n7 = t6.type, o3 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n7.getDerivedStateFromError || null !== o3 && "function" == typeof o3.componentDidCatch && (null === ci || !ci.has(o3)))) return t6.flags |= 65536, a6 &= -a6, t6.lanes |= a6, at(a6 = lt(a6), e5, t6, l4), xe(t6, a6), false;
          }
          t6 = t6.return;
        } while (null !== t6);
        return false;
      }(e4, a5, n6, t5, Bu)) return Ku = 1, nt(e4, C(t5, e4.current)), void (Qu = null);
    } catch (n7) {
      if (null !== a5) throw Qu = a5, n7;
      return Ku = 1, nt(e4, C(t5, e4.current)), void (Qu = null);
    }
    32768 & n6.flags ? (1 === l3 ? e4 = true : Yu || 0 != (536870912 & Bu) ? e4 = false : (qu = e4 = true, (2 === l3 || 9 === l3 || 3 === l3 || 6 === l3) && null !== (l3 = uu.current) && 13 === l3.tag && (l3.flags |= 16384)), Mr(n6, e4)) : Or(n6);
  }
  function Or(e4) {
    var n6 = e4;
    do {
      if (0 != (32768 & n6.flags)) return void Mr(n6, qu);
      e4 = n6.return;
      var t5 = Ft(n6.alternate, n6, Ju);
      if (null !== t5) return void (Qu = t5);
      if (null !== (n6 = n6.sibling)) return void (Qu = n6);
      Qu = n6 = e4;
    } while (null !== n6);
    0 === Ku && (Ku = 5);
  }
  function Mr(e4, n6) {
    do {
      var t5 = jt(e4.alternate, e4);
      if (null !== t5) return t5.flags &= 32767, void (Qu = t5);
      if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n6 && null !== (e4 = e4.sibling)) return void (Qu = e4);
      Qu = e4 = t5;
    } while (null !== e4);
    Ku = 6, Qu = null;
  }
  function Wr(e4, n6, t5, l3, a5, o3, u4, i5, s3) {
    e4.cancelPendingCommit = null;
    do {
      qr();
    } while (0 !== di);
    if (0 != (6 & Mu)) throw Error(r5(327));
    if (null !== n6) {
      if (n6 === e4.current) throw Error(r5(177));
      if (o3 = n6.lanes | n6.childLanes, function(e5, n7, t6, r6, l4, a6) {
        var o4 = e5.pendingLanes;
        e5.pendingLanes = t6, e5.suspendedLanes = 0, e5.pingedLanes = 0, e5.warmLanes = 0, e5.expiredLanes &= t6, e5.entangledLanes &= t6, e5.errorRecoveryDisabledLanes &= t6, e5.shellSuspendCounter = 0;
        var u5 = e5.entanglements, i6 = e5.expirationTimes, s4 = e5.hiddenUpdates;
        for (t6 = o4 & ~t6; 0 < t6; ) {
          var c5 = 31 - Qa(t6), d3 = 1 << c5;
          u5[c5] = 0, i6[c5] = -1;
          var f4 = s4[c5];
          if (null !== f4) for (s4[c5] = null, c5 = 0; c5 < f4.length; c5++) {
            var p4 = f4[c5];
            null !== p4 && (p4.lane &= -536870913);
          }
          t6 &= ~d3;
        }
        0 !== r6 && y3(e5, r6, 0), 0 !== a6 && 0 === l4 && 0 !== e5.tag && (e5.suspendedLanes |= a6 & ~(o4 & ~n7));
      }(e4, t5, o3 |= tu, u4, i5, s3), e4 === Wu && (Qu = Wu = null, Bu = 0), pi = n6, fi = e4, mi = t5, hi = o3, gi = a5, yi = l3, 0 != (10256 & n6.subtreeFlags) || 0 != (10256 & n6.flags) ? (e4.callbackNode = null, e4.callbackPriority = 0, Ga(to, function() {
        return Yr(), null;
      })) : (e4.callbackNode = null, e4.callbackPriority = 0), l3 = 0 != (13878 & n6.flags), 0 != (13878 & n6.subtreeFlags) || l3) {
        l3 = Dl.T, Dl.T = null, a5 = Xl(), Kl(2), u4 = Mu, Mu |= 4;
        try {
          !function(e5, n7) {
            for (Al(e5.containerInfo), Uu = n7; null !== Uu; ) if (n7 = (e5 = Uu).child, 0 != (1028 & e5.subtreeFlags) && null !== n7) n7.return = e5, Uu = n7;
            else for (; null !== Uu; ) {
              var t6 = (e5 = Uu).alternate;
              switch (n7 = e5.flags, e5.tag) {
                case 0:
                  if (0 != (4 & n7) && null !== (n7 = null !== (n7 = e5.updateQueue) ? n7.events : null)) for (var l4 = 0; l4 < n7.length; l4++) {
                    var a6 = n7[l4];
                    a6.ref.impl = a6.nextImpl;
                  }
                  break;
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n7) && null !== t6) {
                    n7 = void 0, l4 = e5, a6 = t6.memoizedProps, t6 = t6.memoizedState;
                    var o4 = l4.stateNode;
                    try {
                      var u5 = et(l4.type, a6);
                      n7 = o4.getSnapshotBeforeUpdate(u5, t6), o4.__reactInternalSnapshotBeforeUpdate = n7;
                    } catch (e6) {
                      Jr(l4, l4.return, e6);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n7) && Yl && Ca(e5.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n7)) throw Error(r5(163));
              }
              if (null !== (n7 = e5.sibling)) {
                n7.return = e5.return, Uu = n7;
                break;
              }
              Uu = e5.return;
            }
          }(e4, n6);
        } finally {
          Mu = u4, Kl(a5), Dl.T = l3;
        }
      }
      di = 1, Qr(), Br(), $r();
    }
  }
  function Qr() {
    if (1 === di) {
      di = 0;
      var e4 = fi, n6 = pi, t5 = 0 != (13878 & n6.flags);
      if (0 != (13878 & n6.subtreeFlags) || t5) {
        t5 = Dl.T, Dl.T = null;
        var r6 = Xl();
        Kl(2);
        var l3 = Mu;
        Mu |= 4;
        try {
          tr(n6, e4), Hl(e4.containerInfo);
        } finally {
          Mu = l3, Kl(r6), Dl.T = t5;
        }
      }
      e4.current = n6, di = 2;
    }
  }
  function Br() {
    if (2 === di) {
      di = 0;
      var e4 = fi, n6 = pi, t5 = 0 != (8772 & n6.flags);
      if (0 != (8772 & n6.subtreeFlags) || t5) {
        t5 = Dl.T, Dl.T = null;
        var r6 = Xl();
        Kl(2);
        var l3 = Mu;
        Mu |= 4;
        try {
          Jt(e4, n6.alternate, n6);
        } finally {
          Mu = l3, Kl(r6), Dl.T = t5;
        }
      }
      di = 3;
    }
  }
  function $r() {
    if (4 === di || 3 === di) {
      di = 0, Xa();
      var e4 = fi, n6 = pi, t5 = mi, r6 = yi;
      0 != (10256 & n6.subtreeFlags) || 0 != (10256 & n6.flags) ? di = 5 : (di = 0, pi = fi = null, Vr(e4, e4.pendingLanes));
      var l3 = e4.pendingLanes;
      if (0 === l3 && (ci = null), S3(t5), n6 = n6.stateNode, null !== r6) {
        n6 = Dl.T, l3 = Xl(), Kl(2), Dl.T = null;
        try {
          for (var a5 = e4.onRecoverableError, o3 = 0; o3 < r6.length; o3++) {
            var u4 = r6[o3];
            a5(u4.value, { componentStack: u4.stack });
          }
        } finally {
          Dl.T = n6, Kl(l3);
        }
      }
      0 != (3 & mi) && qr(), V(e4), l3 = e4.pendingLanes, 0 != (261930 & t5) && 0 != (42 & l3) ? e4 === vi ? bi++ : (bi = 0, vi = e4) : bi = 0, q(0);
    }
  }
  function Vr(e4, n6) {
    0 == (e4.pooledCacheLanes &= n6) && null != (n6 = e4.pooledCache) && (e4.pooledCache = null, B(n6));
  }
  function qr() {
    return Qr(), Br(), $r(), Yr();
  }
  function Yr() {
    if (5 !== di) return false;
    var e4 = fi, n6 = hi;
    hi = 0;
    var t5 = S3(mi), l3 = 32 > t5 ? 32 : t5;
    t5 = Dl.T;
    var a5 = Xl();
    try {
      Kl(l3), Dl.T = null, l3 = gi, gi = null;
      var o3 = fi, u4 = mi;
      if (di = 0, pi = fi = null, mi = 0, 0 != (6 & Mu)) throw Error(r5(331));
      var i5 = Mu;
      return Mu |= 4, br(o3.current), dr(o3, o3.current, u4, l3), Mu = i5, q(0), oo && oo.onPostCommitFiberRoot, true;
    } finally {
      Kl(a5), Dl.T = t5, Vr(e4, n6);
    }
  }
  function Gr(e4, n6, t5) {
    n6 = C(t5, n6), null !== (e4 = we(e4, n6 = rt(e4.stateNode, n6, 2), 2)) && (g3(e4, 2), V(e4));
  }
  function Jr(e4, n6, t5) {
    if (3 === e4.tag) Gr(e4, e4, t5);
    else for (; null !== n6; ) {
      if (3 === n6.tag) {
        Gr(n6, e4, t5);
        break;
      }
      if (1 === n6.tag) {
        var r6 = n6.stateNode;
        if ("function" == typeof n6.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === ci || !ci.has(r6))) {
          e4 = C(t5, e4), null !== (r6 = we(n6, t5 = lt(2), 2)) && (at(t5, r6, n6, e4), g3(r6, 2), V(r6));
          break;
        }
      }
      n6 = n6.return;
    }
  }
  function Kr(e4, n6, t5) {
    var r6 = e4.pingCache;
    if (null === r6) {
      r6 = e4.pingCache = new Ou();
      var l3 = /* @__PURE__ */ new Set();
      r6.set(n6, l3);
    } else void 0 === (l3 = r6.get(n6)) && (l3 = /* @__PURE__ */ new Set(), r6.set(n6, l3));
    l3.has(t5) || (Gu = true, l3.add(t5), e4 = Xr.bind(null, e4, n6, t5), n6.then(e4, e4));
  }
  function Xr(e4, n6, t5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(n6), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, Wu === e4 && (Bu & t5) === t5 && (4 === Ku || 3 === Ku && (62914560 & Bu) === Bu && 300 > Za() - oi ? 0 == (2 & Mu) && Tr(e4, 0) : ei |= t5, ti === Bu && (ti = 0)), V(e4);
  }
  function Zr(e4, n6) {
    0 === n6 && (n6 = m()), null !== (e4 = ge(e4, n6)) && (g3(e4, n6), V(e4));
  }
  function el(e4) {
    var n6 = e4.memoizedState, t5 = 0;
    null !== n6 && (t5 = n6.retryLane), Zr(e4, t5);
  }
  function nl(e4, n6) {
    var t5 = 0;
    switch (e4.tag) {
      case 31:
      case 13:
        var l3 = e4.stateNode, a5 = e4.memoizedState;
        null !== a5 && (t5 = a5.retryLane);
        break;
      case 19:
        l3 = e4.stateNode;
        break;
      case 22:
        l3 = e4.stateNode._retryCache;
        break;
      default:
        throw Error(r5(314));
    }
    null !== l3 && l3.delete(n6), Zr(e4, t5);
  }
  function tl(e4, n6, t5, r6) {
    this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n6, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function rl(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  function ll(e4, n6) {
    var r6 = e4.alternate;
    return null === r6 ? ((r6 = t4(e4.tag, n6, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n6, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null), r6.flags = 65011712 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n6 = e4.dependencies, r6.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6;
  }
  function al(e4, n6) {
    e4.flags &= 65011714;
    var t5 = e4.alternate;
    return null === t5 ? (e4.childLanes = 0, e4.lanes = n6, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n6 = t5.dependencies, e4.dependencies = null === n6 ? null : { lanes: n6.lanes, firstContext: n6.firstContext }), e4;
  }
  function ol(e4, n6, l3, a5, o3, u4) {
    var i5 = 0;
    if (a5 = e4, "function" == typeof e4) rl(e4) && (i5 = 1);
    else if ("string" == typeof e4) i5 = 5;
    else e: switch (e4) {
      case Tl:
        return (e4 = t4(31, l3, n6, o3)).elementType = Tl, e4.lanes = u4, e4;
      case vl:
        return ul(l3.children, o3, u4, n6);
      case Sl:
        i5 = 8, o3 |= 24;
        break;
      case kl:
        return (e4 = t4(12, l3, n6, 2 | o3)).elementType = kl, e4.lanes = u4, e4;
      case El:
        return (e4 = t4(13, l3, n6, o3)).elementType = El, e4.lanes = u4, e4;
      case Cl:
        return (e4 = t4(19, l3, n6, o3)).elementType = Cl, e4.lanes = u4, e4;
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case zl:
            i5 = 10;
            break e;
          case wl:
            i5 = 9;
            break e;
          case xl:
            i5 = 11;
            break e;
          case Pl:
            i5 = 14;
            break e;
          case _l:
            i5 = 16, a5 = null;
            break e;
        }
        i5 = 29, l3 = Error(r5(130, null === e4 ? "null" : typeof e4, "")), a5 = null;
    }
    return (n6 = t4(i5, l3, n6, o3)).elementType = e4, n6.type = a5, n6.lanes = u4, n6;
  }
  function ul(e4, n6, r6, l3) {
    return (e4 = t4(7, e4, l3, n6)).lanes = r6, e4;
  }
  function il(e4, n6, r6) {
    return (e4 = t4(6, e4, null, n6)).lanes = r6, e4;
  }
  function sl(e4, n6, r6) {
    return (n6 = t4(4, null !== e4.children ? e4.children : [], e4.key, n6)).lanes = r6, n6.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n6;
  }
  function cl(e4, n6, t5, r6, l3, a5, o3, u4, i5) {
    this.tag = 1, this.containerInfo = e4, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ql, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = h3(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = h3(0), this.hiddenUpdates = h3(null), this.identifierPrefix = r6, this.onUncaughtError = l3, this.onCaughtError = a5, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = i5, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function dl(e4, n6, t5, r6, l3, a5) {
    l3 = function(e5) {
      return e5 ? e5 = Wa : Wa;
    }(l3), null === r6.context ? r6.context = l3 : r6.pendingContext = l3, (r6 = ke(n6)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && (r6.callback = a5), null !== (t5 = we(e4, r6, n6)) && (zr(t5, 0, n6), ze(t5, e4, n6));
  }
  var fl = {}, pl = import_react2.default, ml = u2, hl = Object.assign, gl = Symbol.for("react.element"), yl = Symbol.for("react.transitional.element"), bl = Symbol.for("react.portal"), vl = Symbol.for("react.fragment"), Sl = Symbol.for("react.strict_mode"), kl = Symbol.for("react.profiler"), wl = Symbol.for("react.consumer"), zl = Symbol.for("react.context"), xl = Symbol.for("react.forward_ref"), El = Symbol.for("react.suspense"), Cl = Symbol.for("react.suspense_list"), Pl = Symbol.for("react.memo"), _l = Symbol.for("react.lazy"), Tl = Symbol.for("react.activity"), Rl = Symbol.for("react.memo_cache_sentinel"), Nl = Symbol.iterator, Ll = Symbol.for("react.client.reference"), Ul = Array.isArray, Dl = pl.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Il = n5.getPublicInstance, Fl = n5.getRootHostContext, jl = n5.getChildHostContext, Al = n5.prepareForCommit, Hl = n5.resetAfterCommit, Ol = n5.createInstance, Ml = n5.appendInitialChild, Wl = n5.finalizeInitialChildren, Ql = n5.shouldSetTextContent, Bl = n5.createTextInstance, $l = null, Vl = null, ql = n5.noTimeout, Yl = true, Gl = null, Jl = null, Kl = n5.setCurrentUpdatePriority, Xl = n5.getCurrentUpdatePriority, Zl = n5.resolveUpdatePriority;
  n5.trackSchedulerEvent, n5.resolveEventType, n5.resolveEventTimeStamp;
  var ea = n5.shouldAttemptEagerTransition, na = n5.detachDeletedInstance;
  n5.requestPostPaintCallback;
  var ta = n5.maySuspendCommit, ra = null, la = null, aa = null, oa = null, ua = null, ia = null, sa = null, ca = null, da = null, fa = n5.appendChild, pa = n5.appendChildToContainer, ma = n5.commitTextUpdate, ha = null, ga = n5.commitUpdate, ya = n5.insertBefore, ba = null, va = n5.removeChild, Sa = n5.removeChildFromContainer, ka = n5.resetTextContent, wa = null, za = null, xa = null, Ea = null, Ca = n5.clearContainer, Pa = null, _a = null, Ta = null, Ra = null, Na = null, La = null, Ua = null, Da = null, Ia = null, Fa = null, ja = null, Aa = null, Ha = null, Oa = [], Ma = -1, Wa = {}, Qa = Math.clz32 ? Math.clz32 : function(e4) {
    return 0 == (e4 >>>= 0) ? 32 : 31 - (Ba(e4) / $a | 0) | 0;
  }, Ba = Math.log, $a = Math.LN2, Va = 256, qa = 262144, Ya = 4194304, Ga = ml.unstable_scheduleCallback, Ja = ml.unstable_cancelCallback, Ka = ml.unstable_shouldYield, Xa = ml.unstable_requestPaint, Za = ml.unstable_now, eo = ml.unstable_ImmediatePriority, no = ml.unstable_UserBlockingPriority, to = ml.unstable_NormalPriority, ro = ml.unstable_IdlePriority, lo = ml.log, ao = ml.unstable_setDisableYieldValue, oo = null, uo = "function" == typeof Object.is ? Object.is : function(e4, n6) {
    return e4 === n6 && (0 !== e4 || 1 / e4 == 1 / n6) || e4 != e4 && n6 != n6;
  };
  "function" == typeof reportError && reportError;
  var io, so, co = Object.prototype.hasOwnProperty, fo = false, po = /* @__PURE__ */ new WeakMap(), mo = [], ho = 0, go = null, yo = [], bo = 0, vo = null, So = o2(null), ko = o2(null), wo = o2(null), zo = o2(null), xo = false, Eo = null;
  Error(r5(519));
  var Co = o2(null), Po = null, _o = null, To = "undefined" != typeof AbortController ? AbortController : function() {
    var e4 = [], n6 = this.signal = { aborted: false, addEventListener: function(n7, t5) {
      e4.push(t5);
    } };
    this.abort = function() {
      n6.aborted = true, e4.forEach(function(e5) {
        return e5();
      });
    };
  }, Ro = ml.unstable_scheduleCallback, No = ml.unstable_NormalPriority, Lo = { $$typeof: zl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, Uo = null, Do = null, Io = false, Fo = false, jo = false, Ao = 0, Ho = null, Oo = 0, Mo = 0, Wo = null, Qo = Dl.S;
  Dl.S = function(e4, n6) {
    ui = Za(), "object" == typeof n6 && null !== n6 && "function" == typeof n6.then && function(e5, n7) {
      if (null === Ho) {
        var t5 = Ho = [];
        Oo = 0, Mo = X(), Wo = { status: "pending", value: void 0, then: function(e6) {
          t5.push(e6);
        } };
      }
      Oo++, n7.then(Z, Z);
    }(0, n6), null !== Qo && Qo(e4, n6);
  };
  var Bo = o2(null), $o = Error(r5(460)), Vo = Error(r5(474)), qo = Error(r5(542)), Yo = { then: function() {
  } }, Go = null, Jo = null, Ko = 0, Xo = fe(true), Zo = fe(false), eu = [], nu = 0, tu = 0, ru = false, lu = false, au = o2(null), ou = o2(0), uu = o2(null), iu = null, su = o2(0), cu = 0, du = null, fu = null, pu = null, mu = false, hu = false, gu = false, yu = 0, bu = 0, vu = null, Su = 0, ku = { readContext: O, use: Je, useCallback: Ae, useContext: Ae, useEffect: Ae, useImperativeHandle: Ae, useLayoutEffect: Ae, useInsertionEffect: Ae, useMemo: Ae, useReducer: Ae, useRef: Ae, useState: Ae, useDebugValue: Ae, useDeferredValue: Ae, useTransition: Ae, useSyncExternalStore: Ae, useId: Ae, useHostTransitionStatus: Ae, useFormState: Ae, useActionState: Ae, useOptimistic: Ae, useMemoCache: Ae, useCacheRefresh: Ae };
  ku.useEffectEvent = Ae;
  var wu = { readContext: O, use: Je, useCallback: function(e4, n6) {
    return qe().memoizedState = [e4, void 0 === n6 ? null : n6], e4;
  }, useContext: O, useEffect: Pn, useImperativeHandle: function(e4, n6, t5) {
    t5 = null != t5 ? t5.concat([e4]) : null, En(4194308, 4, Ln.bind(null, n6, e4), t5);
  }, useLayoutEffect: function(e4, n6) {
    return En(4194308, 4, e4, n6);
  }, useInsertionEffect: function(e4, n6) {
    En(4, 2, e4, n6);
  }, useMemo: function(e4, n6) {
    var t5 = qe();
    n6 = void 0 === n6 ? null : n6;
    var r6 = e4();
    if (gu) {
      k3(true);
      try {
        e4();
      } finally {
        k3(false);
      }
    }
    return t5.memoizedState = [r6, n6], r6;
  }, useReducer: function(e4, n6, t5) {
    var r6 = qe();
    if (void 0 !== t5) {
      var l3 = t5(n6);
      if (gu) {
        k3(true);
        try {
          t5(n6);
        } finally {
          k3(false);
        }
      }
    } else l3 = n6;
    return r6.memoizedState = r6.baseState = l3, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l3 }, r6.queue = e4, e4 = e4.dispatch = Bn.bind(null, du, e4), [r6.memoizedState, e4];
  }, useRef: function(e4) {
    return e4 = { current: e4 }, qe().memoizedState = e4;
  }, useState: function(e4) {
    var n6 = (e4 = sn(e4)).queue, t5 = $n.bind(null, du, n6);
    return n6.dispatch = t5, [e4.memoizedState, t5];
  }, useDebugValue: Dn, useDeferredValue: function(e4, n6) {
    return jn(qe(), e4, n6);
  }, useTransition: function() {
    var e4 = sn(false);
    return e4 = Hn.bind(null, du, e4.queue, true, false), qe().memoizedState = e4, [false, e4];
  }, useSyncExternalStore: function(e4, n6, t5) {
    var l3 = du, a5 = qe();
    if (t5 = n6(), null === Wu) throw Error(r5(349));
    0 != (127 & Bu) || rn(l3, n6, t5), a5.memoizedState = t5;
    var o3 = { value: t5, getSnapshot: n6 };
    return a5.queue = o3, Pn(an.bind(null, l3, o3, e4), [e4]), l3.flags |= 2048, zn(9, { destroy: void 0 }, ln.bind(null, l3, o3, t5, n6), null), t5;
  }, useId: function() {
    var e4 = qe(), n6 = Wu.identifierPrefix;
    return n6 = "_" + n6 + "r_" + (Su++).toString(32) + "_", e4.memoizedState = n6;
  }, useHostTransitionStatus: On, useFormState: bn, useActionState: bn, useOptimistic: function(e4) {
    var n6 = qe();
    n6.memoizedState = n6.baseState = e4;
    var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n6.queue = t5, n6 = qn.bind(null, du, true, t5), t5.dispatch = n6, [e4, n6];
  }, useMemoCache: Ke, useCacheRefresh: function() {
    return qe().memoizedState = Qn.bind(null, du);
  }, useEffectEvent: function(e4) {
    var n6 = qe(), t5 = { impl: e4 };
    return n6.memoizedState = t5, function() {
      if (0 != (2 & Mu)) throw Error(r5(440));
      return t5.impl.apply(void 0, arguments);
    };
  } }, zu = { readContext: O, use: Je, useCallback: In, useContext: O, useEffect: _n, useImperativeHandle: Un, useInsertionEffect: Rn, useLayoutEffect: Nn, useMemo: Fn, useReducer: Ze, useRef: xn, useState: function() {
    return Ze(Xe);
  }, useDebugValue: Dn, useDeferredValue: function(e4, n6) {
    return An(Ye(), fu.memoizedState, e4, n6);
  }, useTransition: function() {
    var e4 = Ze(Xe)[0], n6 = Ye().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Ge(e4), n6];
  }, useSyncExternalStore: tn, useId: Mn, useHostTransitionStatus: On, useFormState: vn, useActionState: vn, useOptimistic: function(e4, n6) {
    return cn(Ye(), 0, e4, n6);
  }, useMemoCache: Ke, useCacheRefresh: Wn };
  zu.useEffectEvent = Tn;
  var xu = { readContext: O, use: Je, useCallback: In, useContext: O, useEffect: _n, useImperativeHandle: Un, useInsertionEffect: Rn, useLayoutEffect: Nn, useMemo: Fn, useReducer: nn, useRef: xn, useState: function() {
    return nn(Xe);
  }, useDebugValue: Dn, useDeferredValue: function(e4, n6) {
    var t5 = Ye();
    return null === fu ? jn(t5, e4, n6) : An(t5, fu.memoizedState, e4, n6);
  }, useTransition: function() {
    var e4 = nn(Xe)[0], n6 = Ye().memoizedState;
    return ["boolean" == typeof e4 ? e4 : Ge(e4), n6];
  }, useSyncExternalStore: tn, useId: Mn, useHostTransitionStatus: On, useFormState: wn, useActionState: wn, useOptimistic: function(e4, n6) {
    var t5 = Ye();
    return null !== fu ? cn(t5, 0, e4, n6) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
  }, useMemoCache: Ke, useCacheRefresh: Wn };
  xu.useEffectEvent = Tn;
  var Eu = { enqueueSetState: function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = kr(), l3 = ke(r6);
    l3.payload = n6, null != t5 && (l3.callback = t5), null !== (n6 = we(e4, l3, r6)) && (zr(n6, 0, r6), ze(n6, e4, r6));
  }, enqueueReplaceState: function(e4, n6, t5) {
    e4 = e4._reactInternals;
    var r6 = kr(), l3 = ke(r6);
    l3.tag = 1, l3.payload = n6, null != t5 && (l3.callback = t5), null !== (n6 = we(e4, l3, r6)) && (zr(n6, 0, r6), ze(n6, e4, r6));
  }, enqueueForceUpdate: function(e4, n6) {
    e4 = e4._reactInternals;
    var t5 = kr(), r6 = ke(t5);
    r6.tag = 2, null != n6 && (r6.callback = n6), null !== (n6 = we(e4, r6, t5)) && (zr(n6, 0, t5), ze(n6, e4, t5));
  } }, Cu = Error(r5(461)), Pu = false, _u = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }, Tu = false, Ru = false, Nu = false, Lu = "function" == typeof WeakSet ? WeakSet : Set, Uu = null, Du = null, Iu = false, Fu = null, ju = 8192, Au = { getCacheForType: function(e4) {
    var n6 = O(Lo), t5 = n6.data.get(e4);
    return void 0 === t5 && (t5 = e4(), n6.data.set(e4, t5)), t5;
  }, cacheSignal: function() {
    return O(Lo).controller.signal;
  } };
  if ("function" == typeof Symbol && Symbol.for) {
    var Hu = Symbol.for;
    Hu("selector.component"), Hu("selector.has_pseudo_class"), Hu("selector.role"), Hu("selector.test_id"), Hu("selector.text");
  }
  var Ou = "function" == typeof WeakMap ? WeakMap : Map, Mu = 0, Wu = null, Qu = null, Bu = 0, $u = 0, Vu = null, qu = false, Yu = false, Gu = false, Ju = 0, Ku = 0, Xu = 0, Zu = 0, ei = 0, ni = 0, ti = 0, ri = null, li = null, ai = false, oi = 0, ui = 0, ii = 1 / 0, si = null, ci = null, di = 0, fi = null, pi = null, mi = 0, hi = 0, gi = null, yi = null, bi = 0, vi = null;
  return fl.createContainer = function(e4, n6, r6, l3, a5, o3, u4, i5, s3, c5) {
    return function(e5, n7, r7, l4, a6, o4, u5, i6, s4, c6, d3, f4) {
      return e5 = new cl(e5, n7, r7, u5, s4, c6, d3, f4, null), n7 = 1, true === o4 && (n7 |= 24), o4 = t4(3, null, null, n7), e5.current = o4, o4.stateNode = e5, (n7 = Q()).refCount++, e5.pooledCache = n7, n7.refCount++, o4.memoizedState = { element: l4, isDehydrated: r7, cache: n7 }, ve(o4), e5;
    }(e4, n6, false, null, 0, l3, o3, 0, u4, i5, s3, c5);
  }, fl.flushSyncWork = function() {
    return 0 != (6 & Mu) || (q(0), false);
  }, fl.updateContainer = function(e4, n6, t5, r6) {
    var l3 = n6.current, a5 = kr();
    return dl(l3, a5, e4, n6, t5, r6), a5;
  }, fl.updateContainerSync = function(e4, n6, t5, r6) {
    return dl(n6.current, 2, e4, n6, t5, r6), 2;
  }, fl;
}, s.exports.default = s.exports, Object.defineProperty(s.exports, "__esModule", { value: true })), o.exports) : a2.exports = function() {
  return i2 || (i2 = 1, n5 = c2, n5.exports = function(n6) {
    function t4(e4, n7, t5, r6) {
      return new eo(e4, n7, t5, r6);
    }
    function r5() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function l2() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function a4() {
    }
    function o2(e4) {
      var n7 = [];
      return e4.forEach(function(e5) {
        n7.push(e5);
      }), n7.sort().join(", ");
    }
    function i4(e4) {
      return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = No && e4[No] || e4["@@iterator"]) ? e4 : null;
    }
    function s2(e4) {
      if (null == e4) return null;
      if ("function" == typeof e4) return e4.$$typeof === Lo ? null : e4.displayName || e4.name || null;
      if ("string" == typeof e4) return e4;
      switch (e4) {
        case vo:
          return "Fragment";
        case ko:
          return "Profiler";
        case So:
          return "StrictMode";
        case Eo:
          return "Suspense";
        case Co:
          return "SuspenseList";
        case To:
          return "Activity";
      }
      if ("object" == typeof e4) switch ("number" == typeof e4.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e4.$$typeof) {
        case bo:
          return "Portal";
        case zo:
          return e4.displayName || "Context";
        case wo:
          return (e4._context.displayName || "Context") + ".Consumer";
        case xo:
          var n7 = e4.render;
          return (e4 = e4.displayName) || (e4 = "" !== (e4 = n7.displayName || n7.name || "") ? "ForwardRef(" + e4 + ")" : "ForwardRef"), e4;
        case Po:
          return null !== (n7 = e4.displayName || null) ? n7 : s2(e4.type) || "Memo";
        case _o:
          n7 = e4._payload, e4 = e4._init;
          try {
            return s2(e4(n7));
          } catch (e5) {
          }
      }
      return null;
    }
    function c4(e4) {
      var n7 = e4.type;
      switch (e4.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (n7._context.displayName || "Context") + ".Consumer";
        case 10:
          return n7.displayName || "Context";
        case 18:
          return "DehydratedFragment";
        case 11:
          return e4 = (e4 = n7.render).displayName || e4.name || "", n7.displayName || ("" !== e4 ? "ForwardRef(" + e4 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return n7;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return s2(n7);
        case 8:
          return n7 === So ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" == typeof n7) return n7.displayName || n7.name || null;
          if ("string" == typeof n7) return n7;
          break;
        case 29:
          if (null != (n7 = e4._debugInfo)) {
            for (var t5 = n7.length - 1; 0 <= t5; t5--) if ("string" == typeof n7[t5].name) return n7[t5].name;
          }
          if (null !== e4.return) return c4(e4.return);
      }
      return null;
    }
    function d2(e4) {
      return { current: e4 };
    }
    function f3(e4, n7) {
      0 > Vu ? console.error("Unexpected pop.") : (n7 !== $u[Vu] && console.error("Unexpected Fiber popped."), e4.current = Bu[Vu], Bu[Vu] = null, $u[Vu] = null, Vu--);
    }
    function p3(e4, n7, t5) {
      Vu++, Bu[Vu] = e4.current, $u[Vu] = t5, e4.current = n7;
    }
    function m(e4) {
      var n7 = 42 & e4;
      if (0 !== n7) return n7;
      switch (e4 & -e4) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return 261888 & e4;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return 3932160 & e4;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return 62914560 & e4;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), e4;
      }
    }
    function h3(e4, n7, t5) {
      var r6 = e4.pendingLanes;
      if (0 === r6) return 0;
      var l3 = 0, a5 = e4.suspendedLanes, o3 = e4.pingedLanes;
      e4 = e4.warmLanes;
      var u4 = 134217727 & r6;
      return 0 !== u4 ? 0 != (r6 = u4 & ~a5) ? l3 = m(r6) : 0 != (o3 &= u4) ? l3 = m(o3) : t5 || 0 != (t5 = u4 & ~e4) && (l3 = m(t5)) : 0 != (u4 = r6 & ~a5) ? l3 = m(u4) : 0 !== o3 ? l3 = m(o3) : t5 || 0 != (t5 = r6 & ~e4) && (l3 = m(t5)), 0 === l3 ? 0 : 0 !== n7 && n7 !== l3 && 0 == (n7 & a5) && ((a5 = l3 & -l3) >= (t5 = n7 & -n7) || 32 === a5 && 0 != (4194048 & t5)) ? n7 : l3;
    }
    function g3(e4, n7) {
      return 0 == (e4.pendingLanes & ~(e4.suspendedLanes & ~e4.pingedLanes) & n7);
    }
    function y3(e4, n7) {
      switch (e4) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return n7 + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return n7 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function b3() {
      var e4 = Zu;
      return 0 == (62914560 & (Zu <<= 1)) && (Zu = 4194304), e4;
    }
    function v3(e4) {
      for (var n7 = [], t5 = 0; 31 > t5; t5++) n7.push(e4);
      return n7;
    }
    function S3(e4, n7) {
      e4.pendingLanes |= n7, 268435456 !== n7 && (e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0);
    }
    function k3(e4, n7, t5) {
      e4.pendingLanes |= n7, e4.suspendedLanes &= ~n7;
      var r6 = 31 - Yu(n7);
      e4.entangledLanes |= n7, e4.entanglements[r6] = 1073741824 | e4.entanglements[r6] | 261930 & t5;
    }
    function w(e4, n7) {
      var t5 = e4.entangledLanes |= n7;
      for (e4 = e4.entanglements; t5; ) {
        var r6 = 31 - Yu(t5), l3 = 1 << r6;
        l3 & n7 | e4[r6] & n7 && (e4[r6] |= n7), t5 &= ~l3;
      }
    }
    function z(e4, n7) {
      var t5 = n7 & -n7;
      return 0 != ((t5 = 0 != (42 & t5) ? 1 : function(e5) {
        switch (e5) {
          case 2:
            e5 = 1;
            break;
          case 8:
            e5 = 4;
            break;
          case 32:
            e5 = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            e5 = 128;
            break;
          case 268435456:
            e5 = 134217728;
            break;
          default:
            e5 = 0;
        }
        return e5;
      }(t5)) & (e4.suspendedLanes | n7)) ? 0 : t5;
    }
    function x(e4, n7, t5) {
      if (fi) for (e4 = e4.pendingUpdatersLaneMap; 0 < t5; ) {
        var r6 = 31 - Yu(t5), l3 = 1 << r6;
        e4[r6].add(n7), t5 &= ~l3;
      }
    }
    function E(e4, n7) {
      if (fi) for (var t5 = e4.pendingUpdatersLaneMap, r6 = e4.memoizedUpdaters; 0 < n7; ) {
        var l3 = 31 - Yu(n7);
        e4 = 1 << l3, 0 < (l3 = t5[l3]).size && (l3.forEach(function(e5) {
          var n8 = e5.alternate;
          null !== n8 && r6.has(n8) || r6.add(e5);
        }), l3.clear()), n7 &= ~e4;
      }
    }
    function C(e4) {
      return 2 < (e4 &= -e4) ? 8 < e4 ? 0 != (134217727 & e4) ? 32 : 268435456 : 8 : 2;
    }
    function P(e4) {
      "function" == typeof si && ci(e4);
    }
    function _(e4, n7, t5, r6) {
      for (var l3 in e4) Ei.call(e4, l3) && "_" !== l3[0] && T(l3, e4[l3], n7, t5, r6);
    }
    function T(e4, n7, t5, r6, l3) {
      switch (typeof n7) {
        case "object":
          if (null === n7) {
            n7 = "null";
            break;
          }
          if (n7.$$typeof === yo) {
            var a5 = s2(n7.type) || "", o3 = n7.key;
            n7 = n7.props;
            var u4 = Object.keys(n7), i5 = u4.length;
            if (null == o3 && 0 === i5) {
              n7 = "<" + a5 + " />";
              break;
            }
            if (3 > r6 || 1 === i5 && "children" === u4[0] && null == o3) {
              n7 = "<" + a5 + "  />";
              break;
            }
            for (var c5 in t5.push([l3 + "".repeat(r6) + e4, "<" + a5]), null !== o3 && T("key", o3, t5, r6 + 1, l3), e4 = false, n7) "children" === c5 ? null != n7.children && (!Uo(n7.children) || 0 < n7.children.length) && (e4 = true) : Ei.call(n7, c5) && "_" !== c5[0] && T(c5, n7[c5], t5, r6 + 1, l3);
            return void t5.push(["", e4 ? "></" + a5 + ">" : "/>"]);
          }
          if ("Array" === (a5 = (a5 = Object.prototype.toString.call(n7)).slice(8, a5.length - 1))) {
            if (c5 = function(e5) {
              for (var n8 = 0, t6 = 0; t6 < e5.length; t6++) {
                var r7 = e5[t6];
                if ("object" == typeof r7 && null !== r7) {
                  if (!Uo(r7) || 2 !== r7.length || "string" != typeof r7[0]) return 1;
                  if (0 !== n8 && 3 !== n8) return 1;
                  n8 = 3;
                } else {
                  if ("function" == typeof r7 || "string" == typeof r7 && 50 < r7.length || 0 !== n8 && 2 !== n8) return 1;
                  n8 = 2;
                }
              }
              return n8;
            }(n7), 2 === c5 || 0 === c5) {
              n7 = JSON.stringify(n7);
              break;
            }
            if (3 === c5) {
              for (t5.push([l3 + "".repeat(r6) + e4, ""]), e4 = 0; e4 < n7.length; e4++) T((a5 = n7[e4])[0], a5[1], t5, r6 + 1, l3);
              return;
            }
          }
          if ("Promise" === a5) {
            if ("fulfilled" === n7.status) {
              if (a5 = t5.length, T(e4, n7.value, t5, r6, l3), t5.length > a5) return void ((t5 = t5[a5])[1] = "Promise<" + (t5[1] || "Object") + ">");
            } else if ("rejected" === n7.status && (a5 = t5.length, T(e4, n7.reason, t5, r6, l3), t5.length > a5)) return void ((t5 = t5[a5])[1] = "Rejected Promise<" + t5[1] + ">");
            return void t5.push(["".repeat(r6) + e4, "Promise"]);
          }
          return "Object" === a5 && (c5 = Object.getPrototypeOf(n7)) && "function" == typeof c5.constructor && (a5 = c5.constructor.name), t5.push([l3 + "".repeat(r6) + e4, "Object" === a5 ? 3 > r6 ? "" : "" : a5]), void (3 > r6 && _(n7, t5, r6 + 1, l3));
        case "function":
          n7 = "" === n7.name ? "() => {}" : n7.name + "() {}";
          break;
        case "string":
          n7 = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." === n7 ? "" : JSON.stringify(n7);
          break;
        case "undefined":
          n7 = "undefined";
          break;
        case "boolean":
          n7 = n7 ? "true" : "false";
          break;
        default:
          n7 = String(n7);
      }
      t5.push([l3 + "".repeat(r6) + e4, n7]);
    }
    function R(e4, n7, t5, r6) {
      var l3 = true;
      for (o3 in e4) o3 in n7 || (t5.push(["" + "".repeat(r6) + o3, ""]), l3 = false);
      for (var a5 in n7) if (a5 in e4) {
        var o3 = e4[a5], u4 = n7[a5];
        if (o3 !== u4) {
          if (0 === r6 && "children" === a5) l3 = "".repeat(r6) + a5, t5.push(["" + l3, ""], ["+" + l3, ""]);
          else {
            if (!(3 <= r6)) {
              if ("object" == typeof o3 && "object" == typeof u4 && null !== o3 && null !== u4 && o3.$$typeof === u4.$$typeof) if (u4.$$typeof === yo) {
                if (o3.type === u4.type && o3.key === u4.key) {
                  o3 = s2(u4.type) || "", l3 = "".repeat(r6) + a5, o3 = "<" + o3 + "  />", t5.push(["" + l3, o3], ["+" + l3, o3]), l3 = false;
                  continue;
                }
              } else {
                var i5 = Object.prototype.toString.call(o3), c5 = Object.prototype.toString.call(u4);
                if (i5 === c5 && ("[object Object]" === c5 || "[object Array]" === c5)) {
                  i5 = ["" + "".repeat(r6) + a5, "[object Array]" === c5 ? "Array" : ""], t5.push(i5), c5 = t5.length, R(o3, u4, t5, r6 + 1) ? c5 === t5.length && (i5[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : l3 = false;
                  continue;
                }
              }
              else if ("function" == typeof o3 && "function" == typeof u4 && o3.name === u4.name && o3.length === u4.length && (i5 = Function.prototype.toString.call(o3)) === (c5 = Function.prototype.toString.call(u4))) {
                o3 = "" === u4.name ? "() => {}" : u4.name + "() {}", t5.push(["" + "".repeat(r6) + a5, o3 + " Referentially unequal function closure. Consider memoization."]);
                continue;
              }
            }
            T(a5, o3, t5, r6, ""), T(a5, u4, t5, r6, "+");
          }
          l3 = false;
        }
      } else t5.push(["+" + "".repeat(r6) + a5, ""]), l3 = false;
      return l3;
    }
    function N(e4) {
      Pi = 63 & e4 ? "Blocking" : 64 & e4 ? "Gesture" : 4194176 & e4 ? "Transition" : 62914560 & e4 ? "Suspense" : 2080374784 & e4 ? "Idle" : "Other";
    }
    function L(e4, n7, t5, r6) {
      Ci && (Ri.start = n7, Ri.end = t5, Ti.color = "warning", Ti.tooltipText = r6, Ti.properties = null, (e4 = e4._debugTask) ? e4.run(performance.measure.bind(performance, r6, Ri)) : performance.measure(r6, Ri));
    }
    function U(e4, n7, t5) {
      L(e4, n7, t5, "Reconnect");
    }
    function D(e4, n7, t5, r6, l3) {
      var a5 = c4(e4);
      if (null !== a5 && Ci) {
        var o3 = e4.alternate, u4 = e4.actualDuration;
        if (null === o3 || o3.child !== e4.child) for (var i5 = e4.child; null !== i5; i5 = i5.sibling) u4 -= i5.actualDuration;
        r6 = 0.5 > u4 ? r6 ? "tertiary-light" : "primary-light" : 10 > u4 ? r6 ? "tertiary" : "primary" : 100 > u4 ? r6 ? "tertiary-dark" : "primary-dark" : "error";
        var s3 = e4.memoizedProps;
        u4 = e4._debugTask, null !== s3 && null !== o3 && o3.memoizedProps !== s3 ? (i5 = [Ni], s3 = R(o3.memoizedProps, s3, i5, 0), 1 < i5.length && (s3 && !_i && 0 == (o3.lanes & l3) && 100 < e4.actualDuration ? (_i = true, i5[0] = Li, Ti.color = "warning", Ti.tooltipText = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.") : (Ti.color = r6, Ti.tooltipText = a5), Ti.properties = i5, Ri.start = n7, Ri.end = t5, null != u4 ? u4.run(performance.measure.bind(performance, "" + a5, Ri)) : performance.measure("" + a5, Ri))) : null != u4 ? u4.run(console.timeStamp.bind(console, a5, n7, t5, "Components ", void 0, r6)) : console.timeStamp(a5, n7, t5, "Components ", void 0, r6);
      }
    }
    function I(e4, n7, t5, r6) {
      if (Ci) {
        var l3 = c4(e4);
        if (null !== l3) {
          for (var a5 = null, o3 = [], u4 = 0; u4 < r6.length; u4++) {
            var i5 = r6[u4];
            null == a5 && null !== i5.source && (a5 = i5.source._debugTask), i5 = i5.value, o3.push(["Error", "object" == typeof i5 && null !== i5 && "string" == typeof i5.message ? String(i5.message) : String(i5)]);
          }
          null !== e4.key && T("key", e4.key, o3, 0, ""), null !== e4.memoizedProps && _(e4.memoizedProps, o3, 0, ""), null == a5 && (a5 = e4._debugTask), e4 = { start: n7, end: t5, detail: { devtools: { color: "error", track: "Components ", tooltipText: 13 === e4.tag ? "Hydration failed" : "Error boundary caught an error", properties: o3 } } }, a5 ? a5.run(performance.measure.bind(performance, "" + l3, e4)) : performance.measure("" + l3, e4);
        }
      }
    }
    function F(e4, n7, t5, r6, l3) {
      if (null !== l3) {
        if (Ci) {
          var a5 = c4(e4);
          if (null !== a5) {
            r6 = [];
            for (var o3 = 0; o3 < l3.length; o3++) {
              var u4 = l3[o3].value;
              r6.push(["Error", "object" == typeof u4 && null !== u4 && "string" == typeof u4.message ? String(u4.message) : String(u4)]);
            }
            null !== e4.key && T("key", e4.key, r6, 0, ""), null !== e4.memoizedProps && _(e4.memoizedProps, r6, 0, ""), n7 = { start: n7, end: t5, detail: { devtools: { color: "error", track: "Components ", tooltipText: "A lifecycle or effect errored", properties: r6 } } }, (e4 = e4._debugTask) ? e4.run(performance.measure.bind(performance, "" + a5, n7)) : performance.measure("" + a5, n7);
          }
        }
      } else null !== (a5 = c4(e4)) && Ci && (l3 = 1 > r6 ? "secondary-light" : 100 > r6 ? "secondary" : 500 > r6 ? "secondary-dark" : "error", (e4 = e4._debugTask) ? e4.run(console.timeStamp.bind(console, a5, n7, t5, "Components ", void 0, l3)) : console.timeStamp(a5, n7, t5, "Components ", void 0, l3));
    }
    function j(e4, n7, t5, r6) {
      !Ci || n7 <= e4 || (t5 = (738197653 & t5) === t5 ? "tertiary-dark" : "primary-dark", r6 ? r6.run(console.timeStamp.bind(console, "Prewarm", e4, n7, Pi, "Scheduler ", t5)) : console.timeStamp("Prewarm", e4, n7, Pi, "Scheduler ", t5));
    }
    function A(e4, n7, t5, r6) {
      !Ci || n7 <= e4 || (t5 = (738197653 & t5) === t5 ? "tertiary-dark" : "primary-dark", r6 ? r6.run(console.timeStamp.bind(console, "Suspended", e4, n7, Pi, "Scheduler ", t5)) : console.timeStamp("Suspended", e4, n7, Pi, "Scheduler ", t5));
    }
    function H(e4, n7, t5, r6) {
      !Ci || n7 <= e4 || (r6 ? r6.run(console.timeStamp.bind(console, "Errored", e4, n7, Pi, "Scheduler ", "error")) : console.timeStamp("Errored", e4, n7, Pi, "Scheduler ", "error"));
    }
    function O(e4, n7, t5, r6, l3) {
      if (Ci && !(n7 <= e4)) {
        for (var a5 = [], o3 = 0; o3 < t5.length; o3++) {
          var u4 = t5[o3].value;
          a5.push(["Error", "object" == typeof u4 && null !== u4 && "string" == typeof u4.message ? String(u4.message) : String(u4)]);
        }
        e4 = { start: e4, end: n7, detail: { devtools: { color: "error", track: Pi, trackGroup: "Scheduler ", tooltipText: r6 ? "Remaining Effects Errored" : "Commit Errored", properties: a5 } } }, l3 ? l3.run(performance.measure.bind(performance, "Errored", e4)) : performance.measure("Errored", e4);
      }
    }
    function M() {
    }
    function W(e4) {
      var n7 = Error.prepareStackTrace;
      return Error.prepareStackTrace = void 0, e4 = e4.stack, Error.prepareStackTrace = n7, e4.startsWith("Error: react-stack-top-frame\n") && (e4 = e4.slice(29)), -1 !== (n7 = e4.indexOf("\n")) && (e4 = e4.slice(n7 + 1)), -1 !== (n7 = e4.indexOf("react_stack_bottom_frame")) && (n7 = e4.lastIndexOf("\n", n7)), -1 === n7 ? "" : e4 = e4.slice(0, n7);
    }
    function Q(e4) {
      if (void 0 === Di) try {
        throw Error();
      } catch (e5) {
        var n7 = e5.stack.trim().match(/\n( *(at )?)/);
        Di = n7 && n7[1] || "", Ii = -1 < e5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e5.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + Di + e4 + Ii;
    }
    function B(e4, n7) {
      if (!e4 || Fi) return "";
      var t5, r6 = ji.get(e4);
      if (void 0 !== r6) return r6;
      Fi = true, r6 = Error.prepareStackTrace, Error.prepareStackTrace = void 0, t5 = Do.H, Do.H = null, function() {
        if (0 === Ui) {
          bi = console.log, vi = console.info, Si = console.warn, ki = console.error, wi = console.group, zi = console.groupCollapsed, xi = console.groupEnd;
          var e5 = { configurable: true, enumerable: true, value: M, writable: true };
          Object.defineProperties(console, { info: e5, log: e5, warn: e5, error: e5, group: e5, groupCollapsed: e5, groupEnd: e5 });
        }
        Ui++;
      }();
      try {
        var l3 = { DetermineComponentFrameRoot: function() {
          try {
            if (n7) {
              var t6 = function() {
                throw Error();
              };
              if (Object.defineProperty(t6.prototype, "props", { set: function() {
                throw Error();
              } }), "object" == typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(t6, []);
                } catch (e5) {
                  var r7 = e5;
                }
                Reflect.construct(e4, [], t6);
              } else {
                try {
                  t6.call();
                } catch (e5) {
                  r7 = e5;
                }
                e4.call(t6.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (e5) {
                r7 = e5;
              }
              (t6 = e4()) && "function" == typeof t6.catch && t6.catch(function() {
              });
            }
          } catch (e5) {
            if (e5 && r7 && "string" == typeof e5.stack) return [e5.stack, r7.stack];
          }
          return [null, null];
        } };
        l3.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var a5 = Object.getOwnPropertyDescriptor(l3.DetermineComponentFrameRoot, "name");
        a5 && a5.configurable && Object.defineProperty(l3.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var o3 = l3.DetermineComponentFrameRoot(), u4 = o3[0], i5 = o3[1];
        if (u4 && i5) {
          var s3 = u4.split("\n"), c5 = i5.split("\n");
          for (o3 = a5 = 0; a5 < s3.length && !s3[a5].includes("DetermineComponentFrameRoot"); ) a5++;
          for (; o3 < c5.length && !c5[o3].includes("DetermineComponentFrameRoot"); ) o3++;
          if (a5 === s3.length || o3 === c5.length) for (a5 = s3.length - 1, o3 = c5.length - 1; 1 <= a5 && 0 <= o3 && s3[a5] !== c5[o3]; ) o3--;
          for (; 1 <= a5 && 0 <= o3; a5--, o3--) if (s3[a5] !== c5[o3]) {
            if (1 !== a5 || 1 !== o3) do {
              if (a5--, 0 > --o3 || s3[a5] !== c5[o3]) {
                var d3 = "\n" + s3[a5].replace(" at new ", " at ");
                return e4.displayName && d3.includes("<anonymous>") && (d3 = d3.replace("<anonymous>", e4.displayName)), "function" == typeof e4 && ji.set(e4, d3), d3;
              }
            } while (1 <= a5 && 0 <= o3);
            break;
          }
        }
      } finally {
        Fi = false, Do.H = t5, function() {
          if (0 == --Ui) {
            var e5 = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, { log: ho({}, e5, { value: bi }), info: ho({}, e5, { value: vi }), warn: ho({}, e5, { value: Si }), error: ho({}, e5, { value: ki }), group: ho({}, e5, { value: wi }), groupCollapsed: ho({}, e5, { value: zi }), groupEnd: ho({}, e5, { value: xi }) });
          }
          0 > Ui && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }(), Error.prepareStackTrace = r6;
      }
      return s3 = (s3 = e4 ? e4.displayName || e4.name : "") ? Q(s3) : "", "function" == typeof e4 && ji.set(e4, s3), s3;
    }
    function $(e4, n7) {
      switch (e4.tag) {
        case 26:
        case 27:
        case 5:
          return Q(e4.type);
        case 16:
          return Q("Lazy");
        case 13:
          return e4.child !== n7 && null !== n7 ? Q("Suspense Fallback") : Q("Suspense");
        case 19:
          return Q("SuspenseList");
        case 0:
        case 15:
          return B(e4.type, false);
        case 11:
          return B(e4.type.render, false);
        case 1:
          return B(e4.type, true);
        case 31:
          return Q("Activity");
        default:
          return "";
      }
    }
    function V(e4) {
      try {
        var n7 = "", t5 = null;
        do {
          n7 += $(e4, t5);
          var r6 = e4._debugInfo;
          if (r6) for (var l3 = r6.length - 1; 0 <= l3; l3--) {
            var a5 = r6[l3];
            if ("string" == typeof a5.name) {
              var o3 = n7;
              e: {
                var u4 = a5.name, i5 = a5.env, s3 = a5.debugLocation;
                if (null != s3) {
                  var c5 = W(s3), d3 = c5.lastIndexOf("\n"), f4 = -1 === d3 ? c5 : c5.slice(d3 + 1);
                  if (-1 !== f4.indexOf(u4)) {
                    var p4 = "\n" + f4;
                    break e;
                  }
                }
                p4 = Q(u4 + (i5 ? " [" + i5 + "]" : ""));
              }
              n7 = o3 + p4;
            }
          }
          t5 = e4, e4 = e4.return;
        } while (e4);
        return n7;
      } catch (e5) {
        return "\nError generating stack: " + e5.message + "\n" + e5.stack;
      }
    }
    function q(e4) {
      return (e4 = e4 ? e4.displayName || e4.name : "") ? Q(e4) : "";
    }
    function Y(e4, n7) {
      if ("object" == typeof e4 && null !== e4) {
        var t5 = Ai.get(e4);
        return void 0 !== t5 ? t5 : (n7 = { value: e4, source: n7, stack: V(n7) }, Ai.set(e4, n7), n7);
      }
      return { value: e4, source: n7, stack: V(n7) };
    }
    function G2(e4) {
      for (; e4 === Mi; ) Mi = Hi[--Oi], Hi[Oi] = null, Wi = Hi[--Oi], Hi[Oi] = null;
      for (; e4 === $i; ) $i = Qi[--Bi], Qi[Bi] = null, qi = Qi[--Bi], Qi[Bi] = null, Vi = Qi[--Bi], Qi[Bi] = null;
    }
    function J() {
      console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function K(e4) {
      return null === e4 && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."), e4;
    }
    function X(e4, n7) {
      p3(Ji, n7, e4), p3(Gi, e4, e4), p3(Yi, null, e4), n7 = Fo(n7), f3(Yi, e4), p3(Yi, n7, e4);
    }
    function Z(e4) {
      f3(Yi, e4), f3(Gi, e4), f3(Ji, e4);
    }
    function ee() {
      return K(Yi.current);
    }
    function ne(e4) {
      null !== e4.memoizedState && p3(Ki, e4, e4);
      var n7 = K(Yi.current), t5 = jo(n7, e4.type);
      n7 !== t5 && (p3(Gi, e4, e4), p3(Yi, t5, e4));
    }
    function te(e4) {
      Gi.current === e4 && (f3(Yi, e4), f3(Gi, e4)), Ki.current === e4 && (f3(Ki, e4), mu._currentValue2 = pu);
    }
    function re() {
      if (null === Xi) return "";
      var e4 = Xi;
      try {
        var n7 = "";
        switch (6 === e4.tag && (e4 = e4.return), e4.tag) {
          case 26:
          case 27:
          case 5:
            n7 += Q(e4.type);
            break;
          case 13:
            n7 += Q("Suspense");
            break;
          case 19:
            n7 += Q("SuspenseList");
            break;
          case 31:
            n7 += Q("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            e4._debugOwner || "" !== n7 || (n7 += q(e4.type));
            break;
          case 11:
            e4._debugOwner || "" !== n7 || (n7 += q(e4.type.render));
        }
        for (; e4; ) if ("number" == typeof e4.tag) {
          var t5 = e4;
          e4 = t5._debugOwner;
          var r6 = t5._debugStack;
          if (e4 && r6) {
            var l3 = W(r6);
            "" !== l3 && (n7 += "\n" + l3);
          }
        } else {
          if (null == e4.debugStack) break;
          var a5 = e4.debugStack;
          (e4 = e4.owner) && a5 && (n7 += "\n" + W(a5));
        }
        var o3 = n7;
      } catch (e5) {
        o3 = "\nError generating stack: " + e5.message + "\n" + e5.stack;
      }
      return o3;
    }
    function le(e4, n7, t5, r6, l3, a5, o3) {
      var u4 = Xi;
      ae(e4);
      try {
        return null !== e4 && e4._debugTask ? e4._debugTask.run(n7.bind(null, t5, r6, l3, a5, o3)) : n7(t5, r6, l3, a5, o3);
      } finally {
        ae(u4);
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function ae(e4) {
      Do.getCurrentStack = null === e4 ? null : re, Zi = false, Xi = e4;
    }
    function oe() {
      var e4 = ns;
      return null !== e4 && (null === Ep ? Ep = e4 : Ep.push.apply(Ep, e4), ns = null), e4;
    }
    function ue() {
      us = os = null, is = false;
    }
    function ie(e4, n7, t5) {
      p3(rs, n7._currentValue2, e4), n7._currentValue2 = t5, p3(ls, n7._currentRenderer2, e4), void 0 !== n7._currentRenderer2 && null !== n7._currentRenderer2 && n7._currentRenderer2 !== as && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), n7._currentRenderer2 = as;
    }
    function se(e4, n7) {
      var t5 = rs.current;
      e4._currentValue2 = t5, t5 = ls.current, f3(ls, n7), e4._currentRenderer2 = t5, f3(rs, n7);
    }
    function ce(e4, n7, t5) {
      for (; null !== e4; ) {
        var r6 = e4.alternate;
        if ((e4.childLanes & n7) !== n7 ? (e4.childLanes |= n7, null !== r6 && (r6.childLanes |= n7)) : null !== r6 && (r6.childLanes & n7) !== n7 && (r6.childLanes |= n7), e4 === t5) break;
        e4 = e4.return;
      }
      e4 !== t5 && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function de(e4, n7, t5, r6) {
      var l3 = e4.child;
      for (null !== l3 && (l3.return = e4); null !== l3; ) {
        var a5 = l3.dependencies;
        if (null !== a5) {
          var o3 = l3.child;
          a5 = a5.firstContext;
          e: for (; null !== a5; ) {
            var u4 = a5;
            a5 = l3;
            for (var i5 = 0; i5 < n7.length; i5++) if (u4.context === n7[i5]) {
              a5.lanes |= t5, null !== (u4 = a5.alternate) && (u4.lanes |= t5), ce(a5.return, t5, e4), r6 || (o3 = null);
              break e;
            }
            a5 = u4.next;
          }
        } else if (18 === l3.tag) {
          if (null === (o3 = l3.return)) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          o3.lanes |= t5, null !== (a5 = o3.alternate) && (a5.lanes |= t5), ce(o3, t5, e4), o3 = null;
        } else o3 = l3.child;
        if (null !== o3) o3.return = l3;
        else for (o3 = l3; null !== o3; ) {
          if (o3 === e4) {
            o3 = null;
            break;
          }
          if (null !== (l3 = o3.sibling)) {
            l3.return = o3.return, o3 = l3;
            break;
          }
          o3 = o3.return;
        }
        l3 = o3;
      }
    }
    function fe(e4, n7, t5, r6) {
      e4 = null;
      for (var l3 = n7, a5 = false; null !== l3; ) {
        if (!a5) {
          if (0 != (524288 & l3.flags)) a5 = true;
          else if (0 != (262144 & l3.flags)) break;
        }
        if (10 === l3.tag) {
          var o3 = l3.alternate;
          if (null === o3) throw Error("Should have a current fiber. This is a bug in React.");
          if (null !== (o3 = o3.memoizedProps)) {
            var u4 = l3.type;
            yi(l3.pendingProps.value, o3.value) || (null !== e4 ? e4.push(u4) : e4 = [u4]);
          }
        } else if (l3 === Ki.current) {
          if (null === (o3 = l3.alternate)) throw Error("Should have a current fiber. This is a bug in React.");
          o3.memoizedState.memoizedState !== l3.memoizedState.memoizedState && (null !== e4 ? e4.push(mu) : e4 = [mu]);
        }
        l3 = l3.return;
      }
      null !== e4 && de(n7, e4, t5, r6), n7.flags |= 262144;
    }
    function pe(e4) {
      for (e4 = e4.firstContext; null !== e4; ) {
        var n7 = e4.context;
        if (!yi(n7._currentValue2, e4.memoizedValue)) return true;
        e4 = e4.next;
      }
      return false;
    }
    function me(e4) {
      os = e4, us = null, null !== (e4 = e4.dependencies) && (e4.firstContext = null);
    }
    function he(e4) {
      return is && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ye(os, e4);
    }
    function ge(e4, n7) {
      return null === os && me(e4), ye(e4, n7);
    }
    function ye(e4, n7) {
      var t5 = n7._currentValue2;
      if (n7 = { context: n7, memoizedValue: t5, next: null }, null === us) {
        if (null === e4) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        us = n7, e4.dependencies = { lanes: 0, firstContext: n7, _debugThenableState: null }, e4.flags |= 524288;
      } else us = us.next = n7;
      return t5;
    }
    function be() {
      return { controller: new ss(), data: /* @__PURE__ */ new Map(), refCount: 0 };
    }
    function ve(e4) {
      e4.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React."), e4.refCount++;
    }
    function Se(e4) {
      e4.refCount--, 0 > e4.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React."), 0 === e4.refCount && cs(ds, function() {
        e4.controller.abort();
      });
    }
    function ke(e4, n7, t5) {
      0 != (127 & e4) ? 0 > Ps && (Ps = ps(), _s = ms(n7), Rs = n7, null != t5 && (Ns = c4(t5)), (Xf & (Qf | Bf)) !== Wf && (Es = true, Ts = 1), e4 = tu(), n7 = nu(), e4 !== Ds || n7 !== Us ? Ds = -1.1 : null !== n7 && (Ts = 1), Ls = e4, Us = n7) : 0 != (4194048 & e4) && 0 > As && (As = ps(), Os = ms(n7), Ms = n7, null != t5 && (Ws = c4(t5)), 0 > js) && (e4 = tu(), n7 = nu(), e4 === $s && n7 === Bs || ($s = -1.1), Qs = e4, Bs = n7);
    }
    function we() {
      var e4 = Ss;
      return Ss = 0, e4;
    }
    function ze(e4) {
      var n7 = Ss;
      return Ss = e4, n7;
    }
    function xe(e4) {
      var n7 = Ss;
      return Ss += e4, n7;
    }
    function Ee() {
      zs = ws = -1.1;
    }
    function Ce() {
      var e4 = ws;
      return ws = -1.1, e4;
    }
    function Pe(e4) {
      0 <= e4 && (ws = e4);
    }
    function _e() {
      var e4 = ks;
      return ks = -0, e4;
    }
    function Te(e4) {
      0 <= e4 && (ks = e4);
    }
    function Re() {
      var e4 = xs;
      return xs = null, e4;
    }
    function Ne() {
      var e4 = Es;
      return Es = false, e4;
    }
    function Le(e4) {
      vs = ps(), 0 > e4.actualStartTime && (e4.actualStartTime = vs);
    }
    function Ue(e4) {
      if (0 <= vs) {
        var n7 = ps() - vs;
        e4.actualDuration += n7, e4.selfBaseDuration = n7, vs = -1;
      }
    }
    function De(e4) {
      if (0 <= vs) {
        var n7 = ps() - vs;
        e4.actualDuration += n7, vs = -1;
      }
    }
    function Ie() {
      if (0 <= vs) {
        var e4 = ps(), n7 = e4 - vs;
        vs = -1, Ss += n7, ks += n7, zs = e4;
      }
    }
    function Fe(e4) {
      null === xs && (xs = []), xs.push(e4), null === bs && (bs = []), bs.push(e4);
    }
    function je() {
      vs = ps(), 0 > ws && (ws = vs);
    }
    function Ae(e4) {
      for (var n7 = e4.child; n7; ) e4.actualDuration += n7.actualDuration, n7 = n7.sibling;
    }
    function He() {
    }
    function Oe(e4) {
      e4 !== Zs && null === e4.next && (null === Zs ? Xs = Zs = e4 : Zs = Zs.next = e4), tc = true, null !== Do.actQueue ? nc || (nc = true, Ye()) : ec || (ec = true, Ye());
    }
    function Me(e4, n7) {
      if (!rc && tc) {
        rc = true;
        do {
          for (var t5 = false, r6 = Xs; null !== r6; ) {
            if (0 !== e4) {
              var l3 = r6.pendingLanes;
              if (0 === l3) var a5 = 0;
              else {
                var o3 = r6.suspendedLanes, u4 = r6.pingedLanes;
                a5 = (1 << 31 - Yu(42 | e4) + 1) - 1, a5 = 201326741 & (a5 &= l3 & ~(o3 & ~u4)) ? 201326741 & a5 | 1 : a5 ? 2 | a5 : 0;
              }
              0 !== a5 && (t5 = true, Ve(r6, a5));
            } else a5 = np, 0 == (3 & (a5 = h3(r6, r6 === Zf ? a5 : 0, null !== r6.cancelPendingCommit || r6.timeoutHandle !== qo))) || g3(r6, a5) || (t5 = true, Ve(r6, a5));
            r6 = r6.next;
          }
        } while (t5);
        rc = false;
      }
    }
    function We() {
      eu(), Qe();
    }
    function Qe() {
      tc = nc = ec = false;
      var e4 = 0;
      0 !== lc && ru() && (e4 = lc);
      for (var n7 = li(), t5 = null, r6 = Xs; null !== r6; ) {
        var l3 = r6.next, a5 = Be(r6, n7);
        0 === a5 ? (r6.next = null, null === t5 ? Xs = l3 : t5.next = l3, null === l3 && (Zs = t5)) : (t5 = r6, (0 !== e4 || 0 != (3 & a5)) && (tc = true)), r6 = l3;
      }
      $p !== Hp && $p !== Bp || Me(e4), 0 !== lc && (lc = 0);
    }
    function Be(e4, n7) {
      for (var t5 = e4.suspendedLanes, r6 = e4.pingedLanes, l3 = e4.expirationTimes, a5 = -62914561 & e4.pendingLanes; 0 < a5; ) {
        var o3 = 31 - Yu(a5), u4 = 1 << o3, i5 = l3[o3];
        -1 === i5 ? 0 != (u4 & t5) && 0 == (u4 & r6) || (l3[o3] = y3(u4, n7)) : i5 <= n7 && (e4.expiredLanes |= u4), a5 &= ~u4;
      }
      if (t5 = np, t5 = h3(e4, e4 === (n7 = Zf) ? t5 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== qo), r6 = e4.callbackNode, 0 === t5 || e4 === n7 && (fp === lp || fp === dp) || null !== e4.cancelPendingCommit) return null !== r6 && qe(r6), e4.callbackNode = null, e4.callbackPriority = 0;
      if (0 == (3 & t5) || g3(e4, t5)) {
        if ((n7 = t5 & -t5) === e4.callbackPriority && (null === Do.actQueue || r6 === ac)) return n7;
        switch (qe(r6), C(t5)) {
          case 2:
          case 8:
            t5 = oi;
            break;
          case 32:
          default:
            t5 = ui;
            break;
          case 268435456:
            t5 = ii;
        }
        return r6 = $e.bind(null, e4), null !== Do.actQueue ? (Do.actQueue.push(r6), t5 = ac) : t5 = ei(t5, r6), e4.callbackPriority = n7, e4.callbackNode = t5, n7;
      }
      return null !== r6 && qe(r6), e4.callbackPriority = 2, e4.callbackNode = null, 2;
    }
    function $e(e4, n7) {
      if (Ks = Js = false, eu(), $p !== Hp && $p !== Bp) return e4.callbackNode = null, e4.callbackPriority = 0, null;
      var t5 = e4.callbackNode;
      if (em === Ip && (em = jp), Oa() && e4.callbackNode !== t5) return null;
      var r6 = np;
      return 0 === (r6 = h3(e4, e4 === Zf ? r6 : 0, null !== e4.cancelPendingCommit || e4.timeoutHandle !== qo)) ? null : (ma(e4, r6, n7), Be(e4, li()), null != e4.callbackNode && e4.callbackNode === t5 ? $e.bind(null, e4) : null);
    }
    function Ve(e4, n7) {
      if (Oa()) return null;
      Js = Ks, Ks = false, ma(e4, n7, true);
    }
    function qe(e4) {
      e4 !== ac && null !== e4 && ni(e4);
    }
    function Ye() {
      null !== Do.actQueue && Do.actQueue.push(function() {
        return Qe(), null;
      }), ei(ai, We);
    }
    function Ge() {
      if (0 === lc) {
        var e4 = ic;
        0 === e4 && (e4 = Ku, 0 == (261888 & (Ku <<= 1)) && (Ku = 256)), lc = e4;
      }
      return lc;
    }
    function Je() {
      if (0 == --uc && (-1 < As || (js = -1.1), null !== oc)) {
        null !== sc && (sc.status = "fulfilled");
        var e4 = oc;
        oc = null, ic = 0, sc = null;
        for (var n7 = 0; n7 < e4.length; n7++) (0, e4[n7])();
      }
    }
    function Ke() {
      var e4 = dc.current;
      return null !== e4 ? e4 : Zf.pooledCache;
    }
    function Xe(e4, n7) {
      p3(dc, null === n7 ? dc.current : n7.pool, e4);
    }
    function Ze() {
      var e4 = Ke();
      return null === e4 ? null : { parent: fs2._currentValue2, pool: e4 };
    }
    function en(e4, n7) {
      if (yi(e4, n7)) return true;
      if ("object" != typeof e4 || null === e4 || "object" != typeof n7 || null === n7) return false;
      var t5 = Object.keys(e4), r6 = Object.keys(n7);
      if (t5.length !== r6.length) return false;
      for (r6 = 0; r6 < t5.length; r6++) {
        var l3 = t5[r6];
        if (!Ei.call(n7, l3) || !yi(e4[l3], n7[l3])) return false;
      }
      return true;
    }
    function nn(e4) {
      return "fulfilled" === (e4 = e4.status) || "rejected" === e4;
    }
    function tn(e4, n7, t5) {
      null !== Do.actQueue && (Do.didUsePromise = true);
      var r6 = e4.thenables;
      if (void 0 === (t5 = r6[t5]) ? r6.push(n7) : t5 !== n7 && (e4.didWarnAboutUncachedPromise || (e4.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), n7.then(He, He), n7 = t5), void 0 === n7._debugInfo) {
        e4 = performance.now();
        var l3 = { name: "string" == typeof (r6 = n7.displayName) ? r6 : "Promise", start: e4, end: e4, value: n7 };
        n7._debugInfo = [{ awaited: l3 }], "fulfilled" !== n7.status && "rejected" !== n7.status && (e4 = function() {
          l3.end = performance.now();
        }, n7.then(e4, e4));
      }
      switch (n7.status) {
        case "fulfilled":
          return n7.value;
        case "rejected":
          throw an(e4 = n7.reason), e4;
        default:
          if ("string" == typeof n7.status) n7.then(He, He);
          else {
            if (null !== (e4 = Zf) && 100 < e4.shellSuspendCounter) throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            (e4 = n7).status = "pending", e4.then(function(e5) {
              if ("pending" === n7.status) {
                var t6 = n7;
                t6.status = "fulfilled", t6.value = e5;
              }
            }, function(e5) {
              if ("pending" === n7.status) {
                var t6 = n7;
                t6.status = "rejected", t6.reason = e5;
              }
            });
          }
          switch (n7.status) {
            case "fulfilled":
              return n7.value;
            case "rejected":
              throw an(e4 = n7.reason), e4;
          }
          throw $c = n7, Vc = true, Mc;
      }
    }
    function rn(e4) {
      try {
        return Oc(e4);
      } catch (e5) {
        if (null !== e5 && "object" == typeof e5 && "function" == typeof e5.then) throw $c = e5, Vc = true, Mc;
        throw e5;
      }
    }
    function ln() {
      if (null === $c) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var e4 = $c;
      return $c = null, Vc = false, e4;
    }
    function an(e4) {
      if (e4 === Mc || e4 === Qc) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function on3(e4) {
      var n7 = Gc;
      return null != e4 && (Gc = null === n7 ? e4 : n7.concat(e4)), n7;
    }
    function un() {
      var e4 = Gc;
      if (null != e4) {
        for (var n7 = e4.length - 1; 0 <= n7; n7--) if (null != e4[n7].name) {
          var t5 = e4[n7].debugTask;
          if (null != t5) return t5;
        }
      }
      return null;
    }
    function sn(e4, n7, t5) {
      for (var r6 = Object.keys(e4.props), l3 = 0; l3 < r6.length; l3++) {
        var a5 = r6[l3];
        if ("children" !== a5 && "key" !== a5) {
          null === n7 && ((n7 = ao(e4, t5.mode, 0))._debugInfo = Gc, n7.return = t5), le(n7, function(e5) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", e5);
          }, a5);
          break;
        }
      }
    }
    function cn(e4) {
      var n7 = Yc;
      return Yc += 1, null === qc && (qc = { didWarnAboutUncachedPromise: false, thenables: [] }), tn(qc, e4, n7);
    }
    function dn(e4, n7) {
      n7 = n7.props.ref, e4.ref = void 0 !== n7 ? n7 : null;
    }
    function fn(e4, n7) {
      if (n7.$$typeof === go) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
      throw e4 = Object.prototype.toString.call(n7), Error("Objects are not valid as a React child (found: " + ("[object Object]" === e4 ? "object with keys {" + Object.keys(n7).join(", ") + "}" : e4) + "). If you meant to render a collection of children, use an array instead.");
    }
    function pn(e4, n7) {
      var t5 = un();
      null !== t5 ? t5.run(fn.bind(null, e4, n7)) : fn(e4, n7);
    }
    function mn(e4, n7) {
      var t5 = c4(e4) || "Component";
      Xc[t5] || (Xc[t5] = true, n7 = n7.displayName || n7.name || "Component", 3 === e4.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", n7, n7, n7) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", n7, n7, t5, n7, t5));
    }
    function hn(e4, n7) {
      var t5 = un();
      null !== t5 ? t5.run(mn.bind(null, e4, n7)) : mn(e4, n7);
    }
    function gn(e4, n7) {
      var t5 = c4(e4) || "Component";
      Zc[t5] || (Zc[t5] = true, n7 = String(n7), 3 === e4.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", n7) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", t5, n7, t5));
    }
    function yn(e4, n7) {
      var t5 = un();
      null !== t5 ? t5.run(gn.bind(null, e4, n7)) : gn(e4, n7);
    }
    function bn(e4) {
      function n7(n8, t5) {
        if (e4) {
          var r7 = n8.deletions;
          null === r7 ? (n8.deletions = [t5], n8.flags |= 16) : r7.push(t5);
        }
      }
      function r6(t5, r7) {
        if (!e4) return null;
        for (; null !== r7; ) n7(t5, r7), r7 = r7.sibling;
        return null;
      }
      function l3(e5) {
        for (var n8 = /* @__PURE__ */ new Map(); null !== e5; ) null !== e5.key ? n8.set(e5.key, e5) : n8.set(e5.index, e5), e5 = e5.sibling;
        return n8;
      }
      function o3(e5, n8) {
        return (e5 = to(e5, n8)).index = 0, e5.sibling = null, e5;
      }
      function u4(n8, t5, r7) {
        return n8.index = r7, e4 ? null !== (r7 = n8.alternate) ? (r7 = r7.index) < t5 ? (n8.flags |= 67108866, t5) : r7 : (n8.flags |= 67108866, t5) : (n8.flags |= 1048576, t5);
      }
      function s3(n8) {
        return e4 && null === n8.alternate && (n8.flags |= 67108866), n8;
      }
      function c5(e5, n8, t5, r7) {
        return null === n8 || 6 !== n8.tag ? ((n8 = uo(t5, e5.mode, r7)).return = e5, n8._debugOwner = e5, n8._debugTask = e5._debugTask, n8._debugInfo = Gc, n8) : ((n8 = o3(n8, t5)).return = e5, n8._debugInfo = Gc, n8);
      }
      function d3(e5, n8, t5, r7) {
        var l4 = t5.type;
        return l4 === vo ? (sn(t5, n8 = p4(e5, n8, t5.props.children, r7, t5.key), e5), n8) : null !== n8 && (n8.elementType === l4 || "object" == typeof l4 && null !== l4 && l4.$$typeof === _o && rn(l4) === n8.type) ? (dn(n8 = o3(n8, t5.props), t5), n8.return = e5, n8._debugOwner = t5._owner, n8._debugInfo = Gc, n8) : (dn(n8 = ao(t5, e5.mode, r7), t5), n8.return = e5, n8._debugInfo = Gc, n8);
      }
      function f4(e5, n8, t5, r7) {
        return null === n8 || 4 !== n8.tag || n8.stateNode.containerInfo !== t5.containerInfo || n8.stateNode.implementation !== t5.implementation ? ((n8 = io(t5, e5.mode, r7)).return = e5, n8._debugInfo = Gc, n8) : ((n8 = o3(n8, t5.children || [])).return = e5, n8._debugInfo = Gc, n8);
      }
      function p4(e5, n8, t5, r7, l4) {
        return null === n8 || 7 !== n8.tag ? ((n8 = oo(t5, e5.mode, r7, l4)).return = e5, n8._debugOwner = e5, n8._debugTask = e5._debugTask, n8._debugInfo = Gc, n8) : ((n8 = o3(n8, t5)).return = e5, n8._debugInfo = Gc, n8);
      }
      function m2(e5, n8, t5) {
        if ("string" == typeof n8 && "" !== n8 || "number" == typeof n8 || "bigint" == typeof n8) return (n8 = uo("" + n8, e5.mode, t5)).return = e5, n8._debugOwner = e5, n8._debugTask = e5._debugTask, n8._debugInfo = Gc, n8;
        if ("object" == typeof n8 && null !== n8) {
          switch (n8.$$typeof) {
            case yo:
              return dn(t5 = ao(n8, e5.mode, t5), n8), t5.return = e5, e5 = on3(n8._debugInfo), t5._debugInfo = Gc, Gc = e5, t5;
            case bo:
              return (n8 = io(n8, e5.mode, t5)).return = e5, n8._debugInfo = Gc, n8;
            case _o:
              var r7 = on3(n8._debugInfo);
              return e5 = m2(e5, n8 = rn(n8), t5), Gc = r7, e5;
          }
          if (Uo(n8) || i4(n8)) return (t5 = oo(n8, e5.mode, t5, null)).return = e5, t5._debugOwner = e5, t5._debugTask = e5._debugTask, e5 = on3(n8._debugInfo), t5._debugInfo = Gc, Gc = e5, t5;
          if ("function" == typeof n8.then) return r7 = on3(n8._debugInfo), e5 = m2(e5, cn(n8), t5), Gc = r7, e5;
          if (n8.$$typeof === zo) return m2(e5, ge(e5, n8), t5);
          pn(e5, n8);
        }
        return "function" == typeof n8 && hn(e5, n8), "symbol" == typeof n8 && yn(e5, n8), null;
      }
      function h4(e5, n8, t5, r7) {
        var l4 = null !== n8 ? n8.key : null;
        if ("string" == typeof t5 && "" !== t5 || "number" == typeof t5 || "bigint" == typeof t5) return null !== l4 ? null : c5(e5, n8, "" + t5, r7);
        if ("object" == typeof t5 && null !== t5) {
          switch (t5.$$typeof) {
            case yo:
              return t5.key === l4 ? (l4 = on3(t5._debugInfo), e5 = d3(e5, n8, t5, r7), Gc = l4, e5) : null;
            case bo:
              return t5.key === l4 ? f4(e5, n8, t5, r7) : null;
            case _o:
              return l4 = on3(t5._debugInfo), e5 = h4(e5, n8, t5 = rn(t5), r7), Gc = l4, e5;
          }
          if (Uo(t5) || i4(t5)) return null !== l4 ? null : (l4 = on3(t5._debugInfo), e5 = p4(e5, n8, t5, r7, null), Gc = l4, e5);
          if ("function" == typeof t5.then) return l4 = on3(t5._debugInfo), e5 = h4(e5, n8, cn(t5), r7), Gc = l4, e5;
          if (t5.$$typeof === zo) return h4(e5, n8, ge(e5, t5), r7);
          pn(e5, t5);
        }
        return "function" == typeof t5 && hn(e5, t5), "symbol" == typeof t5 && yn(e5, t5), null;
      }
      function g4(e5, n8, t5, r7, l4) {
        if ("string" == typeof r7 && "" !== r7 || "number" == typeof r7 || "bigint" == typeof r7) return c5(n8, e5 = e5.get(t5) || null, "" + r7, l4);
        if ("object" == typeof r7 && null !== r7) {
          switch (r7.$$typeof) {
            case yo:
              return t5 = e5.get(null === r7.key ? t5 : r7.key) || null, e5 = on3(r7._debugInfo), n8 = d3(n8, t5, r7, l4), Gc = e5, n8;
            case bo:
              return f4(n8, e5 = e5.get(null === r7.key ? t5 : r7.key) || null, r7, l4);
            case _o:
              var a5 = on3(r7._debugInfo);
              return n8 = g4(e5, n8, t5, r7 = rn(r7), l4), Gc = a5, n8;
          }
          if (Uo(r7) || i4(r7)) return t5 = e5.get(t5) || null, e5 = on3(r7._debugInfo), n8 = p4(n8, t5, r7, l4, null), Gc = e5, n8;
          if ("function" == typeof r7.then) return a5 = on3(r7._debugInfo), n8 = g4(e5, n8, t5, cn(r7), l4), Gc = a5, n8;
          if (r7.$$typeof === zo) return g4(e5, n8, t5, ge(n8, r7), l4);
          pn(n8, r7);
        }
        return "function" == typeof r7 && hn(n8, r7), "symbol" == typeof r7 && yn(n8, r7), null;
      }
      function y4(e5, n8, t5, r7) {
        if ("object" != typeof t5 || null === t5) return r7;
        switch (t5.$$typeof) {
          case yo:
          case bo:
            a4(e5, n8, t5);
            var l4 = t5.key;
            if ("string" != typeof l4) break;
            if (null === r7) {
              (r7 = /* @__PURE__ */ new Set()).add(l4);
              break;
            }
            if (!r7.has(l4)) {
              r7.add(l4);
              break;
            }
            le(n8, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", l4);
            });
            break;
          case _o:
            y4(e5, n8, t5 = rn(t5), r7);
        }
        return r7;
      }
      function b4(t5, a5, c6, d4) {
        if ("object" == typeof c6 && null !== c6 && c6.type === vo && null === c6.key && (sn(c6, null, t5), c6 = c6.props.children), "object" == typeof c6 && null !== c6) {
          switch (c6.$$typeof) {
            case yo:
              var f5 = on3(c6._debugInfo);
              e: {
                for (var p5 = c6.key; null !== a5; ) {
                  if (a5.key === p5) {
                    if ((p5 = c6.type) === vo) {
                      if (7 === a5.tag) {
                        r6(t5, a5.sibling), (d4 = o3(a5, c6.props.children)).return = t5, d4._debugOwner = c6._owner, d4._debugInfo = Gc, sn(c6, d4, t5), t5 = d4;
                        break e;
                      }
                    } else if (a5.elementType === p5 || "object" == typeof p5 && null !== p5 && p5.$$typeof === _o && rn(p5) === a5.type) {
                      r6(t5, a5.sibling), dn(d4 = o3(a5, c6.props), c6), d4.return = t5, d4._debugOwner = c6._owner, d4._debugInfo = Gc, t5 = d4;
                      break e;
                    }
                    r6(t5, a5);
                    break;
                  }
                  n7(t5, a5), a5 = a5.sibling;
                }
                c6.type === vo ? ((d4 = oo(c6.props.children, t5.mode, d4, c6.key)).return = t5, d4._debugOwner = t5, d4._debugTask = t5._debugTask, d4._debugInfo = Gc, sn(c6, d4, t5), t5 = d4) : (dn(d4 = ao(c6, t5.mode, d4), c6), d4.return = t5, d4._debugInfo = Gc, t5 = d4);
              }
              return t5 = s3(t5), Gc = f5, t5;
            case bo:
              e: {
                for (c6 = (f5 = c6).key; null !== a5; ) {
                  if (a5.key === c6) {
                    if (4 === a5.tag && a5.stateNode.containerInfo === f5.containerInfo && a5.stateNode.implementation === f5.implementation) {
                      r6(t5, a5.sibling), (d4 = o3(a5, f5.children || [])).return = t5, t5 = d4;
                      break e;
                    }
                    r6(t5, a5);
                    break;
                  }
                  n7(t5, a5), a5 = a5.sibling;
                }
                (d4 = io(f5, t5.mode, d4)).return = t5, t5 = d4;
              }
              return s3(t5);
            case _o:
              return f5 = on3(c6._debugInfo), t5 = b4(t5, a5, c6 = rn(c6), d4), Gc = f5, t5;
          }
          if (Uo(c6)) return f5 = on3(c6._debugInfo), t5 = function(t6, a6, o4, i5) {
            for (var s4 = null, c7 = null, d5 = null, f6 = a6, p6 = a6 = 0, b5 = null; null !== f6 && p6 < o4.length; p6++) {
              f6.index > p6 ? (b5 = f6, f6 = null) : b5 = f6.sibling;
              var v5 = h4(t6, f6, o4[p6], i5);
              if (null === v5) {
                null === f6 && (f6 = b5);
                break;
              }
              s4 = y4(t6, v5, o4[p6], s4), e4 && f6 && null === v5.alternate && n7(t6, f6), a6 = u4(v5, a6, p6), null === d5 ? c7 = v5 : d5.sibling = v5, d5 = v5, f6 = b5;
            }
            if (p6 === o4.length) return r6(t6, f6), c7;
            if (null === f6) {
              for (; p6 < o4.length; p6++) null !== (f6 = m2(t6, o4[p6], i5)) && (s4 = y4(t6, f6, o4[p6], s4), a6 = u4(f6, a6, p6), null === d5 ? c7 = f6 : d5.sibling = f6, d5 = f6);
              return c7;
            }
            for (f6 = l3(f6); p6 < o4.length; p6++) null !== (b5 = g4(f6, t6, p6, o4[p6], i5)) && (s4 = y4(t6, b5, o4[p6], s4), e4 && null !== b5.alternate && f6.delete(null === b5.key ? p6 : b5.key), a6 = u4(b5, a6, p6), null === d5 ? c7 = b5 : d5.sibling = b5, d5 = b5);
            return e4 && f6.forEach(function(e5) {
              return n7(t6, e5);
            }), c7;
          }(t5, a5, c6, d4), Gc = f5, t5;
          if (i4(c6)) {
            if (f5 = on3(c6._debugInfo), "function" != typeof (p5 = i4(c6))) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var v4 = p5.call(c6);
            return v4 === c6 ? 0 === t5.tag && "[object GeneratorFunction]" === Object.prototype.toString.call(t5.type) && "[object Generator]" === Object.prototype.toString.call(v4) || (Jc || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), Jc = true) : c6.entries !== p5 || wc || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), wc = true), t5 = function(t6, a6, o4, i5) {
              if (null == o4) throw Error("An iterable object provided no iterator.");
              for (var s4 = null, c7 = null, d5 = a6, f6 = a6 = 0, p6 = null, b5 = null, v5 = o4.next(); null !== d5 && !v5.done; f6++, v5 = o4.next()) {
                d5.index > f6 ? (p6 = d5, d5 = null) : p6 = d5.sibling;
                var S4 = h4(t6, d5, v5.value, i5);
                if (null === S4) {
                  null === d5 && (d5 = p6);
                  break;
                }
                b5 = y4(t6, S4, v5.value, b5), e4 && d5 && null === S4.alternate && n7(t6, d5), a6 = u4(S4, a6, f6), null === c7 ? s4 = S4 : c7.sibling = S4, c7 = S4, d5 = p6;
              }
              if (v5.done) return r6(t6, d5), s4;
              if (null === d5) {
                for (; !v5.done; f6++, v5 = o4.next()) null !== (d5 = m2(t6, v5.value, i5)) && (b5 = y4(t6, d5, v5.value, b5), a6 = u4(d5, a6, f6), null === c7 ? s4 = d5 : c7.sibling = d5, c7 = d5);
                return s4;
              }
              for (d5 = l3(d5); !v5.done; f6++, v5 = o4.next()) null !== (p6 = g4(d5, t6, f6, v5.value, i5)) && (b5 = y4(t6, p6, v5.value, b5), e4 && null !== p6.alternate && d5.delete(null === p6.key ? f6 : p6.key), a6 = u4(p6, a6, f6), null === c7 ? s4 = p6 : c7.sibling = p6, c7 = p6);
              return e4 && d5.forEach(function(e5) {
                return n7(t6, e5);
              }), s4;
            }(t5, a5, v4, d4), Gc = f5, t5;
          }
          if ("function" == typeof c6.then) return f5 = on3(c6._debugInfo), t5 = b4(t5, a5, cn(c6), d4), Gc = f5, t5;
          if (c6.$$typeof === zo) return b4(t5, a5, ge(t5, c6), d4);
          pn(t5, c6);
        }
        return "string" == typeof c6 && "" !== c6 || "number" == typeof c6 || "bigint" == typeof c6 ? (f5 = "" + c6, null !== a5 && 6 === a5.tag ? (r6(t5, a5.sibling), (d4 = o3(a5, f5)).return = t5, t5 = d4) : (r6(t5, a5), (d4 = uo(f5, t5.mode, d4)).return = t5, d4._debugOwner = t5, d4._debugTask = t5._debugTask, d4._debugInfo = Gc, t5 = d4), s3(t5)) : ("function" == typeof c6 && hn(t5, c6), "symbol" == typeof c6 && yn(t5, c6), r6(t5, a5));
      }
      return function(e5, n8, r7, l4) {
        var a5 = Gc;
        Gc = null;
        try {
          Yc = 0;
          var o4 = b4(e5, n8, r7, l4);
          return qc = null, o4;
        } catch (n9) {
          if (n9 === Mc || n9 === Qc) throw n9;
          var u5 = t4(29, n9, null, e5.mode);
          u5.lanes = l4, u5.return = e5;
          var i5 = u5._debugInfo = Gc;
          if (u5._debugOwner = e5._debugOwner, u5._debugTask = e5._debugTask, null != i5) {
            for (var s4 = i5.length - 1; 0 <= s4; s4--) if ("string" == typeof i5[s4].stack) {
              u5._debugOwner = i5[s4], u5._debugTask = i5[s4].debugTask;
              break;
            }
          }
          return u5;
        } finally {
          Gc = a5;
        }
      };
    }
    function vn(e4, n7) {
      var t5 = Uo(e4);
      return e4 = !t5 && "function" == typeof i4(e4), !t5 && !e4 || (t5 = t5 ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", t5, n7, t5), false);
    }
    function Sn() {
      for (var e4 = od, n7 = ud = od = 0; n7 < e4; ) {
        var t5 = ad[n7];
        ad[n7++] = null;
        var r6 = ad[n7];
        ad[n7++] = null;
        var l3 = ad[n7];
        ad[n7++] = null;
        var a5 = ad[n7];
        if (ad[n7++] = null, null !== r6 && null !== l3) {
          var o3 = r6.pending;
          null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r6.pending = l3;
        }
        0 !== a5 && xn(t5, l3, a5);
      }
    }
    function kn(e4, n7, t5, r6) {
      ad[od++] = e4, ad[od++] = n7, ad[od++] = t5, ad[od++] = r6, ud |= r6, e4.lanes |= r6, null !== (e4 = e4.alternate) && (e4.lanes |= r6);
    }
    function wn(e4, n7, t5, r6) {
      return kn(e4, n7, t5, r6), En(e4);
    }
    function zn(e4, n7) {
      return kn(e4, null, null, n7), En(e4);
    }
    function xn(e4, n7, t5) {
      e4.lanes |= t5;
      var r6 = e4.alternate;
      null !== r6 && (r6.lanes |= t5);
      for (var l3 = false, a5 = e4.return; null !== a5; ) a5.childLanes |= t5, null !== (r6 = a5.alternate) && (r6.childLanes |= t5), 22 === a5.tag && (null === (e4 = a5.stateNode) || e4._visibility & rd || (l3 = true)), e4 = a5, a5 = a5.return;
      return 3 === e4.tag ? (a5 = e4.stateNode, l3 && null !== n7 && (l3 = 31 - Yu(t5), null === (r6 = (e4 = a5.hiddenUpdates)[l3]) ? e4[l3] = [n7] : r6.push(n7), n7.lane = 536870912 | t5), a5) : null;
    }
    function En(e4) {
      if (rm > tm) throw im = rm = 0, sm = lm = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      im > um && (im = 0, sm = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")), null === e4.alternate && 0 != (4098 & e4.flags) && Xa(e4);
      for (var n7 = e4, t5 = n7.return; null !== t5; ) null === n7.alternate && 0 != (4098 & n7.flags) && Xa(e4), t5 = (n7 = t5).return;
      return 3 === n7.tag ? n7.stateNode : null;
    }
    function Cn(e4) {
      e4.updateQueue = { baseState: e4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
    }
    function Pn(e4, n7) {
      e4 = e4.updateQueue, n7.updateQueue === e4 && (n7.updateQueue = { baseState: e4.baseState, firstBaseUpdate: e4.firstBaseUpdate, lastBaseUpdate: e4.lastBaseUpdate, shared: e4.shared, callbacks: null });
    }
    function _n(e4) {
      return { lane: e4, tag: id, payload: null, callback: null, next: null };
    }
    function Tn(e4, n7, t5) {
      var r6 = e4.updateQueue;
      if (null === r6) return null;
      if (r6 = r6.shared, md === r6 && !pd) {
        var l3 = c4(e4);
        console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", l3), pd = true;
      }
      return (Xf & Qf) !== Wf ? (null === (l3 = r6.pending) ? n7.next = n7 : (n7.next = l3.next, l3.next = n7), r6.pending = n7, n7 = En(e4), xn(e4, null, t5), n7) : (kn(e4, r6, n7, t5), En(e4));
    }
    function Rn(e4, n7, t5) {
      if (null !== (n7 = n7.updateQueue) && (n7 = n7.shared, 0 != (4194048 & t5))) {
        var r6 = n7.lanes;
        t5 |= r6 &= e4.pendingLanes, n7.lanes = t5, w(e4, t5);
      }
    }
    function Nn(e4, n7) {
      var t5 = e4.updateQueue, r6 = e4.alternate;
      if (null !== r6 && t5 === (r6 = r6.updateQueue)) {
        var l3 = null, a5 = null;
        if (null !== (t5 = t5.firstBaseUpdate)) {
          do {
            var o3 = { lane: t5.lane, tag: t5.tag, payload: t5.payload, callback: null, next: null };
            null === a5 ? l3 = a5 = o3 : a5 = a5.next = o3, t5 = t5.next;
          } while (null !== t5);
          null === a5 ? l3 = a5 = n7 : a5 = a5.next = n7;
        } else l3 = a5 = n7;
        return t5 = { baseState: r6.baseState, firstBaseUpdate: l3, lastBaseUpdate: a5, shared: r6.shared, callbacks: r6.callbacks }, void (e4.updateQueue = t5);
      }
      null === (e4 = t5.lastBaseUpdate) ? t5.firstBaseUpdate = n7 : e4.next = n7, t5.lastBaseUpdate = n7;
    }
    function Ln() {
      if (hd && null !== sc) throw sc;
    }
    function Un(e4, n7, t5, r6) {
      hd = false;
      var l3 = e4.updateQueue;
      fd = false, md = l3.shared;
      var a5 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u4 = l3.shared.pending;
      if (null !== u4) {
        l3.shared.pending = null;
        var i5 = u4, s3 = i5.next;
        i5.next = null, null === o3 ? a5 = s3 : o3.next = s3, o3 = i5;
        var c5 = e4.alternate;
        null !== c5 && (u4 = (c5 = c5.updateQueue).lastBaseUpdate) !== o3 && (null === u4 ? c5.firstBaseUpdate = s3 : u4.next = s3, c5.lastBaseUpdate = i5);
      }
      if (null !== a5) {
        var d3 = l3.baseState;
        for (o3 = 0, c5 = s3 = i5 = null, u4 = a5; ; ) {
          var f4 = -536870913 & u4.lane, p4 = f4 !== u4.lane;
          if (p4 ? (np & f4) === f4 : (r6 & f4) === f4) {
            0 !== f4 && f4 === ic && (hd = true), null !== c5 && (c5 = c5.next = { lane: 0, tag: u4.tag, payload: u4.payload, callback: null, next: null });
            e: {
              f4 = e4;
              var m2 = u4, h4 = n7, g4 = t5;
              switch (m2.tag) {
                case sd:
                  if ("function" == typeof (m2 = m2.payload)) {
                    is = true;
                    var y4 = m2.call(g4, d3, h4);
                    if (8 & f4.mode) {
                      P(true);
                      try {
                        m2.call(g4, d3, h4);
                      } finally {
                        P(false);
                      }
                    }
                    is = false, d3 = y4;
                    break e;
                  }
                  d3 = m2;
                  break e;
                case dd:
                  f4.flags = -65537 & f4.flags | 128;
                case id:
                  if ("function" == typeof (y4 = m2.payload)) {
                    if (is = true, m2 = y4.call(g4, d3, h4), 8 & f4.mode) {
                      P(true);
                      try {
                        y4.call(g4, d3, h4);
                      } finally {
                        P(false);
                      }
                    }
                    is = false;
                  } else m2 = y4;
                  if (null == m2) break e;
                  d3 = ho({}, d3, m2);
                  break e;
                case cd:
                  fd = true;
              }
            }
            null !== (f4 = u4.callback) && (e4.flags |= 64, p4 && (e4.flags |= 8192), null === (p4 = l3.callbacks) ? l3.callbacks = [f4] : p4.push(f4));
          } else p4 = { lane: f4, tag: u4.tag, payload: u4.payload, callback: u4.callback, next: null }, null === c5 ? (s3 = c5 = p4, i5 = d3) : c5 = c5.next = p4, o3 |= f4;
          if (null === (u4 = u4.next)) {
            if (null === (u4 = l3.shared.pending)) break;
            u4 = (p4 = u4).next, p4.next = null, l3.lastBaseUpdate = p4, l3.shared.pending = null;
          }
        }
        null === c5 && (i5 = d3), l3.baseState = i5, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c5, null === a5 && (l3.shared.lanes = 0), vp |= o3, e4.lanes = o3, e4.memoizedState = d3;
      }
      md = null;
    }
    function Dn(e4, n7) {
      if ("function" != typeof e4) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + e4);
      e4.call(n7);
    }
    function In(e4, n7) {
      var t5 = e4.shared.hiddenCallbacks;
      if (null !== t5) for (e4.shared.hiddenCallbacks = null, e4 = 0; e4 < t5.length; e4++) Dn(t5[e4], n7);
    }
    function Fn(e4, n7) {
      var t5 = e4.callbacks;
      if (null !== t5) for (e4.callbacks = null, e4 = 0; e4 < t5.length; e4++) Dn(t5[e4], n7);
    }
    function jn(e4, n7) {
      var t5 = yp;
      p3(yd, t5, e4), p3(gd, n7, e4), yp = t5 | n7.baseLanes;
    }
    function An(e4) {
      p3(yd, yp, e4), p3(gd, gd.current, e4);
    }
    function Hn(e4) {
      yp = yd.current, f3(gd, e4), f3(yd, e4);
    }
    function On(e4) {
      var n7 = e4.alternate;
      p3(wd, wd.current & Sd, e4), p3(bd, e4, e4), null === vd && (null === n7 || null !== gd.current || null !== n7.memoizedState) && (vd = e4);
    }
    function Mn(e4) {
      p3(wd, wd.current, e4), p3(bd, e4, e4), null === vd && (vd = e4);
    }
    function Wn(e4) {
      22 === e4.tag ? (p3(wd, wd.current, e4), p3(bd, e4, e4), null === vd && (vd = e4)) : Qn(e4);
    }
    function Qn(e4) {
      p3(wd, wd.current, e4), p3(bd, bd.current, e4);
    }
    function Bn(e4) {
      f3(bd, e4), vd === e4 && (vd = null), f3(wd, e4);
    }
    function $n(e4) {
      for (var n7 = e4; null !== n7; ) {
        if (13 === n7.tag) {
          var t5 = n7.memoizedState;
          if (null !== t5 && (null === (t5 = t5.dehydrated) || Nu(t5) || Lu(t5))) return n7;
        } else if (19 !== n7.tag || "forwards" !== n7.memoizedProps.revealOrder && "backwards" !== n7.memoizedProps.revealOrder && "unstable_legacy-backwards" !== n7.memoizedProps.revealOrder && "together" !== n7.memoizedProps.revealOrder) {
          if (null !== n7.child) {
            n7.child.return = n7, n7 = n7.child;
            continue;
          }
        } else if (0 != (128 & n7.flags)) return n7;
        if (n7 === e4) break;
        for (; null === n7.sibling; ) {
          if (null === n7.return || n7.return === e4) return null;
          n7 = n7.return;
        }
        n7.sibling.return = n7.return, n7 = n7.sibling;
      }
      return null;
    }
    function Vn() {
      var e4 = Bd;
      null === $d ? $d = [e4] : $d.push(e4);
    }
    function qn() {
      var e4 = Bd;
      if (null !== $d && (Vd++, $d[Vd] !== e4)) {
        var n7 = c4(Ud);
        if (!_d.has(n7) && (_d.add(n7), null !== $d)) {
          for (var t5 = "", r6 = 0; r6 <= Vd; r6++) {
            var l3 = $d[r6], a5 = r6 === Vd ? e4 : l3;
            for (l3 = r6 + 1 + ". " + l3; 30 > l3.length; ) l3 += " ";
            t5 += l3 += a5 + "\n";
          }
          console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", n7, t5);
        }
      }
    }
    function Yn(e4) {
      null == e4 || Uo(e4) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Bd, typeof e4);
    }
    function Gn() {
      var e4 = c4(Ud);
      Nd.has(e4) || (Nd.add(e4), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", e4));
    }
    function Jn() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function Kn(e4, n7) {
      if (qd) return false;
      if (null === n7) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Bd), false;
      e4.length !== n7.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", Bd, "[" + n7.join(", ") + "]", "[" + e4.join(", ") + "]");
      for (var t5 = 0; t5 < n7.length && t5 < e4.length; t5++) if (!yi(e4[t5], n7[t5])) return false;
      return true;
    }
    function Xn(e4, n7, t5, r6, l3, a5) {
      Ld = a5, Ud = n7, $d = null !== e4 ? e4._debugHookTypes : null, Vd = -1, qd = null !== e4 && e4.type !== n7.type, "[object AsyncFunction]" !== Object.prototype.toString.call(t5) && "[object AsyncGeneratorFunction]" !== Object.prototype.toString.call(t5) || (a5 = c4(Ud), Rd.has(a5) || (Rd.add(a5), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", null === a5 ? "An unknown Component" : "<" + a5 + ">"))), n7.memoizedState = null, n7.updateQueue = null, n7.lanes = 0, Do.H = null !== e4 && null !== e4.memoizedState ? Kd : null !== $d ? Jd : Gd, Ad = a5 = (8 & n7.mode) !== ts;
      var o3 = xc(t5, r6, l3);
      if (Ad = false, jd && (o3 = et(n7, t5, r6, l3)), a5) {
        P(true);
        try {
          o3 = et(n7, t5, r6, l3);
        } finally {
          P(false);
        }
      }
      return Zn(e4, n7), o3;
    }
    function Zn(e4, n7) {
      n7._debugHookTypes = $d, null === n7.dependencies ? null !== Md && (n7.dependencies = { lanes: 0, firstContext: null, _debugThenableState: Md }) : n7.dependencies._debugThenableState = Md, Do.H = Yd;
      var t5 = null !== Dd && null !== Dd.next;
      if (Ld = 0, $d = Bd = Id = Dd = Ud = null, Vd = -1, null !== e4 && (65011712 & e4.flags) != (65011712 & n7.flags) && console.error("Internal React error: Expected static flag was missing. Please notify the React team."), Fd = false, Od = 0, Md = null, t5) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      null === e4 || gf || null !== (e4 = e4.dependencies) && pe(e4) && (gf = true), Vc ? (Vc = false, e4 = true) : e4 = false, e4 && (n7 = c4(n7) || "Unknown", Td.has(n7) || Rd.has(n7) || (Td.add(n7), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function et(e4, n7, t5, r6) {
      Ud = e4;
      var l3 = 0;
      do {
        if (jd && (Md = null), Od = 0, jd = false, l3 >= Qd) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (l3 += 1, qd = false, Id = Dd = null, null != e4.updateQueue) {
          var a5 = e4.updateQueue;
          a5.lastEffect = null, a5.events = null, a5.stores = null, null != a5.memoCache && (a5.memoCache.index = 0);
        }
        Vd = -1, Do.H = Xd, a5 = xc(n7, t5, r6);
      } while (jd);
      return a5;
    }
    function nt() {
      var e4 = Do.H, n7 = e4.useState()[0];
      return n7 = "function" == typeof n7.then ? ut(n7) : n7, e4 = e4.useState()[0], (null !== Dd ? Dd.memoizedState : null) !== e4 && (Ud.flags |= 1024), n7;
    }
    function tt() {
      var e4 = 0 !== Hd;
      return Hd = 0, e4;
    }
    function rt(e4, n7, t5) {
      n7.updateQueue = e4.updateQueue, n7.flags = (16 & n7.mode) !== ts ? -402655237 & n7.flags : -2053 & n7.flags, e4.lanes &= ~t5;
    }
    function lt(e4) {
      if (Fd) {
        for (e4 = e4.memoizedState; null !== e4; ) {
          var n7 = e4.queue;
          null !== n7 && (n7.pending = null), e4 = e4.next;
        }
        Fd = false;
      }
      Ld = 0, $d = Id = Dd = Ud = null, Vd = -1, Bd = null, jd = false, Od = Hd = 0, Md = null;
    }
    function at() {
      var e4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return null === Id ? Ud.memoizedState = Id = e4 : Id = Id.next = e4, Id;
    }
    function ot() {
      if (null === Dd) {
        var e4 = Ud.alternate;
        e4 = null !== e4 ? e4.memoizedState : null;
      } else e4 = Dd.next;
      var n7 = null === Id ? Ud.memoizedState : Id.next;
      if (null !== n7) Id = n7, Dd = e4;
      else {
        if (null === e4) {
          if (null === Ud.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        e4 = { memoizedState: (Dd = e4).memoizedState, baseState: Dd.baseState, baseQueue: Dd.baseQueue, queue: Dd.queue, next: null }, null === Id ? Ud.memoizedState = Id = e4 : Id = Id.next = e4;
      }
      return Id;
    }
    function ut(e4) {
      var n7 = Od;
      return Od += 1, null === Md && (Md = { didWarnAboutUncachedPromise: false, thenables: [] }), e4 = tn(Md, e4, n7), n7 = Ud, null === (null === Id ? n7.memoizedState : Id.next) && (n7 = n7.alternate, Do.H = null !== n7 && null !== n7.memoizedState ? Kd : Gd), e4;
    }
    function it(e4) {
      if (null !== e4 && "object" == typeof e4) {
        if ("function" == typeof e4.then) return ut(e4);
        if (e4.$$typeof === zo) return he(e4);
      }
      throw Error("An unsupported type was passed to use(): " + String(e4));
    }
    function st(e4) {
      var n7 = null, t5 = Ud.updateQueue;
      if (null !== t5 && (n7 = t5.memoCache), null == n7) {
        var r6 = Ud.alternate;
        null !== r6 && null !== (r6 = r6.updateQueue) && null != (r6 = r6.memoCache) && (n7 = { data: r6.data.map(function(e5) {
          return e5.slice();
        }), index: 0 });
      }
      if (null == n7 && (n7 = { data: [], index: 0 }), null === t5 && (t5 = { lastEffect: null, events: null, stores: null, memoCache: null }, Ud.updateQueue = t5), t5.memoCache = n7, void 0 === (t5 = n7.data[n7.index]) || qd) for (t5 = n7.data[n7.index] = Array(e4), r6 = 0; r6 < e4; r6++) t5[r6] = Ro;
      else t5.length !== e4 && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", t5.length, e4);
      return n7.index++, t5;
    }
    function ct(e4, n7) {
      return "function" == typeof n7 ? n7(e4) : n7;
    }
    function dt(e4, n7, t5) {
      var r6 = at();
      if (void 0 !== t5) {
        var l3 = t5(n7);
        if (Ad) {
          P(true);
          try {
            t5(n7);
          } finally {
            P(false);
          }
        }
      } else l3 = n7;
      return r6.memoizedState = r6.baseState = l3, e4 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e4, lastRenderedState: l3 }, r6.queue = e4, e4 = e4.dispatch = hr.bind(null, Ud, e4), [r6.memoizedState, e4];
    }
    function ft(e4) {
      return pt(ot(), Dd, e4);
    }
    function pt(e4, n7, t5) {
      var r6 = e4.queue;
      if (null === r6) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      r6.lastRenderedReducer = t5;
      var l3 = e4.baseQueue, a5 = r6.pending;
      if (null !== a5) {
        if (null !== l3) {
          var o3 = l3.next;
          l3.next = a5.next, a5.next = o3;
        }
        n7.baseQueue !== l3 && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), n7.baseQueue = l3 = a5, r6.pending = null;
      }
      if (a5 = e4.baseState, null === l3) e4.memoizedState = a5;
      else {
        var u4 = o3 = null, i5 = null, s3 = n7 = l3.next, c5 = false;
        do {
          var d3 = -536870913 & s3.lane;
          if (d3 !== s3.lane ? (np & d3) === d3 : (Ld & d3) === d3) {
            var f4 = s3.revertLane;
            if (0 === f4) null !== i5 && (i5 = i5.next = { lane: 0, revertLane: 0, gesture: null, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }), d3 === ic && (c5 = true);
            else {
              if ((Ld & f4) === f4) {
                s3 = s3.next, f4 === ic && (c5 = true);
                continue;
              }
              d3 = { lane: 0, revertLane: s3.revertLane, gesture: null, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i5 ? (u4 = i5 = d3, o3 = a5) : i5 = i5.next = d3, Ud.lanes |= f4, vp |= f4;
            }
            d3 = s3.action, Ad && t5(a5, d3), a5 = s3.hasEagerState ? s3.eagerState : t5(a5, d3);
          } else f4 = { lane: d3, revertLane: s3.revertLane, gesture: s3.gesture, action: s3.action, hasEagerState: s3.hasEagerState, eagerState: s3.eagerState, next: null }, null === i5 ? (u4 = i5 = f4, o3 = a5) : i5 = i5.next = f4, Ud.lanes |= d3, vp |= d3;
          s3 = s3.next;
        } while (null !== s3 && s3 !== n7);
        if (null === i5 ? o3 = a5 : i5.next = u4, !yi(a5, e4.memoizedState) && (gf = true, c5 && null !== (t5 = sc))) throw t5;
        e4.memoizedState = a5, e4.baseState = o3, e4.baseQueue = i5, r6.lastRenderedState = a5;
      }
      return null === l3 && (r6.lanes = 0), [e4.memoizedState, r6.dispatch];
    }
    function mt(e4) {
      var n7 = ot(), t5 = n7.queue;
      if (null === t5) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      t5.lastRenderedReducer = e4;
      var r6 = t5.dispatch, l3 = t5.pending, a5 = n7.memoizedState;
      if (null !== l3) {
        t5.pending = null;
        var o3 = l3 = l3.next;
        do {
          a5 = e4(a5, o3.action), o3 = o3.next;
        } while (o3 !== l3);
        yi(a5, n7.memoizedState) || (gf = true), n7.memoizedState = a5, null === n7.baseQueue && (n7.baseState = a5), t5.lastRenderedState = a5;
      }
      return [a5, r6];
    }
    function ht(e4, n7, t5) {
      var r6, l3 = Ud, a5 = at();
      if (r6 = n7(), ed || (t5 = n7(), yi(r6, t5) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), ed = true)), null === Zf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      return 0 != (127 & np) || yt(l3, n7, r6), a5.memoizedState = r6, t5 = { value: r6, getSnapshot: n7 }, a5.queue = t5, Bt(vt.bind(null, l3, t5, e4), [e4]), l3.flags |= 2048, Ot(xd | Pd, { destroy: void 0 }, bt.bind(null, l3, t5, r6, n7), null), r6;
    }
    function gt(e4, n7, t5) {
      var r6 = Ud, l3 = ot();
      if (t5 = n7(), !ed) {
        var a5 = n7();
        yi(t5, a5) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), ed = true);
      }
      (a5 = !yi((Dd || l3).memoizedState, t5)) && (l3.memoizedState = t5, gf = true), l3 = l3.queue;
      var o3 = vt.bind(null, r6, l3, e4);
      if (Qt(2048, Pd, o3, [e4]), l3.getSnapshot !== n7 || a5 || null !== Id && Id.memoizedState.tag & xd) {
        if (r6.flags |= 2048, Ot(xd | Pd, { destroy: void 0 }, bt.bind(null, r6, l3, t5, n7), null), null === Zf) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        0 != (127 & Ld) || yt(r6, n7, t5);
      }
      return t5;
    }
    function yt(e4, n7, t5) {
      e4.flags |= 16384, e4 = { getSnapshot: n7, value: t5 }, null === (n7 = Ud.updateQueue) ? (n7 = { lastEffect: null, events: null, stores: null, memoCache: null }, Ud.updateQueue = n7, n7.stores = [e4]) : null === (t5 = n7.stores) ? n7.stores = [e4] : t5.push(e4);
    }
    function bt(e4, n7, t5, r6) {
      n7.value = t5, n7.getSnapshot = r6, St(n7) && kt(e4);
    }
    function vt(e4, n7, t5) {
      return t5(function() {
        St(n7) && (ke(2, "updateSyncExternalStore()", e4), kt(e4));
      });
    }
    function St(e4) {
      var n7 = e4.getSnapshot;
      e4 = e4.value;
      try {
        var t5 = n7();
        return !yi(e4, t5);
      } catch (e5) {
        return true;
      }
    }
    function kt(e4) {
      var n7 = zn(e4, 2);
      null !== n7 && pa(n7, e4, 2);
    }
    function wt(e4) {
      var n7 = at();
      if ("function" == typeof e4) {
        var t5 = e4;
        if (e4 = t5(), Ad) {
          P(true);
          try {
            t5();
          } finally {
            P(false);
          }
        }
      }
      return n7.memoizedState = n7.baseState = e4, n7.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ct, lastRenderedState: e4 }, n7;
    }
    function zt(e4) {
      var n7 = (e4 = wt(e4)).queue, t5 = gr.bind(null, Ud, n7);
      return n7.dispatch = t5, [e4.memoizedState, t5];
    }
    function xt(e4) {
      var n7 = at();
      n7.memoizedState = n7.baseState = e4;
      var t5 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
      return n7.queue = t5, n7 = br.bind(null, Ud, true, t5), t5.dispatch = n7, [e4, n7];
    }
    function Et(e4, n7) {
      return Ct(ot(), 0, e4, n7);
    }
    function Ct(e4, n7, t5, r6) {
      return e4.baseState = t5, pt(e4, Dd, "function" == typeof r6 ? r6 : ct);
    }
    function Pt(e4, n7) {
      var t5 = ot();
      return null !== Dd ? Ct(t5, 0, e4, n7) : (t5.baseState = e4, [e4, t5.queue.dispatch]);
    }
    function _t(e4, n7, t5, r6, l3) {
      if (vr(e4)) throw Error("Cannot update form state while rendering.");
      if (null !== (e4 = n7.action)) {
        var a5 = { payload: l3, action: e4, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e5) {
          a5.listeners.push(e5);
        } };
        null !== Do.T ? t5(true) : a5.isTransition = false, r6(a5), null === (t5 = n7.pending) ? (a5.next = n7.pending = a5, Tt(n7, a5)) : (a5.next = t5.next, n7.pending = t5.next = a5);
      }
    }
    function Tt(e4, n7) {
      var t5 = n7.action, r6 = n7.payload, l3 = e4.state;
      if (n7.isTransition) {
        var a5 = Do.T, o3 = {};
        o3._updatedFibers = /* @__PURE__ */ new Set(), Do.T = o3;
        try {
          var u4 = t5(l3, r6), i5 = Do.S;
          null !== i5 && i5(o3, u4), Rt(e4, n7, u4);
        } catch (t6) {
          Lt(e4, n7, t6);
        } finally {
          null !== a5 && null !== o3.types && (null !== a5.types && a5.types !== o3.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), a5.types = o3.types), Do.T = a5, null === a5 && o3._updatedFibers && (e4 = o3._updatedFibers.size, o3._updatedFibers.clear(), 10 < e4 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else try {
        Rt(e4, n7, o3 = t5(l3, r6));
      } catch (t6) {
        Lt(e4, n7, t6);
      }
    }
    function Rt(e4, n7, t5) {
      null !== t5 && "object" == typeof t5 && "function" == typeof t5.then ? (Do.asyncTransitions++, t5.then(or, or), t5.then(function(t6) {
        Nt(e4, n7, t6);
      }, function(t6) {
        return Lt(e4, n7, t6);
      }), n7.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : Nt(e4, n7, t5);
    }
    function Nt(e4, n7, t5) {
      n7.status = "fulfilled", n7.value = t5, Ut(n7), e4.state = t5, null !== (n7 = e4.pending) && ((t5 = n7.next) === n7 ? e4.pending = null : (t5 = t5.next, n7.next = t5, Tt(e4, t5)));
    }
    function Lt(e4, n7, t5) {
      var r6 = e4.pending;
      if (e4.pending = null, null !== r6) {
        r6 = r6.next;
        do {
          n7.status = "rejected", n7.reason = t5, Ut(n7), n7 = n7.next;
        } while (n7 !== r6);
      }
      e4.action = null;
    }
    function Ut(e4) {
      e4 = e4.listeners;
      for (var n7 = 0; n7 < e4.length; n7++) (0, e4[n7])();
    }
    function Dt(e4, n7) {
      return n7;
    }
    function It(e4, n7) {
      var t5, r6, l3;
      (t5 = at()).memoizedState = t5.baseState = n7, r6 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Dt, lastRenderedState: n7 }, t5.queue = r6, t5 = gr.bind(null, Ud, r6), r6.dispatch = t5, r6 = wt(false);
      var a5 = br.bind(null, Ud, false, r6.queue);
      return l3 = { state: n7, dispatch: null, action: e4, pending: null }, (r6 = at()).queue = l3, t5 = _t.bind(null, Ud, l3, a5, t5), l3.dispatch = t5, r6.memoizedState = e4, [n7, t5, false];
    }
    function Ft(e4) {
      return jt(ot(), Dd, e4);
    }
    function jt(e4, n7, t5) {
      if (n7 = pt(e4, n7, Dt)[0], e4 = ft(ct)[0], "object" == typeof n7 && null !== n7 && "function" == typeof n7.then) try {
        var r6 = ut(n7);
      } catch (e5) {
        if (e5 === Mc) throw Qc;
        throw e5;
      }
      else r6 = n7;
      var l3 = (n7 = ot()).queue, a5 = l3.dispatch;
      return t5 !== n7.memoizedState && (Ud.flags |= 2048, Ot(xd | Pd, { destroy: void 0 }, At.bind(null, l3, t5), null)), [r6, a5, e4];
    }
    function At(e4, n7) {
      e4.action = n7;
    }
    function Ht(e4) {
      var n7 = ot(), t5 = Dd;
      if (null !== t5) return jt(n7, t5, e4);
      ot(), n7 = n7.memoizedState;
      var r6 = (t5 = ot()).queue.dispatch;
      return t5.memoizedState = e4, [n7, r6, false];
    }
    function Ot(e4, n7, t5, r6) {
      return e4 = { tag: e4, create: t5, deps: r6, inst: n7, next: null }, null === (n7 = Ud.updateQueue) && (n7 = { lastEffect: null, events: null, stores: null, memoCache: null }, Ud.updateQueue = n7), null === (t5 = n7.lastEffect) ? n7.lastEffect = e4.next = e4 : (r6 = t5.next, t5.next = e4, e4.next = r6, n7.lastEffect = e4), e4;
    }
    function Mt(e4) {
      return e4 = { current: e4 }, at().memoizedState = e4;
    }
    function Wt(e4, n7, t5, r6) {
      var l3 = at();
      Ud.flags |= e4, l3.memoizedState = Ot(xd | n7, { destroy: void 0 }, t5, void 0 === r6 ? null : r6);
    }
    function Qt(e4, n7, t5, r6) {
      var l3 = ot();
      r6 = void 0 === r6 ? null : r6;
      var a5 = l3.memoizedState.inst;
      null !== Dd && null !== r6 && Kn(r6, Dd.memoizedState.deps) ? l3.memoizedState = Ot(n7, a5, t5, r6) : (Ud.flags |= e4, l3.memoizedState = Ot(xd | n7, a5, t5, r6));
    }
    function Bt(e4, n7) {
      (16 & Ud.mode) !== ts ? Wt(276826112, Pd, e4, n7) : Wt(8390656, Pd, e4, n7);
    }
    function $t(e4) {
      var n7 = at(), t5 = { impl: e4 };
      return n7.memoizedState = t5, function() {
        if ((Xf & Qf) !== Wf) throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return t5.impl.apply(void 0, arguments);
      };
    }
    function Vt(e4) {
      var n7 = ot().memoizedState;
      return function(e5) {
        Ud.flags |= 4;
        var n8 = Ud.updateQueue;
        if (null === n8) n8 = { lastEffect: null, events: null, stores: null, memoCache: null }, Ud.updateQueue = n8, n8.events = [e5];
        else {
          var t5 = n8.events;
          null === t5 ? n8.events = [e5] : t5.push(e5);
        }
      }({ ref: n7, nextImpl: e4 }), function() {
        if ((Xf & Qf) !== Wf) throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return n7.impl.apply(void 0, arguments);
      };
    }
    function qt(e4, n7) {
      var t5 = 4194308;
      return (16 & Ud.mode) !== ts && (t5 |= 134217728), Wt(t5, Cd, e4, n7);
    }
    function Yt(e4, n7) {
      if ("function" == typeof n7) {
        e4 = e4();
        var t5 = n7(e4);
        return function() {
          "function" == typeof t5 ? t5() : n7(null);
        };
      }
      if (null != n7) return n7.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(n7).join(", ") + "}"), e4 = e4(), n7.current = e4, function() {
        n7.current = null;
      };
    }
    function Gt(e4, n7, t5) {
      "function" != typeof n7 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n7 ? typeof n7 : "null"), t5 = null != t5 ? t5.concat([e4]) : null;
      var r6 = 4194308;
      (16 & Ud.mode) !== ts && (r6 |= 134217728), Wt(r6, Cd, Yt.bind(null, n7, e4), t5);
    }
    function Jt(e4, n7, t5) {
      "function" != typeof n7 && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== n7 ? typeof n7 : "null"), t5 = null != t5 ? t5.concat([e4]) : null, Qt(4, Cd, Yt.bind(null, n7, e4), t5);
    }
    function Kt(e4, n7) {
      return at().memoizedState = [e4, void 0 === n7 ? null : n7], e4;
    }
    function Xt(e4, n7) {
      var t5 = ot();
      n7 = void 0 === n7 ? null : n7;
      var r6 = t5.memoizedState;
      return null !== n7 && Kn(n7, r6[1]) ? r6[0] : (t5.memoizedState = [e4, n7], e4);
    }
    function Zt(e4, n7) {
      var t5 = at();
      n7 = void 0 === n7 ? null : n7;
      var r6 = e4();
      if (Ad) {
        P(true);
        try {
          e4();
        } finally {
          P(false);
        }
      }
      return t5.memoizedState = [r6, n7], r6;
    }
    function er(e4, n7) {
      var t5 = ot();
      n7 = void 0 === n7 ? null : n7;
      var r6 = t5.memoizedState;
      if (null !== n7 && Kn(n7, r6[1])) return r6[0];
      if (r6 = e4(), Ad) {
        P(true);
        try {
          e4();
        } finally {
          P(false);
        }
      }
      return t5.memoizedState = [r6, n7], r6;
    }
    function nr(e4, n7) {
      return lr(at(), e4, n7);
    }
    function tr(e4, n7) {
      return ar(ot(), Dd.memoizedState, e4, n7);
    }
    function rr(e4, n7) {
      var t5 = ot();
      return null === Dd ? lr(t5, e4, n7) : ar(t5, Dd.memoizedState, e4, n7);
    }
    function lr(e4, n7, t5) {
      return void 0 === t5 || 0 != (1073741824 & Ld) && 0 == (261930 & np) ? e4.memoizedState = n7 : (e4.memoizedState = t5, e4 = fa(), Ud.lanes |= e4, vp |= e4, t5);
    }
    function ar(e4, n7, t5, r6) {
      return yi(t5, n7) ? t5 : null !== gd.current ? (e4 = lr(e4, t5, r6), yi(e4, n7) || (gf = true), e4) : 0 == (42 & Ld) || 0 != (1073741824 & Ld) && 0 == (261930 & np) ? (gf = true, e4.memoizedState = t5) : (e4 = fa(), Ud.lanes |= e4, vp |= e4, n7);
    }
    function or() {
      Do.asyncTransitions--;
    }
    function ur(e4, n7, t5, r6, l3) {
      var a5 = Xo();
      Ko(0 !== a5 && 8 > a5 ? a5 : 8);
      var o3, u4, i5, s3 = Do.T, c5 = {};
      c5._updatedFibers = /* @__PURE__ */ new Set(), Do.T = c5, br(e4, false, n7, t5);
      try {
        var d3 = l3(), f4 = Do.S;
        null !== f4 && f4(c5, d3), null !== d3 && "object" == typeof d3 && "function" == typeof d3.then ? (Do.asyncTransitions++, d3.then(or, or), yr(e4, n7, (o3 = r6, u4 = [], i5 = { status: "pending", value: null, reason: null, then: function(e5) {
          u4.push(e5);
        } }, d3.then(function() {
          i5.status = "fulfilled", i5.value = o3;
          for (var e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(o3);
        }, function(e5) {
          for (i5.status = "rejected", i5.reason = e5, e5 = 0; e5 < u4.length; e5++) (0, u4[e5])(void 0);
        }), i5), da(e4))) : yr(e4, n7, r6, da(e4));
      } catch (t6) {
        yr(e4, n7, { then: function() {
        }, status: "rejected", reason: t6 }, da(e4));
      } finally {
        Ko(a5), null !== s3 && null !== c5.types && (null !== s3.types && s3.types !== c5.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), s3.types = c5.types), Do.T = s3, null === s3 && c5._updatedFibers && (e4 = c5._updatedFibers.size, c5._updatedFibers.clear(), 10 < e4 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function ir() {
      var e4 = wt(false);
      return e4 = ur.bind(null, Ud, e4.queue, true, false), at().memoizedState = e4, [false, e4];
    }
    function sr() {
      var e4 = ft(ct)[0], n7 = ot().memoizedState;
      return ["boolean" == typeof e4 ? e4 : ut(e4), n7];
    }
    function cr() {
      var e4 = mt(ct)[0], n7 = ot().memoizedState;
      return ["boolean" == typeof e4 ? e4 : ut(e4), n7];
    }
    function dr() {
      return he(mu);
    }
    function fr() {
      var e4 = at(), n7 = Zf.identifierPrefix;
      return n7 = "_" + n7 + "r_" + (Wd++).toString(32) + "_", e4.memoizedState = n7;
    }
    function pr() {
      return at().memoizedState = mr.bind(null, Ud);
    }
    function mr(e4, n7) {
      for (var t5 = e4.return; null !== t5; ) {
        switch (t5.tag) {
          case 24:
          case 3:
            var r6 = da(t5), l3 = _n(r6), a5 = Tn(t5, l3, r6);
            return null !== a5 && (ke(r6, "refresh()", e4), pa(a5, t5, r6), Rn(a5, t5, r6)), e4 = be(), null != n7 && null !== a5 && console.error("The seed argument is not enabled outside experimental channels."), void (l3.payload = { cache: e4 });
        }
        t5 = t5.return;
      }
    }
    function hr(e4, n7, t5) {
      var r6 = arguments;
      "function" == typeof r6[3] && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var l3 = { lane: r6 = da(e4), revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null };
      vr(e4) ? Sr(n7, l3) : null !== (l3 = wn(e4, n7, l3, r6)) && (ke(r6, "dispatch()", e4), pa(l3, e4, r6), kr(l3, n7, r6));
    }
    function gr(e4, n7, t5) {
      var r6 = arguments;
      "function" == typeof r6[3] && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), yr(e4, n7, t5, r6 = da(e4)) && ke(r6, "setState()", e4);
    }
    function yr(e4, n7, t5, r6) {
      var l3 = { lane: r6, revertLane: 0, gesture: null, action: t5, hasEagerState: false, eagerState: null, next: null };
      if (vr(e4)) Sr(n7, l3);
      else {
        var a5 = e4.alternate;
        if (0 === e4.lanes && (null === a5 || 0 === a5.lanes) && null !== (a5 = n7.lastRenderedReducer)) {
          var o3 = Do.H;
          Do.H = ef;
          try {
            var u4 = n7.lastRenderedState, i5 = a5(u4, t5);
            if (l3.hasEagerState = true, l3.eagerState = i5, yi(i5, u4)) return kn(e4, n7, l3, 0), null === Zf && Sn(), false;
          } catch (e5) {
          } finally {
            Do.H = o3;
          }
        }
        if (null !== (t5 = wn(e4, n7, l3, r6))) return pa(t5, e4, r6), kr(t5, n7, r6), true;
      }
      return false;
    }
    function br(e4, n7, t5, r6) {
      if (null === Do.T && 0 === ic && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."), r6 = { lane: 2, revertLane: Ge(), gesture: null, action: r6, hasEagerState: false, eagerState: null, next: null }, vr(e4)) {
        if (n7) throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else null !== (n7 = wn(e4, t5, r6, 2)) && (ke(2, "setOptimistic()", e4), pa(n7, e4, 2));
    }
    function vr(e4) {
      var n7 = e4.alternate;
      return e4 === Ud || null !== n7 && n7 === Ud;
    }
    function Sr(e4, n7) {
      jd = Fd = true;
      var t5 = e4.pending;
      null === t5 ? n7.next = n7 : (n7.next = t5.next, t5.next = n7), e4.pending = n7;
    }
    function kr(e4, n7, t5) {
      if (0 != (4194048 & t5)) {
        var r6 = n7.lanes;
        t5 |= r6 &= e4.pendingLanes, n7.lanes = t5, w(e4, t5);
      }
    }
    function wr(e4) {
      if (null !== e4 && "function" != typeof e4) {
        var n7 = String(e4);
        pf.has(n7) || (pf.add(n7), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", e4));
      }
    }
    function zr(e4, n7, t5, r6) {
      var l3 = e4.memoizedState, a5 = t5(r6, l3);
      if (8 & e4.mode) {
        P(true);
        try {
          a5 = t5(r6, l3);
        } finally {
          P(false);
        }
      }
      void 0 === a5 && (n7 = s2(n7) || "Component", sf.has(n7) || (sf.add(n7), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", n7))), l3 = null == a5 ? l3 : ho({}, l3, a5), e4.memoizedState = l3, 0 === e4.lanes && (e4.updateQueue.baseState = l3);
    }
    function xr(e4, n7, t5, r6, l3, a5, o3) {
      var u4 = e4.stateNode;
      if ("function" == typeof u4.shouldComponentUpdate) {
        if (t5 = u4.shouldComponentUpdate(r6, a5, o3), 8 & e4.mode) {
          P(true);
          try {
            t5 = u4.shouldComponentUpdate(r6, a5, o3);
          } finally {
            P(false);
          }
        }
        return void 0 === t5 && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", s2(n7) || "Component"), t5;
      }
      return !(n7.prototype && n7.prototype.isPureReactComponent && en(t5, r6) && en(l3, a5));
    }
    function Er(e4, n7, t5, r6) {
      var l3 = n7.state;
      "function" == typeof n7.componentWillReceiveProps && n7.componentWillReceiveProps(t5, r6), "function" == typeof n7.UNSAFE_componentWillReceiveProps && n7.UNSAFE_componentWillReceiveProps(t5, r6), n7.state !== l3 && (e4 = c4(e4) || "Component", rf.has(e4) || (rf.add(e4), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", e4)), mf.enqueueReplaceState(n7, n7.state, null));
    }
    function Cr(e4, n7) {
      var t5 = n7;
      if ("ref" in n7) for (var r6 in t5 = {}, n7) "ref" !== r6 && (t5[r6] = n7[r6]);
      if (e4 = e4.defaultProps) for (var l3 in t5 === n7 && (t5 = ho({}, t5)), e4) void 0 === t5[l3] && (t5[l3] = e4[l3]);
      return t5;
    }
    function Pr(e4, n7) {
      try {
        n7.source && c4(n7.source);
        var t5 = n7.value;
        null !== Do.actQueue ? Do.thrownErrors.push(t5) : (0, e4.onUncaughtError)(t5, { componentStack: n7.stack });
      } catch (e5) {
        setTimeout(function() {
          throw e5;
        });
      }
    }
    function _r(e4, n7, t5) {
      try {
        t5.source && c4(t5.source), c4(n7), (0, e4.onCaughtError)(t5.value, { componentStack: t5.stack, errorBoundary: 1 === n7.tag ? n7.stateNode : null });
      } catch (e5) {
        setTimeout(function() {
          throw e5;
        });
      }
    }
    function Tr(e4, n7, t5) {
      return (t5 = _n(t5)).tag = dd, t5.payload = { element: null }, t5.callback = function() {
        le(n7.source, Pr, e4, n7);
      }, t5;
    }
    function Rr(e4) {
      return (e4 = _n(e4)).tag = dd, e4;
    }
    function Nr(e4, n7, t5, r6) {
      var l3 = t5.type.getDerivedStateFromError;
      if ("function" == typeof l3) {
        var a5 = r6.value;
        e4.payload = function() {
          return l3(a5);
        }, e4.callback = function() {
          le(r6.source, _r, n7, t5, r6);
        };
      }
      var o3 = t5.stateNode;
      null !== o3 && "function" == typeof o3.componentDidCatch && (e4.callback = function() {
        le(r6.source, _r, n7, t5, r6), "function" != typeof l3 && (null === Dp ? Dp = /* @__PURE__ */ new Set([this]) : Dp.add(this)), Lc(this, r6), "function" == typeof l3 || 0 == (2 & t5.lanes) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", c4(t5) || "Unknown");
      });
    }
    function Lr(e4, n7, t5, r6) {
      n7.child = null === e4 ? td(n7, null, t5, r6) : nd(n7, e4.child, t5, r6);
    }
    function Ur(e4, n7, t5, r6, l3) {
      t5 = t5.render;
      var a5 = n7.ref;
      if ("ref" in r6) {
        var o3 = {};
        for (var u4 in r6) "ref" !== u4 && (o3[u4] = r6[u4]);
      } else o3 = r6;
      return me(n7), r6 = Xn(e4, n7, t5, o3, a5, l3), u4 = tt(), null === e4 || gf ? (n7.flags |= 1, Lr(e4, n7, r6, l3), n7.child) : (rt(e4, n7, l3), nl(e4, n7, l3));
    }
    function Dr(e4, n7, t5, r6, l3) {
      if (null === e4) {
        var a5 = t5.type;
        return "function" != typeof a5 || no(a5) || void 0 !== a5.defaultProps || null !== t5.compare ? ((e4 = lo(t5.type, null, r6, n7, n7.mode, l3)).ref = n7.ref, e4.return = n7, n7.child = e4) : (t5 = a5, n7.tag = 15, n7.type = t5, $r(n7, a5), Ir(e4, n7, t5, r6, l3));
      }
      if (a5 = e4.child, !tl(e4, l3)) {
        var o3 = a5.memoizedProps;
        if ((t5 = null !== (t5 = t5.compare) ? t5 : en)(o3, r6) && e4.ref === n7.ref) return nl(e4, n7, l3);
      }
      return n7.flags |= 1, (e4 = to(a5, r6)).ref = n7.ref, e4.return = n7, n7.child = e4;
    }
    function Ir(e4, n7, t5, r6, l3) {
      if (null !== e4) {
        var a5 = e4.memoizedProps;
        if (en(a5, r6) && e4.ref === n7.ref && n7.type === e4.type) {
          if (gf = false, n7.pendingProps = r6 = a5, !tl(e4, l3)) return n7.lanes = e4.lanes, nl(e4, n7, l3);
          0 != (131072 & e4.flags) && (gf = true);
        }
      }
      return Wr(e4, n7, t5, r6, l3);
    }
    function Fr(e4, n7, t5, r6) {
      var l3 = r6.children, a5 = null !== e4 ? e4.memoizedState : null;
      if (null === e4 && null === n7.stateNode && (n7.stateNode = { _visibility: rd, _pendingMarkers: null, _retryCache: null, _transitions: null }), "hidden" === r6.mode) {
        if (0 != (128 & n7.flags)) {
          if (a5 = null !== a5 ? a5.baseLanes | t5 : t5, null !== e4) {
            for (r6 = n7.child = e4.child, l3 = 0; null !== r6; ) l3 = l3 | r6.lanes | r6.childLanes, r6 = r6.sibling;
            r6 = l3 & ~a5;
          } else r6 = 0, n7.child = null;
          return Ar(e4, n7, a5, t5, r6);
        }
        if (0 == (536870912 & t5)) return r6 = n7.lanes = 536870912, Ar(e4, n7, null !== a5 ? a5.baseLanes | t5 : t5, t5, r6);
        n7.memoizedState = { baseLanes: 0, cachePool: null }, null !== e4 && Xe(n7, null !== a5 ? a5.cachePool : null), null !== a5 ? jn(n7, a5) : An(n7), Wn(n7);
      } else null !== a5 ? (Xe(n7, a5.cachePool), jn(n7, a5), Qn(n7), n7.memoizedState = null) : (null !== e4 && Xe(n7, null), An(n7), Qn(n7));
      return Lr(e4, n7, l3, t5), n7.child;
    }
    function jr(e4, n7) {
      return null !== e4 && 22 === e4.tag || null !== n7.stateNode || (n7.stateNode = { _visibility: rd, _pendingMarkers: null, _retryCache: null, _transitions: null }), n7.sibling;
    }
    function Ar(e4, n7, t5, r6, l3) {
      var a5 = Ke();
      return a5 = null === a5 ? null : { parent: fs2._currentValue2, pool: a5 }, n7.memoizedState = { baseLanes: t5, cachePool: a5 }, null !== e4 && Xe(n7, null), An(n7), Wn(n7), null !== e4 && fe(e4, n7, r6, true), n7.childLanes = l3, null;
    }
    function Hr(e4, n7) {
      var t5 = n7.hidden;
      return void 0 !== t5 && console.error(`<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`, true === t5 ? "hidden" : false === t5 ? "hidden={false}" : "hidden={...}", t5 ? 'mode="hidden"' : 'mode="visible"'), (n7 = Jr({ mode: n7.mode, children: n7.children }, e4.mode)).ref = e4.ref, e4.child = n7, n7.return = e4, n7;
    }
    function Or(e4, n7, t5) {
      return nd(n7, e4.child, null, t5), (e4 = Hr(n7, n7.pendingProps)).flags |= 2, Bn(n7), n7.memoizedState = null, e4;
    }
    function Mr(e4, n7) {
      var t5 = n7.ref;
      if (null === t5) null !== e4 && null !== e4.ref && (n7.flags |= 4194816);
      else {
        if ("function" != typeof t5 && "object" != typeof t5) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        null !== e4 && e4.ref === t5 || (n7.flags |= 4194816);
      }
    }
    function Wr(e4, n7, t5, r6, l3) {
      if (t5.prototype && "function" == typeof t5.prototype.render) {
        var a5 = s2(t5) || "Unknown";
        yf[a5] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", a5, a5), yf[a5] = true);
      }
      return 8 & n7.mode && fc.recordLegacyContextWarning(n7, null), null === e4 && ($r(n7, n7.type), t5.contextTypes && (a5 = s2(t5) || "Unknown", vf[a5] || (vf[a5] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", a5)))), me(n7), t5 = Xn(e4, n7, t5, r6, void 0, l3), r6 = tt(), null === e4 || gf ? (n7.flags |= 1, Lr(e4, n7, t5, l3), n7.child) : (rt(e4, n7, l3), nl(e4, n7, l3));
    }
    function Qr(e4, n7, t5, r6, l3, a5) {
      return me(n7), Vd = -1, qd = null !== e4 && e4.type !== n7.type, n7.updateQueue = null, t5 = et(n7, r6, t5, l3), Zn(e4, n7), r6 = tt(), null === e4 || gf ? (n7.flags |= 1, Lr(e4, n7, t5, a5), n7.child) : (rt(e4, n7, a5), nl(e4, n7, a5));
    }
    function Br(e4, n7, t5, r6, l3) {
      var a5, o3, u4;
      if (me(n7), null === n7.stateNode) {
        if (o3 = qu, a5 = t5.contextType, "contextType" in t5 && null !== a5 && (void 0 === a5 || a5.$$typeof !== zo) && !ff.has(t5) && (ff.add(t5), u4 = void 0 === a5 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" != typeof a5 ? " However, it is set to a " + typeof a5 + "." : a5.$$typeof === wo ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(a5).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", s2(t5) || "Component", u4)), "object" == typeof a5 && null !== a5 && (o3 = he(a5)), a5 = new t5(r6, o3), 8 & n7.mode) {
          P(true);
          try {
            a5 = new t5(r6, o3);
          } finally {
            P(false);
          }
        }
        if (o3 = n7.memoizedState = null !== a5.state && void 0 !== a5.state ? a5.state : null, a5.updater = mf, n7.stateNode = a5, a5._reactInternals = n7, a5._reactInternalInstance = tf, "function" == typeof t5.getDerivedStateFromProps && null === o3 && (o3 = s2(t5) || "Component", lf.has(o3) || (lf.add(o3), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", o3, null === a5.state ? "null" : "undefined", o3))), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate) {
          var i5 = u4 = o3 = null;
          if ("function" == typeof a5.componentWillMount && true !== a5.componentWillMount.__suppressDeprecationWarning ? o3 = "componentWillMount" : "function" == typeof a5.UNSAFE_componentWillMount && (o3 = "UNSAFE_componentWillMount"), "function" == typeof a5.componentWillReceiveProps && true !== a5.componentWillReceiveProps.__suppressDeprecationWarning ? u4 = "componentWillReceiveProps" : "function" == typeof a5.UNSAFE_componentWillReceiveProps && (u4 = "UNSAFE_componentWillReceiveProps"), "function" == typeof a5.componentWillUpdate && true !== a5.componentWillUpdate.__suppressDeprecationWarning ? i5 = "componentWillUpdate" : "function" == typeof a5.UNSAFE_componentWillUpdate && (i5 = "UNSAFE_componentWillUpdate"), null !== o3 || null !== u4 || null !== i5) {
            a5 = s2(t5) || "Component";
            var d3 = "function" == typeof t5.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            of.has(a5) || (of.add(a5), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", a5, d3, null !== o3 ? "\n  " + o3 : "", null !== u4 ? "\n  " + u4 : "", null !== i5 ? "\n  " + i5 : ""));
          }
        }
        a5 = n7.stateNode, o3 = s2(t5) || "Component", a5.render || (t5.prototype && "function" == typeof t5.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", o3) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", o3)), !a5.getInitialState || a5.getInitialState.isReactClassApproved || a5.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", o3), a5.getDefaultProps && !a5.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", o3), a5.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", o3), t5.childContextTypes && !df.has(t5) && (df.add(t5), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", o3)), t5.contextTypes && !cf.has(t5) && (cf.add(t5), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", o3)), "function" == typeof a5.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", o3), t5.prototype && t5.prototype.isPureReactComponent && void 0 !== a5.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", s2(t5) || "A pure component"), "function" == typeof a5.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", o3), "function" == typeof a5.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", o3), "function" == typeof a5.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", o3), "function" == typeof a5.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", o3), u4 = a5.props !== r6, void 0 !== a5.props && u4 && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", o3), a5.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", o3, o3), "function" != typeof a5.getSnapshotBeforeUpdate || "function" == typeof a5.componentDidUpdate || af.has(t5) || (af.add(t5), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", s2(t5))), "function" == typeof a5.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof a5.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", o3), "function" == typeof t5.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", o3), (u4 = a5.state) && ("object" != typeof u4 || Uo(u4)) && console.error("%s.state: must be set to an object or null", o3), "function" == typeof a5.getChildContext && "object" != typeof t5.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", o3), (a5 = n7.stateNode).props = r6, a5.state = n7.memoizedState, a5.refs = {}, Cn(n7), o3 = t5.contextType, a5.context = "object" == typeof o3 && null !== o3 ? he(o3) : qu, a5.state === r6 && (o3 = s2(t5) || "Component", uf.has(o3) || (uf.add(o3), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", o3))), 8 & n7.mode && fc.recordLegacyContextWarning(n7, a5), fc.recordUnsafeLifecycleWarnings(n7, a5), a5.state = n7.memoizedState, "function" == typeof (o3 = t5.getDerivedStateFromProps) && (zr(n7, t5, o3, r6), a5.state = n7.memoizedState), "function" == typeof t5.getDerivedStateFromProps || "function" == typeof a5.getSnapshotBeforeUpdate || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || (o3 = a5.state, "function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount(), o3 !== a5.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", c4(n7) || "Component"), mf.enqueueReplaceState(a5, a5.state, null)), Un(n7, r6, a5, l3), Ln(), a5.state = n7.memoizedState), "function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== ts && (n7.flags |= 134217728), a5 = true;
      } else if (null === e4) {
        a5 = n7.stateNode;
        var f4 = n7.memoizedProps;
        u4 = Cr(t5, f4), a5.props = u4;
        var p4 = a5.context;
        i5 = t5.contextType, o3 = qu, "object" == typeof i5 && null !== i5 && (o3 = he(i5)), i5 = "function" == typeof (d3 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate, f4 = n7.pendingProps !== f4, i5 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (f4 || p4 !== o3) && Er(n7, a5, r6, o3), fd = false;
        var m2 = n7.memoizedState;
        a5.state = m2, Un(n7, r6, a5, l3), Ln(), p4 = n7.memoizedState, f4 || m2 !== p4 || fd ? ("function" == typeof d3 && (zr(n7, t5, d3, r6), p4 = n7.memoizedState), (u4 = fd || xr(n7, t5, u4, r6, m2, p4, o3)) ? (i5 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== ts && (n7.flags |= 134217728)) : ("function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== ts && (n7.flags |= 134217728), n7.memoizedProps = r6, n7.memoizedState = p4), a5.props = r6, a5.state = p4, a5.context = o3, a5 = u4) : ("function" == typeof a5.componentDidMount && (n7.flags |= 4194308), (16 & n7.mode) !== ts && (n7.flags |= 134217728), a5 = false);
      } else {
        a5 = n7.stateNode, Pn(e4, n7), i5 = Cr(t5, o3 = n7.memoizedProps), a5.props = i5, d3 = n7.pendingProps, m2 = a5.context, p4 = t5.contextType, u4 = qu, "object" == typeof p4 && null !== p4 && (u4 = he(p4)), (p4 = "function" == typeof (f4 = t5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (o3 !== d3 || m2 !== u4) && Er(n7, a5, r6, u4), fd = false, m2 = n7.memoizedState, a5.state = m2, Un(n7, r6, a5, l3), Ln();
        var h4 = n7.memoizedState;
        o3 !== d3 || m2 !== h4 || fd || null !== e4 && null !== e4.dependencies && pe(e4.dependencies) ? ("function" == typeof f4 && (zr(n7, t5, f4, r6), h4 = n7.memoizedState), (i5 = fd || xr(n7, t5, i5, r6, m2, h4, u4) || null !== e4 && null !== e4.dependencies && pe(e4.dependencies)) ? (p4 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, h4, u4), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, h4, u4)), "function" == typeof a5.componentDidUpdate && (n7.flags |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (n7.flags |= 1024)) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 1024), n7.memoizedProps = r6, n7.memoizedState = h4), a5.props = r6, a5.state = h4, a5.context = u4, a5 = i5) : ("function" != typeof a5.componentDidUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || o3 === e4.memoizedProps && m2 === e4.memoizedState || (n7.flags |= 1024), a5 = false);
      }
      if (u4 = a5, Mr(e4, n7), o3 = 0 != (128 & n7.flags), u4 || o3) {
        if (u4 = n7.stateNode, ae(n7), o3 && "function" != typeof t5.getDerivedStateFromError) t5 = null, vs = -1;
        else if (t5 = Cc(u4), 8 & n7.mode) {
          P(true);
          try {
            Cc(u4);
          } finally {
            P(false);
          }
        }
        n7.flags |= 1, null !== e4 && o3 ? (n7.child = nd(n7, e4.child, null, l3), n7.child = nd(n7, null, t5, l3)) : Lr(e4, n7, t5, l3), n7.memoizedState = u4.state, e4 = n7.child;
      } else e4 = nl(e4, n7, l3);
      return l3 = n7.stateNode, a5 && l3.props !== r6 && (kf || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", c4(n7) || "a component"), kf = true), e4;
    }
    function $r(e4, n7) {
      n7 && n7.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", n7.displayName || n7.name || "Component"), "function" == typeof n7.getDerivedStateFromProps && (e4 = s2(n7) || "Unknown", Sf[e4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", e4), Sf[e4] = true)), "object" == typeof n7.contextType && null !== n7.contextType && (n7 = s2(n7) || "Unknown", bf[n7] || (console.error("%s: Function components do not support contextType.", n7), bf[n7] = true));
    }
    function Vr(e4) {
      return { baseLanes: e4, cachePool: Ze() };
    }
    function qr(e4, n7, t5) {
      return e4 = null !== e4 ? e4.childLanes & ~t5 : 0, n7 && (e4 |= wp), e4;
    }
    function Yr(e4, n7, t5) {
      var r6, l3 = n7.pendingProps, a5 = false, o3 = 0 != (128 & n7.flags);
      if ((r6 = o3) || (r6 = (null === e4 || null !== e4.memoizedState) && 0 != (wd.current & kd)), r6 && (a5 = true, n7.flags &= -129), r6 = 0 != (32 & n7.flags), n7.flags &= -33, null === e4) {
        var u4 = l3.children;
        return l3 = l3.fallback, a5 ? (Qn(n7), u4 = Jr({ mode: "hidden", children: u4 }, a5 = n7.mode), l3 = oo(l3, a5, t5, null), u4.return = n7, l3.return = n7, u4.sibling = l3, n7.child = u4, (l3 = n7.child).memoizedState = Vr(t5), l3.childLanes = qr(e4, r6, t5), n7.memoizedState = xf, jr(null, l3)) : (On(n7), Gr(n7, u4));
      }
      var i5, s3 = e4.memoizedState;
      if (null !== s3 && null !== (u4 = s3.dehydrated)) {
        if (o3) 256 & n7.flags ? (On(n7), n7.flags &= -257, n7 = Kr(e4, n7, t5)) : null !== n7.memoizedState ? (Qn(n7), n7.child = e4.child, n7.flags |= 128, n7 = null) : (Qn(n7), u4 = l3.fallback, a5 = n7.mode, l3 = Jr({ mode: "visible", children: l3.children }, a5), (u4 = oo(u4, a5, t5, null)).flags |= 2, l3.return = n7, u4.return = n7, l3.sibling = u4, n7.child = l3, nd(n7, e4.child, null, t5), (l3 = n7.child).memoizedState = Vr(t5), l3.childLanes = qr(e4, r6, t5), n7.memoizedState = xf, n7 = jr(null, l3));
        else if (On(n7), 0 != (536870912 & t5) && xa(n7), Lu(u4)) r6 = (a5 = Uu(u4)).digest, u4 = a5.message, l3 = a5.stack, a5 = a5.componentStack, (u4 = u4 ? Error(u4) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")).stack = l3 || "", u4.digest = r6, l3 = { value: u4, source: null, stack: r6 = void 0 === a5 ? null : a5 }, "string" == typeof r6 && Ai.set(u4, l3), i5 = l3, null === ns ? ns = [i5] : ns.push(i5), n7 = Kr(e4, n7, t5);
        else if (gf || fe(e4, n7, t5, false), r6 = 0 != (t5 & e4.childLanes), gf || r6) {
          if (null !== (r6 = Zf) && 0 !== (l3 = z(r6, t5)) && l3 !== s3.retryLane) throw s3.retryLane = l3, zn(e4, l3), pa(r6, e4, l3), hf;
          Nu(u4) || Ea(), n7 = Kr(e4, n7, t5);
        } else Nu(u4) ? (n7.flags |= 192, n7.child = e4.child, n7 = null) : (e4 = s3.treeContext, (n7 = Gr(n7, l3.children)).flags |= 4096);
        return n7;
      }
      return a5 ? (Qn(n7), u4 = l3.fallback, a5 = n7.mode, o3 = (s3 = e4.child).sibling, (l3 = to(s3, { mode: "hidden", children: l3.children })).subtreeFlags = 65011712 & s3.subtreeFlags, null !== o3 ? u4 = to(o3, u4) : (u4 = oo(u4, a5, t5, null)).flags |= 2, u4.return = n7, l3.return = n7, l3.sibling = u4, n7.child = l3, jr(null, l3), l3 = n7.child, null === (u4 = e4.child.memoizedState) ? u4 = Vr(t5) : (null !== (a5 = u4.cachePool) ? (s3 = fs2._currentValue2, a5 = a5.parent !== s3 ? { parent: s3, pool: s3 } : a5) : a5 = Ze(), u4 = { baseLanes: u4.baseLanes | t5, cachePool: a5 }), l3.memoizedState = u4, l3.childLanes = qr(e4, r6, t5), n7.memoizedState = xf, jr(e4.child, l3)) : (null !== s3 && (62914560 & t5) === t5 && 0 != (t5 & e4.lanes) && xa(n7), On(n7), e4 = (t5 = e4.child).sibling, (t5 = to(t5, { mode: "visible", children: l3.children })).return = n7, t5.sibling = null, null !== e4 && (null === (r6 = n7.deletions) ? (n7.deletions = [e4], n7.flags |= 16) : r6.push(e4)), n7.child = t5, n7.memoizedState = null, t5);
    }
    function Gr(e4, n7) {
      return (n7 = Jr({ mode: "visible", children: n7 }, e4.mode)).return = e4, e4.child = n7;
    }
    function Jr(e4, n7) {
      return (e4 = t4(22, e4, null, n7)).lanes = 0, e4;
    }
    function Kr(e4, n7, t5) {
      return nd(n7, e4.child, null, t5), (e4 = Gr(n7, n7.pendingProps.children)).flags |= 2, n7.memoizedState = null, e4;
    }
    function Xr(e4, n7, t5) {
      e4.lanes |= n7;
      var r6 = e4.alternate;
      null !== r6 && (r6.lanes |= n7), ce(e4.return, n7, t5);
    }
    function Zr(e4, n7, t5, r6, l3, a5) {
      var o3 = e4.memoizedState;
      null === o3 ? e4.memoizedState = { isBackwards: n7, rendering: null, renderingStartTime: 0, last: r6, tail: t5, tailMode: l3, treeForkCount: a5 } : (o3.isBackwards = n7, o3.rendering = null, o3.renderingStartTime = 0, o3.last = r6, o3.tail = t5, o3.tailMode = l3, o3.treeForkCount = a5);
    }
    function el(e4, n7, t5) {
      var r6 = n7.pendingProps, l3 = r6.revealOrder, a5 = r6.tail, o3 = r6.children, u4 = wd.current;
      if ((r6 = 0 != (u4 & kd)) ? (u4 = u4 & Sd | kd, n7.flags |= 128) : u4 &= Sd, p3(wd, u4, n7), u4 = null == l3 ? "null" : l3, "forwards" !== l3 && "unstable_legacy-backwards" !== l3 && "together" !== l3 && "independent" !== l3 && !wf[u4]) if (wf[u4] = true, null == l3) console.error('The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".');
      else if ("backwards" === l3) console.error('The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.');
      else if ("string" == typeof l3) switch (l3.toLowerCase()) {
        case "together":
        case "forwards":
        case "backwards":
        case "independent":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', l3, l3.toLowerCase());
          break;
        case "forward":
        case "backward":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', l3, l3.toLowerCase());
          break;
        default:
          console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', l3);
      }
      else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', l3);
      zf[u4 = null == a5 ? "null" : a5] || (null == a5 ? "forwards" !== l3 && "backwards" !== l3 && "unstable_legacy-backwards" !== l3 || (zf[u4] = true, console.error('The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".')) : "visible" !== a5 && "collapsed" !== a5 && "hidden" !== a5 ? (zf[u4] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?', a5)) : "forwards" !== l3 && "backwards" !== l3 && "unstable_legacy-backwards" !== l3 && (zf[u4] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a5)));
      e: if (("forwards" === l3 || "backwards" === l3 || "unstable_legacy-backwards" === l3) && null != o3 && false !== o3) if (Uo(o3)) {
        for (u4 = 0; u4 < o3.length; u4++) if (!vn(o3[u4], u4)) break e;
      } else if (u4 = i4(o3), "function" == typeof u4) {
        if (u4 = u4.call(o3)) for (var s3 = u4.next(), c5 = 0; !s3.done; s3 = u4.next()) {
          if (!vn(s3.value, c5)) break e;
          c5++;
        }
      } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', l3);
      if (Lr(e4, n7, o3, t5), o3 = 0, !r6 && null !== e4 && 0 != (128 & e4.flags)) e: for (e4 = n7.child; null !== e4; ) {
        if (13 === e4.tag) null !== e4.memoizedState && Xr(e4, t5, n7);
        else if (19 === e4.tag) Xr(e4, t5, n7);
        else if (null !== e4.child) {
          e4.child.return = e4, e4 = e4.child;
          continue;
        }
        if (e4 === n7) break e;
        for (; null === e4.sibling; ) {
          if (null === e4.return || e4.return === n7) break e;
          e4 = e4.return;
        }
        e4.sibling.return = e4.return, e4 = e4.sibling;
      }
      switch (l3) {
        case "forwards":
          for (t5 = n7.child, l3 = null; null !== t5; ) null !== (e4 = t5.alternate) && null === $n(e4) && (l3 = t5), t5 = t5.sibling;
          null === (t5 = l3) ? (l3 = n7.child, n7.child = null) : (l3 = t5.sibling, t5.sibling = null), Zr(n7, false, l3, t5, a5, o3);
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          for (t5 = null, l3 = n7.child, n7.child = null; null !== l3; ) {
            if (null !== (e4 = l3.alternate) && null === $n(e4)) {
              n7.child = l3;
              break;
            }
            e4 = l3.sibling, l3.sibling = t5, t5 = l3, l3 = e4;
          }
          Zr(n7, true, t5, null, a5, o3);
          break;
        case "together":
          Zr(n7, false, null, null, void 0, o3);
          break;
        default:
          n7.memoizedState = null;
      }
      return n7.child;
    }
    function nl(e4, n7, t5) {
      if (null !== e4 && (n7.dependencies = e4.dependencies), vs = -1, vp |= n7.lanes, 0 == (t5 & n7.childLanes)) {
        if (null === e4) return null;
        if (fe(e4, n7, t5, false), 0 == (t5 & n7.childLanes)) return null;
      }
      if (null !== e4 && n7.child !== e4.child) throw Error("Resuming work not yet implemented.");
      if (null !== n7.child) {
        for (t5 = to(e4 = n7.child, e4.pendingProps), n7.child = t5, t5.return = n7; null !== e4.sibling; ) e4 = e4.sibling, (t5 = t5.sibling = to(e4, e4.pendingProps)).return = n7;
        t5.sibling = null;
      }
      return n7.child;
    }
    function tl(e4, n7) {
      return 0 != (e4.lanes & n7) || !(null === (e4 = e4.dependencies) || !pe(e4));
    }
    function rl(e4, n7, t5) {
      if (n7._debugNeedsRemount && null !== e4) {
        (t5 = lo(n7.type, n7.key, n7.pendingProps, n7._debugOwner || null, n7.mode, n7.lanes))._debugStack = n7._debugStack, t5._debugTask = n7._debugTask;
        var r6 = n7.return;
        if (null === r6) throw Error("Cannot swap the root fiber.");
        if (e4.alternate = null, n7.alternate = null, t5.index = n7.index, t5.sibling = n7.sibling, t5.return = n7.return, t5.ref = n7.ref, t5._debugInfo = n7._debugInfo, n7 === r6.child) r6.child = t5;
        else {
          var l3 = r6.child;
          if (null === l3) throw Error("Expected parent to have a child.");
          for (; l3.sibling !== n7; ) if (null === (l3 = l3.sibling)) throw Error("Expected to find the previous sibling.");
          l3.sibling = t5;
        }
        return null === (n7 = r6.deletions) ? (r6.deletions = [e4], r6.flags |= 16) : n7.push(e4), t5.flags |= 2, t5;
      }
      if (null !== e4) if (e4.memoizedProps !== n7.pendingProps || n7.type !== e4.type) gf = true;
      else {
        if (!tl(e4, t5) && 0 == (128 & n7.flags)) return gf = false, function(e5, n8, t6) {
          switch (n8.tag) {
            case 3:
              X(n8, n8.stateNode.containerInfo), ie(n8, fs2, e5.memoizedState.cache);
              break;
            case 27:
            case 5:
              ne(n8);
              break;
            case 4:
              X(n8, n8.stateNode.containerInfo);
              break;
            case 10:
              ie(n8, n8.type, n8.memoizedProps.value);
              break;
            case 12:
              0 != (t6 & n8.childLanes) && (n8.flags |= 4), n8.flags |= 2048;
              var r7 = n8.stateNode;
              r7.effectDuration = -0, r7.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== n8.memoizedState) return n8.flags |= 128, Mn(n8), null;
              break;
            case 13:
              if (null !== (r7 = n8.memoizedState)) return null !== r7.dehydrated ? (On(n8), n8.flags |= 128, null) : 0 != (t6 & n8.child.childLanes) ? Yr(e5, n8, t6) : (On(n8), null !== (e5 = nl(e5, n8, t6)) ? e5.sibling : null);
              On(n8);
              break;
            case 19:
              var l4 = 0 != (128 & e5.flags);
              if ((r7 = 0 != (t6 & n8.childLanes)) || (fe(e5, n8, t6, false), r7 = 0 != (t6 & n8.childLanes)), l4) {
                if (r7) return el(e5, n8, t6);
                n8.flags |= 128;
              }
              if (null !== (l4 = n8.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), p3(wd, wd.current, n8), r7) break;
              return null;
            case 22:
              return n8.lanes = 0, Fr(e5, n8, t6, n8.pendingProps);
            case 24:
              ie(n8, fs2, e5.memoizedState.cache);
          }
          return nl(e5, n8, t6);
        }(e4, n7, t5);
        gf = 0 != (131072 & e4.flags);
      }
      else gf = false, (r6 = es) && (J(), r6 = 0 != (1048576 & n7.flags)), r6 && (r6 = n7.index, J(), function(e5, n8, t6) {
        J(), Qi[Bi++] = Vi, Qi[Bi++] = qi, Qi[Bi++] = $i, $i = e5;
        var r7 = Vi;
        e5 = qi;
        var l4 = 32 - Yu(r7) - 1;
        r7 &= ~(1 << l4), t6 += 1;
        var a6 = 32 - Yu(n8) + l4;
        if (30 < a6) {
          var o4 = l4 - l4 % 5;
          a6 = (r7 & (1 << o4) - 1).toString(32), r7 >>= o4, l4 -= o4, Vi = 1 << 32 - Yu(n8) + l4 | t6 << l4 | r7, qi = a6 + e5;
        } else Vi = 1 << a6 | t6 << l4 | r7, qi = e5;
      }(n7, Wi, r6));
      switch (n7.lanes = 0, n7.tag) {
        case 16:
          e: {
            if (r6 = n7.pendingProps, e4 = rn(n7.elementType), n7.type = e4, "function" != typeof e4) {
              if (null != e4) {
                if ((l3 = e4.$$typeof) === xo) {
                  n7.tag = 11, n7.type = e4, n7 = Ur(null, n7, e4, r6, t5);
                  break e;
                }
                if (l3 === Po) {
                  n7.tag = 14, n7 = Dr(null, n7, e4, r6, t5);
                  break e;
                }
              }
              throw n7 = "", null !== e4 && "object" == typeof e4 && e4.$$typeof === _o && (n7 = " Did you wrap a component in React.lazy() more than once?"), e4 = s2(e4) || e4, Error("Element type is invalid. Received a promise that resolves to: " + e4 + ". Lazy element type must resolve to a class or function." + n7);
            }
            no(e4) ? (r6 = Cr(e4, r6), n7.tag = 1, n7.type = e4, n7 = Br(null, n7, e4, r6, t5)) : (n7.tag = 0, $r(n7, e4), n7.type = e4, n7 = Wr(null, n7, e4, r6, t5));
          }
          return n7;
        case 0:
          return Wr(e4, n7, n7.type, n7.pendingProps, t5);
        case 1:
          return Br(e4, n7, r6 = n7.type, l3 = Cr(r6, n7.pendingProps), t5);
        case 3:
          if (X(n7, n7.stateNode.containerInfo), null === e4) throw Error("Should have a current fiber. This is a bug in React.");
          var a5 = n7.pendingProps;
          r6 = (l3 = n7.memoizedState).element, Pn(e4, n7), Un(n7, a5, null, t5);
          var o3 = n7.memoizedState;
          return a5 = o3.cache, ie(n7, fs2, a5), a5 !== l3.cache && de(n7, [fs2], t5, true), Ln(), (a5 = o3.element) !== r6 ? (Lr(e4, n7, a5, t5), n7 = n7.child) : n7 = nl(e4, n7, t5), n7;
        case 26:
        case 27:
        case 5:
          return ne(n7), l3 = n7.type, a5 = n7.pendingProps, o3 = null !== e4 ? e4.memoizedProps : null, r6 = a5.children, Qo(l3, a5) ? r6 = null : null !== o3 && Qo(l3, o3) && (n7.flags |= 32), null !== n7.memoizedState && (l3 = Xn(e4, n7, nt, null, null, t5), mu._currentValue2 = l3), Mr(e4, n7), Lr(e4, n7, r6, t5), n7.child;
        case 6:
          return null;
        case 13:
          return Yr(e4, n7, t5);
        case 4:
          return X(n7, n7.stateNode.containerInfo), r6 = n7.pendingProps, null === e4 ? n7.child = nd(n7, null, r6, t5) : Lr(e4, n7, r6, t5), n7.child;
        case 11:
          return Ur(e4, n7, n7.type, n7.pendingProps, t5);
        case 7:
          return Lr(e4, n7, n7.pendingProps, t5), n7.child;
        case 8:
          return Lr(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 12:
          return n7.flags |= 4, n7.flags |= 2048, (r6 = n7.stateNode).effectDuration = -0, r6.passiveEffectDuration = -0, Lr(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 10:
          return r6 = n7.type, a5 = (l3 = n7.pendingProps).value, "value" in l3 || Ef || (Ef = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), ie(n7, r6, a5), Lr(e4, n7, l3.children, t5), n7.child;
        case 9:
          return l3 = n7.type._context, "function" != typeof (r6 = n7.pendingProps.children) && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), me(n7), l3 = he(l3), r6 = xc(r6, l3, void 0), n7.flags |= 1, Lr(e4, n7, r6, t5), n7.child;
        case 14:
          return Dr(e4, n7, n7.type, n7.pendingProps, t5);
        case 15:
          return Ir(e4, n7, n7.type, n7.pendingProps, t5);
        case 19:
          return el(e4, n7, t5);
        case 31:
          return function(e5, n8, t6) {
            var r7 = n8.pendingProps, l4 = 0 != (128 & n8.flags);
            if (n8.flags &= -129, null === e5) return Hr(n8, r7);
            var a6 = e5.memoizedState;
            if (null !== a6) {
              var o4 = a6.dehydrated;
              if (Mn(n8), l4) if (256 & n8.flags) n8.flags &= -257, n8 = Or(e5, n8, t6);
              else {
                if (null === n8.memoizedState) throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
                n8.child = e5.child, n8.flags |= 128, n8 = null;
              }
              else if (0 != (536870912 & t6) && xa(n8), gf || fe(e5, n8, t6, false), l4 = 0 != (t6 & e5.childLanes), gf || l4) {
                if (null !== (r7 = Zf) && 0 !== (o4 = z(r7, t6)) && o4 !== a6.retryLane) throw a6.retryLane = o4, zn(e5, o4), pa(r7, e5, o4), hf;
                Ea(), n8 = Or(e5, n8, t6);
              } else e5 = a6.treeContext, (n8 = Hr(n8, r7)).flags |= 4096;
              return n8;
            }
            return a6 = e5.child, r7 = { mode: r7.mode, children: r7.children }, 0 != (536870912 & t6) && 0 != (t6 & e5.lanes) && xa(n8), (e5 = to(a6, r7)).ref = n8.ref, n8.child = e5, e5.return = n8, e5;
          }(e4, n7, t5);
        case 22:
          return Fr(e4, n7, t5, n7.pendingProps);
        case 24:
          return me(n7), r6 = he(fs2), null === e4 ? (null === (l3 = Ke()) && (l3 = Zf, a5 = be(), l3.pooledCache = a5, ve(a5), null !== a5 && (l3.pooledCacheLanes |= t5), l3 = a5), n7.memoizedState = { parent: r6, cache: l3 }, Cn(n7), ie(n7, fs2, l3)) : (0 != (e4.lanes & t5) && (Pn(e4, n7), Un(n7, null, null, t5), Ln()), l3 = e4.memoizedState, a5 = n7.memoizedState, l3.parent !== r6 ? (l3 = { parent: r6, cache: r6 }, n7.memoizedState = l3, 0 === n7.lanes && (n7.memoizedState = n7.updateQueue.baseState = l3), ie(n7, fs2, r6)) : (r6 = a5.cache, ie(n7, fs2, r6), r6 !== l3.cache && de(n7, [fs2], t5, true))), Lr(e4, n7, n7.pendingProps.children, t5), n7.child;
        case 29:
          throw n7.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + n7.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function ll(e4) {
      e4.flags |= 4;
    }
    function al(e4, n7, t5, r6, l3) {
      if ((32 & e4.mode) !== ts && (null === t5 ? au(n7, r6) : ou(n7, t5, r6))) {
        if (e4.flags |= 16777216, (335544128 & l3) === l3 || uu(n7, r6)) if (iu(e4.stateNode, n7, r6)) e4.flags |= 8192;
        else {
          if (null !== (a5 = bd.current) && ((4194048 & np) === np ? null !== vd : (62914560 & np) !== np && 0 == (536870912 & np) || a5 !== vd)) throw $c = Bc, Wc;
          e4.flags |= 8192;
        }
      } else e4.flags &= -16777217;
      var a5;
    }
    function ol(e4, n7) {
      null !== n7 && (e4.flags |= 4), 16384 & e4.flags && (n7 = 22 !== e4.tag ? b3() : 536870912, e4.lanes |= n7, zp |= n7);
    }
    function ul(e4, n7) {
      switch (e4.tailMode) {
        case "hidden":
          n7 = e4.tail;
          for (var t5 = null; null !== n7; ) null !== n7.alternate && (t5 = n7), n7 = n7.sibling;
          null === t5 ? e4.tail = null : t5.sibling = null;
          break;
        case "collapsed":
          t5 = e4.tail;
          for (var r6 = null; null !== t5; ) null !== t5.alternate && (r6 = t5), t5 = t5.sibling;
          null === r6 ? n7 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
      }
    }
    function il(e4) {
      var n7 = null !== e4.alternate && e4.alternate.child === e4.child, t5 = 0, r6 = 0;
      if (n7) if ((2 & e4.mode) !== ts) {
        for (var l3 = e4.selfBaseDuration, a5 = e4.child; null !== a5; ) t5 |= a5.lanes | a5.childLanes, r6 |= 65011712 & a5.subtreeFlags, r6 |= 65011712 & a5.flags, l3 += a5.treeBaseDuration, a5 = a5.sibling;
        e4.treeBaseDuration = l3;
      } else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= 65011712 & l3.subtreeFlags, r6 |= 65011712 & l3.flags, l3.return = e4, l3 = l3.sibling;
      else if ((2 & e4.mode) !== ts) {
        l3 = e4.actualDuration, a5 = e4.selfBaseDuration;
        for (var o3 = e4.child; null !== o3; ) t5 |= o3.lanes | o3.childLanes, r6 |= o3.subtreeFlags, r6 |= o3.flags, l3 += o3.actualDuration, a5 += o3.treeBaseDuration, o3 = o3.sibling;
        e4.actualDuration = l3, e4.treeBaseDuration = a5;
      } else for (l3 = e4.child; null !== l3; ) t5 |= l3.lanes | l3.childLanes, r6 |= l3.subtreeFlags, r6 |= l3.flags, l3.return = e4, l3 = l3.sibling;
      return e4.subtreeFlags |= r6, e4.childLanes = t5, n7;
    }
    function sl(e4, n7, t5) {
      var r6 = n7.pendingProps;
      switch (G2(n7), n7.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
        case 1:
          return il(n7), null;
        case 3:
          return t5 = n7.stateNode, r6 = null, null !== e4 && (r6 = e4.memoizedState.cache), n7.memoizedState.cache !== r6 && (n7.flags |= 2048), se(fs2, n7), Z(n7), t5.pendingContext && (t5.context = t5.pendingContext, t5.pendingContext = null), null !== e4 && null !== e4.child || null === e4 || e4.memoizedState.isDehydrated && 0 == (256 & n7.flags) || (n7.flags |= 1024, oe()), il(n7), null;
        case 26:
          var l3, a5;
        case 27:
        case 5:
          if (te(n7), l3 = n7.type, null !== e4 && null != n7.stateNode) !function(e5, n8, t6, r7) {
            e5.memoizedProps !== r7 && ll(n8);
          }(e4, n7, 0, r6);
          else {
            if (!r6) {
              if (null === n7.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return il(n7), null;
            }
            a5 = ee();
            var o3 = K(Ji.current);
            (function(e5, n8, t6, r7) {
              for (t6 = n8.child; null !== t6; ) {
                if (5 === t6.tag || 6 === t6.tag) Mo(e5, t6.stateNode);
                else if (4 !== t6.tag && !Qu && null !== t6.child) {
                  t6.child.return = t6, t6 = t6.child;
                  continue;
                }
                if (t6 === n8) break;
                for (; null === t6.sibling; ) {
                  if (null === t6.return || t6.return === n8) return;
                  t6 = t6.return;
                }
                t6.sibling.return = t6.return, t6 = t6.sibling;
              }
            })(o3 = Oo(l3, r6, o3, a5, n7), n7, false), n7.stateNode = o3, Wo(o3, l3, r6, a5) && ll(n7);
          }
          return il(n7), al(n7, n7.type, null === e4 ? null : e4.memoizedProps, n7.pendingProps, t5), null;
        case 6:
          if (e4 && null != n7.stateNode) (t5 = e4.memoizedProps) !== r6 && ll(n7);
          else {
            if ("string" != typeof r6 && null === n7.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            e4 = K(Ji.current), t5 = ee(), n7.stateNode = Bo(r6, e4, t5, n7);
          }
          return il(n7), null;
        case 31:
          if (t5 = n7.memoizedState, null === e4 || null !== e4.memoizedState) {
            if (r6 = false, null !== t5) {
              if (null === e4) {
                if (!r6) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                throw Error("Expected prepareToHydrateHostActivityInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              }
              0 == (128 & n7.flags) && (t5 = n7.memoizedState = null), n7.flags |= 4, il(n7), (2 & n7.mode) !== ts && null !== t5 && null !== (e4 = n7.child) && (n7.treeBaseDuration -= e4.treeBaseDuration), e4 = false;
            } else t5 = oe(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = t5), e4 = true;
            if (!e4) return 256 & n7.flags ? (Bn(n7), n7) : (Bn(n7), null);
            if (0 != (128 & n7.flags)) throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
          }
          return il(n7), null;
        case 13:
          if (r6 = n7.memoizedState, null === e4 || null !== e4.memoizedState && null !== e4.memoizedState.dehydrated) {
            if (a5 = false, null !== (l3 = r6) && null !== l3.dehydrated) {
              if (null === e4) {
                if (!a5) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              }
              0 == (128 & n7.flags) && (l3 = n7.memoizedState = null), n7.flags |= 4, il(n7), (2 & n7.mode) !== ts && null !== l3 && null !== (l3 = n7.child) && (n7.treeBaseDuration -= l3.treeBaseDuration), l3 = false;
            } else l3 = oe(), null !== e4 && null !== e4.memoizedState && (e4.memoizedState.hydrationErrors = l3), l3 = true;
            if (!l3) return 256 & n7.flags ? (Bn(n7), n7) : (Bn(n7), null);
          }
          return Bn(n7), 0 != (128 & n7.flags) ? (n7.lanes = t5, (2 & n7.mode) !== ts && Ae(n7), n7) : (t5 = null !== r6, e4 = null !== e4 && null !== e4.memoizedState, t5 && (l3 = null, null !== (r6 = n7.child).alternate && null !== r6.alternate.memoizedState && null !== r6.alternate.memoizedState.cachePool && (l3 = r6.alternate.memoizedState.cachePool.pool), a5 = null, null !== r6.memoizedState && null !== r6.memoizedState.cachePool && (a5 = r6.memoizedState.cachePool.pool), a5 !== l3 && (r6.flags |= 2048)), t5 !== e4 && t5 && (n7.child.flags |= 8192), ol(n7, n7.updateQueue), il(n7), (2 & n7.mode) !== ts && t5 && null !== (e4 = n7.child) && (n7.treeBaseDuration -= e4.treeBaseDuration), null);
        case 4:
          return Z(n7), null === e4 && Jo(n7.stateNode.containerInfo), il(n7), null;
        case 10:
          return se(n7.type, n7), il(n7), null;
        case 19:
          if (f3(wd, n7), null === (r6 = n7.memoizedState)) return il(n7), null;
          if (l3 = 0 != (128 & n7.flags), null === (a5 = r6.rendering)) if (l3) ul(r6, false);
          else {
            if (bp !== $f || null !== e4 && 0 != (128 & e4.flags)) for (e4 = n7.child; null !== e4; ) {
              if (null !== (a5 = $n(e4))) {
                for (n7.flags |= 128, ul(r6, false), e4 = a5.updateQueue, n7.updateQueue = e4, ol(n7, e4), n7.subtreeFlags = 0, e4 = t5, t5 = n7.child; null !== t5; ) ro(t5, e4), t5 = t5.sibling;
                return p3(wd, wd.current & Sd | kd, n7), n7.child;
              }
              e4 = e4.sibling;
            }
            null !== r6.tail && li() > Rp && (n7.flags |= 128, l3 = true, ul(r6, false), n7.lanes = 4194304);
          }
          else {
            if (!l3) if (null !== (e4 = $n(a5))) {
              if (n7.flags |= 128, l3 = true, e4 = e4.updateQueue, n7.updateQueue = e4, ol(n7, e4), ul(r6, true), null === r6.tail && "hidden" === r6.tailMode && !a5.alternate) return il(n7), null;
            } else 2 * li() - r6.renderingStartTime > Rp && 536870912 !== t5 && (n7.flags |= 128, l3 = true, ul(r6, false), n7.lanes = 4194304);
            r6.isBackwards ? (a5.sibling = n7.child, n7.child = a5) : (null !== (e4 = r6.last) ? e4.sibling = a5 : n7.child = a5, r6.last = a5);
          }
          return null !== r6.tail ? (e4 = r6.tail, r6.rendering = e4, r6.tail = e4.sibling, r6.renderingStartTime = li(), e4.sibling = null, t5 = wd.current, p3(wd, t5 = l3 ? t5 & Sd | kd : t5 & Sd, n7), e4) : (il(n7), null);
        case 22:
        case 23:
          return Bn(n7), Hn(n7), r6 = null !== n7.memoizedState, null !== e4 ? null !== e4.memoizedState !== r6 && (n7.flags |= 8192) : r6 && (n7.flags |= 8192), r6 ? 0 != (536870912 & t5) && 0 == (128 & n7.flags) && (il(n7), 6 & n7.subtreeFlags && (n7.flags |= 8192)) : il(n7), null !== (t5 = n7.updateQueue) && ol(n7, t5.retryQueue), t5 = null, null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), r6 = null, null !== n7.memoizedState && null !== n7.memoizedState.cachePool && (r6 = n7.memoizedState.cachePool.pool), r6 !== t5 && (n7.flags |= 2048), null !== e4 && f3(dc, n7), null;
        case 24:
          return t5 = null, null !== e4 && (t5 = e4.memoizedState.cache), n7.memoizedState.cache !== t5 && (n7.flags |= 2048), se(fs2, n7), il(n7), null;
        case 25:
        case 30:
          return null;
      }
      throw Error("Unknown unit of work tag (" + n7.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function cl(e4, n7) {
      switch (G2(n7), n7.tag) {
        case 1:
          return 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== ts && Ae(n7), n7) : null;
        case 3:
          return se(fs2, n7), Z(n7), 0 != (65536 & (e4 = n7.flags)) && 0 == (128 & e4) ? (n7.flags = -65537 & e4 | 128, n7) : null;
        case 26:
        case 27:
        case 5:
          return te(n7), null;
        case 31:
          if (null !== n7.memoizedState && (Bn(n7), null === n7.alternate)) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
          return 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== ts && Ae(n7), n7) : null;
        case 13:
          if (Bn(n7), null !== (e4 = n7.memoizedState) && null !== e4.dehydrated && null === n7.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
          return 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== ts && Ae(n7), n7) : null;
        case 19:
          return f3(wd, n7), null;
        case 4:
          return Z(n7), null;
        case 10:
          return se(n7.type, n7), null;
        case 22:
        case 23:
          return Bn(n7), Hn(n7), null !== e4 && f3(dc, n7), 65536 & (e4 = n7.flags) ? (n7.flags = -65537 & e4 | 128, (2 & n7.mode) !== ts && Ae(n7), n7) : null;
        case 24:
          return se(fs2, n7), null;
        default:
          return null;
      }
    }
    function dl(e4, n7) {
      switch (G2(n7), n7.tag) {
        case 3:
          se(fs2, n7), Z(n7);
          break;
        case 26:
        case 27:
        case 5:
          te(n7);
          break;
        case 4:
          Z(n7);
          break;
        case 31:
          null !== n7.memoizedState && Bn(n7);
          break;
        case 13:
          Bn(n7);
          break;
        case 19:
          f3(wd, n7);
          break;
        case 10:
          se(n7.type, n7);
          break;
        case 22:
        case 23:
          Bn(n7), Hn(n7), null !== e4 && f3(dc, n7);
          break;
        case 24:
          se(fs2, n7);
      }
    }
    function fl(e4) {
      return (2 & e4.mode) !== ts;
    }
    function pl(e4, n7) {
      fl(e4) ? (je(), hl(n7, e4), Ie()) : hl(n7, e4);
    }
    function ml(e4, n7, t5) {
      fl(e4) ? (je(), gl(t5, e4, n7), Ie()) : gl(t5, e4, n7);
    }
    function hl(e4, n7) {
      try {
        var t5 = n7.updateQueue, r6 = null !== t5 ? t5.lastEffect : null;
        if (null !== r6) {
          var l3 = r6.next;
          t5 = l3;
          do {
            var a5;
            (t5.tag & e4) === e4 && (r6 = void 0, (e4 & Ed) !== zd && (cm = true), r6 = le(n7, Fc, t5), (e4 & Ed) !== zd && (cm = false), void 0 !== r6 && "function" != typeof r6) && le(n7, function(e5, n8) {
              console.error("%s must not return anything besides a function, which is used for clean-up.%s", e5, n8);
            }, a5 = 0 != (t5.tag & Cd) ? "useLayoutEffect" : 0 != (t5.tag & Ed) ? "useInsertionEffect" : "useEffect", null === r6 ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" == typeof r6.then ? "\n\nIt looks like you wrote " + a5 + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + a5 + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + r6), t5 = t5.next;
          } while (t5 !== l3);
        }
      } catch (e5) {
        Qa(n7, n7.return, e5);
      }
    }
    function gl(e4, n7, t5) {
      try {
        var r6 = n7.updateQueue, l3 = null !== r6 ? r6.lastEffect : null;
        if (null !== l3) {
          var a5 = l3.next;
          r6 = a5;
          do {
            if ((r6.tag & e4) === e4) {
              var o3 = r6.inst, u4 = o3.destroy;
              void 0 !== u4 && (o3.destroy = void 0, (e4 & Ed) !== zd && (cm = true), le(l3 = n7, Ac, l3, t5, u4), (e4 & Ed) !== zd && (cm = false));
            }
            r6 = r6.next;
          } while (r6 !== a5);
        }
      } catch (e5) {
        Qa(n7, n7.return, e5);
      }
    }
    function yl(e4, n7) {
      fl(e4) ? (je(), hl(n7, e4), Ie()) : hl(n7, e4);
    }
    function bl(e4, n7, t5) {
      fl(e4) ? (je(), gl(t5, e4, n7), Ie()) : gl(t5, e4, n7);
    }
    function vl(e4) {
      var n7 = e4.updateQueue;
      if (null !== n7) {
        var t5 = e4.stateNode;
        e4.type.defaultProps || "ref" in e4.memoizedProps || kf || (t5.props !== e4.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(e4) || "instance"), t5.state !== e4.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(e4) || "instance"));
        try {
          le(e4, Fn, n7, t5);
        } catch (n8) {
          Qa(e4, e4.return, n8);
        }
      }
    }
    function Sl(e4, n7, t5) {
      return e4.getSnapshotBeforeUpdate(n7, t5);
    }
    function kl(e4, n7) {
      var t5 = n7.memoizedProps, r6 = n7.memoizedState;
      n7 = e4.stateNode, e4.type.defaultProps || "ref" in e4.memoizedProps || kf || (n7.props !== e4.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(e4) || "instance"), n7.state !== e4.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(e4) || "instance"));
      try {
        var l3 = Cr(e4.type, t5), a5 = le(e4, Sl, n7, l3, r6);
        t5 = Cf, void 0 !== a5 || t5.has(e4.type) || (t5.add(e4.type), le(e4, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", c4(e4));
        })), n7.__reactInternalSnapshotBeforeUpdate = a5;
      } catch (n8) {
        Qa(e4, e4.return, n8);
      }
    }
    function wl(e4, n7, t5) {
      t5.props = Cr(e4.type, e4.memoizedProps), t5.state = e4.memoizedState, fl(e4) ? (je(), le(e4, Dc, e4, n7, t5), Ie()) : le(e4, Dc, e4, n7, t5);
    }
    function zl(e4) {
      var n7 = e4.ref;
      if (null !== n7) {
        switch (e4.tag) {
          case 26:
          case 27:
          case 5:
            var t5 = Io(e4.stateNode);
            break;
          default:
            t5 = e4.stateNode;
        }
        if ("function" == typeof n7) if (fl(e4)) try {
          je(), e4.refCleanup = n7(t5);
        } finally {
          Ie();
        }
        else e4.refCleanup = n7(t5);
        else "string" == typeof n7 ? console.error("String refs are no longer supported.") : n7.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", c4(e4)), n7.current = t5;
      }
    }
    function xl(e4, n7) {
      try {
        le(e4, zl, e4);
      } catch (t5) {
        Qa(e4, n7, t5);
      }
    }
    function El(e4, n7) {
      var t5 = e4.ref, r6 = e4.refCleanup;
      if (null !== t5) if ("function" == typeof r6) try {
        if (fl(e4)) try {
          je(), le(e4, r6);
        } finally {
          Ie();
        }
        else le(e4, r6);
      } catch (t6) {
        Qa(e4, n7, t6);
      } finally {
        e4.refCleanup = null, null != (e4 = e4.alternate) && (e4.refCleanup = null);
      }
      else if ("function" == typeof t5) try {
        if (fl(e4)) try {
          je(), le(e4, t5, null);
        } finally {
          Ie();
        }
        else le(e4, t5, null);
      } catch (t6) {
        Qa(e4, n7, t6);
      }
      else t5.current = null;
    }
    function Cl(e4, n7, t5, r6) {
      var l3 = e4.memoizedProps, a5 = l3.id, o3 = l3.onCommit;
      l3 = l3.onRender, n7 = null === n7 ? "mount" : "update", Js && (n7 = "nested-update"), "function" == typeof l3 && l3(a5, n7, e4.actualDuration, e4.treeBaseDuration, e4.actualStartTime, t5), "function" == typeof o3 && o3(a5, n7, r6, t5);
    }
    function Pl(e4, n7, t5, r6) {
      var l3 = e4.memoizedProps;
      e4 = l3.id, l3 = l3.onPostCommit, n7 = null === n7 ? "mount" : "update", Js && (n7 = "nested-update"), "function" == typeof l3 && l3(e4, n7, r6, t5);
    }
    function _l(e4) {
      var n7 = e4.type, t5 = e4.memoizedProps, r6 = e4.stateNode;
      try {
        le(e4, vu, r6, n7, t5, e4);
      } catch (n8) {
        Qa(e4, e4.return, n8);
      }
    }
    function Tl(e4) {
      return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
    }
    function Rl(e4) {
      e: for (; ; ) {
        for (; null === e4.sibling; ) {
          if (null === e4.return || Tl(e4.return)) return null;
          e4 = e4.return;
        }
        for (e4.sibling.return = e4.return, e4 = e4.sibling; 5 !== e4.tag && 6 !== e4.tag && 18 !== e4.tag; ) {
          if (2 & e4.flags) continue e;
          if (null === e4.child || 4 === e4.tag) continue e;
          e4.child.return = e4, e4 = e4.child;
        }
        if (!(2 & e4.flags)) return e4.stateNode;
      }
    }
    function Nl(e4, n7, t5) {
      var r6 = e4.tag;
      if (5 === r6 || 6 === r6) e4 = e4.stateNode, n7 ? wu(t5, e4, n7) : yu(t5, e4);
      else if (4 !== r6 && null !== (e4 = e4.child)) for (Nl(e4, n7, t5), e4 = e4.sibling; null !== e4; ) Nl(e4, n7, t5), e4 = e4.sibling;
    }
    function Ll(e4, n7, t5) {
      var r6 = e4.tag;
      if (5 === r6 || 6 === r6) e4 = e4.stateNode, n7 ? ku(t5, e4, n7) : gu(t5, e4);
      else if (4 !== r6 && null !== (e4 = e4.child)) for (Ll(e4, n7, t5), e4 = e4.sibling; null !== e4; ) Ll(e4, n7, t5), e4 = e4.sibling;
    }
    function Ul(e4) {
      for (var n7, t5 = e4.return; null !== t5; ) {
        if (Tl(t5)) {
          n7 = t5;
          break;
        }
        t5 = t5.return;
      }
      if (null == n7) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      switch (n7.tag) {
        case 27:
        case 5:
          t5 = n7.stateNode, 32 & n7.flags && (Eu(t5), n7.flags &= -33), Ll(e4, n7 = Rl(e4), t5);
          break;
        case 3:
        case 4:
          n7 = n7.stateNode.containerInfo, Nl(e4, t5 = Rl(e4), n7);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Dl(e4, n7) {
      return 31 === n7.tag ? (n7 = n7.memoizedState, null !== e4.memoizedState && null === n7) : 13 === n7.tag ? (e4 = e4.memoizedState, n7 = n7.memoizedState, null !== e4 && null !== e4.dehydrated && (null === n7 || null === n7.dehydrated)) : 3 === n7.tag && e4.memoizedState.isDehydrated && 0 == (256 & n7.flags);
    }
    function Il(e4, n7, t5) {
      var r6 = Ce(), l3 = _e(), a5 = Re(), o3 = Ne(), u4 = t5.flags;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Bl(e4, t5), 4 & u4 && pl(t5, Cd | xd);
          break;
        case 1:
          if (Bl(e4, t5), 4 & u4) if (e4 = t5.stateNode, null === n7) t5.type.defaultProps || "ref" in t5.memoizedProps || kf || (e4.props !== t5.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(t5) || "instance"), e4.state !== t5.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(t5) || "instance")), fl(t5) ? (je(), le(t5, _c, t5, e4), Ie()) : le(t5, _c, t5, e4);
          else {
            var i5 = Cr(t5.type, n7.memoizedProps);
            n7 = n7.memoizedState, t5.type.defaultProps || "ref" in t5.memoizedProps || kf || (e4.props !== t5.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", c4(t5) || "instance"), e4.state !== t5.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", c4(t5) || "instance")), fl(t5) ? (je(), le(t5, Rc, t5, e4, i5, n7, e4.__reactInternalSnapshotBeforeUpdate), Ie()) : le(t5, Rc, t5, e4, i5, n7, e4.__reactInternalSnapshotBeforeUpdate);
          }
          64 & u4 && vl(t5), 512 & u4 && xl(t5, t5.return);
          break;
        case 3:
          if (n7 = we(), Bl(e4, t5), 64 & u4 && null !== (u4 = t5.updateQueue)) {
            if (i5 = null, null !== t5.child) switch (t5.child.tag) {
              case 27:
              case 5:
                i5 = Io(t5.child.stateNode);
                break;
              case 1:
                i5 = t5.child.stateNode;
            }
            try {
              le(t5, Fn, u4, i5);
            } catch (e5) {
              Qa(t5, t5.return, e5);
            }
          }
          e4.effectDuration += ze(n7);
          break;
        case 27:
        case 26:
        case 5:
          if (Bl(e4, t5), null === n7) {
            if (4 & u4) _l(t5);
            else if (64 & u4) {
              e4 = t5.type, n7 = t5.memoizedProps, i5 = t5.stateNode;
              try {
                le(t5, Iu, i5, e4, n7, t5);
              } catch (e5) {
                Qa(t5, t5.return, e5);
              }
            }
          }
          512 & u4 && xl(t5, t5.return);
          break;
        case 12:
          if (4 & u4) {
            u4 = we(), Bl(e4, t5), (e4 = t5.stateNode).effectDuration += xe(u4);
            try {
              le(t5, Cl, t5, n7, gs, e4.effectDuration);
            } catch (e5) {
              Qa(t5, t5.return, e5);
            }
          } else Bl(e4, t5);
          break;
        case 31:
        default:
          Bl(e4, t5);
          break;
        case 13:
          Bl(e4, t5), 64 & u4 && null !== (e4 = t5.memoizedState) && null !== (e4 = e4.dehydrated) && (u4 = qa.bind(null, t5), Du(e4, u4));
          break;
        case 22:
          if (!(u4 = null !== t5.memoizedState || Pf)) {
            n7 = null !== n7 && null !== n7.memoizedState || _f, i5 = Pf;
            var s3 = _f;
            Pf = u4, (_f = n7) && !s3 ? (Yl(e4, t5, 0 != (8772 & t5.subtreeFlags)), (2 & t5.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && U(t5, ws, zs)) : Bl(e4, t5), Pf = i5, _f = s3;
          }
        case 30:
      }
      (2 & t5.mode) !== ts && 0 <= ws && 0 <= zs && ((Es || 0.05 < ks) && F(t5, ws, zs, ks, xs), null === t5.alternate && null !== t5.return && null !== t5.return.alternate && 0.05 < zs - ws && (Dl(t5.return.alternate, t5.return) || L(t5, ws, zs, "Mount"))), Pe(r6), Te(l3), xs = a5, Es = o3;
    }
    function Fl(e4) {
      var n7 = e4.alternate;
      null !== n7 && (e4.alternate = null, Fl(n7)), e4.child = null, e4.deletions = null, e4.sibling = null, 5 === e4.tag && null !== (n7 = e4.stateNode) && lu(n7), e4.stateNode = null, e4._debugOwner = null, e4.return = null, e4.dependencies = null, e4.memoizedProps = null, e4.memoizedState = null, e4.pendingProps = null, e4.stateNode = null, e4.updateQueue = null;
    }
    function jl(e4, n7, t5) {
      for (t5 = t5.child; null !== t5; ) Al(e4, n7, t5), t5 = t5.sibling;
    }
    function Al(e4, n7, t5) {
      var r6 = Ce(), l3 = _e(), a5 = Re(), o3 = Ne();
      switch (t5.tag) {
        case 26:
        case 27:
          var u4, i5;
        case 5:
          _f || El(t5, n7);
        case 6:
          if (u4 = Df, i5 = If, Df = null, jl(e4, n7, t5), If = i5, null !== (Df = u4)) if (If) try {
            le(t5, xu, Df, t5.stateNode);
          } catch (e5) {
            Qa(t5, n7, e5);
          }
          else try {
            le(t5, zu, Df, t5.stateNode);
          } catch (e5) {
            Qa(t5, n7, e5);
          }
          break;
        case 18:
          null !== Df && (If ? ju(Df, t5.stateNode) : Fu(Df, t5.stateNode));
          break;
        case 4:
          u4 = Df, i5 = If, Df = t5.stateNode.containerInfo, If = true, jl(e4, n7, t5), Df = u4, If = i5;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          gl(Ed, t5, n7), _f || ml(t5, n7, Cd), jl(e4, n7, t5);
          break;
        case 1:
          _f || (El(t5, n7), "function" == typeof (u4 = t5.stateNode).componentWillUnmount && wl(t5, n7, u4)), jl(e4, n7, t5);
          break;
        case 21:
          jl(e4, n7, t5);
          break;
        case 22:
          _f = (u4 = _f) || null !== t5.memoizedState, jl(e4, n7, t5), _f = u4;
          break;
        default:
          jl(e4, n7, t5);
      }
      (2 & t5.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(t5, ws, zs, ks, xs), Pe(r6), Te(l3), xs = a5, Es = o3;
    }
    function Hl(e4, n7) {
      var t5 = function(e5) {
        switch (e5.tag) {
          case 31:
          case 13:
          case 19:
            var n8 = e5.stateNode;
            return null === n8 && (n8 = e5.stateNode = new Rf()), n8;
          case 22:
            return null === (n8 = (e5 = e5.stateNode)._retryCache) && (n8 = e5._retryCache = new Rf()), n8;
          default:
            throw Error("Unexpected Suspense handler tag (" + e5.tag + "). This is a bug in React.");
        }
      }(e4);
      n7.forEach(function(n8) {
        if (!t5.has(n8)) {
          if (t5.add(n8), fi) {
            if (null === Lf || null === Uf) throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            Za(Uf, Lf);
          }
          var r6 = Ya.bind(null, e4, n8);
          n8.then(r6, r6);
        }
      });
    }
    function Ol(e4, n7) {
      var t5 = n7.deletions;
      if (null !== t5) for (var r6 = 0; r6 < t5.length; r6++) {
        var l3 = e4, a5 = n7, o3 = t5[r6], u4 = Ce(), i5 = a5;
        e: for (; null !== i5; ) {
          switch (i5.tag) {
            case 27:
            case 5:
              Df = i5.stateNode, If = false;
              break e;
            case 3:
            case 4:
              Df = i5.stateNode.containerInfo, If = true;
              break e;
          }
          i5 = i5.return;
        }
        if (null === Df) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        Al(l3, a5, o3), Df = null, If = false, (2 & o3.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && L(o3, ws, zs, "Unmount"), Pe(u4), null !== (a5 = (l3 = o3).alternate) && (a5.return = null), l3.return = null;
      }
      if (13886 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) Ml(n7, e4), n7 = n7.sibling;
    }
    function Ml(e4, n7) {
      var t5 = Ce(), r6 = _e(), l3 = Re(), a5 = Ne(), o3 = e4.alternate, u4 = e4.flags;
      switch (e4.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ol(n7, e4), Wl(e4), 4 & u4 && (gl(Ed | xd, e4, e4.return), hl(Ed | xd, e4), ml(e4, e4.return, Cd | xd));
          break;
        case 1:
          Ol(n7, e4), Wl(e4), 512 & u4 && (_f || null === o3 || El(o3, o3.return)), 64 & u4 && Pf && null !== (u4 = e4.updateQueue) && null !== (o3 = u4.callbacks) && (n7 = u4.shared.hiddenCallbacks, u4.shared.hiddenCallbacks = null === n7 ? o3 : n7.concat(o3));
          break;
        case 26:
          var i5;
        case 27:
        case 5:
          if (Ol(n7, e4), Wl(e4), 512 & u4 && (_f || null === o3 || El(o3, o3.return)), 32 & e4.flags) {
            n7 = e4.stateNode;
            try {
              le(e4, Eu, n7);
            } catch (n8) {
              Qa(e4, e4.return, n8);
            }
          }
          4 & u4 && null != e4.stateNode && function(e5, n8, t6) {
            try {
              le(e5, Su, e5.stateNode, e5.type, t6, n8, e5);
            } catch (n9) {
              Qa(e5, e5.return, n9);
            }
          }(e4, n7 = e4.memoizedProps, null !== o3 ? o3.memoizedProps : n7), 1024 & u4 && (Tf = true, "form" !== e4.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          if (Ol(n7, e4), Wl(e4), 4 & u4 && Yo) {
            if (null === e4.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            u4 = e4.memoizedProps, o3 = null !== o3 ? o3.memoizedProps : u4, n7 = e4.stateNode;
            try {
              le(e4, bu, n7, o3, u4);
            } catch (n8) {
              Qa(e4, e4.return, n8);
            }
          }
          break;
        case 3:
          var s3;
          i5 = we(), Ol(n7, e4), Wl(e4), Tf && (Tf = false, Ql(e4)), n7.effectDuration += ze(i5);
          break;
        case 4:
          Ol(n7, e4), Wl(e4);
          break;
        case 12:
          u4 = we(), Ol(n7, e4), Wl(e4), e4.stateNode.effectDuration += xe(u4);
          break;
        case 31:
          Ol(n7, e4), Wl(e4), 4 & u4 && null !== (u4 = e4.updateQueue) && (e4.updateQueue = null, Hl(e4, u4));
          break;
        case 13:
          Ol(n7, e4), Wl(e4), 8192 & e4.child.flags && null !== e4.memoizedState != (null !== o3 && null !== o3.memoizedState) && (Pp = li()), 4 & u4 && null !== (u4 = e4.updateQueue) && (e4.updateQueue = null, Hl(e4, u4));
          break;
        case 22:
          i5 = null !== e4.memoizedState;
          var c5 = null !== o3 && null !== o3.memoizedState, d3 = Pf, f4 = _f;
          if (Pf = d3 || i5, _f = f4 || c5, Ol(n7, e4), _f = f4, Pf = d3, c5 && !i5 && !d3 && !f4 && (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && U(e4, ws, zs), Wl(e4), 8192 & u4 && ((n7 = e4.stateNode)._visibility = i5 ? -2 & n7._visibility : n7._visibility | rd, !i5 || null === o3 || c5 || Pf || _f || (Vl(e4), (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && L(e4, ws, zs, "Disconnect")), Yo)) {
            e: if (o3 = null, Yo) for (n7 = e4; ; ) {
              if (5 === n7.tag || Ou) {
                if (null === o3) {
                  c5 = o3 = n7;
                  try {
                    s3 = c5.stateNode, i5 ? le(c5, Cu, s3) : le(c5, _u, c5.stateNode, c5.memoizedProps);
                  } catch (e5) {
                    Qa(c5, c5.return, e5);
                  }
                }
              } else if (6 === n7.tag) {
                if (null === o3) {
                  c5 = n7;
                  try {
                    var p4 = c5.stateNode;
                    i5 ? le(c5, Pu, p4) : le(c5, Tu, p4, c5.memoizedProps);
                  } catch (e5) {
                    Qa(c5, c5.return, e5);
                  }
                }
              } else if (18 === n7.tag) {
                if (null === o3) {
                  c5 = n7;
                  try {
                    var m2 = c5.stateNode;
                    i5 ? le(c5, Au, m2) : le(c5, Hu, c5.stateNode);
                  } catch (e5) {
                    Qa(c5, c5.return, e5);
                  }
                }
              } else if ((22 !== n7.tag && 23 !== n7.tag || null === n7.memoizedState || n7 === e4) && null !== n7.child) {
                n7.child.return = n7, n7 = n7.child;
                continue;
              }
              if (n7 === e4) break e;
              for (; null === n7.sibling; ) {
                if (null === n7.return || n7.return === e4) break e;
                o3 === n7 && (o3 = null), n7 = n7.return;
              }
              o3 === n7 && (o3 = null), n7.sibling.return = n7.return, n7 = n7.sibling;
            }
          }
          4 & u4 && null !== (u4 = e4.updateQueue) && null !== (o3 = u4.retryQueue) && (u4.retryQueue = null, Hl(e4, o3));
          break;
        case 19:
          Ol(n7, e4), Wl(e4), 4 & u4 && null !== (u4 = e4.updateQueue) && (e4.updateQueue = null, Hl(e4, u4));
          break;
        case 30:
        case 21:
          break;
        default:
          Ol(n7, e4), Wl(e4);
      }
      (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && ((Es || 0.05 < ks) && F(e4, ws, zs, ks, xs), null === e4.alternate && null !== e4.return && null !== e4.return.alternate && 0.05 < zs - ws && (Dl(e4.return.alternate, e4.return) || L(e4, ws, zs, "Mount"))), Pe(t5), Te(r6), xs = l3, Es = a5;
    }
    function Wl(e4) {
      var n7 = e4.flags;
      if (2 & n7) {
        try {
          le(e4, Ul, e4);
        } catch (n8) {
          Qa(e4, e4.return, n8);
        }
        e4.flags &= -3;
      }
      4096 & n7 && (e4.flags &= -4097);
    }
    function Ql(e4) {
      if (1024 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) {
        var n7 = e4;
        Ql(n7), 5 === n7.tag && 1024 & n7.flags && hu(n7.stateNode), e4 = e4.sibling;
      }
    }
    function Bl(e4, n7) {
      if (8772 & n7.subtreeFlags) for (n7 = n7.child; null !== n7; ) Il(e4, n7.alternate, n7), n7 = n7.sibling;
    }
    function $l(e4) {
      var n7 = Ce(), t5 = _e(), r6 = Re(), l3 = Ne();
      switch (e4.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ml(e4, e4.return, Cd), Vl(e4);
          break;
        case 1:
          El(e4, e4.return);
          var a5 = e4.stateNode;
          "function" == typeof a5.componentWillUnmount && wl(e4, e4.return, a5), Vl(e4);
          break;
        case 27:
        case 26:
        case 5:
          El(e4, e4.return), Vl(e4);
          break;
        case 22:
          null === e4.memoizedState && Vl(e4);
          break;
        default:
          Vl(e4);
      }
      (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(e4, ws, zs, ks, xs), Pe(n7), Te(t5), xs = r6, Es = l3;
    }
    function Vl(e4) {
      for (e4 = e4.child; null !== e4; ) $l(e4), e4 = e4.sibling;
    }
    function ql(e4, n7, t5, r6) {
      var l3 = Ce(), a5 = _e(), o3 = Re(), u4 = Ne(), i5 = t5.flags;
      switch (t5.tag) {
        case 0:
        case 11:
        case 15:
          Yl(e4, t5, r6), pl(t5, Cd);
          break;
        case 1:
          if (Yl(e4, t5, r6), "function" == typeof (n7 = t5.stateNode).componentDidMount && le(t5, _c, t5, n7), null !== (n7 = t5.updateQueue)) {
            e4 = t5.stateNode;
            try {
              le(t5, In, n7, e4);
            } catch (e5) {
              Qa(t5, t5.return, e5);
            }
          }
          r6 && 64 & i5 && vl(t5), xl(t5, t5.return);
          break;
        case 27:
        case 26:
        case 5:
          Yl(e4, t5, r6), r6 && null === n7 && 4 & i5 && _l(t5), xl(t5, t5.return);
          break;
        case 12:
          if (r6 && 4 & i5) {
            i5 = we(), Yl(e4, t5, r6), (r6 = t5.stateNode).effectDuration += xe(i5);
            try {
              le(t5, Cl, t5, n7, gs, r6.effectDuration);
            } catch (e5) {
              Qa(t5, t5.return, e5);
            }
          } else Yl(e4, t5, r6);
          break;
        case 31:
        case 13:
        default:
          Yl(e4, t5, r6);
          break;
        case 22:
          null === t5.memoizedState && Yl(e4, t5, r6), xl(t5, t5.return);
        case 30:
      }
      (2 & t5.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(t5, ws, zs, ks, xs), Pe(l3), Te(a5), xs = o3, Es = u4;
    }
    function Yl(e4, n7, t5) {
      for (t5 = t5 && 0 != (8772 & n7.subtreeFlags), n7 = n7.child; null !== n7; ) ql(e4, n7.alternate, n7, t5), n7 = n7.sibling;
    }
    function Gl(e4, n7) {
      var t5 = null;
      null !== e4 && null !== e4.memoizedState && null !== e4.memoizedState.cachePool && (t5 = e4.memoizedState.cachePool.pool), e4 = null, null !== n7.memoizedState && null !== n7.memoizedState.cachePool && (e4 = n7.memoizedState.cachePool.pool), e4 !== t5 && (null != e4 && ve(e4), null != t5 && Se(t5));
    }
    function Jl(e4, n7) {
      e4 = null, null !== n7.alternate && (e4 = n7.alternate.memoizedState.cache), (n7 = n7.memoizedState.cache) !== e4 && (ve(n7), null != e4 && Se(e4));
    }
    function Kl(e4, n7, t5, r6, l3) {
      if (10256 & n7.subtreeFlags || 0 !== n7.actualDuration && (null === n7.alternate || n7.alternate.child !== n7.child)) for (n7 = n7.child; null !== n7; ) {
        var a5 = n7.sibling;
        Xl(e4, n7, t5, r6, null !== a5 ? a5.actualStartTime : l3), n7 = a5;
      }
    }
    function Xl(e4, n7, t5, r6, l3) {
      var a5 = Ce(), o3 = _e(), u4 = Re(), i5 = Ne(), s3 = _i, c5 = n7.flags;
      switch (n7.tag) {
        case 0:
        case 11:
        case 15:
          (2 & n7.mode) !== ts && 0 < n7.actualStartTime && 0 != (1 & n7.flags) && D(n7, n7.actualStartTime, l3, jf, t5), Kl(e4, n7, t5, r6, l3), 2048 & c5 && yl(n7, Pd | xd);
          break;
        case 1:
          (2 & n7.mode) !== ts && 0 < n7.actualStartTime && (0 != (128 & n7.flags) ? I(n7, n7.actualStartTime, l3, []) : 0 != (1 & n7.flags) && D(n7, n7.actualStartTime, l3, jf, t5)), Kl(e4, n7, t5, r6, l3);
          break;
        case 3:
          var d3 = we(), f4 = jf;
          jf = null !== n7.alternate && n7.alternate.memoizedState.isDehydrated && 0 == (256 & n7.flags), Kl(e4, n7, t5, r6, l3), jf = f4, 2048 & c5 && (t5 = null, null !== n7.alternate && (t5 = n7.alternate.memoizedState.cache), (r6 = n7.memoizedState.cache) !== t5 && (ve(r6), null != t5 && Se(t5))), e4.passiveEffectDuration += ze(d3);
          break;
        case 12:
          if (2048 & c5) {
            c5 = we(), Kl(e4, n7, t5, r6, l3), (e4 = n7.stateNode).passiveEffectDuration += xe(c5);
            try {
              le(n7, Pl, n7, n7.alternate, gs, e4.passiveEffectDuration);
            } catch (e5) {
              Qa(n7, n7.return, e5);
            }
          } else Kl(e4, n7, t5, r6, l3);
          break;
        case 31:
          c5 = jf, d3 = null !== n7.alternate ? n7.alternate.memoizedState : null, f4 = n7.memoizedState, null !== d3 && null === f4 ? null !== (f4 = n7.deletions) && 0 < f4.length && 18 === f4[0].tag ? (jf = false, null !== (d3 = d3.hydrationErrors) && I(n7, n7.actualStartTime, l3, d3)) : jf = true : jf = false, Kl(e4, n7, t5, r6, l3), jf = c5;
          break;
        case 13:
          c5 = jf, d3 = null !== n7.alternate ? n7.alternate.memoizedState : null, f4 = n7.memoizedState, null === d3 || null === d3.dehydrated || null !== f4 && null !== f4.dehydrated ? jf = false : null !== (f4 = n7.deletions) && 0 < f4.length && 18 === f4[0].tag ? (jf = false, null !== (d3 = d3.hydrationErrors) && I(n7, n7.actualStartTime, l3, d3)) : jf = true, Kl(e4, n7, t5, r6, l3), jf = c5;
          break;
        case 23:
          break;
        case 22:
          f4 = n7.stateNode, d3 = n7.alternate, null !== n7.memoizedState ? f4._visibility & ld ? Kl(e4, n7, t5, r6, l3) : na(e4, n7, t5, r6, l3) : f4._visibility & ld ? Kl(e4, n7, t5, r6, l3) : (f4._visibility |= ld, Zl(e4, n7, t5, r6, 0 != (10256 & n7.subtreeFlags) || 0 !== n7.actualDuration && (null === n7.alternate || n7.alternate.child !== n7.child), l3), (2 & n7.mode) === ts || jf || (0 <= (e4 = n7.actualStartTime) && 0.05 < l3 - e4 && U(n7, e4, l3), 0 <= ws && 0 <= zs && 0.05 < zs - ws && U(n7, ws, zs))), 2048 & c5 && Gl(d3, n7);
          break;
        case 24:
          Kl(e4, n7, t5, r6, l3), 2048 & c5 && Jl(n7.alternate, n7);
          break;
        default:
          Kl(e4, n7, t5, r6, l3);
      }
      (2 & n7.mode) !== ts && ((e4 = !jf && null === n7.alternate && null !== n7.return && null !== n7.return.alternate) && 0 <= (t5 = n7.actualStartTime) && 0.05 < l3 - t5 && L(n7, t5, l3, "Mount"), 0 <= ws && 0 <= zs && ((Es || 0.05 < ks) && F(n7, ws, zs, ks, xs), e4 && 0.05 < zs - ws && L(n7, ws, zs, "Mount"))), Pe(a5), Te(o3), xs = u4, Es = i5, _i = s3;
    }
    function Zl(e4, n7, t5, r6, l3, a5) {
      for (l3 = l3 && (0 != (10256 & n7.subtreeFlags) || 0 !== n7.actualDuration && (null === n7.alternate || n7.alternate.child !== n7.child)), n7 = n7.child; null !== n7; ) {
        var o3 = n7.sibling;
        ea(e4, n7, t5, r6, l3, null !== o3 ? o3.actualStartTime : a5), n7 = o3;
      }
    }
    function ea(e4, n7, t5, r6, l3, a5) {
      var o3 = Ce(), u4 = _e(), i5 = Re(), s3 = Ne(), c5 = _i;
      l3 && (2 & n7.mode) !== ts && 0 < n7.actualStartTime && 0 != (1 & n7.flags) && D(n7, n7.actualStartTime, a5, jf, t5);
      var d3 = n7.flags;
      switch (n7.tag) {
        case 0:
        case 11:
        case 15:
          Zl(e4, n7, t5, r6, l3, a5), yl(n7, Pd);
          break;
        case 23:
          break;
        case 22:
          var f4 = n7.stateNode;
          null !== n7.memoizedState ? f4._visibility & ld ? Zl(e4, n7, t5, r6, l3, a5) : na(e4, n7, t5, r6, a5) : (f4._visibility |= ld, Zl(e4, n7, t5, r6, l3, a5)), l3 && 2048 & d3 && Gl(n7.alternate, n7);
          break;
        case 24:
          Zl(e4, n7, t5, r6, l3, a5), l3 && 2048 & d3 && Jl(n7.alternate, n7);
          break;
        default:
          Zl(e4, n7, t5, r6, l3, a5);
      }
      (2 & n7.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(n7, ws, zs, ks, xs), Pe(o3), Te(u4), xs = i5, Es = s3, _i = c5;
    }
    function na(e4, n7, t5, r6, l3) {
      if (10256 & n7.subtreeFlags || 0 !== n7.actualDuration && (null === n7.alternate || n7.alternate.child !== n7.child)) for (var a5 = n7.child; null !== a5; ) {
        var o3 = e4, u4 = t5, i5 = r6, s3 = null !== (n7 = a5.sibling) ? n7.actualStartTime : l3, c5 = _i;
        (2 & a5.mode) !== ts && 0 < a5.actualStartTime && 0 != (1 & a5.flags) && D(a5, a5.actualStartTime, s3, jf, u4);
        var d3 = a5.flags;
        switch (a5.tag) {
          case 22:
            na(o3, a5, u4, i5, s3), 2048 & d3 && Gl(a5.alternate, a5);
            break;
          case 24:
            na(o3, a5, u4, i5, s3), 2048 & d3 && Jl(a5.alternate, a5);
            break;
          default:
            na(o3, a5, u4, i5, s3);
        }
        _i = c5, a5 = n7;
      }
    }
    function ta(e4, n7, t5) {
      if (e4.subtreeFlags & Af) for (e4 = e4.child; null !== e4; ) ra(e4, n7, t5), e4 = e4.sibling;
    }
    function ra(e4, n7, t5) {
      switch (e4.tag) {
        case 26:
          if (ta(e4, n7, t5), e4.flags & Af) if (null !== e4.memoizedState) Wu(t5, Ff, e4.memoizedState, e4.memoizedProps);
          else {
            var r6 = e4.stateNode, l3 = e4.type;
            e4 = e4.memoizedProps, ((335544128 & n7) === n7 || uu(l3, e4)) && cu(t5, r6, l3, e4);
          }
          break;
        case 5:
          ta(e4, n7, t5), e4.flags & Af && (r6 = e4.stateNode, l3 = e4.type, e4 = e4.memoizedProps, ((335544128 & n7) === n7 || uu(l3, e4)) && cu(t5, r6, l3, e4));
          break;
        case 3:
        case 4:
        default:
          ta(e4, n7, t5);
          break;
        case 22:
          null === e4.memoizedState && (null !== (r6 = e4.alternate) && null !== r6.memoizedState ? (r6 = Af, Af = 16777216, ta(e4, n7, t5), Af = r6) : ta(e4, n7, t5));
      }
    }
    function la(e4) {
      var n7 = e4.alternate;
      if (null !== n7 && null !== (e4 = n7.child)) {
        n7.child = null;
        do {
          n7 = e4.sibling, e4.sibling = null, e4 = n7;
        } while (null !== e4);
      }
    }
    function aa(e4) {
      var n7 = e4.deletions;
      if (0 != (16 & e4.flags)) {
        if (null !== n7) for (var t5 = 0; t5 < n7.length; t5++) {
          var r6 = n7[t5], l3 = Ce();
          Nf = r6, sa(r6, e4), (2 & r6.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && L(r6, ws, zs, "Unmount"), Pe(l3);
        }
        la(e4);
      }
      if (10256 & e4.subtreeFlags) for (e4 = e4.child; null !== e4; ) oa(e4), e4 = e4.sibling;
    }
    function oa(e4) {
      var n7 = Ce(), t5 = _e(), r6 = Re(), l3 = Ne();
      switch (e4.tag) {
        case 0:
        case 11:
        case 15:
          aa(e4), 2048 & e4.flags && bl(e4, e4.return, Pd | xd);
          break;
        case 3:
          var a5 = we();
          aa(e4), e4.stateNode.passiveEffectDuration += ze(a5);
          break;
        case 12:
          a5 = we(), aa(e4), e4.stateNode.passiveEffectDuration += xe(a5);
          break;
        case 22:
          a5 = e4.stateNode, null !== e4.memoizedState && a5._visibility & ld && (null === e4.return || 13 !== e4.return.tag) ? (a5._visibility &= -3, ua(e4), (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && L(e4, ws, zs, "Disconnect")) : aa(e4);
          break;
        default:
          aa(e4);
      }
      (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(e4, ws, zs, ks, xs), Pe(n7), Te(t5), Es = l3, xs = r6;
    }
    function ua(e4) {
      var n7 = e4.deletions;
      if (0 != (16 & e4.flags)) {
        if (null !== n7) for (var t5 = 0; t5 < n7.length; t5++) {
          var r6 = n7[t5], l3 = Ce();
          Nf = r6, sa(r6, e4), (2 & r6.mode) !== ts && 0 <= ws && 0 <= zs && 0.05 < zs - ws && L(r6, ws, zs, "Unmount"), Pe(l3);
        }
        la(e4);
      }
      for (e4 = e4.child; null !== e4; ) ia(e4), e4 = e4.sibling;
    }
    function ia(e4) {
      var n7 = Ce(), t5 = _e(), r6 = Re(), l3 = Ne();
      switch (e4.tag) {
        case 0:
        case 11:
        case 15:
          bl(e4, e4.return, Pd), ua(e4);
          break;
        case 22:
          var a5 = e4.stateNode;
          a5._visibility & ld && (a5._visibility &= -3, ua(e4));
          break;
        default:
          ua(e4);
      }
      (2 & e4.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(e4, ws, zs, ks, xs), Pe(n7), Te(t5), Es = l3, xs = r6;
    }
    function sa(e4, n7) {
      for (; null !== Nf; ) {
        var t5 = Nf, r6 = t5, l3 = n7, a5 = Ce(), o3 = _e(), u4 = Re(), i5 = Ne();
        switch (r6.tag) {
          case 0:
          case 11:
          case 15:
            bl(r6, l3, Pd);
            break;
          case 23:
          case 22:
            null !== r6.memoizedState && null !== r6.memoizedState.cachePool && null != (l3 = r6.memoizedState.cachePool.pool) && ve(l3);
            break;
          case 24:
            Se(r6.memoizedState.cache);
        }
        if ((2 & r6.mode) !== ts && 0 <= ws && 0 <= zs && (Es || 0.05 < ks) && F(r6, ws, zs, ks, xs), Pe(a5), Te(o3), Es = i5, xs = u4, null !== (r6 = t5.child)) r6.return = t5, Nf = r6;
        else e: for (t5 = e4; null !== Nf; ) {
          if (a5 = (r6 = Nf).sibling, o3 = r6.return, Fl(r6), r6 === t5) {
            Nf = null;
            break e;
          }
          if (null !== a5) {
            a5.return = o3, Nf = a5;
            break e;
          }
          Nf = o3;
        }
      }
    }
    function ca() {
      var e4 = "undefined" != typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return e4 || null === Do.actQueue || console.error("The current testing environment is not configured to support act(...)"), e4;
    }
    function da(e4) {
      if ((Xf & Qf) !== Wf && 0 !== np) return np & -np;
      var n7 = Do.T;
      return null !== n7 ? (n7._updatedFibers || (n7._updatedFibers = /* @__PURE__ */ new Set()), n7._updatedFibers.add(e4), Ge()) : Zo();
    }
    function fa() {
      if (0 === wp) if (0 == (536870912 & np) || es) {
        var e4 = Xu;
        0 == (3932160 & (Xu <<= 1)) && (Xu = 262144), wp = e4;
      } else wp = 536870912;
      return null !== (e4 = bd.current) && (e4.flags |= 32), wp;
    }
    function pa(e4, n7, t5) {
      if (cm && console.error("useInsertionEffect must not schedule updates."), am && (om = true), (e4 !== Zf || fp !== lp && fp !== dp) && null === e4.cancelPendingCommit || (Sa(e4, 0), ya(e4, np, wp, false)), S3(e4, t5), (Xf & Qf) !== Wf && e4 === Zf) {
        if (Zi) switch (n7.tag) {
          case 0:
          case 11:
          case 15:
            e4 = ep && c4(ep) || "Unknown", pm.has(e4) || (pm.add(e4), n7 = c4(n7) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", n7, e4, e4));
            break;
          case 1:
            fm || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), fm = true);
        }
      } else fi && x(e4, n7, t5), function(e5) {
        ca() && null === Do.actQueue && le(e5, function() {
          console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", c4(e5));
        });
      }(n7), e4 === Zf && ((Xf & Qf) === Wf && (Sp |= t5), bp === Gf && ya(e4, np, wp, false)), Oe(e4);
    }
    function ma(e4, n7, t5) {
      if ((Xf & (Qf | Bf)) !== Wf) throw Error("Should not already be working.");
      if (0 !== np && null !== ep) {
        var r6 = ep, l3 = li();
        switch (Ys) {
          case ap:
          case lp:
            var a5 = Gs;
            Ci && ((r6 = r6._debugTask) ? r6.run(console.timeStamp.bind(console, "Suspended", a5, l3, "Components ", void 0, "primary-light")) : console.timeStamp("Suspended", a5, l3, "Components ", void 0, "primary-light"));
            break;
          case dp:
            a5 = Gs, Ci && ((r6 = r6._debugTask) ? r6.run(console.timeStamp.bind(console, "Action", a5, l3, "Components ", void 0, "primary-light")) : console.timeStamp("Action", a5, l3, "Components ", void 0, "primary-light"));
            break;
          default:
            Ci && (3 > (r6 = l3 - Gs) || console.timeStamp("Blocked", Gs, l3, "Components ", void 0, 5 > r6 ? "primary-light" : 10 > r6 ? "primary" : 100 > r6 ? "primary-dark" : "error"));
        }
      }
      a5 = (t5 = !t5 && 0 == (127 & n7) && 0 == (n7 & e4.expiredLanes) || g3(e4, n7)) ? function(e5, n8) {
        var t6 = Xf;
        Xf |= Qf;
        var r7 = wa(), l4 = za();
        if (Zf !== e5 || np !== n8) {
          if (fi) {
            var a6 = e5.memoizedUpdaters;
            0 < a6.size && (Za(e5, np), a6.clear()), E(e5, n8);
          }
          Lp = null, Rp = li() + Np, Sa(e5, n8);
        } else hp = g3(e5, n8);
        e: for (; ; ) try {
          if (fp !== tp && null !== ep) n: switch (n8 = ep, a6 = pp, fp) {
            case rp:
              fp = tp, pp = null, La(e5, n8, a6, rp);
              break;
            case lp:
            case dp:
              if (nn(a6)) {
                fp = tp, pp = null, Ra(n8);
                break;
              }
              n8 = function() {
                fp !== lp && fp !== dp || Zf !== e5 || (fp = sp), Oe(e5);
              }, a6.then(n8, n8);
              break e;
            case ap:
              fp = sp;
              break e;
            case op:
              fp = up;
              break e;
            case sp:
              nn(a6) ? (fp = tp, pp = null, Ra(n8)) : (fp = tp, pp = null, La(e5, n8, a6, sp));
              break;
            case up:
              var o4 = null;
              switch (ep.tag) {
                case 26:
                  o4 = ep.memoizedState;
                case 5:
                case 27:
                  var u5 = ep, i6 = u5.type, s3 = u5.pendingProps;
                  if (o4 ? Mu(o4) : iu(u5.stateNode, i6, s3)) {
                    fp = tp, pp = null;
                    var c5 = u5.sibling;
                    if (null !== c5) ep = c5;
                    else {
                      var d3 = u5.return;
                      null !== d3 ? (ep = d3, Ua(d3)) : ep = null;
                    }
                    break n;
                  }
                  break;
                default:
                  console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
              }
              fp = tp, pp = null, La(e5, n8, a6, up);
              break;
            case ip:
              fp = tp, pp = null, La(e5, n8, a6, ip);
              break;
            case cp:
              ba(), bp = Jf;
              break e;
            default:
              throw Error("Unexpected SuspendedReason. This is a bug in React.");
          }
          null !== Do.actQueue ? Pa() : _a();
          break;
        } catch (n9) {
          ka(e5, n9);
        }
        return ue(), Do.H = r7, Do.A = l4, Xf = t6, null !== ep ? $f : (Zf = null, np = 0, Sn(), bp);
      }(e4, n7) : Ca(e4, n7, true);
      for (var o3 = t5; ; ) {
        if (a5 === $f) {
          hp && !t5 && ya(e4, n7, 0, false), n7 = fp, Gs = ps(), Ys = n7;
          break;
        }
        if (r6 = li(), l3 = e4.current.alternate, !o3 || ga(l3)) {
          if (a5 === qf) {
            if (o3 = n7, e4.errorRecoveryDisabledLanes & o3) var u4 = 0;
            else u4 = 0 != (u4 = -536870913 & e4.pendingLanes) ? u4 : 536870912 & u4 ? 536870912 : 0;
            if (0 !== u4) {
              N(n7), H(hs, r6, 0, Up), va(n7, r6), n7 = u4;
              e: {
                r6 = e4, a5 = o3, o3 = xp;
                var i5 = Go;
                if (i5 && (Sa(r6, u4).flags |= 256), (u4 = Ca(r6, u4, false)) !== qf) {
                  if (gp && !i5) {
                    r6.errorRecoveryDisabledLanes |= a5, Sp |= a5, a5 = Gf;
                    break e;
                  }
                  r6 = Ep, Ep = o3, null !== r6 && (null === Ep ? Ep = r6 : Ep.push.apply(Ep, r6));
                }
                a5 = u4;
              }
              if (o3 = false, a5 !== qf) continue;
              r6 = li();
            }
          }
          if (a5 === Vf) {
            N(n7), H(hs, r6, 0, Up), va(n7, r6), Sa(e4, 0), ya(e4, n7, 0, true);
            break;
          }
          e: {
            switch (t5 = e4, a5) {
              case $f:
              case Vf:
                throw Error("Root did not complete. This is a bug in React.");
              case Gf:
                if ((4194048 & n7) !== n7) break;
              case Jf:
                N(n7), j(hs, r6, n7, Up), va(n7, r6), 0 != (127 & (l3 = n7)) ? Is = r6 : 0 != (4194048 & l3) && (Vs = r6), ya(t5, n7, wp, !mp);
                break e;
              case qf:
                Ep = null;
                break;
              case Yf:
              case Kf:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (null !== Do.actQueue) Ia(t5, l3, n7, Ep, Lp, Cp, wp, Sp, zp, a5, 0, null, hs, r6);
            else {
              if ((62914560 & n7) === n7 && 10 < (o3 = Pp + Tp - li())) {
                if (ya(t5, n7, wp, !mp), 0 !== h3(t5, 0, true)) break e;
                Yp = n7, t5.timeoutHandle = $o(ha.bind(null, t5, l3, Ep, Lp, Cp, n7, wp, Sp, zp, mp, a5, "Throttled", hs, r6), o3);
                break e;
              }
              ha(t5, l3, Ep, Lp, Cp, n7, wp, Sp, zp, mp, a5, null, hs, r6);
            }
          }
          break;
        }
        N(n7), l3 = hs, a5 = r6, !Ci || a5 <= l3 || (Up ? Up.run(console.timeStamp.bind(console, "Teared Render", l3, a5, Pi, "Scheduler ", "error")) : console.timeStamp("Teared Render", l3, a5, Pi, "Scheduler ", "error")), va(n7, r6), a5 = Ca(e4, n7, false), o3 = false;
      }
      Oe(e4);
    }
    function ha(e4, n7, t5, r6, l3, a5, o3, u4, i5, s3, c5, d3, f4, p4) {
      e4.timeoutHandle = qo;
      var m2 = n7.subtreeFlags, h4 = null;
      if ((8192 & m2 || 16785408 == (16785408 & m2)) && (ra(n7, a5, h4 = su()), m2 = (62914560 & a5) === a5 ? Pp - li() : (4194048 & a5) === a5 ? _p - li() : 0, null !== (m2 = du(h4, m2)))) return Yp = a5, e4.cancelPendingCommit = m2(Ia.bind(null, e4, n7, a5, t5, r6, l3, o3, u4, i5, c5, h4, fu(h4, e4.containerInfo), f4, p4)), void ya(e4, a5, o3, !s3);
      Ia(e4, n7, a5, t5, r6, l3, o3, u4, i5, c5, 0, d3, f4, p4);
    }
    function ga(e4) {
      for (var n7 = e4; ; ) {
        var t5 = n7.tag;
        if ((0 === t5 || 11 === t5 || 15 === t5) && 16384 & n7.flags && null !== (t5 = n7.updateQueue) && null !== (t5 = t5.stores)) for (var r6 = 0; r6 < t5.length; r6++) {
          var l3 = t5[r6], a5 = l3.getSnapshot;
          l3 = l3.value;
          try {
            if (!yi(a5(), l3)) return false;
          } catch (e5) {
            return false;
          }
        }
        if (t5 = n7.child, 16384 & n7.subtreeFlags && null !== t5) t5.return = n7, n7 = t5;
        else {
          if (n7 === e4) break;
          for (; null === n7.sibling; ) {
            if (null === n7.return || n7.return === e4) return true;
            n7 = n7.return;
          }
          n7.sibling.return = n7.return, n7 = n7.sibling;
        }
      }
      return true;
    }
    function ya(e4, n7, t5, r6) {
      n7 &= ~kp, n7 &= ~Sp, e4.suspendedLanes |= n7, e4.pingedLanes &= ~n7, r6 && (e4.warmLanes |= n7), r6 = e4.expirationTimes;
      for (var l3 = n7; 0 < l3; ) {
        var a5 = 31 - Yu(l3), o3 = 1 << a5;
        r6[a5] = -1, l3 &= ~o3;
      }
      0 !== t5 && k3(e4, t5, n7);
    }
    function ba() {
      if (null !== ep) {
        if (fp === tp) var e4 = ep.return;
        else e4 = ep, ue(), lt(e4), qc = null, Yc = 0, e4 = ep;
        for (; null !== e4; ) dl(e4.alternate, e4), e4 = e4.return;
        ep = null;
      }
    }
    function va(e4, n7) {
      0 != (127 & e4) && (Cs = n7), 0 != (4194048 & e4) && (Fs = n7);
    }
    function Sa(e4, n7) {
      Ci && (console.timeStamp("Blocking Track", 3e-3, 3e-3, "Blocking", "Scheduler ", "primary-light"), console.timeStamp("Transition Track", 3e-3, 3e-3, "Transition", "Scheduler ", "primary-light"), console.timeStamp("Suspense Track", 3e-3, 3e-3, "Suspense", "Scheduler ", "primary-light"), console.timeStamp("Idle Track", 3e-3, 3e-3, "Idle", "Scheduler ", "primary-light"));
      var t5 = hs;
      if (hs = ps(), 0 !== np && 0 < t5) {
        if (N(np), bp === Yf || bp === Gf) j(t5, hs, n7, Up);
        else {
          var r6 = hs, l3 = Up;
          if (Ci && !(r6 <= t5)) {
            var a5 = (738197653 & n7) === n7 ? "tertiary-dark" : "primary-dark", o3 = (536870912 & n7) === n7 ? "Prewarm" : (201326741 & n7) === n7 ? "Interrupted Hydration" : "Interrupted Render";
            l3 ? l3.run(console.timeStamp.bind(console, o3, t5, r6, Pi, "Scheduler ", a5)) : console.timeStamp(o3, t5, r6, Pi, "Scheduler ", a5);
          }
        }
        va(np, hs);
      }
      if (t5 = Up, Up = null, 0 != (127 & n7)) {
        Up = _s, l3 = 0 <= Ps && Ps < Cs ? Cs : Ps, a5 = 0 <= (r6 = 0 <= Ls && Ls < Cs ? Cs : Ls) ? r6 : 0 <= l3 ? l3 : hs, 0 <= Is && (N(2), A(Is, a5, n7, t5)), t5 = l3;
        var u4 = r6, i5 = Us, s3 = 0 < Ds, c5 = 1 === Ts, d3 = 2 === Ts;
        if (l3 = hs, r6 = _s, a5 = Rs, o3 = Ns, Ci) {
          if (Pi = "Blocking", 0 < t5 ? t5 > l3 && (t5 = l3) : t5 = l3, 0 < u4 ? u4 > t5 && (u4 = t5) : u4 = t5, null !== i5 && t5 > u4) {
            var f4 = s3 ? "secondary-light" : "warning";
            r6 ? r6.run(console.timeStamp.bind(console, s3 ? "Consecutive" : "Event: " + i5, u4, t5, Pi, "Scheduler ", f4)) : console.timeStamp(s3 ? "Consecutive" : "Event: " + i5, u4, t5, Pi, "Scheduler ", f4);
          }
          l3 > t5 && (u4 = c5 ? "error" : (738197653 & n7) === n7 ? "tertiary-light" : "primary-light", c5 = d3 ? "Promise Resolved" : c5 ? "Cascading Update" : 5 < l3 - t5 ? "Update Blocked" : "Update", d3 = [], null != o3 && d3.push(["Component name", o3]), null != a5 && d3.push(["Method name", a5]), t5 = { start: t5, end: l3, detail: { devtools: { properties: d3, track: Pi, trackGroup: "Scheduler ", color: u4 } } }, r6 ? r6.run(performance.measure.bind(performance, c5, t5)) : performance.measure(c5, t5));
        }
        Ps = -1.1, Ts = 0, Ns = Rs = null, Is = -1.1, Ds = Ls, Ls = -1.1, Cs = ps();
      }
      if (0 != (4194048 & n7) && (Up = Os, l3 = 0 <= js && js < Fs ? Fs : js, t5 = 0 <= As && As < Fs ? Fs : As, a5 = 0 <= (r6 = 0 <= Qs && Qs < Fs ? Fs : Qs) ? r6 : 0 <= t5 ? t5 : hs, 0 <= Vs && (N(256), A(Vs, a5, n7, Up)), d3 = r6, u4 = Bs, i5 = 0 < $s, s3 = 2 === Hs, a5 = hs, r6 = Os, o3 = Ms, c5 = Ws, Ci && (Pi = "Transition", 0 < t5 ? t5 > a5 && (t5 = a5) : t5 = a5, 0 < l3 ? l3 > t5 && (l3 = t5) : l3 = t5, 0 < d3 ? d3 > l3 && (d3 = l3) : d3 = l3, l3 > d3 && null !== u4 && (f4 = i5 ? "secondary-light" : "warning", r6 ? r6.run(console.timeStamp.bind(console, i5 ? "Consecutive" : "Event: " + u4, d3, l3, Pi, "Scheduler ", f4)) : console.timeStamp(i5 ? "Consecutive" : "Event: " + u4, d3, l3, Pi, "Scheduler ", f4)), t5 > l3 && (r6 ? r6.run(console.timeStamp.bind(console, "Action", l3, t5, Pi, "Scheduler ", "primary-dark")) : console.timeStamp("Action", l3, t5, Pi, "Scheduler ", "primary-dark")), a5 > t5 && (l3 = s3 ? "Promise Resolved" : 5 < a5 - t5 ? "Update Blocked" : "Update", d3 = [], null != c5 && d3.push(["Component name", c5]), null != o3 && d3.push(["Method name", o3]), t5 = { start: t5, end: a5, detail: { devtools: { properties: d3, track: Pi, trackGroup: "Scheduler ", color: "primary-light" } } }, r6 ? r6.run(performance.measure.bind(performance, l3, t5)) : performance.measure(l3, t5))), As = js = -1.1, Hs = 0, Vs = -1.1, $s = Qs, Qs = -1.1, Fs = ps()), (t5 = e4.timeoutHandle) !== qo && (e4.timeoutHandle = qo, Vo(t5)), null !== (t5 = e4.cancelPendingCommit) && (e4.cancelPendingCommit = null, t5()), Yp = 0, ba(), Zf = e4, ep = t5 = to(e4.current, null), np = n7, fp = tp, pp = null, mp = false, hp = g3(e4, n7), gp = false, bp = $f, zp = wp = kp = Sp = vp = 0, Ep = xp = null, Cp = false, 0 != (8 & n7) && (n7 |= 32 & n7), 0 !== (r6 = e4.entangledLanes)) for (e4 = e4.entanglements, r6 &= n7; 0 < r6; ) a5 = 1 << (l3 = 31 - Yu(r6)), n7 |= e4[l3], r6 &= ~a5;
      return yp = n7, Sn(), 1e3 < (e4 = hi()) - pi && (Do.recentlyCreatedOwnerStacks = 0, pi = e4), fc.discardPendingWarnings(), t5;
    }
    function ka(e4, n7) {
      Ud = null, Do.H = Yd, Do.getCurrentStack = null, Zi = false, Xi = null, n7 === Mc || n7 === Qc ? (n7 = ln(), fp = ap) : n7 === Wc ? (n7 = ln(), fp = op) : fp = n7 === hf ? cp : null !== n7 && "object" == typeof n7 && "function" == typeof n7.then ? ip : rp, pp = n7;
      var t5 = ep;
      null === t5 ? (bp = Vf, Pr(e4, Y(n7, e4.current))) : 2 & t5.mode && Ue(t5);
    }
    function wa() {
      var e4 = Do.H;
      return Do.H = Yd, null === e4 ? Yd : e4;
    }
    function za() {
      var e4 = Do.A;
      return Do.A = Hf, e4;
    }
    function xa(e4) {
      null === Up && (Up = null == e4._debugTask ? null : e4._debugTask);
    }
    function Ea() {
      bp = Gf, mp || (4194048 & np) !== np && null !== bd.current || (hp = true), 0 == (134217727 & vp) && 0 == (134217727 & Sp) || null === Zf || ya(Zf, np, wp, false);
    }
    function Ca(e4, n7, t5) {
      var r6 = Xf;
      Xf |= Qf;
      var l3 = wa(), a5 = za();
      if (Zf !== e4 || np !== n7) {
        if (fi) {
          var o3 = e4.memoizedUpdaters;
          0 < o3.size && (Za(e4, np), o3.clear()), E(e4, n7);
        }
        Lp = null, Sa(e4, n7);
      }
      n7 = false, o3 = bp;
      e: for (; ; ) try {
        if (fp !== tp && null !== ep) {
          var u4 = ep, i5 = pp;
          switch (fp) {
            case cp:
              ba(), o3 = Jf;
              break e;
            case ap:
            case lp:
            case dp:
            case ip:
              null === bd.current && (n7 = true);
              var s3 = fp;
              if (fp = tp, pp = null, La(e4, u4, i5, s3), t5 && hp) {
                o3 = $f;
                break e;
              }
              break;
            default:
              s3 = fp, fp = tp, pp = null, La(e4, u4, i5, s3);
          }
        }
        Pa(), o3 = bp;
        break;
      } catch (n8) {
        ka(e4, n8);
      }
      return n7 && e4.shellSuspendCounter++, ue(), Xf = r6, Do.H = l3, Do.A = a5, null === ep && (Zf = null, np = 0, Sn()), o3;
    }
    function Pa() {
      for (; null !== ep; ) Ta(ep);
    }
    function _a() {
      for (; null !== ep && !ti(); ) Ta(ep);
    }
    function Ta(e4) {
      var n7 = e4.alternate;
      (2 & e4.mode) !== ts ? (Le(e4), n7 = le(e4, rl, n7, e4, yp), Ue(e4)) : n7 = le(e4, rl, n7, e4, yp), e4.memoizedProps = e4.pendingProps, null === n7 ? Ua(e4) : ep = n7;
    }
    function Ra(e4) {
      var n7 = le(e4, Na, e4);
      e4.memoizedProps = e4.pendingProps, null === n7 ? Ua(e4) : ep = n7;
    }
    function Na(e4) {
      var n7 = e4.alternate, t5 = (2 & e4.mode) !== ts;
      switch (t5 && Le(e4), e4.tag) {
        case 15:
        case 0:
          n7 = Qr(n7, e4, e4.pendingProps, e4.type, void 0, np);
          break;
        case 11:
          n7 = Qr(n7, e4, e4.pendingProps, e4.type.render, e4.ref, np);
          break;
        case 5:
          lt(e4);
        default:
          dl(n7, e4), n7 = rl(n7, e4 = ep = ro(e4, yp), yp);
      }
      return t5 && Ue(e4), n7;
    }
    function La(e4, n7, t5, r6) {
      ue(), lt(n7), qc = null, Yc = 0;
      var l3 = n7.return;
      try {
        if (function(e5, n8, t6, r7, l4) {
          if (t6.flags |= 32768, fi && Za(e5, l4), null !== r7 && "object" == typeof r7 && "function" == typeof r7.then) {
            if (null !== (n8 = t6.alternate) && fe(n8, t6, l4, true), null !== (t6 = bd.current)) {
              switch (t6.tag) {
                case 31:
                case 13:
                  return null === vd ? Ea() : null === t6.alternate && bp === $f && (bp = Yf), t6.flags &= -257, t6.flags |= 65536, t6.lanes = l4, r7 === Bc ? t6.flags |= 16384 : (null === (n8 = t6.updateQueue) ? t6.updateQueue = /* @__PURE__ */ new Set([r7]) : n8.add(r7), Ba(e5, r7, l4)), false;
                case 22:
                  return t6.flags |= 65536, r7 === Bc ? t6.flags |= 16384 : (null === (n8 = t6.updateQueue) ? (n8 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([r7]) }, t6.updateQueue = n8) : null === (t6 = n8.retryQueue) ? n8.retryQueue = /* @__PURE__ */ new Set([r7]) : t6.add(r7), Ba(e5, r7, l4)), false;
              }
              throw Error("Unexpected Suspense handler tag (" + t6.tag + "). This is a bug in React.");
            }
            return Ba(e5, r7, l4), Ea(), false;
          }
          var a5 = Y(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: r7 }), t6);
          if (null === xp ? xp = [a5] : xp.push(a5), bp !== Gf && (bp = qf), null === n8) return true;
          r7 = Y(r7, t6), t6 = n8;
          do {
            switch (t6.tag) {
              case 3:
                return t6.flags |= 65536, e5 = l4 & -l4, t6.lanes |= e5, Nn(t6, e5 = Tr(t6.stateNode, r7, e5)), false;
              case 1:
                if (n8 = t6.type, a5 = t6.stateNode, 0 == (128 & t6.flags) && ("function" == typeof n8.getDerivedStateFromError || null !== a5 && "function" == typeof a5.componentDidCatch && (null === Dp || !Dp.has(a5)))) return t6.flags |= 65536, l4 &= -l4, t6.lanes |= l4, Nr(l4 = Rr(l4), e5, t6, r7), Nn(t6, l4), false;
            }
            t6 = t6.return;
          } while (null !== t6);
          return false;
        }(e4, l3, n7, t5, np)) return bp = Vf, Pr(e4, Y(t5, e4.current)), void (ep = null);
      } catch (n8) {
        if (null !== l3) throw ep = l3, n8;
        return bp = Vf, Pr(e4, Y(t5, e4.current)), void (ep = null);
      }
      32768 & n7.flags ? (r6 === rp ? e4 = true : hp || 0 != (536870912 & np) ? e4 = false : (mp = e4 = true, (r6 === lp || r6 === dp || r6 === ap || r6 === ip) && null !== (r6 = bd.current) && 13 === r6.tag && (r6.flags |= 16384)), Da(n7, e4)) : Ua(n7);
    }
    function Ua(e4) {
      var n7 = e4;
      do {
        if (0 != (32768 & n7.flags)) return void Da(n7, mp);
        var t5 = n7.alternate;
        if (e4 = n7.return, Le(n7), t5 = le(n7, sl, t5, n7, yp), (2 & n7.mode) !== ts && De(n7), null !== t5) return void (ep = t5);
        if (null !== (n7 = n7.sibling)) return void (ep = n7);
        ep = n7 = e4;
      } while (null !== n7);
      bp === $f && (bp = Kf);
    }
    function Da(e4, n7) {
      do {
        var t5 = cl(e4.alternate, e4);
        if (null !== t5) return t5.flags &= 32767, void (ep = t5);
        if ((2 & e4.mode) !== ts) {
          De(e4), t5 = e4.actualDuration;
          for (var r6 = e4.child; null !== r6; ) t5 += r6.actualDuration, r6 = r6.sibling;
          e4.actualDuration = t5;
        }
        if (null !== (t5 = e4.return) && (t5.flags |= 32768, t5.subtreeFlags = 0, t5.deletions = null), !n7 && null !== (e4 = e4.sibling)) return void (ep = e4);
        ep = e4 = t5;
      } while (null !== e4);
      bp = Jf, ep = null;
    }
    function Ia(e4, n7, t5, r6, l3, a5, o3, u4, i5, s3, c5, d3, f4, p4) {
      e4.cancelPendingCommit = null;
      do {
        Oa();
      } while ($p !== Hp);
      if (fc.flushLegacyContextWarning(), fc.flushPendingUnsafeLifecycleWarnings(), (Xf & (Qf | Bf)) !== Wf) throw Error("Should not already be working.");
      if (N(t5), s3 === qf ? H(f4, p4, 0, Up) : null !== r6 ? function(e5, n8, t6, r7, l4, a6) {
        if (Ci && !(n8 <= e5)) {
          t6 = [];
          for (var o4 = 0; o4 < r7.length; o4++) {
            var u5 = r7[o4].value;
            t6.push(["Recoverable Error", "object" == typeof u5 && null !== u5 && "string" == typeof u5.message ? String(u5.message) : String(u5)]);
          }
          e5 = { start: e5, end: n8, detail: { devtools: { color: "primary-dark", track: Pi, trackGroup: "Scheduler ", tooltipText: l4 ? "Hydration Failed" : "Recovered after Error", properties: t6 } } }, a6 ? a6.run(performance.measure.bind(performance, "Recovered", e5)) : performance.measure("Recovered", e5);
        }
      }(f4, p4, t5, r6, null !== n7 && null !== n7.alternate && n7.alternate.memoizedState.isDehydrated && 0 != (256 & n7.flags), Up) : function(e5, n8, t6, r7) {
        if (Ci && !(n8 <= e5)) {
          var l4 = (738197653 & t6) === t6 ? "tertiary-dark" : "primary-dark";
          t6 = (536870912 & t6) === t6 ? "Prepared" : (201326741 & t6) === t6 ? "Hydrated" : "Render", r7 ? r7.run(console.timeStamp.bind(console, t6, e5, n8, Pi, "Scheduler ", l4)) : console.timeStamp(t6, e5, n8, Pi, "Scheduler ", l4);
        }
      }(f4, p4, t5, Up), null !== n7) {
        if (0 === t5 && console.error("finishedLanes should not be empty during a commit. This is a bug in React."), n7 === e4.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        if (a5 = n7.lanes | n7.childLanes, function(e5, n8, t6, r7, l4, a6) {
          var o4 = e5.pendingLanes;
          e5.pendingLanes = t6, e5.suspendedLanes = 0, e5.pingedLanes = 0, e5.warmLanes = 0, e5.expiredLanes &= t6, e5.entangledLanes &= t6, e5.errorRecoveryDisabledLanes &= t6, e5.shellSuspendCounter = 0;
          var u5 = e5.entanglements, i6 = e5.expirationTimes, s4 = e5.hiddenUpdates;
          for (t6 = o4 & ~t6; 0 < t6; ) {
            var c6 = 31 - Yu(t6), d4 = 1 << c6;
            u5[c6] = 0, i6[c6] = -1;
            var f5 = s4[c6];
            if (null !== f5) for (s4[c6] = null, c6 = 0; c6 < f5.length; c6++) {
              var p5 = f5[c6];
              null !== p5 && (p5.lane &= -536870913);
            }
            t6 &= ~d4;
          }
          0 !== r7 && k3(e5, r7, 0), 0 !== a6 && 0 === l4 && 0 !== e5.tag && (e5.suspendedLanes |= a6 & ~(o4 & ~n8));
        }(e4, t5, a5 |= ud, o3, u4, i5), e4 === Zf && (ep = Zf = null, np = 0), qp = n7, Vp = e4, Yp = t5, Gp = a5, Kp = l3, Xp = r6, Jp = p4, Zp = d3, em = Ip, nm = null, 0 !== n7.actualDuration || 0 != (10256 & n7.subtreeFlags) || 0 != (10256 & n7.flags) ? (e4.callbackNode = null, e4.callbackPriority = 0, b4 = ui, v4 = function() {
          return eu(), em === Ip && (em = jp), Ma(), null;
        }, null !== (S4 = Do.actQueue) ? S4.push(v4) : ei(b4, v4)) : (e4.callbackNode = null, e4.callbackPriority = 0), bs = null, gs = ps(), null !== d3 && (m2 = p4, h4 = gs, g4 = d3, y4 = Up, !Ci || h4 <= m2 || (y4 ? y4.run(console.timeStamp.bind(console, g4, m2, h4, Pi, "Scheduler ", "secondary-light")) : console.timeStamp(g4, m2, h4, Pi, "Scheduler ", "secondary-light"))), r6 = 0 != (13878 & n7.flags), 0 != (13878 & n7.subtreeFlags) || r6) {
          r6 = Do.T, Do.T = null, l3 = Xo(), Ko(2), o3 = Xf, Xf |= Bf;
          try {
            !function(e5, n8) {
              for (Ao(e5.containerInfo), Nf = n8; null !== Nf; ) if (n8 = (e5 = Nf).child, 0 != (1028 & e5.subtreeFlags) && null !== n8) n8.return = e5, Nf = n8;
              else for (; null !== Nf; ) {
                var t6 = (n8 = e5 = Nf).alternate, r7 = n8.flags;
                switch (n8.tag) {
                  case 0:
                    if (0 != (4 & r7) && null !== (n8 = null !== (n8 = n8.updateQueue) ? n8.events : null)) for (t6 = 0; t6 < n8.length; t6++) (r7 = n8[t6]).ref.impl = r7.nextImpl;
                    break;
                  case 11:
                  case 15:
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  case 1:
                    0 != (1024 & r7) && null !== t6 && kl(n8, t6);
                    break;
                  case 3:
                    0 != (1024 & r7) && Yo && Ru(n8.stateNode.containerInfo);
                    break;
                  default:
                    if (0 != (1024 & r7)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
                if (null !== (n8 = e5.sibling)) {
                  n8.return = e5.return, Nf = n8;
                  break;
                }
                Nf = e5.return;
              }
            }(e4, n7);
          } finally {
            Xf = o3, Ko(l3), Do.T = r6;
          }
        }
        $p = Op, Fa(), ja(), Aa();
      }
      var m2, h4, g4, y4, b4, v4, S4;
    }
    function Fa() {
      if ($p === Op) {
        $p = Hp;
        var e4 = Vp, n7 = qp, t5 = Yp, r6 = 0 != (13878 & n7.flags);
        if (0 != (13878 & n7.subtreeFlags) || r6) {
          r6 = Do.T, Do.T = null;
          var l3 = Xo();
          Ko(2);
          var a5 = Xf;
          Xf |= Bf;
          try {
            Lf = t5, Uf = e4, Ee(), Ml(n7, e4), Uf = Lf = null, Ho(e4.containerInfo);
          } finally {
            Xf = a5, Ko(l3), Do.T = r6;
          }
        }
        e4.current = n7, $p = Mp;
      }
    }
    function ja() {
      if ($p === Mp) {
        $p = Hp;
        var e4 = nm;
        if (null !== e4) {
          gs = ps();
          var n7 = ys, t5 = gs;
          !Ci || t5 <= n7 || console.timeStamp(e4, n7, t5, Pi, "Scheduler ", "secondary-light");
        }
        e4 = Vp, t5 = Yp;
        var r6 = 0 != (8772 & (n7 = qp).flags);
        if (0 != (8772 & n7.subtreeFlags) || r6) {
          r6 = Do.T, Do.T = null;
          var l3 = Xo();
          Ko(2);
          var a5 = Xf;
          Xf |= Bf;
          try {
            Lf = t5, Uf = e4, Ee(), Il(e4, n7.alternate, n7), Uf = Lf = null;
          } finally {
            Xf = a5, Ko(l3), Do.T = r6;
          }
        }
        e4 = Jp, n7 = Zp, ys = ps(), e4 = null === n7 ? e4 : gs, n7 = ys, t5 = em === Fp, r6 = Up, null !== bs ? O(e4, n7, bs, false, r6) : !Ci || n7 <= e4 || (r6 ? r6.run(console.timeStamp.bind(console, t5 ? "Commit Interrupted View Transition" : "Commit", e4, n7, Pi, "Scheduler ", t5 ? "error" : "secondary-dark")) : console.timeStamp(t5 ? "Commit Interrupted View Transition" : "Commit", e4, n7, Pi, "Scheduler ", t5 ? "error" : "secondary-dark")), $p = Wp;
      }
    }
    function Aa() {
      if ($p === Qp || $p === Wp) {
        if ($p === Qp) {
          var e4 = ys, n7 = ys = ps(), t5 = em === Fp;
          !Ci || n7 <= e4 || console.timeStamp(t5 ? "Interrupted View Transition" : "Starting Animation", e4, n7, Pi, "Scheduler ", t5 ? " error" : "secondary-light"), em !== Fp && (em = Ap);
        }
        $p = Hp, ri(), e4 = Vp;
        var r6 = qp;
        n7 = Yp, t5 = Xp;
        var l3 = 0 !== r6.actualDuration || 0 != (10256 & r6.subtreeFlags) || 0 != (10256 & r6.flags);
        l3 ? $p = Bp : ($p = Hp, qp = Vp = null, Ha(e4, e4.pendingLanes), im = 0, sm = null);
        var a5, o3, u4 = e4.pendingLanes;
        if (0 === u4 && (Dp = null), l3 || Ka(e4), u4 = C(n7), r6 = r6.stateNode, fi && e4.memoizedUpdaters.clear(), null !== t5) {
          a5 = Do.T, o3 = Xo(), Ko(2), Do.T = null;
          try {
            var i5 = e4.onRecoverableError;
            for (r6 = 0; r6 < t5.length; r6++) {
              var s3 = t5[r6], c5 = (d3 = { componentStack: d3 = s3.stack }, Object.defineProperty(d3, "digest", { get: function() {
                console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
              } }), d3);
              le(s3.source, i5, s3.value, c5);
            }
          } finally {
            Do.T = a5, Ko(o3);
          }
        }
        0 != (3 & Yp) && Oa(), Oe(e4), u4 = e4.pendingLanes, 0 != (261930 & n7) && 0 != (42 & u4) ? (Ks = true, e4 === lm ? rm++ : (rm = 0, lm = e4)) : rm = 0, l3 || va(n7, ys), Me(0);
      }
      var d3;
    }
    function Ha(e4, n7) {
      0 == (e4.pooledCacheLanes &= n7) && null != (n7 = e4.pooledCache) && (e4.pooledCache = null, Se(n7));
    }
    function Oa() {
      return Fa(), ja(), Aa(), Ma();
    }
    function Ma() {
      if ($p !== Bp) return false;
      var e4 = Vp, n7 = Gp;
      Gp = 0;
      var t5 = C(Yp), r6 = 32 > t5 ? 32 : t5;
      t5 = Do.T;
      var l3 = Xo();
      try {
        Ko(r6), Do.T = null;
        var a5 = Kp;
        Kp = null, r6 = Vp;
        var o3, u4 = Yp;
        if ($p = Hp, qp = Vp = null, Yp = 0, (Xf & (Qf | Bf)) !== Wf) throw Error("Cannot flush passive effects while already rendering.");
        if (N(u4), am = true, om = false, bs = null, o3 = li(), em === Ap) {
          var i5 = ys, s3 = o3;
          !Ci || s3 <= i5 || (qs ? qs.run(console.timeStamp.bind(console, "Animating", i5, s3, Pi, "Scheduler ", "secondary-dark")) : console.timeStamp("Animating", i5, s3, Pi, "Scheduler ", "secondary-dark"));
        } else {
          i5 = ys, s3 = o3;
          var c5 = em === jp;
          !Ci || s3 <= i5 || (Up ? Up.run(console.timeStamp.bind(console, c5 ? "Waiting for Paint" : "Waiting", i5, s3, Pi, "Scheduler ", "secondary-light")) : console.timeStamp(c5 ? "Waiting for Paint" : "Waiting", i5, s3, Pi, "Scheduler ", "secondary-light"));
        }
        i5 = Xf, Xf |= Bf;
        var d3 = r6.current;
        Ee(), oa(d3);
        var f4 = r6.current;
        d3 = Jp, Ee(), Xl(r6, f4, u4, a5, d3), Ka(r6), Xf = i5;
        var p4 = li();
        f4 = o3, d3 = Up, null !== bs ? O(f4, p4, bs, true, d3) : !Ci || p4 <= f4 || (d3 ? d3.run(console.timeStamp.bind(console, "Remaining Effects", f4, p4, Pi, "Scheduler ", "secondary-dark")) : console.timeStamp("Remaining Effects", f4, p4, Pi, "Scheduler ", "secondary-dark")), va(u4, p4), Me(0), om ? r6 === sm ? im++ : (im = 0, sm = r6) : im = 0, om = am = false, di && di.onPostCommitFiberRoot;
        var m2 = r6.current.stateNode;
        return m2.effectDuration = 0, m2.passiveEffectDuration = 0, true;
      } finally {
        Ko(l3), Do.T = t5, Ha(e4, n7);
      }
    }
    function Wa(e4, n7, t5) {
      Fe(n7 = Y(t5, n7)), null !== (e4 = Tn(e4, n7 = Tr(e4.stateNode, n7, 2), 2)) && (S3(e4, 2), Oe(e4));
    }
    function Qa(e4, n7, t5) {
      if (cm = false, 3 === e4.tag) Wa(e4, e4, t5);
      else {
        for (; null !== n7; ) {
          if (3 === n7.tag) return void Wa(n7, e4, t5);
          if (1 === n7.tag) {
            var r6 = n7.stateNode;
            if ("function" == typeof n7.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === Dp || !Dp.has(r6))) return Fe(e4 = Y(t5, e4)), void (null !== (r6 = Tn(n7, t5 = Rr(2), 2)) && (Nr(t5, r6, n7, e4), S3(r6, 2), Oe(r6)));
          }
          n7 = n7.return;
        }
        console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", t5);
      }
    }
    function Ba(e4, n7, t5) {
      var r6 = e4.pingCache;
      if (null === r6) {
        r6 = e4.pingCache = new Mf();
        var l3 = /* @__PURE__ */ new Set();
        r6.set(n7, l3);
      } else void 0 === (l3 = r6.get(n7)) && (l3 = /* @__PURE__ */ new Set(), r6.set(n7, l3));
      l3.has(t5) || (gp = true, l3.add(t5), r6 = $a.bind(null, e4, n7, t5), fi && Za(e4, t5), n7.then(r6, r6));
    }
    function $a(e4, n7, t5) {
      var r6 = e4.pingCache;
      null !== r6 && r6.delete(n7), e4.pingedLanes |= e4.suspendedLanes & t5, e4.warmLanes &= ~t5, 0 != (127 & t5) ? 0 > Ps && (Cs = Ps = ps(), _s = ms("Promise Resolved"), Ts = 2) : 0 != (4194048 & t5) && 0 > As && (Fs = As = ps(), Os = ms("Promise Resolved"), Hs = 2), ca() && null === Do.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"), Zf === e4 && (np & t5) === t5 && (bp === Gf || bp === Yf && (62914560 & np) === np && li() - Pp < Tp ? (Xf & Qf) === Wf && Sa(e4, 0) : kp |= t5, zp === np && (zp = 0)), Oe(e4);
    }
    function Va(e4, n7) {
      0 === n7 && (n7 = b3()), null !== (e4 = zn(e4, n7)) && (S3(e4, n7), Oe(e4));
    }
    function qa(e4) {
      var n7 = e4.memoizedState, t5 = 0;
      null !== n7 && (t5 = n7.retryLane), Va(e4, t5);
    }
    function Ya(e4, n7) {
      var t5 = 0;
      switch (e4.tag) {
        case 31:
        case 13:
          var r6 = e4.stateNode, l3 = e4.memoizedState;
          null !== l3 && (t5 = l3.retryLane);
          break;
        case 19:
          r6 = e4.stateNode;
          break;
        case 22:
          r6 = e4.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      null !== r6 && r6.delete(n7), Va(e4, t5);
    }
    function Ga(e4, n7, t5) {
      if (0 != (67117056 & n7.subtreeFlags)) for (n7 = n7.child; null !== n7; ) {
        var r6 = e4, l3 = n7, a5 = l3.type === So;
        a5 = t5 || a5, 22 !== l3.tag ? 67108864 & l3.flags ? a5 && le(l3, Ja, r6, l3) : Ga(r6, l3, a5) : null === l3.memoizedState && (a5 && 8192 & l3.flags ? le(l3, Ja, r6, l3) : 67108864 & l3.subtreeFlags && le(l3, Ga, r6, l3, a5)), n7 = n7.sibling;
      }
    }
    function Ja(e4, n7) {
      P(true);
      try {
        $l(n7), ia(n7), ql(e4, n7.alternate, n7, false), ea(e4, n7, 0, null, false, 0);
      } finally {
        P(false);
      }
    }
    function Ka(e4) {
      var n7 = true;
      24 & e4.current.mode || (n7 = false), Ga(e4, e4.current, n7);
    }
    function Xa(e4) {
      if ((Xf & Qf) === Wf) {
        var n7 = e4.tag;
        if (3 === n7 || 1 === n7 || 0 === n7 || 11 === n7 || 14 === n7 || 15 === n7) {
          if (n7 = c4(e4) || "ReactComponent", null !== dm) {
            if (dm.has(n7)) return;
            dm.add(n7);
          } else dm = /* @__PURE__ */ new Set([n7]);
          le(e4, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function Za(e4, n7) {
      fi && e4.memoizedUpdaters.forEach(function(t5) {
        x(e4, t5, n7);
      });
    }
    function eo(e4, n7, t5, r6) {
      this.tag = e4, this.key = t5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n7, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = false, this._debugHookTypes = null, mm || "function" != typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function no(e4) {
      return !(!(e4 = e4.prototype) || !e4.isReactComponent);
    }
    function to(e4, n7) {
      var r6 = e4.alternate;
      switch (null === r6 ? ((r6 = t4(e4.tag, n7, e4.key, e4.mode)).elementType = e4.elementType, r6.type = e4.type, r6.stateNode = e4.stateNode, r6._debugOwner = e4._debugOwner, r6._debugStack = e4._debugStack, r6._debugTask = e4._debugTask, r6._debugHookTypes = e4._debugHookTypes, r6.alternate = e4, e4.alternate = r6) : (r6.pendingProps = n7, r6.type = e4.type, r6.flags = 0, r6.subtreeFlags = 0, r6.deletions = null, r6.actualDuration = -0, r6.actualStartTime = -1.1), r6.flags = 65011712 & e4.flags, r6.childLanes = e4.childLanes, r6.lanes = e4.lanes, r6.child = e4.child, r6.memoizedProps = e4.memoizedProps, r6.memoizedState = e4.memoizedState, r6.updateQueue = e4.updateQueue, n7 = e4.dependencies, r6.dependencies = null === n7 ? null : { lanes: n7.lanes, firstContext: n7.firstContext, _debugThenableState: n7._debugThenableState }, r6.sibling = e4.sibling, r6.index = e4.index, r6.ref = e4.ref, r6.refCleanup = e4.refCleanup, r6.selfBaseDuration = e4.selfBaseDuration, r6.treeBaseDuration = e4.treeBaseDuration, r6._debugInfo = e4._debugInfo, r6._debugNeedsRemount = e4._debugNeedsRemount, r6.tag) {
        case 0:
        case 15:
        case 1:
        case 11:
          r6.type = e4.type;
      }
      return r6;
    }
    function ro(e4, n7) {
      e4.flags &= 65011714;
      var t5 = e4.alternate;
      return null === t5 ? (e4.childLanes = 0, e4.lanes = n7, e4.child = null, e4.subtreeFlags = 0, e4.memoizedProps = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.stateNode = null, e4.selfBaseDuration = 0, e4.treeBaseDuration = 0) : (e4.childLanes = t5.childLanes, e4.lanes = t5.lanes, e4.child = t5.child, e4.subtreeFlags = 0, e4.deletions = null, e4.memoizedProps = t5.memoizedProps, e4.memoizedState = t5.memoizedState, e4.updateQueue = t5.updateQueue, e4.type = t5.type, n7 = t5.dependencies, e4.dependencies = null === n7 ? null : { lanes: n7.lanes, firstContext: n7.firstContext, _debugThenableState: n7._debugThenableState }, e4.selfBaseDuration = t5.selfBaseDuration, e4.treeBaseDuration = t5.treeBaseDuration), e4;
    }
    function lo(e4, n7, r6, l3, a5, o3) {
      var u4 = 0, i5 = e4;
      if ("function" == typeof e4) no(e4) && (u4 = 1);
      else if ("string" == typeof e4) u4 = 5;
      else e: switch (e4) {
        case To:
          return (n7 = t4(31, r6, n7, a5)).elementType = To, n7.lanes = o3, n7;
        case vo:
          return oo(r6.children, a5, o3, n7);
        case So:
          u4 = 8, a5 |= 24;
          break;
        case ko:
          return l3 = a5, "string" != typeof (e4 = r6).id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e4.id), (n7 = t4(12, e4, n7, 2 | l3)).elementType = ko, n7.lanes = o3, n7.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, n7;
        case Eo:
          return (n7 = t4(13, r6, n7, a5)).elementType = Eo, n7.lanes = o3, n7;
        case Co:
          return (n7 = t4(19, r6, n7, a5)).elementType = Co, n7.lanes = o3, n7;
        default:
          if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
            case zo:
              u4 = 10;
              break e;
            case wo:
              u4 = 9;
              break e;
            case xo:
              u4 = 11;
              break e;
            case Po:
              u4 = 14;
              break e;
            case _o:
              u4 = 16, i5 = null;
              break e;
          }
          i5 = "", (void 0 === e4 || "object" == typeof e4 && null !== e4 && 0 === Object.keys(e4).length) && (i5 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), null === e4 ? r6 = "null" : Uo(e4) ? r6 = "array" : void 0 !== e4 && e4.$$typeof === yo ? (r6 = "<" + (s2(e4.type) || "Unknown") + " />", i5 = " Did you accidentally export a JSX literal instead of a component?") : r6 = typeof e4, (u4 = l3 ? "number" == typeof l3.tag ? c4(l3) : "string" == typeof l3.name ? l3.name : null : null) && (i5 += "\n\nCheck the render method of `" + u4 + "`."), u4 = 29, r6 = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + r6 + "." + i5), i5 = null;
      }
      return (n7 = t4(u4, r6, n7, a5)).elementType = e4, n7.type = i5, n7.lanes = o3, n7._debugOwner = l3, n7;
    }
    function ao(e4, n7, t5) {
      return (n7 = lo(e4.type, e4.key, e4.props, e4._owner, n7, t5))._debugOwner = e4._owner, n7._debugStack = e4._debugStack, n7._debugTask = e4._debugTask, n7;
    }
    function oo(e4, n7, r6, l3) {
      return (e4 = t4(7, e4, l3, n7)).lanes = r6, e4;
    }
    function uo(e4, n7, r6) {
      return (e4 = t4(6, e4, null, n7)).lanes = r6, e4;
    }
    function io(e4, n7, r6) {
      return (n7 = t4(4, null !== e4.children ? e4.children : [], e4.key, n7)).lanes = r6, n7.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, n7;
    }
    function so(e4, n7, t5, r6, l3, a5, o3, u4, i5) {
      for (this.tag = 1, this.containerInfo = e4, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = qo, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = v3(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = v3(0), this.hiddenUpdates = v3(null), this.identifierPrefix = r6, this.onUncaughtError = l3, this.onCaughtError = a5, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = i5, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), e4 = this.pendingUpdatersLaneMap = [], n7 = 0; 31 > n7; n7++) e4.push(/* @__PURE__ */ new Set());
      this._debugRootType = t5 ? "hydrateRoot()" : "createRoot()";
    }
    function co(e4, n7, t5, r6, l3, a5) {
      l3 = function(e5) {
        return e5 ? e5 = qu : qu;
      }(l3), null === r6.context ? r6.context = l3 : r6.pendingContext = l3, Zi && null !== Xi && !gm && (gm = true, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", c4(Xi) || "Unknown")), (r6 = _n(n7)).payload = { element: t5 }, null !== (a5 = void 0 === a5 ? null : a5) && ("function" != typeof a5 && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", a5), r6.callback = a5), null !== (t5 = Tn(e4, r6, n7)) && (ke(n7, "root.render()", null), pa(t5, e4, n7), Rn(t5, e4, n7));
    }
    var fo = {}, po = import_react2.default, mo = u2, ho = Object.assign, go = Symbol.for("react.element"), yo = Symbol.for("react.transitional.element"), bo = Symbol.for("react.portal"), vo = Symbol.for("react.fragment"), So = Symbol.for("react.strict_mode"), ko = Symbol.for("react.profiler"), wo = Symbol.for("react.consumer"), zo = Symbol.for("react.context"), xo = Symbol.for("react.forward_ref"), Eo = Symbol.for("react.suspense"), Co = Symbol.for("react.suspense_list"), Po = Symbol.for("react.memo"), _o = Symbol.for("react.lazy"), To = Symbol.for("react.activity"), Ro = Symbol.for("react.memo_cache_sentinel"), No = Symbol.iterator, Lo = Symbol.for("react.client.reference"), Uo = Array.isArray, Do = po.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Io = n6.getPublicInstance, Fo = n6.getRootHostContext, jo = n6.getChildHostContext, Ao = n6.prepareForCommit, Ho = n6.resetAfterCommit, Oo = n6.createInstance, Mo = n6.appendInitialChild, Wo = n6.finalizeInitialChildren, Qo = n6.shouldSetTextContent, Bo = n6.createTextInstance, $o = null, Vo = null, qo = n6.noTimeout, Yo = true, Go = null, Jo = null, Ko = n6.setCurrentUpdatePriority, Xo = n6.getCurrentUpdatePriority, Zo = n6.resolveUpdatePriority, eu = n6.trackSchedulerEvent, nu = n6.resolveEventType, tu = n6.resolveEventTimeStamp, ru = n6.shouldAttemptEagerTransition, lu = n6.detachDeletedInstance;
    n6.requestPostPaintCallback;
    var au = n6.maySuspendCommit, ou = null, uu = null, iu = null, su = null, cu = null, du = null, fu = null, pu = null, mu = null, hu = null, gu = n6.appendChild, yu = n6.appendChildToContainer, bu = n6.commitTextUpdate, vu = null, Su = n6.commitUpdate, ku = n6.insertBefore, wu = null, zu = n6.removeChild, xu = n6.removeChildFromContainer, Eu = n6.resetTextContent, Cu = null, Pu = null, _u = null, Tu = null, Ru = n6.clearContainer, Nu = null, Lu = null, Uu = null, Du = null, Iu = null, Fu = null, ju = null, Au = null, Hu = null, Ou = null, Mu = null, Wu = null, Qu = null, Bu = [], $u = [], Vu = -1, qu = {};
    Object.freeze(qu);
    var Yu = Math.clz32 ? Math.clz32 : function(e4) {
      return 0 == (e4 >>>= 0) ? 32 : 31 - (Gu(e4) / Ju | 0) | 0;
    }, Gu = Math.log, Ju = Math.LN2, Ku = 256, Xu = 262144, Zu = 4194304, ei = mo.unstable_scheduleCallback, ni = mo.unstable_cancelCallback, ti = mo.unstable_shouldYield, ri = mo.unstable_requestPaint, li = mo.unstable_now, ai = mo.unstable_ImmediatePriority, oi = mo.unstable_UserBlockingPriority, ui = mo.unstable_NormalPriority, ii = mo.unstable_IdlePriority, si = mo.log, ci = mo.unstable_setDisableYieldValue, di = null, fi = "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, pi = 0;
    if ("object" == typeof performance && "function" == typeof performance.now) var mi = performance, hi = function() {
      return mi.now();
    };
    else {
      var gi = Date;
      hi = function() {
        return gi.now();
      };
    }
    var yi = "function" == typeof Object.is ? Object.is : function(e4, n7) {
      return e4 === n7 && (0 !== e4 || 1 / e4 == 1 / n7) || e4 != e4 && n7 != n7;
    };
    "function" == typeof reportError && reportError;
    var bi, vi, Si, ki, wi, zi, xi, Ei = Object.prototype.hasOwnProperty, Ci = "undefined" != typeof console && "function" == typeof console.timeStamp && "undefined" != typeof performance && "function" == typeof performance.measure, Pi = "Blocking", _i = false, Ti = { color: "primary", properties: null, tooltipText: "", track: "Components " }, Ri = { start: -0, end: -0, detail: { devtools: Ti } }, Ni = ["Changed Props", ""], Li = ["Changed Props", "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner."], Ui = 0;
    M.__reactDisabledLog = true;
    var Di, Ii, Fi = false, ji = new ("function" == typeof WeakMap ? WeakMap : Map)(), Ai = /* @__PURE__ */ new WeakMap(), Hi = [], Oi = 0, Mi = null, Wi = 0, Qi = [], Bi = 0, $i = null, Vi = 1, qi = "", Yi = d2(null), Gi = d2(null), Ji = d2(null), Ki = d2(null), Xi = null, Zi = false, es = false, ns = null, ts = 0, rs = d2(null), ls = d2(null), as = {}, os = null, us = null, is = false, ss = "undefined" != typeof AbortController ? AbortController : function() {
      var e4 = [], n7 = this.signal = { aborted: false, addEventListener: function(n8, t5) {
        e4.push(t5);
      } };
      this.abort = function() {
        n7.aborted = true, e4.forEach(function(e5) {
          return e5();
        });
      };
    }, cs = mo.unstable_scheduleCallback, ds = mo.unstable_NormalPriority, fs2 = { $$typeof: zo, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0, _currentRenderer: null, _currentRenderer2: null }, ps = mo.unstable_now, ms = console.createTask ? console.createTask : function() {
      return null;
    }, hs = -0, gs = -0, ys = -0, bs = null, vs = -1.1, Ss = -0, ks = -0, ws = -1.1, zs = -1.1, xs = null, Es = false, Cs = -0, Ps = -1.1, _s = null, Ts = 0, Rs = null, Ns = null, Ls = -1.1, Us = null, Ds = -1.1, Is = -1.1, Fs = -0, js = -1.1, As = -1.1, Hs = 0, Os = null, Ms = null, Ws = null, Qs = -1.1, Bs = null, $s = -1.1, Vs = -1.1, qs = null, Ys = 0, Gs = -1.1, Js = false, Ks = false, Xs = null, Zs = null, ec = false, nc = false, tc = false, rc = false, lc = 0, ac = {}, oc = null, uc = 0, ic = 0, sc = null, cc = Do.S;
    Do.S = function(e4, n7) {
      if (_p = li(), "object" == typeof n7 && null !== n7 && "function" == typeof n7.then) {
        if (0 > js && 0 > As) {
          js = ps();
          var t5 = tu(), r6 = nu();
          t5 === $s && r6 === Bs || ($s = -1.1), Qs = t5, Bs = r6;
        }
        !function(e5, n8) {
          if (null === oc) {
            var t6 = oc = [];
            uc = 0, ic = Ge(), sc = { status: "pending", value: void 0, then: function(e6) {
              t6.push(e6);
            } };
          }
          uc++, n8.then(Je, Je);
        }(0, n7);
      }
      null !== cc && cc(e4, n7);
    };
    var dc = d2(null), fc = { recordUnsafeLifecycleWarnings: function() {
    }, flushPendingUnsafeLifecycleWarnings: function() {
    }, recordLegacyContextWarning: function() {
    }, flushLegacyContextWarning: function() {
    }, discardPendingWarnings: function() {
    } }, pc = [], mc = [], hc = [], gc = [], yc = [], bc = [], vc = /* @__PURE__ */ new Set();
    fc.recordUnsafeLifecycleWarnings = function(e4, n7) {
      vc.has(e4.type) || ("function" == typeof n7.componentWillMount && true !== n7.componentWillMount.__suppressDeprecationWarning && pc.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillMount && mc.push(e4), "function" == typeof n7.componentWillReceiveProps && true !== n7.componentWillReceiveProps.__suppressDeprecationWarning && hc.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillReceiveProps && gc.push(e4), "function" == typeof n7.componentWillUpdate && true !== n7.componentWillUpdate.__suppressDeprecationWarning && yc.push(e4), 8 & e4.mode && "function" == typeof n7.UNSAFE_componentWillUpdate && bc.push(e4));
    }, fc.flushPendingUnsafeLifecycleWarnings = function() {
      var e4 = /* @__PURE__ */ new Set();
      0 < pc.length && (pc.forEach(function(n8) {
        e4.add(c4(n8) || "Component"), vc.add(n8.type);
      }), pc = []);
      var n7 = /* @__PURE__ */ new Set();
      0 < mc.length && (mc.forEach(function(e5) {
        n7.add(c4(e5) || "Component"), vc.add(e5.type);
      }), mc = []);
      var t5 = /* @__PURE__ */ new Set();
      0 < hc.length && (hc.forEach(function(e5) {
        t5.add(c4(e5) || "Component"), vc.add(e5.type);
      }), hc = []);
      var r6 = /* @__PURE__ */ new Set();
      0 < gc.length && (gc.forEach(function(e5) {
        r6.add(c4(e5) || "Component"), vc.add(e5.type);
      }), gc = []);
      var l3 = /* @__PURE__ */ new Set();
      0 < yc.length && (yc.forEach(function(e5) {
        l3.add(c4(e5) || "Component"), vc.add(e5.type);
      }), yc = []);
      var a5 = /* @__PURE__ */ new Set();
      if (0 < bc.length && (bc.forEach(function(e5) {
        a5.add(c4(e5) || "Component"), vc.add(e5.type);
      }), bc = []), 0 < n7.size) {
        var u4 = o2(n7);
        console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", u4);
      }
      0 < r6.size && (u4 = o2(r6), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", u4)), 0 < a5.size && (u4 = o2(a5), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", u4)), 0 < e4.size && (u4 = o2(e4), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4)), 0 < t5.size && (u4 = o2(t5), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4)), 0 < l3.size && (u4 = o2(l3), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", u4));
    };
    var Sc = /* @__PURE__ */ new Map(), kc = /* @__PURE__ */ new Set();
    fc.recordLegacyContextWarning = function(e4, n7) {
      for (var t5 = null, r6 = e4; null !== r6; ) 8 & r6.mode && (t5 = r6), r6 = r6.return;
      null === t5 ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !kc.has(e4.type) && (r6 = Sc.get(t5), null != e4.type.contextTypes || null != e4.type.childContextTypes || null !== n7 && "function" == typeof n7.getChildContext) && (void 0 === r6 && (r6 = [], Sc.set(t5, r6)), r6.push(e4));
    }, fc.flushLegacyContextWarning = function() {
      Sc.forEach(function(e4) {
        if (0 !== e4.length) {
          var n7 = e4[0], t5 = /* @__PURE__ */ new Set();
          e4.forEach(function(e5) {
            t5.add(c4(e5) || "Component"), kc.add(e5.type);
          });
          var r6 = o2(t5);
          le(n7, function() {
            console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", r6);
          });
        }
      });
    }, fc.discardPendingWarnings = function() {
      pc = [], mc = [], hc = [], gc = [], yc = [], bc = [], Sc = /* @__PURE__ */ new Map();
    };
    var wc, zc = { react_stack_bottom_frame: function(e4, n7, t5) {
      var r6 = Zi;
      Zi = true;
      try {
        return e4(n7, t5);
      } finally {
        Zi = r6;
      }
    } }, xc = zc.react_stack_bottom_frame.bind(zc), Ec = { react_stack_bottom_frame: function(e4) {
      var n7 = Zi;
      Zi = true;
      try {
        return e4.render();
      } finally {
        Zi = n7;
      }
    } }, Cc = Ec.react_stack_bottom_frame.bind(Ec), Pc = { react_stack_bottom_frame: function(e4, n7) {
      try {
        n7.componentDidMount();
      } catch (n8) {
        Qa(e4, e4.return, n8);
      }
    } }, _c = Pc.react_stack_bottom_frame.bind(Pc), Tc = { react_stack_bottom_frame: function(e4, n7, t5, r6, l3) {
      try {
        n7.componentDidUpdate(t5, r6, l3);
      } catch (n8) {
        Qa(e4, e4.return, n8);
      }
    } }, Rc = Tc.react_stack_bottom_frame.bind(Tc), Nc = { react_stack_bottom_frame: function(e4, n7) {
      var t5 = n7.stack;
      e4.componentDidCatch(n7.value, { componentStack: null !== t5 ? t5 : "" });
    } }, Lc = Nc.react_stack_bottom_frame.bind(Nc), Uc = { react_stack_bottom_frame: function(e4, n7, t5) {
      try {
        t5.componentWillUnmount();
      } catch (t6) {
        Qa(e4, n7, t6);
      }
    } }, Dc = Uc.react_stack_bottom_frame.bind(Uc), Ic = { react_stack_bottom_frame: function(e4) {
      var n7 = e4.create;
      return e4 = e4.inst, n7 = n7(), e4.destroy = n7;
    } }, Fc = Ic.react_stack_bottom_frame.bind(Ic), jc = { react_stack_bottom_frame: function(e4, n7, t5) {
      try {
        t5();
      } catch (t6) {
        Qa(e4, n7, t6);
      }
    } }, Ac = jc.react_stack_bottom_frame.bind(jc), Hc = { react_stack_bottom_frame: function(e4) {
      return (0, e4._init)(e4._payload);
    } }, Oc = Hc.react_stack_bottom_frame.bind(Hc), Mc = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), Wc = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), Qc = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), Bc = { then: function() {
      console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
    } }, $c = null, Vc = false, qc = null, Yc = 0, Gc = null, Jc = wc = false, Kc = {}, Xc = {}, Zc = {};
    a4 = function(e4, n7, t5) {
      if (null !== t5 && "object" == typeof t5 && t5._store && (!t5._store.validated && null == t5.key || 2 === t5._store.validated)) {
        if ("object" != typeof t5._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        t5._store.validated = 1;
        var r6 = c4(e4), l3 = r6 || "null";
        if (!Kc[l3]) {
          Kc[l3] = true, t5 = t5._owner, e4 = e4._debugOwner;
          var a5 = "";
          e4 && "number" == typeof e4.tag && (l3 = c4(e4)) && (a5 = "\n\nCheck the render method of `" + l3 + "`."), a5 || r6 && (a5 = "\n\nCheck the top-level render call using <" + r6 + ">.");
          var o3 = "";
          null != t5 && e4 !== t5 && (r6 = null, "number" == typeof t5.tag ? r6 = c4(t5) : "string" == typeof t5.name && (r6 = t5.name), r6 && (o3 = " It was passed a child from " + r6 + ".")), le(n7, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', a5, o3);
          });
        }
      }
    };
    var ed, nd = bn(true), td = bn(false), rd = 1, ld = 2, ad = [], od = 0, ud = 0, id = 0, sd = 1, cd = 2, dd = 3, fd = false, pd = false, md = null, hd = false, gd = d2(null), yd = d2(0), bd = d2(null), vd = null, Sd = 1, kd = 2, wd = d2(0), zd = 0, xd = 1, Ed = 2, Cd = 4, Pd = 8, _d = /* @__PURE__ */ new Set(), Td = /* @__PURE__ */ new Set(), Rd = /* @__PURE__ */ new Set(), Nd = /* @__PURE__ */ new Set(), Ld = 0, Ud = null, Dd = null, Id = null, Fd = false, jd = false, Ad = false, Hd = 0, Od = 0, Md = null, Wd = 0, Qd = 25, Bd = null, $d = null, Vd = -1, qd = false, Yd = { readContext: he, use: it, useCallback: Jn, useContext: Jn, useEffect: Jn, useImperativeHandle: Jn, useLayoutEffect: Jn, useInsertionEffect: Jn, useMemo: Jn, useReducer: Jn, useRef: Jn, useState: Jn, useDebugValue: Jn, useDeferredValue: Jn, useTransition: Jn, useSyncExternalStore: Jn, useId: Jn, useHostTransitionStatus: Jn, useFormState: Jn, useActionState: Jn, useOptimistic: Jn, useMemoCache: Jn, useCacheRefresh: Jn };
    Yd.useEffectEvent = Jn;
    var Gd = null, Jd = null, Kd = null, Xd = null, Zd = null, ef = null, nf = null;
    Gd = { readContext: function(e4) {
      return he(e4);
    }, use: it, useCallback: function(e4, n7) {
      return Bd = "useCallback", Vn(), Yn(n7), Kt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", Vn(), he(e4);
    }, useEffect: function(e4, n7) {
      return Bd = "useEffect", Vn(), Yn(n7), Bt(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", Vn(), Yn(t5), Gt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      Bd = "useInsertionEffect", Vn(), Yn(n7), Wt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", Vn(), Yn(n7), qt(e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", Vn(), Yn(n7);
      var t5 = Do.H;
      Do.H = Zd;
      try {
        return Zt(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", Vn();
      var r6 = Do.H;
      Do.H = Zd;
      try {
        return dt(e4, n7, t5);
      } finally {
        Do.H = r6;
      }
    }, useRef: function(e4) {
      return Bd = "useRef", Vn(), Mt(e4);
    }, useState: function(e4) {
      Bd = "useState", Vn();
      var n7 = Do.H;
      Do.H = Zd;
      try {
        return zt(e4);
      } finally {
        Do.H = n7;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", Vn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", Vn(), nr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", Vn(), ir();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", Vn(), ht(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", Vn(), fr();
    }, useFormState: function(e4, n7) {
      return Bd = "useFormState", Vn(), Gn(), It(e4, n7);
    }, useActionState: function(e4, n7) {
      return Bd = "useActionState", Vn(), It(e4, n7);
    }, useOptimistic: function(e4) {
      return Bd = "useOptimistic", Vn(), xt(e4);
    }, useHostTransitionStatus: dr, useMemoCache: st, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", Vn(), pr();
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", Vn(), $t(e4);
    } }, Jd = { readContext: function(e4) {
      return he(e4);
    }, use: it, useCallback: function(e4, n7) {
      return Bd = "useCallback", qn(), Kt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", qn(), he(e4);
    }, useEffect: function(e4, n7) {
      return Bd = "useEffect", qn(), Bt(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", qn(), Gt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      Bd = "useInsertionEffect", qn(), Wt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", qn(), qt(e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", qn();
      var t5 = Do.H;
      Do.H = Zd;
      try {
        return Zt(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", qn();
      var r6 = Do.H;
      Do.H = Zd;
      try {
        return dt(e4, n7, t5);
      } finally {
        Do.H = r6;
      }
    }, useRef: function(e4) {
      return Bd = "useRef", qn(), Mt(e4);
    }, useState: function(e4) {
      Bd = "useState", qn();
      var n7 = Do.H;
      Do.H = Zd;
      try {
        return zt(e4);
      } finally {
        Do.H = n7;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", qn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", qn(), nr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", qn(), ir();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", qn(), ht(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", qn(), fr();
    }, useActionState: function(e4, n7) {
      return Bd = "useActionState", qn(), It(e4, n7);
    }, useFormState: function(e4, n7) {
      return Bd = "useFormState", qn(), Gn(), It(e4, n7);
    }, useOptimistic: function(e4) {
      return Bd = "useOptimistic", qn(), xt(e4);
    }, useHostTransitionStatus: dr, useMemoCache: st, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", qn(), pr();
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", qn(), $t(e4);
    } }, Kd = { readContext: function(e4) {
      return he(e4);
    }, use: it, useCallback: function(e4, n7) {
      return Bd = "useCallback", qn(), Xt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", qn(), he(e4);
    }, useEffect: function(e4, n7) {
      Bd = "useEffect", qn(), Qt(2048, Pd, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", qn(), Jt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return Bd = "useInsertionEffect", qn(), Qt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", qn(), Qt(4, Cd, e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", qn();
      var t5 = Do.H;
      Do.H = ef;
      try {
        return er(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", qn();
      var r6 = Do.H;
      Do.H = ef;
      try {
        return ft(e4);
      } finally {
        Do.H = r6;
      }
    }, useRef: function() {
      return Bd = "useRef", qn(), ot().memoizedState;
    }, useState: function() {
      Bd = "useState", qn();
      var e4 = Do.H;
      Do.H = ef;
      try {
        return ft(ct);
      } finally {
        Do.H = e4;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", qn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", qn(), tr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", qn(), sr();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", qn(), gt(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", qn(), ot().memoizedState;
    }, useFormState: function(e4) {
      return Bd = "useFormState", qn(), Gn(), Ft(e4);
    }, useActionState: function(e4) {
      return Bd = "useActionState", qn(), Ft(e4);
    }, useOptimistic: function(e4, n7) {
      return Bd = "useOptimistic", qn(), Et(e4, n7);
    }, useHostTransitionStatus: dr, useMemoCache: st, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", qn(), ot().memoizedState;
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", qn(), Vt(e4);
    } }, Xd = { readContext: function(e4) {
      return he(e4);
    }, use: it, useCallback: function(e4, n7) {
      return Bd = "useCallback", qn(), Xt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", qn(), he(e4);
    }, useEffect: function(e4, n7) {
      Bd = "useEffect", qn(), Qt(2048, Pd, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", qn(), Jt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return Bd = "useInsertionEffect", qn(), Qt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", qn(), Qt(4, Cd, e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", qn();
      var t5 = Do.H;
      Do.H = nf;
      try {
        return er(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", qn();
      var r6 = Do.H;
      Do.H = nf;
      try {
        return mt(e4);
      } finally {
        Do.H = r6;
      }
    }, useRef: function() {
      return Bd = "useRef", qn(), ot().memoizedState;
    }, useState: function() {
      Bd = "useState", qn();
      var e4 = Do.H;
      Do.H = nf;
      try {
        return mt(ct);
      } finally {
        Do.H = e4;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", qn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", qn(), rr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", qn(), cr();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", qn(), gt(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", qn(), ot().memoizedState;
    }, useFormState: function(e4) {
      return Bd = "useFormState", qn(), Gn(), Ht(e4);
    }, useActionState: function(e4) {
      return Bd = "useActionState", qn(), Ht(e4);
    }, useOptimistic: function(e4, n7) {
      return Bd = "useOptimistic", qn(), Pt(e4, n7);
    }, useHostTransitionStatus: dr, useMemoCache: st, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", qn(), ot().memoizedState;
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", qn(), Vt(e4);
    } }, Zd = { readContext: function(e4) {
      return l2(), he(e4);
    }, use: function(e4) {
      return r5(), it(e4);
    }, useCallback: function(e4, n7) {
      return Bd = "useCallback", r5(), Vn(), Kt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", r5(), Vn(), he(e4);
    }, useEffect: function(e4, n7) {
      return Bd = "useEffect", r5(), Vn(), Bt(e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", r5(), Vn(), Gt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      Bd = "useInsertionEffect", r5(), Vn(), Wt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", r5(), Vn(), qt(e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", r5(), Vn();
      var t5 = Do.H;
      Do.H = Zd;
      try {
        return Zt(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", r5(), Vn();
      var l3 = Do.H;
      Do.H = Zd;
      try {
        return dt(e4, n7, t5);
      } finally {
        Do.H = l3;
      }
    }, useRef: function(e4) {
      return Bd = "useRef", r5(), Vn(), Mt(e4);
    }, useState: function(e4) {
      Bd = "useState", r5(), Vn();
      var n7 = Do.H;
      Do.H = Zd;
      try {
        return zt(e4);
      } finally {
        Do.H = n7;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", r5(), Vn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", r5(), Vn(), nr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", r5(), Vn(), ir();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", r5(), Vn(), ht(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", r5(), Vn(), fr();
    }, useFormState: function(e4, n7) {
      return Bd = "useFormState", r5(), Vn(), It(e4, n7);
    }, useActionState: function(e4, n7) {
      return Bd = "useActionState", r5(), Vn(), It(e4, n7);
    }, useOptimistic: function(e4) {
      return Bd = "useOptimistic", r5(), Vn(), xt(e4);
    }, useMemoCache: function(e4) {
      return r5(), st(e4);
    }, useHostTransitionStatus: dr, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", Vn(), pr();
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", r5(), Vn(), $t(e4);
    } }, ef = { readContext: function(e4) {
      return l2(), he(e4);
    }, use: function(e4) {
      return r5(), it(e4);
    }, useCallback: function(e4, n7) {
      return Bd = "useCallback", r5(), qn(), Xt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", r5(), qn(), he(e4);
    }, useEffect: function(e4, n7) {
      Bd = "useEffect", r5(), qn(), Qt(2048, Pd, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", r5(), qn(), Jt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return Bd = "useInsertionEffect", r5(), qn(), Qt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", r5(), qn(), Qt(4, Cd, e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", r5(), qn();
      var t5 = Do.H;
      Do.H = ef;
      try {
        return er(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", r5(), qn();
      var l3 = Do.H;
      Do.H = ef;
      try {
        return ft(e4);
      } finally {
        Do.H = l3;
      }
    }, useRef: function() {
      return Bd = "useRef", r5(), qn(), ot().memoizedState;
    }, useState: function() {
      Bd = "useState", r5(), qn();
      var e4 = Do.H;
      Do.H = ef;
      try {
        return ft(ct);
      } finally {
        Do.H = e4;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", r5(), qn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", r5(), qn(), tr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", r5(), qn(), sr();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", r5(), qn(), gt(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", r5(), qn(), ot().memoizedState;
    }, useFormState: function(e4) {
      return Bd = "useFormState", r5(), qn(), Ft(e4);
    }, useActionState: function(e4) {
      return Bd = "useActionState", r5(), qn(), Ft(e4);
    }, useOptimistic: function(e4, n7) {
      return Bd = "useOptimistic", r5(), qn(), Et(e4, n7);
    }, useMemoCache: function(e4) {
      return r5(), st(e4);
    }, useHostTransitionStatus: dr, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", qn(), ot().memoizedState;
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", r5(), qn(), Vt(e4);
    } }, nf = { readContext: function(e4) {
      return l2(), he(e4);
    }, use: function(e4) {
      return r5(), it(e4);
    }, useCallback: function(e4, n7) {
      return Bd = "useCallback", r5(), qn(), Xt(e4, n7);
    }, useContext: function(e4) {
      return Bd = "useContext", r5(), qn(), he(e4);
    }, useEffect: function(e4, n7) {
      Bd = "useEffect", r5(), qn(), Qt(2048, Pd, e4, n7);
    }, useImperativeHandle: function(e4, n7, t5) {
      return Bd = "useImperativeHandle", r5(), qn(), Jt(e4, n7, t5);
    }, useInsertionEffect: function(e4, n7) {
      return Bd = "useInsertionEffect", r5(), qn(), Qt(4, Ed, e4, n7);
    }, useLayoutEffect: function(e4, n7) {
      return Bd = "useLayoutEffect", r5(), qn(), Qt(4, Cd, e4, n7);
    }, useMemo: function(e4, n7) {
      Bd = "useMemo", r5(), qn();
      var t5 = Do.H;
      Do.H = ef;
      try {
        return er(e4, n7);
      } finally {
        Do.H = t5;
      }
    }, useReducer: function(e4, n7, t5) {
      Bd = "useReducer", r5(), qn();
      var l3 = Do.H;
      Do.H = ef;
      try {
        return mt(e4);
      } finally {
        Do.H = l3;
      }
    }, useRef: function() {
      return Bd = "useRef", r5(), qn(), ot().memoizedState;
    }, useState: function() {
      Bd = "useState", r5(), qn();
      var e4 = Do.H;
      Do.H = ef;
      try {
        return mt(ct);
      } finally {
        Do.H = e4;
      }
    }, useDebugValue: function() {
      Bd = "useDebugValue", r5(), qn();
    }, useDeferredValue: function(e4, n7) {
      return Bd = "useDeferredValue", r5(), qn(), rr(e4, n7);
    }, useTransition: function() {
      return Bd = "useTransition", r5(), qn(), cr();
    }, useSyncExternalStore: function(e4, n7, t5) {
      return Bd = "useSyncExternalStore", r5(), qn(), gt(e4, n7, t5);
    }, useId: function() {
      return Bd = "useId", r5(), qn(), ot().memoizedState;
    }, useFormState: function(e4) {
      return Bd = "useFormState", r5(), qn(), Ht(e4);
    }, useActionState: function(e4) {
      return Bd = "useActionState", r5(), qn(), Ht(e4);
    }, useOptimistic: function(e4, n7) {
      return Bd = "useOptimistic", r5(), qn(), Pt(e4, n7);
    }, useMemoCache: function(e4) {
      return r5(), st(e4);
    }, useHostTransitionStatus: dr, useCacheRefresh: function() {
      return Bd = "useCacheRefresh", qn(), ot().memoizedState;
    }, useEffectEvent: function(e4) {
      return Bd = "useEffectEvent", r5(), qn(), Vt(e4);
    } };
    var tf = {}, rf = /* @__PURE__ */ new Set(), lf = /* @__PURE__ */ new Set(), af = /* @__PURE__ */ new Set(), of = /* @__PURE__ */ new Set(), uf = /* @__PURE__ */ new Set(), sf = /* @__PURE__ */ new Set(), cf = /* @__PURE__ */ new Set(), df = /* @__PURE__ */ new Set(), ff = /* @__PURE__ */ new Set(), pf = /* @__PURE__ */ new Set();
    Object.freeze(tf);
    var mf = { enqueueSetState: function(e4, n7, t5) {
      var r6 = da(e4 = e4._reactInternals), l3 = _n(r6);
      l3.payload = n7, null != t5 && (wr(t5), l3.callback = t5), null !== (n7 = Tn(e4, l3, r6)) && (ke(r6, "this.setState()", e4), pa(n7, e4, r6), Rn(n7, e4, r6));
    }, enqueueReplaceState: function(e4, n7, t5) {
      var r6 = da(e4 = e4._reactInternals), l3 = _n(r6);
      l3.tag = sd, l3.payload = n7, null != t5 && (wr(t5), l3.callback = t5), null !== (n7 = Tn(e4, l3, r6)) && (ke(r6, "this.replaceState()", e4), pa(n7, e4, r6), Rn(n7, e4, r6));
    }, enqueueForceUpdate: function(e4, n7) {
      var t5 = da(e4 = e4._reactInternals), r6 = _n(t5);
      r6.tag = cd, null != n7 && (wr(n7), r6.callback = n7), null !== (n7 = Tn(e4, r6, t5)) && (ke(t5, "this.forceUpdate()", e4), pa(n7, e4, t5), Rn(n7, e4, t5));
    } }, hf = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), gf = false, yf = {}, bf = {}, vf = {}, Sf = {}, kf = false, wf = {}, zf = {}, xf = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }, Ef = false, Cf = null;
    Cf = /* @__PURE__ */ new Set();
    var Pf = false, _f = false, Tf = false, Rf = "function" == typeof WeakSet ? WeakSet : Set, Nf = null, Lf = null, Uf = null, Df = null, If = false, Ff = null, jf = false, Af = 8192, Hf = { getCacheForType: function(e4) {
      var n7 = he(fs2), t5 = n7.data.get(e4);
      return void 0 === t5 && (t5 = e4(), n7.data.set(e4, t5)), t5;
    }, cacheSignal: function() {
      return he(fs2).controller.signal;
    }, getOwner: function() {
      return Xi;
    } };
    if ("function" == typeof Symbol && Symbol.for) {
      var Of = Symbol.for;
      Of("selector.component"), Of("selector.has_pseudo_class"), Of("selector.role"), Of("selector.test_id"), Of("selector.text");
    }
    var Mf = "function" == typeof WeakMap ? WeakMap : Map, Wf = 0, Qf = 2, Bf = 4, $f = 0, Vf = 1, qf = 2, Yf = 3, Gf = 4, Jf = 6, Kf = 5, Xf = Wf, Zf = null, ep = null, np = 0, tp = 0, rp = 1, lp = 2, ap = 3, op = 4, up = 5, ip = 6, sp = 7, cp = 8, dp = 9, fp = tp, pp = null, mp = false, hp = false, gp = false, yp = 0, bp = $f, vp = 0, Sp = 0, kp = 0, wp = 0, zp = 0, xp = null, Ep = null, Cp = false, Pp = 0, _p = 0, Tp = 300, Rp = 1 / 0, Np = 500, Lp = null, Up = null, Dp = null, Ip = 0, Fp = 1, jp = 2, Ap = 3, Hp = 0, Op = 1, Mp = 2, Wp = 3, Qp = 4, Bp = 5, $p = 0, Vp = null, qp = null, Yp = 0, Gp = 0, Jp = -0, Kp = null, Xp = null, Zp = null, em = Ip, nm = null, tm = 50, rm = 0, lm = null, am = false, om = false, um = 50, im = 0, sm = null, cm = false, dm = null, fm = false, pm = /* @__PURE__ */ new Set(), mm = false;
    try {
      var hm = Object.preventExtensions({});
      /* @__PURE__ */ new Map([[hm, null]]), /* @__PURE__ */ new Set([hm]);
    } catch (e4) {
      mm = true;
    }
    var gm = false;
    return fo.createContainer = function(e4, n7, r6, l3, a5, o3, u4, i5, s3, c5) {
      return function(e5, n8, r7, l4, a6, o4, u5, i6, s4, c6, d3, f4) {
        return e5 = new so(e5, n8, r7, u5, s4, c6, d3, f4, null), n8 = 1, true === o4 && (n8 |= 24), o4 = t4(3, null, null, 2 | n8), e5.current = o4, o4.stateNode = e5, ve(n8 = be()), e5.pooledCache = n8, ve(n8), o4.memoizedState = { element: l4, isDehydrated: r7, cache: n8 }, Cn(o4), e5;
      }(e4, n7, false, null, 0, l3, o3, 0, u4, i5, s3, c5);
    }, fo.flushSyncWork = function() {
      return (Xf & (Qf | Bf)) !== Wf || (Me(0), false);
    }, fo.updateContainer = function(e4, n7, t5, r6) {
      var l3 = n7.current, a5 = da(l3);
      return co(l3, a5, e4, n7, t5, r6), a5;
    }, fo.updateContainerSync = function(e4, n7, t5, r6) {
      return co(n7.current, 2, e4, n7, t5, r6), 2;
    }, fo;
  }, n5.exports.default = n5.exports, Object.defineProperty(n5.exports, "__esModule", { value: true })), c2.exports;
  var n5;
}();
var f = t2(a2.exports);
var p2 = { exports: {} };
var h2;
var g2 = {};
false ? p2.exports = (d || (d = 1, m.ConcurrentRoot = 1, m.ContinuousEventPriority = 8, m.DefaultEventPriority = 32, m.DiscreteEventPriority = 2, m.IdleEventPriority = 268435456, m.LegacyRoot = 0, m.NoEventPriority = 0), m) : p2.exports = (h2 || (h2 = 1, g2.ConcurrentRoot = 1, g2.ContinuousEventPriority = 8, g2.DefaultEventPriority = 32, g2.DiscreteEventPriority = 2, g2.IdleEventPriority = 268435456, g2.LegacyRoot = 0, g2.NoEventPriority = 0), g2);
var y2 = p2.exports;
var b2 = (e4, n5) => {
  const t4 = Object.keys(e4), r5 = Object.keys(n5);
  if (t4.length !== r5.length) return false;
  for (let r6 = 0; r6 < t4.length; r6 += 1) {
    const l2 = t4[r6];
    if ("render" === l2 && !e4[l2] != !n5[l2]) return false;
    if ("children" !== l2 && e4[l2] !== n5[l2]) {
      if ("object" == typeof e4[l2] && "object" == typeof n5[l2] && b2(e4[l2], n5[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e4[l2] || "string" == typeof n5[l2])) return e4[l2] === n5[l2];
  }
  return true;
};
var v2 = {};
var S2 = console.error;
var k2 = ({ appendChild: e4, appendChildToContainer: n5, commitTextUpdate: t4, commitUpdate: r5, createInstance: l2, createTextInstance: a4, insertBefore: o2, removeChild: u4, removeChildFromContainer: i4, resetAfterCommit: s2 }) => {
  const c4 = f({ appendChild: e4, appendChildToContainer: n5, appendInitialChild: e4, createInstance: l2, createTextInstance: a4, insertBefore: o2, commitUpdate: (e5, n6, t5, l3) => {
    b2(t5, l3) || r5(e5, null, n6, t5, l3);
  }, commitTextUpdate: t4, removeChild: u4, removeChildFromContainer: i4, resetAfterCommit: s2, noTimeout: -1, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e5) => e5, getRootHostContext: () => v2, getChildHostContext: () => v2, prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: () => y2.DefaultEventPriority, maySuspendCommit: () => false, requestPostPaintCallback: () => {
  }, resolveUpdatePriority: () => y2.DefaultEventPriority, setCurrentUpdatePriority: () => {
  }, shouldAttemptEagerTransition: () => false, detachDeletedInstance: () => {
  }, resolveEventTimeStamp: () => {
  }, resolveEventType: () => {
  }, trackSchedulerEvent: () => {
  } });
  return { createContainer: (e5) => c4.createContainer(e5, y2.ConcurrentRoot, null, false, null, "", S2, S2, S2, () => {
  }, null), updateContainer: (e5, n6, t5, r6) => {
    c4.updateContainerSync(e5, n6, t5, r6), c4.flushSyncWork();
  } };
};

// node_modules/@react-pdf/reconciler/lib/reconciler-23.js
var import_object_assign = __toESM(require_object_assign(), 1);
var import_react3 = __toESM(require_react(), 1);
var n3 = __toESM(require_scheduler(), 1);
function r4(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
function l(e4) {
  if (e4.__esModule) return e4;
  var t4 = e4.default;
  if ("function" == typeof t4) {
    var n5 = function e5() {
      return this instanceof e5 ? Reflect.construct(t4, arguments, this.constructor) : t4.apply(this, arguments);
    };
    n5.prototype = t4.prototype;
  } else n5 = {};
  return Object.defineProperty(n5, "__esModule", { value: true }), Object.keys(e4).forEach(function(t5) {
    var r5 = Object.getOwnPropertyDescriptor(e4, t5);
    Object.defineProperty(n5, t5, r5.get ? r5 : { enumerable: true, get: function() {
      return e4[t5];
    } });
  }), n5;
}
var i3;
var a3 = { exports: {} };
var u3 = l(n3);
/** @license React v0.23.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(i3 = a3).exports = function n4(r5) {
  var l2 = import_object_assign.default, a4 = import_react3.default, o2 = u3;
  function f3(e4) {
    for (var t4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e4, n5 = 1; n5 < arguments.length; n5++) t4 += "&args[]=" + encodeURIComponent(arguments[n5]);
    return "Minified React error #" + e4 + "; visit " + t4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var c4 = a4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  c4.hasOwnProperty("ReactCurrentDispatcher") || (c4.ReactCurrentDispatcher = { current: null }), c4.hasOwnProperty("ReactCurrentBatchConfig") || (c4.ReactCurrentBatchConfig = { suspense: null });
  var s2 = "function" == typeof Symbol && Symbol.for, d2 = s2 ? Symbol.for("react.element") : 60103, p3 = s2 ? Symbol.for("react.portal") : 60106, m = s2 ? Symbol.for("react.fragment") : 60107, h3 = s2 ? Symbol.for("react.strict_mode") : 60108, g3 = s2 ? Symbol.for("react.profiler") : 60114, b3 = s2 ? Symbol.for("react.provider") : 60109, y3 = s2 ? Symbol.for("react.context") : 60110, v3 = s2 ? Symbol.for("react.concurrent_mode") : 60111, T = s2 ? Symbol.for("react.forward_ref") : 60112, x = s2 ? Symbol.for("react.suspense") : 60113, E = s2 ? Symbol.for("react.suspense_list") : 60120, k3 = s2 ? Symbol.for("react.memo") : 60115, S3 = s2 ? Symbol.for("react.lazy") : 60116, C = "function" == typeof Symbol && Symbol.iterator;
  function w(e4) {
    return null === e4 || "object" != typeof e4 ? null : "function" == typeof (e4 = C && e4[C] || e4["@@iterator"]) ? e4 : null;
  }
  function z(e4) {
    if (null == e4) return null;
    if ("function" == typeof e4) return e4.displayName || e4.name || null;
    if ("string" == typeof e4) return e4;
    switch (e4) {
      case m:
        return "Fragment";
      case p3:
        return "Portal";
      case g3:
        return "Profiler";
      case h3:
        return "StrictMode";
      case x:
        return "Suspense";
      case E:
        return "SuspenseList";
    }
    if ("object" == typeof e4) switch (e4.$$typeof) {
      case y3:
        return "Context.Consumer";
      case b3:
        return "Context.Provider";
      case T:
        var t4 = e4.render;
        return t4 = t4.displayName || t4.name || "", e4.displayName || ("" !== t4 ? "ForwardRef(" + t4 + ")" : "ForwardRef");
      case k3:
        return z(e4.type);
      case S3:
        if (e4 = 1 === e4._status ? e4._result : null) return z(e4);
    }
    return null;
  }
  function P(e4) {
    var t4 = e4, n5 = e4;
    if (e4.alternate) for (; t4.return; ) t4 = t4.return;
    else {
      e4 = t4;
      do {
        0 != (1026 & (t4 = e4).effectTag) && (n5 = t4.return), e4 = t4.return;
      } while (e4);
    }
    return 3 === t4.tag ? n5 : null;
  }
  function _(e4) {
    if (P(e4) !== e4) throw Error(f3(188));
  }
  function N(e4) {
    var t4 = e4.alternate;
    if (!t4) {
      if (null === (t4 = P(e4))) throw Error(f3(188));
      return t4 !== e4 ? null : e4;
    }
    for (var n5 = e4, r6 = t4; ; ) {
      var l3 = n5.return;
      if (null === l3) break;
      var i4 = l3.alternate;
      if (null === i4) {
        if (null !== (r6 = l3.return)) {
          n5 = r6;
          continue;
        }
        break;
      }
      if (l3.child === i4.child) {
        for (i4 = l3.child; i4; ) {
          if (i4 === n5) return _(l3), e4;
          if (i4 === r6) return _(l3), t4;
          i4 = i4.sibling;
        }
        throw Error(f3(188));
      }
      if (n5.return !== r6.return) n5 = l3, r6 = i4;
      else {
        for (var a5 = false, u4 = l3.child; u4; ) {
          if (u4 === n5) {
            a5 = true, n5 = l3, r6 = i4;
            break;
          }
          if (u4 === r6) {
            a5 = true, r6 = l3, n5 = i4;
            break;
          }
          u4 = u4.sibling;
        }
        if (!a5) {
          for (u4 = i4.child; u4; ) {
            if (u4 === n5) {
              a5 = true, n5 = i4, r6 = l3;
              break;
            }
            if (u4 === r6) {
              a5 = true, r6 = i4, n5 = l3;
              break;
            }
            u4 = u4.sibling;
          }
          if (!a5) throw Error(f3(189));
        }
      }
      if (n5.alternate !== r6) throw Error(f3(190));
    }
    if (3 !== n5.tag) throw Error(f3(188));
    return n5.stateNode.current === n5 ? e4 : t4;
  }
  function U(e4) {
    if (!(e4 = N(e4))) return null;
    for (var t4 = e4; ; ) {
      if (5 === t4.tag || 6 === t4.tag) return t4;
      if (t4.child) t4.child.return = t4, t4 = t4.child;
      else {
        if (t4 === e4) break;
        for (; !t4.sibling; ) {
          if (!t4.return || t4.return === e4) return null;
          t4 = t4.return;
        }
        t4.sibling.return = t4.return, t4 = t4.sibling;
      }
    }
    return null;
  }
  var R = r5.getPublicInstance, I = r5.getRootHostContext, M = r5.getChildHostContext, F = r5.prepareForCommit, Q = r5.resetAfterCommit, D = r5.createInstance, W = r5.appendInitialChild, j = r5.finalizeInitialChildren, O = r5.prepareUpdate, B = r5.shouldSetTextContent, H = r5.createTextInstance, A = null, L = null, $ = r5.noTimeout, q = true, V = null, K = r5.appendChild, G2 = r5.appendChildToContainer, Y = r5.commitTextUpdate, J = null, X = r5.commitUpdate, Z = r5.insertBefore, ee = null, te = r5.removeChild, ne = r5.removeChildFromContainer, re = r5.resetTextContent, le = null, ie = null, ae = null, ue = null, oe = null, fe = null, ce = /^(.*)[\\\/]/;
  function se(e4) {
    var t4 = "";
    do {
      e: switch (e4.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var n5 = "";
          break e;
        default:
          var r6 = e4._debugOwner, l3 = e4._debugSource, i4 = z(e4.type);
          n5 = null, r6 && (n5 = z(r6.type)), r6 = i4, i4 = "", l3 ? i4 = " (at " + l3.fileName.replace(ce, "") + ":" + l3.lineNumber + ")" : n5 && (i4 = " (created by " + n5 + ")"), n5 = "\n    in " + (r6 || "Unknown") + i4;
      }
      t4 += n5, e4 = e4.return;
    } while (e4);
    return t4;
  }
  var de = [], pe = -1;
  function me(e4) {
    0 > pe || (e4.current = de[pe], de[pe] = null, pe--);
  }
  function he(e4, t4) {
    pe++, de[pe] = e4.current, e4.current = t4;
  }
  var ge = {}, be = { current: ge }, ye = { current: false }, ve = ge;
  function Te(e4, t4) {
    var n5 = e4.type.contextTypes;
    if (!n5) return ge;
    var r6 = e4.stateNode;
    if (r6 && r6.__reactInternalMemoizedUnmaskedChildContext === t4) return r6.__reactInternalMemoizedMaskedChildContext;
    var l3, i4 = {};
    for (l3 in n5) i4[l3] = t4[l3];
    return r6 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = t4, e4.__reactInternalMemoizedMaskedChildContext = i4), i4;
  }
  function xe(e4) {
    return null != (e4 = e4.childContextTypes);
  }
  function Ee(e4) {
    me(ye), me(be);
  }
  function ke(e4) {
    me(ye), me(be);
  }
  function Se(e4, t4, n5) {
    if (be.current !== ge) throw Error(f3(168));
    he(be, t4), he(ye, n5);
  }
  function Ce(e4, t4, n5) {
    var r6 = e4.stateNode;
    if (e4 = t4.childContextTypes, "function" != typeof r6.getChildContext) return n5;
    for (var i4 in r6 = r6.getChildContext()) if (!(i4 in e4)) throw Error(f3(108, z(t4) || "Unknown", i4));
    return l2({}, n5, {}, r6);
  }
  function we(e4) {
    var t4 = e4.stateNode;
    return t4 = t4 && t4.__reactInternalMemoizedMergedChildContext || ge, ve = be.current, he(be, t4), he(ye, ye.current), true;
  }
  function ze(e4, t4, n5) {
    var r6 = e4.stateNode;
    if (!r6) throw Error(f3(169));
    n5 ? (t4 = Ce(e4, t4, ve), r6.__reactInternalMemoizedMergedChildContext = t4, me(ye), me(be), he(be, t4)) : me(ye), he(ye, n5);
  }
  var Pe = o2.unstable_runWithPriority, _e = o2.unstable_scheduleCallback, Ne = o2.unstable_cancelCallback, Ue = o2.unstable_shouldYield, Re = o2.unstable_requestPaint, Ie = o2.unstable_now, Me = o2.unstable_getCurrentPriorityLevel, Fe = o2.unstable_ImmediatePriority, Qe = o2.unstable_UserBlockingPriority, De = o2.unstable_NormalPriority, We = o2.unstable_LowPriority, je = o2.unstable_IdlePriority, Oe = {}, Be = void 0 !== Re ? Re : function() {
  }, He = null, Ae = null, Le = false, $e = Ie(), qe = 1e4 > $e ? Ie : function() {
    return Ie() - $e;
  };
  function Ve() {
    switch (Me()) {
      case Fe:
        return 99;
      case Qe:
        return 98;
      case De:
        return 97;
      case We:
        return 96;
      case je:
        return 95;
      default:
        throw Error(f3(332));
    }
  }
  function Ke(e4) {
    switch (e4) {
      case 99:
        return Fe;
      case 98:
        return Qe;
      case 97:
        return De;
      case 96:
        return We;
      case 95:
        return je;
      default:
        throw Error(f3(332));
    }
  }
  function Ge(e4, t4) {
    return e4 = Ke(e4), Pe(e4, t4);
  }
  function Ye(e4, t4, n5) {
    return e4 = Ke(e4), _e(e4, t4, n5);
  }
  function Je(e4) {
    return null === He ? (He = [e4], Ae = _e(Fe, Ze)) : He.push(e4), Oe;
  }
  function Xe() {
    if (null !== Ae) {
      var e4 = Ae;
      Ae = null, Ne(e4);
    }
    Ze();
  }
  function Ze() {
    if (!Le && null !== He) {
      Le = true;
      var e4 = 0;
      try {
        var t4 = He;
        Ge(99, function() {
          for (; e4 < t4.length; e4++) {
            var n5 = t4[e4];
            do {
              n5 = n5(true);
            } while (null !== n5);
          }
        }), He = null;
      } catch (t5) {
        throw null !== He && (He = He.slice(e4 + 1)), _e(Fe, Xe), t5;
      } finally {
        Le = false;
      }
    }
  }
  var et = 3;
  function tt(e4, t4, n5) {
    return 1073741821 - (1 + ((1073741821 - e4 + t4 / 10) / (n5 /= 10) | 0)) * n5;
  }
  var nt = "function" == typeof Object.is ? Object.is : function(e4, t4) {
    return e4 === t4 && (0 !== e4 || 1 / e4 == 1 / t4) || e4 != e4 && t4 != t4;
  }, rt = Object.prototype.hasOwnProperty;
  function lt(e4, t4) {
    if (nt(e4, t4)) return true;
    if ("object" != typeof e4 || null === e4 || "object" != typeof t4 || null === t4) return false;
    var n5 = Object.keys(e4), r6 = Object.keys(t4);
    if (n5.length !== r6.length) return false;
    for (r6 = 0; r6 < n5.length; r6++) if (!rt.call(t4, n5[r6]) || !nt(e4[n5[r6]], t4[n5[r6]])) return false;
    return true;
  }
  function it(e4, t4) {
    if (e4 && e4.defaultProps) for (var n5 in t4 = l2({}, t4), e4 = e4.defaultProps) void 0 === t4[n5] && (t4[n5] = e4[n5]);
    return t4;
  }
  var at = { current: null }, ut = null, ot = null, ft = null;
  function ct() {
    ft = ot = ut = null;
  }
  function st(e4, t4) {
    var n5 = e4.type._context;
    he(at, n5._currentValue2), n5._currentValue2 = t4;
  }
  function dt(e4) {
    var t4 = at.current;
    me(at), (e4 = e4.type._context)._currentValue2 = t4;
  }
  function pt(e4, t4) {
    for (; null !== e4; ) {
      var n5 = e4.alternate;
      if (e4.childExpirationTime < t4) e4.childExpirationTime = t4, null !== n5 && n5.childExpirationTime < t4 && (n5.childExpirationTime = t4);
      else {
        if (!(null !== n5 && n5.childExpirationTime < t4)) break;
        n5.childExpirationTime = t4;
      }
      e4 = e4.return;
    }
  }
  function mt(e4, t4) {
    ut = e4, ft = ot = null, null !== (e4 = e4.dependencies) && null !== e4.firstContext && (e4.expirationTime >= t4 && (On = true), e4.firstContext = null);
  }
  function ht(e4, t4) {
    if (ft !== e4 && false !== t4 && 0 !== t4) if ("number" == typeof t4 && 1073741823 !== t4 || (ft = e4, t4 = 1073741823), t4 = { context: e4, observedBits: t4, next: null }, null === ot) {
      if (null === ut) throw Error(f3(308));
      ot = t4, ut.dependencies = { expirationTime: 0, firstContext: t4, responders: null };
    } else ot = ot.next = t4;
    return e4._currentValue2;
  }
  var gt = false;
  function bt(e4) {
    return { baseState: e4, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function yt(e4) {
    return { baseState: e4.baseState, firstUpdate: e4.firstUpdate, lastUpdate: e4.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function vt(e4, t4) {
    return { expirationTime: e4, suspenseConfig: t4, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
  }
  function Tt(e4, t4) {
    null === e4.lastUpdate ? e4.firstUpdate = e4.lastUpdate = t4 : (e4.lastUpdate.next = t4, e4.lastUpdate = t4);
  }
  function xt(e4, t4) {
    var n5 = e4.alternate;
    if (null === n5) {
      var r6 = e4.updateQueue, l3 = null;
      null === r6 && (r6 = e4.updateQueue = bt(e4.memoizedState));
    } else r6 = e4.updateQueue, l3 = n5.updateQueue, null === r6 ? null === l3 ? (r6 = e4.updateQueue = bt(e4.memoizedState), l3 = n5.updateQueue = bt(n5.memoizedState)) : r6 = e4.updateQueue = yt(l3) : null === l3 && (l3 = n5.updateQueue = yt(r6));
    null === l3 || r6 === l3 ? Tt(r6, t4) : null === r6.lastUpdate || null === l3.lastUpdate ? (Tt(r6, t4), Tt(l3, t4)) : (Tt(r6, t4), l3.lastUpdate = t4);
  }
  function Et(e4, t4) {
    var n5 = e4.updateQueue;
    null === (n5 = null === n5 ? e4.updateQueue = bt(e4.memoizedState) : kt(e4, n5)).lastCapturedUpdate ? n5.firstCapturedUpdate = n5.lastCapturedUpdate = t4 : (n5.lastCapturedUpdate.next = t4, n5.lastCapturedUpdate = t4);
  }
  function kt(e4, t4) {
    var n5 = e4.alternate;
    return null !== n5 && t4 === n5.updateQueue && (t4 = e4.updateQueue = yt(t4)), t4;
  }
  function St(e4, t4, n5, r6, i4, a5) {
    switch (n5.tag) {
      case 1:
        return "function" == typeof (e4 = n5.payload) ? e4.call(a5, r6, i4) : e4;
      case 3:
        e4.effectTag = -4097 & e4.effectTag | 64;
      case 0:
        if (null == (i4 = "function" == typeof (e4 = n5.payload) ? e4.call(a5, r6, i4) : e4)) break;
        return l2({}, r6, i4);
      case 2:
        gt = true;
    }
    return r6;
  }
  function Ct(e4, t4, n5, r6, l3) {
    gt = false;
    for (var i4 = (t4 = kt(e4, t4)).baseState, a5 = null, u4 = 0, o3 = t4.firstUpdate, f4 = i4; null !== o3; ) {
      var c5 = o3.expirationTime;
      c5 < l3 ? (null === a5 && (a5 = o3, i4 = f4), u4 < c5 && (u4 = c5)) : (El(c5, o3.suspenseConfig), f4 = St(e4, 0, o3, f4, n5, r6), null !== o3.callback && (e4.effectTag |= 32, o3.nextEffect = null, null === t4.lastEffect ? t4.firstEffect = t4.lastEffect = o3 : (t4.lastEffect.nextEffect = o3, t4.lastEffect = o3))), o3 = o3.next;
    }
    for (c5 = null, o3 = t4.firstCapturedUpdate; null !== o3; ) {
      var s3 = o3.expirationTime;
      s3 < l3 ? (null === c5 && (c5 = o3, null === a5 && (i4 = f4)), u4 < s3 && (u4 = s3)) : (f4 = St(e4, 0, o3, f4, n5, r6), null !== o3.callback && (e4.effectTag |= 32, o3.nextEffect = null, null === t4.lastCapturedEffect ? t4.firstCapturedEffect = t4.lastCapturedEffect = o3 : (t4.lastCapturedEffect.nextEffect = o3, t4.lastCapturedEffect = o3))), o3 = o3.next;
    }
    null === a5 && (t4.lastUpdate = null), null === c5 ? t4.lastCapturedUpdate = null : e4.effectTag |= 32, null === a5 && null === c5 && (i4 = f4), t4.baseState = i4, t4.firstUpdate = a5, t4.firstCapturedUpdate = c5, kl(u4), e4.expirationTime = u4, e4.memoizedState = f4;
  }
  function wt(e4, t4, n5) {
    null !== t4.firstCapturedUpdate && (null !== t4.lastUpdate && (t4.lastUpdate.next = t4.firstCapturedUpdate, t4.lastUpdate = t4.lastCapturedUpdate), t4.firstCapturedUpdate = t4.lastCapturedUpdate = null), zt(t4.firstEffect, n5), t4.firstEffect = t4.lastEffect = null, zt(t4.firstCapturedEffect, n5), t4.firstCapturedEffect = t4.lastCapturedEffect = null;
  }
  function zt(e4, t4) {
    for (; null !== e4; ) {
      var n5 = e4.callback;
      if (null !== n5) {
        e4.callback = null;
        var r6 = t4;
        if ("function" != typeof n5) throw Error(f3(191, n5));
        n5.call(r6);
      }
      e4 = e4.nextEffect;
    }
  }
  var Pt = c4.ReactCurrentBatchConfig, _t = new a4.Component().refs;
  function Nt(e4, t4, n5, r6) {
    n5 = null == (n5 = n5(r6, t4 = e4.memoizedState)) ? t4 : l2({}, t4, n5), e4.memoizedState = n5, null !== (r6 = e4.updateQueue) && 0 === e4.expirationTime && (r6.baseState = n5);
  }
  var Ut = { isMounted: function(e4) {
    return !!(e4 = e4._reactInternalFiber) && P(e4) === e4;
  }, enqueueSetState: function(e4, t4, n5) {
    e4 = e4._reactInternalFiber;
    var r6 = cl(), l3 = Pt.suspense;
    (l3 = vt(r6 = sl(r6, e4, l3), l3)).payload = t4, null != n5 && (l3.callback = n5), xt(e4, l3), dl(e4, r6);
  }, enqueueReplaceState: function(e4, t4, n5) {
    e4 = e4._reactInternalFiber;
    var r6 = cl(), l3 = Pt.suspense;
    (l3 = vt(r6 = sl(r6, e4, l3), l3)).tag = 1, l3.payload = t4, null != n5 && (l3.callback = n5), xt(e4, l3), dl(e4, r6);
  }, enqueueForceUpdate: function(e4, t4) {
    e4 = e4._reactInternalFiber;
    var n5 = cl(), r6 = Pt.suspense;
    (r6 = vt(n5 = sl(n5, e4, r6), r6)).tag = 2, null != t4 && (r6.callback = t4), xt(e4, r6), dl(e4, n5);
  } };
  function Rt(e4, t4, n5, r6, l3, i4, a5) {
    return "function" == typeof (e4 = e4.stateNode).shouldComponentUpdate ? e4.shouldComponentUpdate(r6, i4, a5) : !(t4.prototype && t4.prototype.isPureReactComponent && lt(n5, r6) && lt(l3, i4));
  }
  function It(e4, t4, n5) {
    var r6 = false, l3 = ge, i4 = t4.contextType;
    return "object" == typeof i4 && null !== i4 ? i4 = ht(i4) : (l3 = xe(t4) ? ve : be.current, i4 = (r6 = null != (r6 = t4.contextTypes)) ? Te(e4, l3) : ge), t4 = new t4(n5, i4), e4.memoizedState = null !== t4.state && void 0 !== t4.state ? t4.state : null, t4.updater = Ut, e4.stateNode = t4, t4._reactInternalFiber = e4, r6 && ((e4 = e4.stateNode).__reactInternalMemoizedUnmaskedChildContext = l3, e4.__reactInternalMemoizedMaskedChildContext = i4), t4;
  }
  function Mt(e4, t4, n5, r6) {
    e4 = t4.state, "function" == typeof t4.componentWillReceiveProps && t4.componentWillReceiveProps(n5, r6), "function" == typeof t4.UNSAFE_componentWillReceiveProps && t4.UNSAFE_componentWillReceiveProps(n5, r6), t4.state !== e4 && Ut.enqueueReplaceState(t4, t4.state, null);
  }
  function Ft(e4, t4, n5, r6) {
    var l3 = e4.stateNode;
    l3.props = n5, l3.state = e4.memoizedState, l3.refs = _t;
    var i4 = t4.contextType;
    "object" == typeof i4 && null !== i4 ? l3.context = ht(i4) : (i4 = xe(t4) ? ve : be.current, l3.context = Te(e4, i4)), null !== (i4 = e4.updateQueue) && (Ct(e4, i4, n5, l3, r6), l3.state = e4.memoizedState), "function" == typeof (i4 = t4.getDerivedStateFromProps) && (Nt(e4, t4, i4, n5), l3.state = e4.memoizedState), "function" == typeof t4.getDerivedStateFromProps || "function" == typeof l3.getSnapshotBeforeUpdate || "function" != typeof l3.UNSAFE_componentWillMount && "function" != typeof l3.componentWillMount || (t4 = l3.state, "function" == typeof l3.componentWillMount && l3.componentWillMount(), "function" == typeof l3.UNSAFE_componentWillMount && l3.UNSAFE_componentWillMount(), t4 !== l3.state && Ut.enqueueReplaceState(l3, l3.state, null), null !== (i4 = e4.updateQueue) && (Ct(e4, i4, n5, l3, r6), l3.state = e4.memoizedState)), "function" == typeof l3.componentDidMount && (e4.effectTag |= 4);
  }
  var Qt = Array.isArray;
  function Dt(e4, t4, n5) {
    if (null !== (e4 = n5.ref) && "function" != typeof e4 && "object" != typeof e4) {
      if (n5._owner) {
        if (n5 = n5._owner) {
          if (1 !== n5.tag) throw Error(f3(309));
          var r6 = n5.stateNode;
        }
        if (!r6) throw Error(f3(147, e4));
        var l3 = "" + e4;
        return null !== t4 && null !== t4.ref && "function" == typeof t4.ref && t4.ref._stringRef === l3 ? t4.ref : (t4 = function(e5) {
          var t5 = r6.refs;
          t5 === _t && (t5 = r6.refs = {}), null === e5 ? delete t5[l3] : t5[l3] = e5;
        }, t4._stringRef = l3, t4);
      }
      if ("string" != typeof e4) throw Error(f3(284));
      if (!n5._owner) throw Error(f3(290, e4));
    }
    return e4;
  }
  function Wt(e4, t4) {
    if ("textarea" !== e4.type) throw Error(f3(31, "[object Object]" === Object.prototype.toString.call(t4) ? "object with keys {" + Object.keys(t4).join(", ") + "}" : t4, ""));
  }
  function jt(e4) {
    function t4(t5, n6) {
      if (e4) {
        var r7 = t5.lastEffect;
        null !== r7 ? (r7.nextEffect = n6, t5.lastEffect = n6) : t5.firstEffect = t5.lastEffect = n6, n6.nextEffect = null, n6.effectTag = 8;
      }
    }
    function n5(n6, r7) {
      if (!e4) return null;
      for (; null !== r7; ) t4(n6, r7), r7 = r7.sibling;
      return null;
    }
    function r6(e5, t5) {
      for (e5 = /* @__PURE__ */ new Map(); null !== t5; ) null !== t5.key ? e5.set(t5.key, t5) : e5.set(t5.index, t5), t5 = t5.sibling;
      return e5;
    }
    function l3(e5, t5, n6) {
      return (e5 = Al(e5, t5)).index = 0, e5.sibling = null, e5;
    }
    function i4(t5, n6, r7) {
      return t5.index = r7, e4 ? null !== (r7 = t5.alternate) ? (r7 = r7.index) < n6 ? (t5.effectTag = 2, n6) : r7 : (t5.effectTag = 2, n6) : n6;
    }
    function a5(t5) {
      return e4 && null === t5.alternate && (t5.effectTag = 2), t5;
    }
    function u4(e5, t5, n6, r7) {
      return null === t5 || 6 !== t5.tag ? ((t5 = ql(n6, e5.mode, r7)).return = e5, t5) : ((t5 = l3(t5, n6)).return = e5, t5);
    }
    function o3(e5, t5, n6, r7) {
      return null !== t5 && t5.elementType === n6.type ? ((r7 = l3(t5, n6.props)).ref = Dt(e5, t5, n6), r7.return = e5, r7) : ((r7 = Ll(n6.type, n6.key, n6.props, null, e5.mode, r7)).ref = Dt(e5, t5, n6), r7.return = e5, r7);
    }
    function c5(e5, t5, n6, r7) {
      return null === t5 || 4 !== t5.tag || t5.stateNode.containerInfo !== n6.containerInfo || t5.stateNode.implementation !== n6.implementation ? ((t5 = Vl(n6, e5.mode, r7)).return = e5, t5) : ((t5 = l3(t5, n6.children || [])).return = e5, t5);
    }
    function s3(e5, t5, n6, r7, i5) {
      return null === t5 || 7 !== t5.tag ? ((t5 = $l(n6, e5.mode, r7, i5)).return = e5, t5) : ((t5 = l3(t5, n6)).return = e5, t5);
    }
    function h4(e5, t5, n6) {
      if ("string" == typeof t5 || "number" == typeof t5) return (t5 = ql("" + t5, e5.mode, n6)).return = e5, t5;
      if ("object" == typeof t5 && null !== t5) {
        switch (t5.$$typeof) {
          case d2:
            return (n6 = Ll(t5.type, t5.key, t5.props, null, e5.mode, n6)).ref = Dt(e5, null, t5), n6.return = e5, n6;
          case p3:
            return (t5 = Vl(t5, e5.mode, n6)).return = e5, t5;
        }
        if (Qt(t5) || w(t5)) return (t5 = $l(t5, e5.mode, n6, null)).return = e5, t5;
        Wt(e5, t5);
      }
      return null;
    }
    function g4(e5, t5, n6, r7) {
      var l4 = null !== t5 ? t5.key : null;
      if ("string" == typeof n6 || "number" == typeof n6) return null !== l4 ? null : u4(e5, t5, "" + n6, r7);
      if ("object" == typeof n6 && null !== n6) {
        switch (n6.$$typeof) {
          case d2:
            return n6.key === l4 ? n6.type === m ? s3(e5, t5, n6.props.children, r7, l4) : o3(e5, t5, n6, r7) : null;
          case p3:
            return n6.key === l4 ? c5(e5, t5, n6, r7) : null;
        }
        if (Qt(n6) || w(n6)) return null !== l4 ? null : s3(e5, t5, n6, r7, null);
        Wt(e5, n6);
      }
      return null;
    }
    function b4(e5, t5, n6, r7, l4) {
      if ("string" == typeof r7 || "number" == typeof r7) return u4(t5, e5 = e5.get(n6) || null, "" + r7, l4);
      if ("object" == typeof r7 && null !== r7) {
        switch (r7.$$typeof) {
          case d2:
            return e5 = e5.get(null === r7.key ? n6 : r7.key) || null, r7.type === m ? s3(t5, e5, r7.props.children, l4, r7.key) : o3(t5, e5, r7, l4);
          case p3:
            return c5(t5, e5 = e5.get(null === r7.key ? n6 : r7.key) || null, r7, l4);
        }
        if (Qt(r7) || w(r7)) return s3(t5, e5 = e5.get(n6) || null, r7, l4, null);
        Wt(t5, r7);
      }
      return null;
    }
    function y4(l4, a6, u5, o4) {
      for (var f4 = null, c6 = null, s4 = a6, d3 = a6 = 0, p4 = null; null !== s4 && d3 < u5.length; d3++) {
        s4.index > d3 ? (p4 = s4, s4 = null) : p4 = s4.sibling;
        var m2 = g4(l4, s4, u5[d3], o4);
        if (null === m2) {
          null === s4 && (s4 = p4);
          break;
        }
        e4 && s4 && null === m2.alternate && t4(l4, s4), a6 = i4(m2, a6, d3), null === c6 ? f4 = m2 : c6.sibling = m2, c6 = m2, s4 = p4;
      }
      if (d3 === u5.length) return n5(l4, s4), f4;
      if (null === s4) {
        for (; d3 < u5.length; d3++) null !== (s4 = h4(l4, u5[d3], o4)) && (a6 = i4(s4, a6, d3), null === c6 ? f4 = s4 : c6.sibling = s4, c6 = s4);
        return f4;
      }
      for (s4 = r6(l4, s4); d3 < u5.length; d3++) null !== (p4 = b4(s4, l4, d3, u5[d3], o4)) && (e4 && null !== p4.alternate && s4.delete(null === p4.key ? d3 : p4.key), a6 = i4(p4, a6, d3), null === c6 ? f4 = p4 : c6.sibling = p4, c6 = p4);
      return e4 && s4.forEach(function(e5) {
        return t4(l4, e5);
      }), f4;
    }
    function v4(l4, a6, u5, o4) {
      var c6 = w(u5);
      if ("function" != typeof c6) throw Error(f3(150));
      if (null == (u5 = c6.call(u5))) throw Error(f3(151));
      for (var s4 = c6 = null, d3 = a6, p4 = a6 = 0, m2 = null, y5 = u5.next(); null !== d3 && !y5.done; p4++, y5 = u5.next()) {
        d3.index > p4 ? (m2 = d3, d3 = null) : m2 = d3.sibling;
        var v5 = g4(l4, d3, y5.value, o4);
        if (null === v5) {
          null === d3 && (d3 = m2);
          break;
        }
        e4 && d3 && null === v5.alternate && t4(l4, d3), a6 = i4(v5, a6, p4), null === s4 ? c6 = v5 : s4.sibling = v5, s4 = v5, d3 = m2;
      }
      if (y5.done) return n5(l4, d3), c6;
      if (null === d3) {
        for (; !y5.done; p4++, y5 = u5.next()) null !== (y5 = h4(l4, y5.value, o4)) && (a6 = i4(y5, a6, p4), null === s4 ? c6 = y5 : s4.sibling = y5, s4 = y5);
        return c6;
      }
      for (d3 = r6(l4, d3); !y5.done; p4++, y5 = u5.next()) null !== (y5 = b4(d3, l4, p4, y5.value, o4)) && (e4 && null !== y5.alternate && d3.delete(null === y5.key ? p4 : y5.key), a6 = i4(y5, a6, p4), null === s4 ? c6 = y5 : s4.sibling = y5, s4 = y5);
      return e4 && d3.forEach(function(e5) {
        return t4(l4, e5);
      }), c6;
    }
    return function(e5, r7, i5, u5) {
      var o4 = "object" == typeof i5 && null !== i5 && i5.type === m && null === i5.key;
      o4 && (i5 = i5.props.children);
      var c6 = "object" == typeof i5 && null !== i5;
      if (c6) switch (i5.$$typeof) {
        case d2:
          e: {
            for (c6 = i5.key, o4 = r7; null !== o4; ) {
              if (o4.key === c6) {
                if (7 === o4.tag ? i5.type === m : o4.elementType === i5.type) {
                  n5(e5, o4.sibling), (r7 = l3(o4, i5.type === m ? i5.props.children : i5.props)).ref = Dt(e5, o4, i5), r7.return = e5, e5 = r7;
                  break e;
                }
                n5(e5, o4);
                break;
              }
              t4(e5, o4), o4 = o4.sibling;
            }
            i5.type === m ? ((r7 = $l(i5.props.children, e5.mode, u5, i5.key)).return = e5, e5 = r7) : ((u5 = Ll(i5.type, i5.key, i5.props, null, e5.mode, u5)).ref = Dt(e5, r7, i5), u5.return = e5, e5 = u5);
          }
          return a5(e5);
        case p3:
          e: {
            for (o4 = i5.key; null !== r7; ) {
              if (r7.key === o4) {
                if (4 === r7.tag && r7.stateNode.containerInfo === i5.containerInfo && r7.stateNode.implementation === i5.implementation) {
                  n5(e5, r7.sibling), (r7 = l3(r7, i5.children || [])).return = e5, e5 = r7;
                  break e;
                }
                n5(e5, r7);
                break;
              }
              t4(e5, r7), r7 = r7.sibling;
            }
            (r7 = Vl(i5, e5.mode, u5)).return = e5, e5 = r7;
          }
          return a5(e5);
      }
      if ("string" == typeof i5 || "number" == typeof i5) return i5 = "" + i5, null !== r7 && 6 === r7.tag ? (n5(e5, r7.sibling), (r7 = l3(r7, i5)).return = e5, e5 = r7) : (n5(e5, r7), (r7 = ql(i5, e5.mode, u5)).return = e5, e5 = r7), a5(e5);
      if (Qt(i5)) return y4(e5, r7, i5, u5);
      if (w(i5)) return v4(e5, r7, i5, u5);
      if (c6 && Wt(e5, i5), void 0 === i5 && !o4) switch (e5.tag) {
        case 1:
        case 0:
          throw e5 = e5.type, Error(f3(152, e5.displayName || e5.name || "Component"));
      }
      return n5(e5, r7);
    };
  }
  var Ot = jt(true), Bt = jt(false), Ht = {}, At = { current: Ht }, Lt = { current: Ht }, $t = { current: Ht };
  function qt(e4) {
    if (e4 === Ht) throw Error(f3(174));
    return e4;
  }
  function Vt(e4, t4) {
    he($t, t4), he(Lt, e4), he(At, Ht), t4 = I(t4), me(At), he(At, t4);
  }
  function Kt(e4) {
    me(At), me(Lt), me($t);
  }
  function Gt(e4) {
    var t4 = qt($t.current), n5 = qt(At.current);
    n5 !== (t4 = M(n5, e4.type, t4)) && (he(Lt, e4), he(At, t4));
  }
  function Yt(e4) {
    Lt.current === e4 && (me(At), me(Lt));
  }
  var Jt = { current: 0 };
  function Xt(e4) {
    for (var t4 = e4; null !== t4; ) {
      if (13 === t4.tag) {
        var n5 = t4.memoizedState;
        if (null !== n5 && (null === (n5 = n5.dehydrated) || oe(n5) || fe(n5))) return t4;
      } else if (19 === t4.tag && void 0 !== t4.memoizedProps.revealOrder) {
        if (0 != (64 & t4.effectTag)) return t4;
      } else if (null !== t4.child) {
        t4.child.return = t4, t4 = t4.child;
        continue;
      }
      if (t4 === e4) break;
      for (; null === t4.sibling; ) {
        if (null === t4.return || t4.return === e4) return null;
        t4 = t4.return;
      }
      t4.sibling.return = t4.return, t4 = t4.sibling;
    }
    return null;
  }
  function Zt(e4, t4) {
    return { responder: e4, props: t4 };
  }
  var en = c4.ReactCurrentDispatcher, tn = c4.ReactCurrentBatchConfig, nn = 0, rn = null, ln = null, an = null, un = null, on3 = null, fn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  function gn() {
    throw Error(f3(321));
  }
  function bn(e4, t4) {
    if (null === t4) return false;
    for (var n5 = 0; n5 < t4.length && n5 < e4.length; n5++) if (!nt(e4[n5], t4[n5])) return false;
    return true;
  }
  function yn(e4, t4, n5, r6, l3, i4) {
    if (nn = i4, rn = t4, an = null !== e4 ? e4.memoizedState : null, en.current = null === an ? Dn : Wn, t4 = n5(r6, l3), pn) {
      do {
        pn = false, hn += 1, an = null !== e4 ? e4.memoizedState : null, fn = un, sn = on3 = ln = null, en.current = Wn, t4 = n5(r6, l3);
      } while (pn);
      mn = null, hn = 0;
    }
    if (en.current = Qn, (e4 = rn).memoizedState = un, e4.expirationTime = cn, e4.updateQueue = sn, e4.effectTag |= dn, e4 = null !== ln && null !== ln.next, nn = 0, fn = on3 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, e4) throw Error(f3(300));
    return t4;
  }
  function vn() {
    en.current = Qn, nn = 0, fn = on3 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  }
  function Tn() {
    var e4 = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
    return null === on3 ? un = on3 = e4 : on3 = on3.next = e4, on3;
  }
  function xn() {
    if (null !== fn) fn = (on3 = fn).next, an = null !== (ln = an) ? ln.next : null;
    else {
      if (null === an) throw Error(f3(310));
      var e4 = { memoizedState: (ln = an).memoizedState, baseState: ln.baseState, queue: ln.queue, baseUpdate: ln.baseUpdate, next: null };
      on3 = null === on3 ? un = e4 : on3.next = e4, an = ln.next;
    }
    return on3;
  }
  function En(e4, t4) {
    return "function" == typeof t4 ? t4(e4) : t4;
  }
  function kn(e4) {
    var t4 = xn(), n5 = t4.queue;
    if (null === n5) throw Error(f3(311));
    if (n5.lastRenderedReducer = e4, 0 < hn) {
      var r6 = n5.dispatch;
      if (null !== mn) {
        var l3 = mn.get(n5);
        if (void 0 !== l3) {
          mn.delete(n5);
          var i4 = t4.memoizedState;
          do {
            i4 = e4(i4, l3.action), l3 = l3.next;
          } while (null !== l3);
          return nt(i4, t4.memoizedState) || (On = true), t4.memoizedState = i4, t4.baseUpdate === n5.last && (t4.baseState = i4), n5.lastRenderedState = i4, [i4, r6];
        }
      }
      return [t4.memoizedState, r6];
    }
    r6 = n5.last;
    var a5 = t4.baseUpdate;
    if (i4 = t4.baseState, null !== a5 ? (null !== r6 && (r6.next = null), r6 = a5.next) : r6 = null !== r6 ? r6.next : null, null !== r6) {
      var u4 = l3 = null, o3 = r6, c5 = false;
      do {
        var s3 = o3.expirationTime;
        s3 < nn ? (c5 || (c5 = true, u4 = a5, l3 = i4), s3 > cn && kl(cn = s3)) : (El(s3, o3.suspenseConfig), i4 = o3.eagerReducer === e4 ? o3.eagerState : e4(i4, o3.action)), a5 = o3, o3 = o3.next;
      } while (null !== o3 && o3 !== r6);
      c5 || (u4 = a5, l3 = i4), nt(i4, t4.memoizedState) || (On = true), t4.memoizedState = i4, t4.baseUpdate = u4, t4.baseState = l3, n5.lastRenderedState = i4;
    }
    return [t4.memoizedState, n5.dispatch];
  }
  function Sn(e4) {
    var t4 = Tn();
    return "function" == typeof e4 && (e4 = e4()), t4.memoizedState = t4.baseState = e4, e4 = (e4 = t4.queue = { last: null, dispatch: null, lastRenderedReducer: En, lastRenderedState: e4 }).dispatch = Fn.bind(null, rn, e4), [t4.memoizedState, e4];
  }
  function Cn(e4) {
    return kn(En);
  }
  function wn(e4, t4, n5, r6) {
    return e4 = { tag: e4, create: t4, destroy: n5, deps: r6, next: null }, null === sn ? (sn = { lastEffect: null }).lastEffect = e4.next = e4 : null === (t4 = sn.lastEffect) ? sn.lastEffect = e4.next = e4 : (n5 = t4.next, t4.next = e4, e4.next = n5, sn.lastEffect = e4), e4;
  }
  function zn(e4, t4, n5, r6) {
    var l3 = Tn();
    dn |= e4, l3.memoizedState = wn(t4, n5, void 0, void 0 === r6 ? null : r6);
  }
  function Pn(e4, t4, n5, r6) {
    var l3 = xn();
    r6 = void 0 === r6 ? null : r6;
    var i4 = void 0;
    if (null !== ln) {
      var a5 = ln.memoizedState;
      if (i4 = a5.destroy, null !== r6 && bn(r6, a5.deps)) return void wn(0, n5, i4, r6);
    }
    dn |= e4, l3.memoizedState = wn(t4, n5, i4, r6);
  }
  function _n(e4, t4) {
    return zn(516, 192, e4, t4);
  }
  function Nn(e4, t4) {
    return Pn(516, 192, e4, t4);
  }
  function Un(e4, t4) {
    return "function" == typeof t4 ? (e4 = e4(), t4(e4), function() {
      t4(null);
    }) : null != t4 ? (e4 = e4(), t4.current = e4, function() {
      t4.current = null;
    }) : void 0;
  }
  function Rn() {
  }
  function In(e4, t4) {
    return Tn().memoizedState = [e4, void 0 === t4 ? null : t4], e4;
  }
  function Mn(e4, t4) {
    var n5 = xn();
    t4 = void 0 === t4 ? null : t4;
    var r6 = n5.memoizedState;
    return null !== r6 && null !== t4 && bn(t4, r6[1]) ? r6[0] : (n5.memoizedState = [e4, t4], e4);
  }
  function Fn(e4, t4, n5) {
    if (!(25 > hn)) throw Error(f3(301));
    var r6 = e4.alternate;
    if (e4 === rn || null !== r6 && r6 === rn) if (pn = true, e4 = { expirationTime: nn, suspenseConfig: null, action: n5, eagerReducer: null, eagerState: null, next: null }, null === mn && (mn = /* @__PURE__ */ new Map()), void 0 === (n5 = mn.get(t4))) mn.set(t4, e4);
    else {
      for (t4 = n5; null !== t4.next; ) t4 = t4.next;
      t4.next = e4;
    }
    else {
      var l3 = cl(), i4 = Pt.suspense;
      i4 = { expirationTime: l3 = sl(l3, e4, i4), suspenseConfig: i4, action: n5, eagerReducer: null, eagerState: null, next: null };
      var a5 = t4.last;
      if (null === a5) i4.next = i4;
      else {
        var u4 = a5.next;
        null !== u4 && (i4.next = u4), a5.next = i4;
      }
      if (t4.last = i4, 0 === e4.expirationTime && (null === r6 || 0 === r6.expirationTime) && null !== (r6 = t4.lastRenderedReducer)) try {
        var o3 = t4.lastRenderedState, c5 = r6(o3, n5);
        if (i4.eagerReducer = r6, i4.eagerState = c5, nt(c5, o3)) return;
      } catch (e5) {
      }
      dl(e4, l3);
    }
  }
  var Qn = { readContext: ht, useCallback: gn, useContext: gn, useEffect: gn, useImperativeHandle: gn, useLayoutEffect: gn, useMemo: gn, useReducer: gn, useRef: gn, useState: gn, useDebugValue: gn, useResponder: gn, useDeferredValue: gn, useTransition: gn }, Dn = { readContext: ht, useCallback: In, useContext: ht, useEffect: _n, useImperativeHandle: function(e4, t4, n5) {
    return n5 = null != n5 ? n5.concat([e4]) : null, zn(4, 36, Un.bind(null, t4, e4), n5);
  }, useLayoutEffect: function(e4, t4) {
    return zn(4, 36, e4, t4);
  }, useMemo: function(e4, t4) {
    var n5 = Tn();
    return t4 = void 0 === t4 ? null : t4, e4 = e4(), n5.memoizedState = [e4, t4], e4;
  }, useReducer: function(e4, t4, n5) {
    var r6 = Tn();
    return t4 = void 0 !== n5 ? n5(t4) : t4, r6.memoizedState = r6.baseState = t4, e4 = (e4 = r6.queue = { last: null, dispatch: null, lastRenderedReducer: e4, lastRenderedState: t4 }).dispatch = Fn.bind(null, rn, e4), [r6.memoizedState, e4];
  }, useRef: function(e4) {
    return e4 = { current: e4 }, Tn().memoizedState = e4;
  }, useState: Sn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e4, t4) {
    var n5 = Sn(e4), r6 = n5[0], l3 = n5[1];
    return _n(function() {
      o2.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === t4 ? null : t4;
        try {
          l3(e4);
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, t4]), r6;
  }, useTransition: function(e4) {
    var t4 = Sn(false), n5 = t4[0], r6 = t4[1];
    return [In(function(t5) {
      r6(true), o2.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === e4 ? null : e4;
        try {
          r6(false), t5();
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, n5]), n5];
  } }, Wn = { readContext: ht, useCallback: Mn, useContext: ht, useEffect: Nn, useImperativeHandle: function(e4, t4, n5) {
    return n5 = null != n5 ? n5.concat([e4]) : null, Pn(4, 36, Un.bind(null, t4, e4), n5);
  }, useLayoutEffect: function(e4, t4) {
    return Pn(4, 36, e4, t4);
  }, useMemo: function(e4, t4) {
    var n5 = xn();
    t4 = void 0 === t4 ? null : t4;
    var r6 = n5.memoizedState;
    return null !== r6 && null !== t4 && bn(t4, r6[1]) ? r6[0] : (e4 = e4(), n5.memoizedState = [e4, t4], e4);
  }, useReducer: kn, useRef: function() {
    return xn().memoizedState;
  }, useState: Cn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e4, t4) {
    var n5 = Cn(), r6 = n5[0], l3 = n5[1];
    return Nn(function() {
      o2.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === t4 ? null : t4;
        try {
          l3(e4);
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, t4]), r6;
  }, useTransition: function(e4) {
    var t4 = Cn(), n5 = t4[0], r6 = t4[1];
    return [Mn(function(t5) {
      r6(true), o2.unstable_next(function() {
        var n6 = tn.suspense;
        tn.suspense = void 0 === e4 ? null : e4;
        try {
          r6(false), t5();
        } finally {
          tn.suspense = n6;
        }
      });
    }, [e4, n5]), n5];
  } }, jn = c4.ReactCurrentOwner, On = false;
  function Bn(e4, t4, n5, r6) {
    t4.child = null === e4 ? Bt(t4, null, n5, r6) : Ot(t4, e4.child, n5, r6);
  }
  function Hn(e4, t4, n5, r6, l3) {
    n5 = n5.render;
    var i4 = t4.ref;
    return mt(t4, l3), r6 = yn(e4, t4, n5, r6, i4, l3), null === e4 || On ? (t4.effectTag |= 1, Bn(e4, t4, r6, l3), t4.child) : (t4.updateQueue = e4.updateQueue, t4.effectTag &= -517, e4.expirationTime <= l3 && (e4.expirationTime = 0), ir(e4, t4, l3));
  }
  function An(e4, t4, n5, r6, l3, i4) {
    if (null === e4) {
      var a5 = n5.type;
      return "function" != typeof a5 || Hl(a5) || void 0 !== a5.defaultProps || null !== n5.compare || void 0 !== n5.defaultProps ? ((e4 = Ll(n5.type, null, r6, null, t4.mode, i4)).ref = t4.ref, e4.return = t4, t4.child = e4) : (t4.tag = 15, t4.type = a5, Ln(e4, t4, a5, r6, l3, i4));
    }
    return a5 = e4.child, l3 < i4 && (l3 = a5.memoizedProps, (n5 = null !== (n5 = n5.compare) ? n5 : lt)(l3, r6) && e4.ref === t4.ref) ? ir(e4, t4, i4) : (t4.effectTag |= 1, (e4 = Al(a5, r6)).ref = t4.ref, e4.return = t4, t4.child = e4);
  }
  function Ln(e4, t4, n5, r6, l3, i4) {
    return null !== e4 && lt(e4.memoizedProps, r6) && e4.ref === t4.ref && (On = false, l3 < i4) ? ir(e4, t4, i4) : qn(e4, t4, n5, r6, i4);
  }
  function $n(e4, t4) {
    var n5 = t4.ref;
    (null === e4 && null !== n5 || null !== e4 && e4.ref !== n5) && (t4.effectTag |= 128);
  }
  function qn(e4, t4, n5, r6, l3) {
    var i4 = xe(n5) ? ve : be.current;
    return i4 = Te(t4, i4), mt(t4, l3), n5 = yn(e4, t4, n5, r6, i4, l3), null === e4 || On ? (t4.effectTag |= 1, Bn(e4, t4, n5, l3), t4.child) : (t4.updateQueue = e4.updateQueue, t4.effectTag &= -517, e4.expirationTime <= l3 && (e4.expirationTime = 0), ir(e4, t4, l3));
  }
  function Vn(e4, t4, n5, r6, l3) {
    if (xe(n5)) {
      var i4 = true;
      we(t4);
    } else i4 = false;
    if (mt(t4, l3), null === t4.stateNode) null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), It(t4, n5, r6), Ft(t4, n5, r6, l3), r6 = true;
    else if (null === e4) {
      var a5 = t4.stateNode, u4 = t4.memoizedProps;
      a5.props = u4;
      var o3 = a5.context, f4 = n5.contextType;
      f4 = "object" == typeof f4 && null !== f4 ? ht(f4) : Te(t4, f4 = xe(n5) ? ve : be.current);
      var c5 = n5.getDerivedStateFromProps, s3 = "function" == typeof c5 || "function" == typeof a5.getSnapshotBeforeUpdate;
      s3 || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 !== r6 || o3 !== f4) && Mt(t4, a5, r6, f4), gt = false;
      var d3 = t4.memoizedState;
      o3 = a5.state = d3;
      var p4 = t4.updateQueue;
      null !== p4 && (Ct(t4, p4, r6, a5, l3), o3 = t4.memoizedState), u4 !== r6 || d3 !== o3 || ye.current || gt ? ("function" == typeof c5 && (Nt(t4, n5, c5, r6), o3 = t4.memoizedState), (u4 = gt || Rt(t4, n5, u4, r6, d3, o3, f4)) ? (s3 || "function" != typeof a5.UNSAFE_componentWillMount && "function" != typeof a5.componentWillMount || ("function" == typeof a5.componentWillMount && a5.componentWillMount(), "function" == typeof a5.UNSAFE_componentWillMount && a5.UNSAFE_componentWillMount()), "function" == typeof a5.componentDidMount && (t4.effectTag |= 4)) : ("function" == typeof a5.componentDidMount && (t4.effectTag |= 4), t4.memoizedProps = r6, t4.memoizedState = o3), a5.props = r6, a5.state = o3, a5.context = f4, r6 = u4) : ("function" == typeof a5.componentDidMount && (t4.effectTag |= 4), r6 = false);
    } else a5 = t4.stateNode, u4 = t4.memoizedProps, a5.props = t4.type === t4.elementType ? u4 : it(t4.type, u4), o3 = a5.context, f4 = "object" == typeof (f4 = n5.contextType) && null !== f4 ? ht(f4) : Te(t4, f4 = xe(n5) ? ve : be.current), (s3 = "function" == typeof (c5 = n5.getDerivedStateFromProps) || "function" == typeof a5.getSnapshotBeforeUpdate) || "function" != typeof a5.UNSAFE_componentWillReceiveProps && "function" != typeof a5.componentWillReceiveProps || (u4 !== r6 || o3 !== f4) && Mt(t4, a5, r6, f4), gt = false, o3 = t4.memoizedState, d3 = a5.state = o3, null !== (p4 = t4.updateQueue) && (Ct(t4, p4, r6, a5, l3), d3 = t4.memoizedState), u4 !== r6 || o3 !== d3 || ye.current || gt ? ("function" == typeof c5 && (Nt(t4, n5, c5, r6), d3 = t4.memoizedState), (c5 = gt || Rt(t4, n5, u4, r6, o3, d3, f4)) ? (s3 || "function" != typeof a5.UNSAFE_componentWillUpdate && "function" != typeof a5.componentWillUpdate || ("function" == typeof a5.componentWillUpdate && a5.componentWillUpdate(r6, d3, f4), "function" == typeof a5.UNSAFE_componentWillUpdate && a5.UNSAFE_componentWillUpdate(r6, d3, f4)), "function" == typeof a5.componentDidUpdate && (t4.effectTag |= 4), "function" == typeof a5.getSnapshotBeforeUpdate && (t4.effectTag |= 256)) : ("function" != typeof a5.componentDidUpdate || u4 === e4.memoizedProps && o3 === e4.memoizedState || (t4.effectTag |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || u4 === e4.memoizedProps && o3 === e4.memoizedState || (t4.effectTag |= 256), t4.memoizedProps = r6, t4.memoizedState = d3), a5.props = r6, a5.state = d3, a5.context = f4, r6 = c5) : ("function" != typeof a5.componentDidUpdate || u4 === e4.memoizedProps && o3 === e4.memoizedState || (t4.effectTag |= 4), "function" != typeof a5.getSnapshotBeforeUpdate || u4 === e4.memoizedProps && o3 === e4.memoizedState || (t4.effectTag |= 256), r6 = false);
    return Kn(e4, t4, n5, r6, i4, l3);
  }
  function Kn(e4, t4, n5, r6, l3, i4) {
    $n(e4, t4);
    var a5 = 0 != (64 & t4.effectTag);
    if (!r6 && !a5) return l3 && ze(t4, n5, false), ir(e4, t4, i4);
    r6 = t4.stateNode, jn.current = t4;
    var u4 = a5 && "function" != typeof n5.getDerivedStateFromError ? null : r6.render();
    return t4.effectTag |= 1, null !== e4 && a5 ? (t4.child = Ot(t4, e4.child, null, i4), t4.child = Ot(t4, null, u4, i4)) : Bn(e4, t4, u4, i4), t4.memoizedState = r6.state, l3 && ze(t4, n5, true), t4.child;
  }
  function Gn(e4) {
    var t4 = e4.stateNode;
    t4.pendingContext ? Se(0, t4.pendingContext, t4.pendingContext !== t4.context) : t4.context && Se(0, t4.context, false), Vt(e4, t4.containerInfo);
  }
  var Yn, Jn, Xn, Zn, er = { dehydrated: null, retryTime: 0 };
  function tr(e4, t4, n5) {
    var r6, l3 = t4.mode, i4 = t4.pendingProps, a5 = Jt.current, u4 = false;
    if ((r6 = 0 != (64 & t4.effectTag)) || (r6 = 0 != (2 & a5) && (null === e4 || null !== e4.memoizedState)), r6 ? (u4 = true, t4.effectTag &= -65) : null !== e4 && null === e4.memoizedState || void 0 === i4.fallback || true === i4.unstable_avoidThisFallback || (a5 |= 1), he(Jt, 1 & a5), null === e4) {
      if (i4.fallback, u4) {
        if (u4 = i4.fallback, (i4 = $l(null, l3, 0, null)).return = t4, 0 == (2 & t4.mode)) for (e4 = null !== t4.memoizedState ? t4.child.child : t4.child, i4.child = e4; null !== e4; ) e4.return = i4, e4 = e4.sibling;
        return (n5 = $l(u4, l3, n5, null)).return = t4, i4.sibling = n5, t4.memoizedState = er, t4.child = i4, n5;
      }
      return l3 = i4.children, t4.memoizedState = null, t4.child = Bt(t4, null, l3, n5);
    }
    if (null !== e4.memoizedState) {
      if (l3 = (e4 = e4.child).sibling, u4) {
        if (i4 = i4.fallback, (n5 = Al(e4, e4.pendingProps)).return = t4, 0 == (2 & t4.mode) && (u4 = null !== t4.memoizedState ? t4.child.child : t4.child) !== e4.child) for (n5.child = u4; null !== u4; ) u4.return = n5, u4 = u4.sibling;
        return (l3 = Al(l3, i4, l3.expirationTime)).return = t4, n5.sibling = l3, n5.childExpirationTime = 0, t4.memoizedState = er, t4.child = n5, l3;
      }
      return n5 = Ot(t4, e4.child, i4.children, n5), t4.memoizedState = null, t4.child = n5;
    }
    if (e4 = e4.child, u4) {
      if (u4 = i4.fallback, (i4 = $l(null, l3, 0, null)).return = t4, i4.child = e4, null !== e4 && (e4.return = i4), 0 == (2 & t4.mode)) for (e4 = null !== t4.memoizedState ? t4.child.child : t4.child, i4.child = e4; null !== e4; ) e4.return = i4, e4 = e4.sibling;
      return (n5 = $l(u4, l3, n5, null)).return = t4, i4.sibling = n5, n5.effectTag |= 2, i4.childExpirationTime = 0, t4.memoizedState = er, t4.child = i4, n5;
    }
    return t4.memoizedState = null, t4.child = Ot(t4, e4, i4.children, n5);
  }
  function nr(e4, t4) {
    e4.expirationTime < t4 && (e4.expirationTime = t4);
    var n5 = e4.alternate;
    null !== n5 && n5.expirationTime < t4 && (n5.expirationTime = t4), pt(e4.return, t4);
  }
  function rr(e4, t4, n5, r6, l3, i4) {
    var a5 = e4.memoizedState;
    null === a5 ? e4.memoizedState = { isBackwards: t4, rendering: null, last: r6, tail: n5, tailExpiration: 0, tailMode: l3, lastEffect: i4 } : (a5.isBackwards = t4, a5.rendering = null, a5.last = r6, a5.tail = n5, a5.tailExpiration = 0, a5.tailMode = l3, a5.lastEffect = i4);
  }
  function lr(e4, t4, n5) {
    var r6 = t4.pendingProps, l3 = r6.revealOrder, i4 = r6.tail;
    if (Bn(e4, t4, r6.children, n5), 0 != (2 & (r6 = Jt.current))) r6 = 1 & r6 | 2, t4.effectTag |= 64;
    else {
      if (null !== e4 && 0 != (64 & e4.effectTag)) e: for (e4 = t4.child; null !== e4; ) {
        if (13 === e4.tag) null !== e4.memoizedState && nr(e4, n5);
        else if (19 === e4.tag) nr(e4, n5);
        else if (null !== e4.child) {
          e4.child.return = e4, e4 = e4.child;
          continue;
        }
        if (e4 === t4) break e;
        for (; null === e4.sibling; ) {
          if (null === e4.return || e4.return === t4) break e;
          e4 = e4.return;
        }
        e4.sibling.return = e4.return, e4 = e4.sibling;
      }
      r6 &= 1;
    }
    if (he(Jt, r6), 0 == (2 & t4.mode)) t4.memoizedState = null;
    else switch (l3) {
      case "forwards":
        for (n5 = t4.child, l3 = null; null !== n5; ) null !== (e4 = n5.alternate) && null === Xt(e4) && (l3 = n5), n5 = n5.sibling;
        null === (n5 = l3) ? (l3 = t4.child, t4.child = null) : (l3 = n5.sibling, n5.sibling = null), rr(t4, false, l3, n5, i4, t4.lastEffect);
        break;
      case "backwards":
        for (n5 = null, l3 = t4.child, t4.child = null; null !== l3; ) {
          if (null !== (e4 = l3.alternate) && null === Xt(e4)) {
            t4.child = l3;
            break;
          }
          e4 = l3.sibling, l3.sibling = n5, n5 = l3, l3 = e4;
        }
        rr(t4, true, n5, null, i4, t4.lastEffect);
        break;
      case "together":
        rr(t4, false, null, null, void 0, t4.lastEffect);
        break;
      default:
        t4.memoizedState = null;
    }
    return t4.child;
  }
  function ir(e4, t4, n5) {
    null !== e4 && (t4.dependencies = e4.dependencies);
    var r6 = t4.expirationTime;
    if (0 !== r6 && kl(r6), t4.childExpirationTime < n5) return null;
    if (null !== e4 && t4.child !== e4.child) throw Error(f3(153));
    if (null !== t4.child) {
      for (n5 = Al(e4 = t4.child, e4.pendingProps, e4.expirationTime), t4.child = n5, n5.return = t4; null !== e4.sibling; ) e4 = e4.sibling, (n5 = n5.sibling = Al(e4, e4.pendingProps, e4.expirationTime)).return = t4;
      n5.sibling = null;
    }
    return t4.child;
  }
  function ar(e4) {
    e4.effectTag |= 4;
  }
  function ur(e4, t4) {
    switch (e4.tailMode) {
      case "hidden":
        t4 = e4.tail;
        for (var n5 = null; null !== t4; ) null !== t4.alternate && (n5 = t4), t4 = t4.sibling;
        null === n5 ? e4.tail = null : n5.sibling = null;
        break;
      case "collapsed":
        n5 = e4.tail;
        for (var r6 = null; null !== n5; ) null !== n5.alternate && (r6 = n5), n5 = n5.sibling;
        null === r6 ? t4 || null === e4.tail ? e4.tail = null : e4.tail.sibling = null : r6.sibling = null;
    }
  }
  function or(e4) {
    switch (e4.tag) {
      case 1:
        xe(e4.type) && Ee();
        var t4 = e4.effectTag;
        return 4096 & t4 ? (e4.effectTag = -4097 & t4 | 64, e4) : null;
      case 3:
        if (Kt(), ke(), 0 != (64 & (t4 = e4.effectTag))) throw Error(f3(285));
        return e4.effectTag = -4097 & t4 | 64, e4;
      case 5:
        return Yt(e4), null;
      case 13:
        return me(Jt), 4096 & (t4 = e4.effectTag) ? (e4.effectTag = -4097 & t4 | 64, e4) : null;
      case 19:
        return me(Jt), null;
      case 4:
        return Kt(), null;
      case 10:
        return dt(e4), null;
      default:
        return null;
    }
  }
  function fr(e4, t4) {
    return { value: e4, source: t4, stack: se(t4) };
  }
  Yn = function(e4, t4) {
    for (var n5 = t4.child; null !== n5; ) {
      if (5 === n5.tag || 6 === n5.tag) W(e4, n5.stateNode);
      else if (4 !== n5.tag && null !== n5.child) {
        n5.child.return = n5, n5 = n5.child;
        continue;
      }
      if (n5 === t4) break;
      for (; null === n5.sibling; ) {
        if (null === n5.return || n5.return === t4) return;
        n5 = n5.return;
      }
      n5.sibling.return = n5.return, n5 = n5.sibling;
    }
  }, Jn = function() {
  }, Xn = function(e4, t4, n5, r6, l3) {
    if ((e4 = e4.memoizedProps) !== r6) {
      var i4 = t4.stateNode, a5 = qt(At.current);
      n5 = O(i4, n5, e4, r6, l3, a5), (t4.updateQueue = n5) && ar(t4);
    }
  }, Zn = function(e4, t4, n5, r6) {
    n5 !== r6 && ar(t4);
  };
  var cr = "function" == typeof WeakSet ? WeakSet : Set;
  function sr(e4, t4) {
    var n5 = t4.source, r6 = t4.stack;
    null === r6 && null !== n5 && (r6 = se(n5)), null !== n5 && z(n5.type), t4 = t4.value, null !== e4 && 1 === e4.tag && z(e4.type);
    try {
      console.error(t4);
    } catch (e5) {
      setTimeout(function() {
        throw e5;
      });
    }
  }
  function dr(e4) {
    var t4 = e4.ref;
    if (null !== t4) if ("function" == typeof t4) try {
      t4(null);
    } catch (t5) {
      Fl(e4, t5);
    }
    else t4.current = null;
  }
  function pr(e4, t4) {
    switch (t4.tag) {
      case 0:
      case 11:
      case 15:
        mr(2, 0, t4);
        break;
      case 1:
        if (256 & t4.effectTag && null !== e4) {
          var n5 = e4.memoizedProps, r6 = e4.memoizedState;
          t4 = (e4 = t4.stateNode).getSnapshotBeforeUpdate(t4.elementType === t4.type ? n5 : it(t4.type, n5), r6), e4.__reactInternalSnapshotBeforeUpdate = t4;
        }
        break;
      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        break;
      default:
        throw Error(f3(163));
    }
  }
  function mr(e4, t4, n5) {
    if (null !== (n5 = null !== (n5 = n5.updateQueue) ? n5.lastEffect : null)) {
      var r6 = n5 = n5.next;
      do {
        if (0 != (r6.tag & e4)) {
          var l3 = r6.destroy;
          r6.destroy = void 0, void 0 !== l3 && l3();
        }
        0 != (r6.tag & t4) && (l3 = r6.create, r6.destroy = l3()), r6 = r6.next;
      } while (r6 !== n5);
    }
  }
  function hr(e4, t4, n5) {
    switch ("function" == typeof jl && jl(t4), t4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (null !== (e4 = t4.updateQueue) && null !== (e4 = e4.lastEffect)) {
          var r6 = e4.next;
          Ge(97 < n5 ? 97 : n5, function() {
            var e5 = r6;
            do {
              var n6 = e5.destroy;
              if (void 0 !== n6) {
                var l3 = t4;
                try {
                  n6();
                } catch (e6) {
                  Fl(l3, e6);
                }
              }
              e5 = e5.next;
            } while (e5 !== r6);
          });
        }
        break;
      case 1:
        dr(t4), "function" == typeof (n5 = t4.stateNode).componentWillUnmount && function(e5, t5) {
          try {
            t5.props = e5.memoizedProps, t5.state = e5.memoizedState, t5.componentWillUnmount();
          } catch (t6) {
            Fl(e5, t6);
          }
        }(t4, n5);
        break;
      case 5:
        dr(t4);
        break;
      case 4:
        Tr(e4, t4, n5);
    }
  }
  function gr(e4, t4, n5) {
    for (var r6 = t4; ; ) if (hr(e4, r6, n5), null === r6.child || 4 === r6.tag) {
      if (r6 === t4) break;
      for (; null === r6.sibling; ) {
        if (null === r6.return || r6.return === t4) return;
        r6 = r6.return;
      }
      r6.sibling.return = r6.return, r6 = r6.sibling;
    } else r6.child.return = r6, r6 = r6.child;
  }
  function br(e4) {
    var t4 = e4.alternate;
    e4.return = null, e4.child = null, e4.memoizedState = null, e4.updateQueue = null, e4.dependencies = null, e4.alternate = null, e4.firstEffect = null, e4.lastEffect = null, e4.pendingProps = null, e4.memoizedProps = null, null !== t4 && br(t4);
  }
  function yr(e4) {
    return 5 === e4.tag || 3 === e4.tag || 4 === e4.tag;
  }
  function vr(e4) {
    e: {
      for (var t4 = e4.return; null !== t4; ) {
        if (yr(t4)) {
          var n5 = t4;
          break e;
        }
        t4 = t4.return;
      }
      throw Error(f3(160));
    }
    switch (t4 = n5.stateNode, n5.tag) {
      case 5:
        var r6 = false;
        break;
      case 3:
      case 4:
        t4 = t4.containerInfo, r6 = true;
        break;
      default:
        throw Error(f3(161));
    }
    16 & n5.effectTag && (re(t4), n5.effectTag &= -17);
    e: t: for (n5 = e4; ; ) {
      for (; null === n5.sibling; ) {
        if (null === n5.return || yr(n5.return)) {
          n5 = null;
          break e;
        }
        n5 = n5.return;
      }
      for (n5.sibling.return = n5.return, n5 = n5.sibling; 5 !== n5.tag && 6 !== n5.tag && 18 !== n5.tag; ) {
        if (2 & n5.effectTag) continue t;
        if (null === n5.child || 4 === n5.tag) continue t;
        n5.child.return = n5, n5 = n5.child;
      }
      if (!(2 & n5.effectTag)) {
        n5 = n5.stateNode;
        break e;
      }
    }
    for (var l3 = e4; ; ) {
      var i4 = 5 === l3.tag || 6 === l3.tag;
      if (i4) i4 = i4 ? l3.stateNode : l3.stateNode.instance, n5 ? r6 ? ee(t4, i4, n5) : Z(t4, i4, n5) : r6 ? G2(t4, i4) : K(t4, i4);
      else if (4 !== l3.tag && null !== l3.child) {
        l3.child.return = l3, l3 = l3.child;
        continue;
      }
      if (l3 === e4) break;
      for (; null === l3.sibling; ) {
        if (null === l3.return || l3.return === e4) return;
        l3 = l3.return;
      }
      l3.sibling.return = l3.return, l3 = l3.sibling;
    }
  }
  function Tr(e4, t4, n5) {
    for (var r6, l3, i4 = t4, a5 = false; ; ) {
      if (!a5) {
        a5 = i4.return;
        e: for (; ; ) {
          if (null === a5) throw Error(f3(160));
          switch (r6 = a5.stateNode, a5.tag) {
            case 5:
              l3 = false;
              break e;
            case 3:
            case 4:
              r6 = r6.containerInfo, l3 = true;
              break e;
          }
          a5 = a5.return;
        }
        a5 = true;
      }
      if (5 === i4.tag || 6 === i4.tag) gr(e4, i4, n5), l3 ? ne(r6, i4.stateNode) : te(r6, i4.stateNode);
      else if (4 === i4.tag) {
        if (null !== i4.child) {
          r6 = i4.stateNode.containerInfo, l3 = true, i4.child.return = i4, i4 = i4.child;
          continue;
        }
      } else if (hr(e4, i4, n5), null !== i4.child) {
        i4.child.return = i4, i4 = i4.child;
        continue;
      }
      if (i4 === t4) break;
      for (; null === i4.sibling; ) {
        if (null === i4.return || i4.return === t4) return;
        4 === (i4 = i4.return).tag && (a5 = false);
      }
      i4.sibling.return = i4.return, i4 = i4.sibling;
    }
  }
  function xr(e4, t4) {
    switch (t4.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        mr(4, 8, t4);
        break;
      case 1:
      case 3:
      case 12:
      case 17:
      case 20:
      case 21:
        break;
      case 5:
        var n5 = t4.stateNode;
        if (null != n5) {
          var r6 = t4.memoizedProps;
          e4 = null !== e4 ? e4.memoizedProps : r6;
          var l3 = t4.type, i4 = t4.updateQueue;
          t4.updateQueue = null, null !== i4 && X(n5, i4, l3, e4, r6, t4);
        }
        break;
      case 6:
        if (null === t4.stateNode) throw Error(f3(162));
        n5 = t4.memoizedProps, Y(t4.stateNode, null !== e4 ? e4.memoizedProps : n5, n5);
        break;
      case 13:
        !function(e5) {
          var t5 = e5;
          if (null === e5.memoizedState) var n6 = false;
          else n6 = true, t5 = e5.child, Jr = qe();
          if (null !== t5) {
            e: if (e5 = t5, q) for (t5 = e5; ; ) {
              if (5 === t5.tag) {
                var r7 = t5.stateNode;
                n6 ? le(r7) : ae(t5.stateNode, t5.memoizedProps);
              } else if (6 === t5.tag) r7 = t5.stateNode, n6 ? ie(r7) : ue(r7, t5.memoizedProps);
              else {
                if (13 === t5.tag && null !== t5.memoizedState && null === t5.memoizedState.dehydrated) {
                  (r7 = t5.child.sibling).return = t5, t5 = r7;
                  continue;
                }
                if (null !== t5.child) {
                  t5.child.return = t5, t5 = t5.child;
                  continue;
                }
              }
              if (t5 === e5) break e;
              for (; null === t5.sibling; ) {
                if (null === t5.return || t5.return === e5) break e;
                t5 = t5.return;
              }
              t5.sibling.return = t5.return, t5 = t5.sibling;
            }
          }
        }(t4), Er(t4);
        break;
      case 19:
        Er(t4);
        break;
      default:
        throw Error(f3(163));
    }
  }
  function Er(e4) {
    var t4 = e4.updateQueue;
    if (null !== t4) {
      e4.updateQueue = null;
      var n5 = e4.stateNode;
      null === n5 && (n5 = e4.stateNode = new cr()), t4.forEach(function(t5) {
        var r6 = Dl.bind(null, e4, t5);
        n5.has(t5) || (n5.add(t5), t5.then(r6, r6));
      });
    }
  }
  var kr = "function" == typeof WeakMap ? WeakMap : Map;
  function Sr(e4, t4, n5) {
    (n5 = vt(n5, null)).tag = 3, n5.payload = { element: null };
    var r6 = t4.value;
    return n5.callback = function() {
      el || (el = true, tl = r6), sr(e4, t4);
    }, n5;
  }
  function Cr(e4, t4, n5) {
    (n5 = vt(n5, null)).tag = 3;
    var r6 = e4.type.getDerivedStateFromError;
    if ("function" == typeof r6) {
      var l3 = t4.value;
      n5.payload = function() {
        return sr(e4, t4), r6(l3);
      };
    }
    var i4 = e4.stateNode;
    return null !== i4 && "function" == typeof i4.componentDidCatch && (n5.callback = function() {
      "function" != typeof r6 && (null === nl ? nl = /* @__PURE__ */ new Set([this]) : nl.add(this), sr(e4, t4));
      var n6 = t4.stack;
      this.componentDidCatch(t4.value, { componentStack: null !== n6 ? n6 : "" });
    }), n5;
  }
  var wr, zr = Math.ceil, Pr = c4.ReactCurrentDispatcher, _r = c4.ReactCurrentOwner, Nr = 0, Ur = 8, Rr = 16, Ir = 32, Mr = 0, Fr = 1, Qr = 2, Dr = 3, Wr = 4, jr = 5, Or = Nr, Br = null, Hr = null, Ar = 0, Lr = Mr, $r = null, qr = 1073741823, Vr = 1073741823, Kr = null, Gr = 0, Yr = false, Jr = 0, Xr = 500, Zr = null, el = false, tl = null, nl = null, rl = false, ll = null, il = 90, al = null, ul = 0, ol = null, fl = 0;
  function cl() {
    return (Or & (Rr | Ir)) !== Nr ? 1073741821 - (qe() / 10 | 0) : 0 !== fl ? fl : fl = 1073741821 - (qe() / 10 | 0);
  }
  function sl(e4, t4, n5) {
    if (0 == (2 & (t4 = t4.mode))) return 1073741823;
    var r6 = Ve();
    if (0 == (4 & t4)) return 99 === r6 ? 1073741823 : 1073741822;
    if ((Or & Rr) !== Nr) return Ar;
    if (null !== n5) e4 = tt(e4, 0 | n5.timeoutMs || 5e3, 250);
    else switch (r6) {
      case 99:
        e4 = 1073741823;
        break;
      case 98:
        e4 = tt(e4, 150, 100);
        break;
      case 97:
      case 96:
        e4 = tt(e4, 5e3, 250);
        break;
      case 95:
        e4 = 2;
        break;
      default:
        throw Error(f3(326));
    }
    return null !== Br && e4 === Ar && --e4, e4;
  }
  function dl(e4, t4) {
    if (50 < ul) throw ul = 0, ol = null, Error(f3(185));
    if (null !== (e4 = pl(e4, t4))) {
      var n5 = Ve();
      1073741823 === t4 ? (Or & Ur) !== Nr && (Or & (Rr | Ir)) === Nr ? bl(e4) : (hl(e4), Or === Nr && Xe()) : hl(e4), (4 & Or) === Nr || 98 !== n5 && 99 !== n5 || (null === al ? al = /* @__PURE__ */ new Map([[e4, t4]]) : (void 0 === (n5 = al.get(e4)) || n5 > t4) && al.set(e4, t4));
    }
  }
  function pl(e4, t4) {
    e4.expirationTime < t4 && (e4.expirationTime = t4);
    var n5 = e4.alternate;
    null !== n5 && n5.expirationTime < t4 && (n5.expirationTime = t4);
    var r6 = e4.return, l3 = null;
    if (null === r6 && 3 === e4.tag) l3 = e4.stateNode;
    else for (; null !== r6; ) {
      if (n5 = r6.alternate, r6.childExpirationTime < t4 && (r6.childExpirationTime = t4), null !== n5 && n5.childExpirationTime < t4 && (n5.childExpirationTime = t4), null === r6.return && 3 === r6.tag) {
        l3 = r6.stateNode;
        break;
      }
      r6 = r6.return;
    }
    return null !== l3 && (Br === l3 && (kl(t4), Lr === Wr && Yl(l3, Ar)), Jl(l3, t4)), l3;
  }
  function ml(e4) {
    var t4 = e4.lastExpiredTime;
    return 0 !== t4 ? t4 : Gl(e4, t4 = e4.firstPendingTime) ? (t4 = e4.lastPingedTime) > (e4 = e4.nextKnownPendingLevel) ? t4 : e4 : t4;
  }
  function hl(e4) {
    if (0 !== e4.lastExpiredTime) e4.callbackExpirationTime = 1073741823, e4.callbackPriority = 99, e4.callbackNode = Je(bl.bind(null, e4));
    else {
      var t4 = ml(e4), n5 = e4.callbackNode;
      if (0 === t4) null !== n5 && (e4.callbackNode = null, e4.callbackExpirationTime = 0, e4.callbackPriority = 90);
      else {
        var r6 = cl();
        if (r6 = 1073741823 === t4 ? 99 : 1 === t4 || 2 === t4 ? 95 : 0 >= (r6 = 10 * (1073741821 - t4) - 10 * (1073741821 - r6)) ? 99 : 250 >= r6 ? 98 : 5250 >= r6 ? 97 : 95, null !== n5) {
          var l3 = e4.callbackPriority;
          if (e4.callbackExpirationTime === t4 && l3 >= r6) return;
          n5 !== Oe && Ne(n5);
        }
        e4.callbackExpirationTime = t4, e4.callbackPriority = r6, t4 = 1073741823 === t4 ? Je(bl.bind(null, e4)) : Ye(r6, gl.bind(null, e4), { timeout: 10 * (1073741821 - t4) - qe() }), e4.callbackNode = t4;
      }
    }
  }
  function gl(e4, t4) {
    if (fl = 0, t4) return Xl(e4, t4 = cl()), hl(e4), null;
    var n5 = ml(e4);
    if (0 !== n5) {
      if (t4 = e4.callbackNode, (Or & (Rr | Ir)) !== Nr) throw Error(f3(327));
      if (Rl(), e4 === Br && n5 === Ar || vl(e4, n5), null !== Hr) {
        var r6 = Or;
        Or |= Rr;
        for (var l3 = xl(); ; ) try {
          Cl();
          break;
        } catch (t5) {
          Tl(e4, t5);
        }
        if (ct(), Or = r6, Pr.current = l3, Lr === Fr) throw t4 = $r, vl(e4, n5), Yl(e4, n5), hl(e4), t4;
        if (null === Hr) switch (l3 = e4.finishedWork = e4.current.alternate, e4.finishedExpirationTime = n5, r6 = Lr, Br = null, r6) {
          case Mr:
          case Fr:
            throw Error(f3(345));
          case Qr:
            Xl(e4, 2 < n5 ? 2 : n5);
            break;
          case Dr:
            if (Yl(e4, n5), n5 === (r6 = e4.lastSuspendedTime) && (e4.nextKnownPendingLevel = Pl(l3)), 1073741823 === qr && 10 < (l3 = Jr + Xr - qe())) {
              if (Yr) {
                var i4 = e4.lastPingedTime;
                if (0 === i4 || i4 >= n5) {
                  e4.lastPingedTime = n5, vl(e4, n5);
                  break;
                }
              }
              if (0 !== (i4 = ml(e4)) && i4 !== n5) break;
              if (0 !== r6 && r6 !== n5) {
                e4.lastPingedTime = r6;
                break;
              }
              e4.timeoutHandle = A(_l.bind(null, e4), l3);
              break;
            }
            _l(e4);
            break;
          case Wr:
            if (Yl(e4, n5), n5 === (r6 = e4.lastSuspendedTime) && (e4.nextKnownPendingLevel = Pl(l3)), Yr && (0 === (l3 = e4.lastPingedTime) || l3 >= n5)) {
              e4.lastPingedTime = n5, vl(e4, n5);
              break;
            }
            if (0 !== (l3 = ml(e4)) && l3 !== n5) break;
            if (0 !== r6 && r6 !== n5) {
              e4.lastPingedTime = r6;
              break;
            }
            if (1073741823 !== Vr ? r6 = 10 * (1073741821 - Vr) - qe() : 1073741823 === qr ? r6 = 0 : (r6 = 10 * (1073741821 - qr) - 5e3, 0 > (r6 = (l3 = qe()) - r6) && (r6 = 0), (n5 = 10 * (1073741821 - n5) - l3) < (r6 = (120 > r6 ? 120 : 480 > r6 ? 480 : 1080 > r6 ? 1080 : 1920 > r6 ? 1920 : 3e3 > r6 ? 3e3 : 4320 > r6 ? 4320 : 1960 * zr(r6 / 1960)) - r6) && (r6 = n5)), 10 < r6) {
              e4.timeoutHandle = A(_l.bind(null, e4), r6);
              break;
            }
            _l(e4);
            break;
          case jr:
            if (1073741823 !== qr && null !== Kr) {
              i4 = qr;
              var a5 = Kr;
              if (0 >= (r6 = 0 | a5.busyMinDurationMs) ? r6 = 0 : (l3 = 0 | a5.busyDelayMs, r6 = (i4 = qe() - (10 * (1073741821 - i4) - (0 | a5.timeoutMs || 5e3))) <= l3 ? 0 : l3 + r6 - i4), 10 < r6) {
                Yl(e4, n5), e4.timeoutHandle = A(_l.bind(null, e4), r6);
                break;
              }
            }
            _l(e4);
            break;
          default:
            throw Error(f3(329));
        }
        if (hl(e4), e4.callbackNode === t4) return gl.bind(null, e4);
      }
    }
    return null;
  }
  function bl(e4) {
    var t4 = e4.lastExpiredTime;
    if (t4 = 0 !== t4 ? t4 : 1073741823, e4.finishedExpirationTime === t4) _l(e4);
    else {
      if ((Or & (Rr | Ir)) !== Nr) throw Error(f3(327));
      if (Rl(), e4 === Br && t4 === Ar || vl(e4, t4), null !== Hr) {
        var n5 = Or;
        Or |= Rr;
        for (var r6 = xl(); ; ) try {
          Sl();
          break;
        } catch (t5) {
          Tl(e4, t5);
        }
        if (ct(), Or = n5, Pr.current = r6, Lr === Fr) throw n5 = $r, vl(e4, t4), Yl(e4, t4), hl(e4), n5;
        if (null !== Hr) throw Error(f3(261));
        e4.finishedWork = e4.current.alternate, e4.finishedExpirationTime = t4, Br = null, _l(e4), hl(e4);
      }
    }
    return null;
  }
  function yl(e4, t4) {
    if ((Or & (Rr | Ir)) !== Nr) throw Error(f3(187));
    var n5 = Or;
    Or |= 1;
    try {
      return Ge(99, e4.bind(null, t4));
    } finally {
      Or = n5, Xe();
    }
  }
  function vl(e4, t4) {
    e4.finishedWork = null, e4.finishedExpirationTime = 0;
    var n5 = e4.timeoutHandle;
    if (n5 !== $ && (e4.timeoutHandle = $, L(n5)), null !== Hr) for (n5 = Hr.return; null !== n5; ) {
      var r6 = n5;
      switch (r6.tag) {
        case 1:
          var l3 = r6.type.childContextTypes;
          null != l3 && Ee();
          break;
        case 3:
          Kt(), ke();
          break;
        case 5:
          Yt(r6);
          break;
        case 4:
          Kt();
          break;
        case 13:
        case 19:
          me(Jt);
          break;
        case 10:
          dt(r6);
      }
      n5 = n5.return;
    }
    Br = e4, Hr = Al(e4.current, null), Ar = t4, Lr = Mr, $r = null, Vr = qr = 1073741823, Kr = null, Gr = 0, Yr = false;
  }
  function Tl(e4, t4) {
    for (; ; ) {
      try {
        if (ct(), vn(), null === Hr || null === Hr.return) return Lr = Fr, $r = t4, null;
        e: {
          var n5 = e4, r6 = Hr.return, l3 = Hr, i4 = t4;
          if (t4 = Ar, l3.effectTag |= 2048, l3.firstEffect = l3.lastEffect = null, null !== i4 && "object" == typeof i4 && "function" == typeof i4.then) {
            var a5 = i4, u4 = 0 != (1 & Jt.current), o3 = r6;
            do {
              var f4;
              if (f4 = 13 === o3.tag) {
                var c5 = o3.memoizedState;
                if (null !== c5) f4 = null !== c5.dehydrated;
                else {
                  var s3 = o3.memoizedProps;
                  f4 = void 0 !== s3.fallback && (true !== s3.unstable_avoidThisFallback || !u4);
                }
              }
              if (f4) {
                var d3 = o3.updateQueue;
                if (null === d3) {
                  var p4 = /* @__PURE__ */ new Set();
                  p4.add(a5), o3.updateQueue = p4;
                } else d3.add(a5);
                if (0 == (2 & o3.mode)) {
                  if (o3.effectTag |= 64, l3.effectTag &= -2981, 1 === l3.tag) if (null === l3.alternate) l3.tag = 17;
                  else {
                    var m2 = vt(1073741823, null);
                    m2.tag = 2, xt(l3, m2);
                  }
                  l3.expirationTime = 1073741823;
                  break e;
                }
                i4 = void 0, l3 = t4;
                var h4 = n5.pingCache;
                if (null === h4 ? (h4 = n5.pingCache = new kr(), i4 = /* @__PURE__ */ new Set(), h4.set(a5, i4)) : void 0 === (i4 = h4.get(a5)) && (i4 = /* @__PURE__ */ new Set(), h4.set(a5, i4)), !i4.has(l3)) {
                  i4.add(l3);
                  var g4 = Ql.bind(null, n5, a5, l3);
                  a5.then(g4, g4);
                }
                o3.effectTag |= 4096, o3.expirationTime = t4;
                break e;
              }
              o3 = o3.return;
            } while (null !== o3);
            i4 = Error((z(l3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + se(l3));
          }
          Lr !== jr && (Lr = Qr), i4 = fr(i4, l3), o3 = r6;
          do {
            switch (o3.tag) {
              case 3:
                a5 = i4, o3.effectTag |= 4096, o3.expirationTime = t4, Et(o3, Sr(o3, a5, t4));
                break e;
              case 1:
                a5 = i4;
                var b4 = o3.type, y4 = o3.stateNode;
                if (0 == (64 & o3.effectTag) && ("function" == typeof b4.getDerivedStateFromError || null !== y4 && "function" == typeof y4.componentDidCatch && (null === nl || !nl.has(y4)))) {
                  o3.effectTag |= 4096, o3.expirationTime = t4, Et(o3, Cr(o3, a5, t4));
                  break e;
                }
            }
            o3 = o3.return;
          } while (null !== o3);
        }
        Hr = zl(Hr);
      } catch (e5) {
        t4 = e5;
        continue;
      }
      break;
    }
  }
  function xl() {
    var e4 = Pr.current;
    return Pr.current = Qn, null === e4 ? Qn : e4;
  }
  function El(e4, t4) {
    e4 < qr && 2 < e4 && (qr = e4), null !== t4 && e4 < Vr && 2 < e4 && (Vr = e4, Kr = t4);
  }
  function kl(e4) {
    e4 > Gr && (Gr = e4);
  }
  function Sl() {
    for (; null !== Hr; ) Hr = wl(Hr);
  }
  function Cl() {
    for (; null !== Hr && !Ue(); ) Hr = wl(Hr);
  }
  function wl(e4) {
    var t4 = wr(e4.alternate, e4, Ar);
    return e4.memoizedProps = e4.pendingProps, null === t4 && (t4 = zl(e4)), _r.current = null, t4;
  }
  function zl(e4) {
    Hr = e4;
    do {
      var t4 = Hr.alternate;
      if (e4 = Hr.return, 0 == (2048 & Hr.effectTag)) {
        e: {
          var n5 = t4, r6 = Ar, l3 = (t4 = Hr).pendingProps;
          switch (t4.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
            case 20:
            case 21:
              break;
            case 1:
            case 17:
              xe(t4.type) && Ee();
              break;
            case 3:
              Kt(), ke(), (l3 = t4.stateNode).pendingContext && (l3.context = l3.pendingContext, l3.pendingContext = null), null === n5 || n5.child, Jn(t4);
              break;
            case 5:
              Yt(t4);
              var i4 = qt($t.current);
              if (r6 = t4.type, null !== n5 && null != t4.stateNode) Xn(n5, t4, r6, l3, i4), n5.ref !== t4.ref && (t4.effectTag |= 128);
              else if (l3) {
                n5 = qt(At.current);
                var a5 = D(r6, l3, i4, n5, t4);
                Yn(a5, t4, false, false), t4.stateNode = a5, j(a5, r6, l3, i4, n5) && ar(t4), null !== t4.ref && (t4.effectTag |= 128);
              } else if (null === t4.stateNode) throw Error(f3(166));
              break;
            case 6:
              if (n5 && null != t4.stateNode) Zn(n5, t4, n5.memoizedProps, l3);
              else {
                if ("string" != typeof l3 && null === t4.stateNode) throw Error(f3(166));
                n5 = qt($t.current), i4 = qt(At.current), t4.stateNode = H(l3, n5, i4, t4);
              }
              break;
            case 13:
              if (me(Jt), l3 = t4.memoizedState, 0 != (64 & t4.effectTag)) {
                t4.expirationTime = r6;
                break e;
              }
              l3 = null !== l3, i4 = false, null === n5 ? t4.memoizedProps.fallback : (i4 = null !== (r6 = n5.memoizedState), l3 || null === r6 || null !== (r6 = n5.child.sibling) && (null !== (a5 = t4.firstEffect) ? (t4.firstEffect = r6, r6.nextEffect = a5) : (t4.firstEffect = t4.lastEffect = r6, r6.nextEffect = null), r6.effectTag = 8)), l3 && !i4 && 0 != (2 & t4.mode) && (null === n5 && true !== t4.memoizedProps.unstable_avoidThisFallback || 0 != (1 & Jt.current) ? Lr === Mr && (Lr = Dr) : (Lr !== Mr && Lr !== Dr || (Lr = Wr), 0 !== Gr && null !== Br && (Yl(Br, Ar), Jl(Br, Gr)))), (l3 || i4) && (t4.effectTag |= 4);
              break;
            case 4:
              Kt(), Jn(t4);
              break;
            case 10:
              dt(t4);
              break;
            case 19:
              if (me(Jt), null === (l3 = t4.memoizedState)) break;
              if (i4 = 0 != (64 & t4.effectTag), null === (a5 = l3.rendering)) {
                if (i4) ur(l3, false);
                else if (Lr !== Mr || null !== n5 && 0 != (64 & n5.effectTag)) for (n5 = t4.child; null !== n5; ) {
                  if (null !== (a5 = Xt(n5))) {
                    for (t4.effectTag |= 64, ur(l3, false), null !== (n5 = a5.updateQueue) && (t4.updateQueue = n5, t4.effectTag |= 4), null === l3.lastEffect && (t4.firstEffect = null), t4.lastEffect = l3.lastEffect, n5 = r6, l3 = t4.child; null !== l3; ) r6 = n5, (i4 = l3).effectTag &= 2, i4.nextEffect = null, i4.firstEffect = null, i4.lastEffect = null, null === (a5 = i4.alternate) ? (i4.childExpirationTime = 0, i4.expirationTime = r6, i4.child = null, i4.memoizedProps = null, i4.memoizedState = null, i4.updateQueue = null, i4.dependencies = null) : (i4.childExpirationTime = a5.childExpirationTime, i4.expirationTime = a5.expirationTime, i4.child = a5.child, i4.memoizedProps = a5.memoizedProps, i4.memoizedState = a5.memoizedState, i4.updateQueue = a5.updateQueue, r6 = a5.dependencies, i4.dependencies = null === r6 ? null : { expirationTime: r6.expirationTime, firstContext: r6.firstContext, responders: r6.responders }), l3 = l3.sibling;
                    he(Jt, 1 & Jt.current | 2), t4 = t4.child;
                    break e;
                  }
                  n5 = n5.sibling;
                }
              } else {
                if (!i4) if (null !== (n5 = Xt(a5))) {
                  if (t4.effectTag |= 64, i4 = true, null !== (n5 = n5.updateQueue) && (t4.updateQueue = n5, t4.effectTag |= 4), ur(l3, true), null === l3.tail && "hidden" === l3.tailMode) {
                    null !== (t4 = t4.lastEffect = l3.lastEffect) && (t4.nextEffect = null);
                    break;
                  }
                } else qe() > l3.tailExpiration && 1 < r6 && (t4.effectTag |= 64, i4 = true, ur(l3, false), t4.expirationTime = t4.childExpirationTime = r6 - 1);
                l3.isBackwards ? (a5.sibling = t4.child, t4.child = a5) : (null !== (n5 = l3.last) ? n5.sibling = a5 : t4.child = a5, l3.last = a5);
              }
              if (null !== l3.tail) {
                0 === l3.tailExpiration && (l3.tailExpiration = qe() + 500), n5 = l3.tail, l3.rendering = n5, l3.tail = n5.sibling, l3.lastEffect = t4.lastEffect, n5.sibling = null, l3 = Jt.current, he(Jt, l3 = i4 ? 1 & l3 | 2 : 1 & l3), t4 = n5;
                break e;
              }
              break;
            default:
              throw Error(f3(156, t4.tag));
          }
          t4 = null;
        }
        if (n5 = Hr, 1 === Ar || 1 !== n5.childExpirationTime) {
          for (l3 = 0, i4 = n5.child; null !== i4; ) (r6 = i4.expirationTime) > l3 && (l3 = r6), (a5 = i4.childExpirationTime) > l3 && (l3 = a5), i4 = i4.sibling;
          n5.childExpirationTime = l3;
        }
        if (null !== t4) return t4;
        null !== e4 && 0 == (2048 & e4.effectTag) && (null === e4.firstEffect && (e4.firstEffect = Hr.firstEffect), null !== Hr.lastEffect && (null !== e4.lastEffect && (e4.lastEffect.nextEffect = Hr.firstEffect), e4.lastEffect = Hr.lastEffect), 1 < Hr.effectTag && (null !== e4.lastEffect ? e4.lastEffect.nextEffect = Hr : e4.firstEffect = Hr, e4.lastEffect = Hr));
      } else {
        if (null !== (t4 = or(Hr))) return t4.effectTag &= 2047, t4;
        null !== e4 && (e4.firstEffect = e4.lastEffect = null, e4.effectTag |= 2048);
      }
      if (null !== (t4 = Hr.sibling)) return t4;
      Hr = e4;
    } while (null !== Hr);
    return Lr === Mr && (Lr = jr), null;
  }
  function Pl(e4) {
    var t4 = e4.expirationTime;
    return t4 > (e4 = e4.childExpirationTime) ? t4 : e4;
  }
  function _l(e4) {
    var t4 = Ve();
    return Ge(99, Nl.bind(null, e4, t4)), null;
  }
  function Nl(e4, t4) {
    if (Rl(), (Or & (Rr | Ir)) !== Nr) throw Error(f3(327));
    var n5 = e4.finishedWork, r6 = e4.finishedExpirationTime;
    if (null === n5) return null;
    if (e4.finishedWork = null, e4.finishedExpirationTime = 0, n5 === e4.current) throw Error(f3(177));
    e4.callbackNode = null, e4.callbackExpirationTime = 0, e4.callbackPriority = 90, e4.nextKnownPendingLevel = 0;
    var l3 = Pl(n5);
    if (e4.firstPendingTime = l3, r6 <= e4.lastSuspendedTime ? e4.firstSuspendedTime = e4.lastSuspendedTime = e4.nextKnownPendingLevel = 0 : r6 <= e4.firstSuspendedTime && (e4.firstSuspendedTime = r6 - 1), r6 <= e4.lastPingedTime && (e4.lastPingedTime = 0), r6 <= e4.lastExpiredTime && (e4.lastExpiredTime = 0), e4 === Br && (Hr = Br = null, Ar = 0), 1 < n5.effectTag ? null !== n5.lastEffect ? (n5.lastEffect.nextEffect = n5, l3 = n5.firstEffect) : l3 = n5 : l3 = n5.firstEffect, null !== l3) {
      var i4 = Or;
      Or |= Ir, _r.current = null, F(e4.containerInfo), Zr = l3;
      do {
        try {
          Ul();
        } catch (e5) {
          if (null === Zr) throw Error(f3(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = l3;
      do {
        try {
          for (var a5 = e4, u4 = t4; null !== Zr; ) {
            var o3 = Zr.effectTag;
            if (16 & o3 && q && re(Zr.stateNode), 128 & o3) {
              var c5 = Zr.alternate;
              if (null !== c5) {
                var s3 = c5.ref;
                null !== s3 && ("function" == typeof s3 ? s3(null) : s3.current = null);
              }
            }
            switch (1038 & o3) {
              case 2:
                vr(Zr), Zr.effectTag &= -3;
                break;
              case 6:
                vr(Zr), Zr.effectTag &= -3, xr(Zr.alternate, Zr);
                break;
              case 1024:
                Zr.effectTag &= -1025;
                break;
              case 1028:
                Zr.effectTag &= -1025, xr(Zr.alternate, Zr);
                break;
              case 4:
                xr(Zr.alternate, Zr);
                break;
              case 8:
                var d3 = a5, p4 = Zr, m2 = u4;
                q ? Tr(d3, p4, m2) : gr(d3, p4, m2), br(p4);
            }
            Zr = Zr.nextEffect;
          }
        } catch (e5) {
          if (null === Zr) throw Error(f3(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Q(e4.containerInfo), e4.current = n5, Zr = l3;
      do {
        try {
          for (o3 = r6; null !== Zr; ) {
            var h4 = Zr.effectTag;
            if (36 & h4) {
              var g4 = Zr.alternate;
              switch (s3 = o3, (c5 = Zr).tag) {
                case 0:
                case 11:
                case 15:
                  mr(16, 32, c5);
                  break;
                case 1:
                  var b4 = c5.stateNode;
                  if (4 & c5.effectTag) if (null === g4) b4.componentDidMount();
                  else {
                    var y4 = c5.elementType === c5.type ? g4.memoizedProps : it(c5.type, g4.memoizedProps);
                    b4.componentDidUpdate(y4, g4.memoizedState, b4.__reactInternalSnapshotBeforeUpdate);
                  }
                  var v4 = c5.updateQueue;
                  null !== v4 && wt(0, v4, b4);
                  break;
                case 3:
                  var T2 = c5.updateQueue;
                  if (null !== T2) {
                    if (a5 = null, null !== c5.child) switch (c5.child.tag) {
                      case 5:
                        a5 = R(c5.child.stateNode);
                        break;
                      case 1:
                        a5 = c5.child.stateNode;
                    }
                    wt(0, T2, a5);
                  }
                  break;
                case 5:
                  var x2 = c5.stateNode;
                  null === g4 && 4 & c5.effectTag && J(x2, c5.type, c5.memoizedProps, c5);
                  break;
                case 6:
                case 4:
                case 12:
                case 19:
                case 17:
                case 20:
                case 21:
                  break;
                case 13:
                  V && c5.memoizedState;
                  break;
                default:
                  throw Error(f3(163));
              }
            }
            if (128 & h4) {
              c5 = void 0;
              var E2 = Zr.ref;
              if (null !== E2) {
                var k4 = Zr.stateNode;
                c5 = 5 === Zr.tag ? R(k4) : k4, "function" == typeof E2 ? E2(c5) : E2.current = c5;
              }
            }
            Zr = Zr.nextEffect;
          }
        } catch (e5) {
          if (null === Zr) throw Error(f3(330));
          Fl(Zr, e5), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = null, Be(), Or = i4;
    } else e4.current = n5;
    if (rl) rl = false, ll = e4, il = t4;
    else for (Zr = l3; null !== Zr; ) t4 = Zr.nextEffect, Zr.nextEffect = null, Zr = t4;
    if (0 === (t4 = e4.firstPendingTime) && (nl = null), 1073741823 === t4 ? e4 === ol ? ul++ : (ul = 0, ol = e4) : ul = 0, "function" == typeof Wl && Wl(n5.stateNode, r6), hl(e4), el) throw el = false, e4 = tl, tl = null, e4;
    return (Or & Ur) !== Nr || Xe(), null;
  }
  function Ul() {
    for (; null !== Zr; ) {
      var e4 = Zr.effectTag;
      0 != (256 & e4) && pr(Zr.alternate, Zr), 0 == (512 & e4) || rl || (rl = true, Ye(97, function() {
        return Rl(), null;
      })), Zr = Zr.nextEffect;
    }
  }
  function Rl() {
    if (90 !== il) {
      var e4 = 97 < il ? 97 : il;
      return il = 90, Ge(e4, Il);
    }
  }
  function Il() {
    if (null === ll) return false;
    var e4 = ll;
    if (ll = null, (Or & (Rr | Ir)) !== Nr) throw Error(f3(331));
    var t4 = Or;
    for (Or |= Ir, e4 = e4.current.firstEffect; null !== e4; ) {
      try {
        var n5 = e4;
        if (0 != (512 & n5.effectTag)) switch (n5.tag) {
          case 0:
          case 11:
          case 15:
            mr(128, 0, n5), mr(0, 64, n5);
        }
      } catch (t5) {
        if (null === e4) throw Error(f3(330));
        Fl(e4, t5);
      }
      n5 = e4.nextEffect, e4.nextEffect = null, e4 = n5;
    }
    return Or = t4, Xe(), true;
  }
  function Ml(e4, t4, n5) {
    xt(e4, t4 = Sr(e4, t4 = fr(n5, t4), 1073741823)), null !== (e4 = pl(e4, 1073741823)) && hl(e4);
  }
  function Fl(e4, t4) {
    if (3 === e4.tag) Ml(e4, e4, t4);
    else for (var n5 = e4.return; null !== n5; ) {
      if (3 === n5.tag) {
        Ml(n5, e4, t4);
        break;
      }
      if (1 === n5.tag) {
        var r6 = n5.stateNode;
        if ("function" == typeof n5.type.getDerivedStateFromError || "function" == typeof r6.componentDidCatch && (null === nl || !nl.has(r6))) {
          xt(n5, e4 = Cr(n5, e4 = fr(t4, e4), 1073741823)), null !== (n5 = pl(n5, 1073741823)) && hl(n5);
          break;
        }
      }
      n5 = n5.return;
    }
  }
  function Ql(e4, t4, n5) {
    var r6 = e4.pingCache;
    null !== r6 && r6.delete(t4), Br === e4 && Ar === n5 ? Lr === Wr || Lr === Dr && 1073741823 === qr && qe() - Jr < Xr ? vl(e4, Ar) : Yr = true : Gl(e4, n5) && (0 !== (t4 = e4.lastPingedTime) && t4 < n5 || (e4.lastPingedTime = n5, e4.finishedExpirationTime === n5 && (e4.finishedExpirationTime = 0, e4.finishedWork = null), hl(e4)));
  }
  function Dl(e4, t4) {
    var n5 = e4.stateNode;
    null !== n5 && n5.delete(t4), 0 == (t4 = 0) && (t4 = sl(t4 = cl(), e4, null)), null !== (e4 = pl(e4, t4)) && hl(e4);
  }
  wr = function(e4, t4, n5) {
    var r6 = t4.expirationTime;
    if (null !== e4) {
      var l3 = t4.pendingProps;
      if (e4.memoizedProps !== l3 || ye.current) On = true;
      else {
        if (r6 < n5) {
          switch (On = false, t4.tag) {
            case 3:
              Gn(t4);
              break;
            case 5:
              if (Gt(t4), 4 & t4.mode && 1 !== n5 && null(t4.type, l3)) return t4.expirationTime = t4.childExpirationTime = 1, null;
              break;
            case 1:
              xe(t4.type) && we(t4);
              break;
            case 4:
              Vt(t4, t4.stateNode.containerInfo);
              break;
            case 10:
              st(t4, t4.memoizedProps.value);
              break;
            case 13:
              if (null !== t4.memoizedState) return 0 !== (r6 = t4.child.childExpirationTime) && r6 >= n5 ? tr(e4, t4, n5) : (he(Jt, 1 & Jt.current), null !== (t4 = ir(e4, t4, n5)) ? t4.sibling : null);
              he(Jt, 1 & Jt.current);
              break;
            case 19:
              if (r6 = t4.childExpirationTime >= n5, 0 != (64 & e4.effectTag)) {
                if (r6) return lr(e4, t4, n5);
                t4.effectTag |= 64;
              }
              if (null !== (l3 = t4.memoizedState) && (l3.rendering = null, l3.tail = null), he(Jt, Jt.current), !r6) return null;
          }
          return ir(e4, t4, n5);
        }
        On = false;
      }
    } else On = false;
    switch (t4.expirationTime = 0, t4.tag) {
      case 2:
        if (r6 = t4.type, null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), e4 = t4.pendingProps, l3 = Te(t4, be.current), mt(t4, n5), l3 = yn(null, t4, r6, e4, l3, n5), t4.effectTag |= 1, "object" == typeof l3 && null !== l3 && "function" == typeof l3.render && void 0 === l3.$$typeof) {
          if (t4.tag = 1, vn(), xe(r6)) {
            var i4 = true;
            we(t4);
          } else i4 = false;
          t4.memoizedState = null !== l3.state && void 0 !== l3.state ? l3.state : null;
          var a5 = r6.getDerivedStateFromProps;
          "function" == typeof a5 && Nt(t4, r6, a5, e4), l3.updater = Ut, t4.stateNode = l3, l3._reactInternalFiber = t4, Ft(t4, r6, e4, n5), t4 = Kn(null, t4, r6, true, i4, n5);
        } else t4.tag = 0, Bn(null, t4, l3, n5), t4 = t4.child;
        return t4;
      case 16:
        if (l3 = t4.elementType, null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), e4 = t4.pendingProps, function(e5) {
          if (-1 === e5._status) {
            e5._status = 0;
            var t5 = e5._ctor;
            t5 = t5(), e5._result = t5, t5.then(function(t6) {
              0 === e5._status && (t6 = t6.default, e5._status = 1, e5._result = t6);
            }, function(t6) {
              0 === e5._status && (e5._status = 2, e5._result = t6);
            });
          }
        }(l3), 1 !== l3._status) throw l3._result;
        switch (l3 = l3._result, t4.type = l3, i4 = t4.tag = function(e5) {
          if ("function" == typeof e5) return Hl(e5) ? 1 : 0;
          if (null != e5) {
            if ((e5 = e5.$$typeof) === T) return 11;
            if (e5 === k3) return 14;
          }
          return 2;
        }(l3), e4 = it(l3, e4), i4) {
          case 0:
            t4 = qn(null, t4, l3, e4, n5);
            break;
          case 1:
            t4 = Vn(null, t4, l3, e4, n5);
            break;
          case 11:
            t4 = Hn(null, t4, l3, e4, n5);
            break;
          case 14:
            t4 = An(null, t4, l3, it(l3.type, e4), r6, n5);
            break;
          default:
            throw Error(f3(306, l3, ""));
        }
        return t4;
      case 0:
        return r6 = t4.type, l3 = t4.pendingProps, qn(e4, t4, r6, l3 = t4.elementType === r6 ? l3 : it(r6, l3), n5);
      case 1:
        return r6 = t4.type, l3 = t4.pendingProps, Vn(e4, t4, r6, l3 = t4.elementType === r6 ? l3 : it(r6, l3), n5);
      case 3:
        if (Gn(t4), null === (r6 = t4.updateQueue)) throw Error(f3(282));
        if (l3 = null !== (l3 = t4.memoizedState) ? l3.element : null, Ct(t4, r6, t4.pendingProps, null, n5), (r6 = t4.memoizedState.element) === l3) t4 = ir(e4, t4, n5);
        else {
          if ((l3 = t4.stateNode.hydrate) && (l3 = false), l3) for (n5 = Bt(t4, null, r6, n5), t4.child = n5; n5; ) n5.effectTag = -3 & n5.effectTag | 1024, n5 = n5.sibling;
          else Bn(e4, t4, r6, n5);
          t4 = t4.child;
        }
        return t4;
      case 5:
        return Gt(t4), r6 = t4.type, l3 = t4.pendingProps, i4 = null !== e4 ? e4.memoizedProps : null, a5 = l3.children, B(r6, l3) ? a5 = null : null !== i4 && B(r6, i4) && (t4.effectTag |= 16), $n(e4, t4), 4 & t4.mode && 1 !== n5 && null(r6, l3) ? (t4.expirationTime = t4.childExpirationTime = 1, t4 = null) : (Bn(e4, t4, a5, n5), t4 = t4.child), t4;
      case 6:
        return null;
      case 13:
        return tr(e4, t4, n5);
      case 4:
        return Vt(t4, t4.stateNode.containerInfo), r6 = t4.pendingProps, null === e4 ? t4.child = Ot(t4, null, r6, n5) : Bn(e4, t4, r6, n5), t4.child;
      case 11:
        return r6 = t4.type, l3 = t4.pendingProps, Hn(e4, t4, r6, l3 = t4.elementType === r6 ? l3 : it(r6, l3), n5);
      case 7:
        return Bn(e4, t4, t4.pendingProps, n5), t4.child;
      case 8:
      case 12:
        return Bn(e4, t4, t4.pendingProps.children, n5), t4.child;
      case 10:
        e: {
          if (r6 = t4.type._context, l3 = t4.pendingProps, a5 = t4.memoizedProps, st(t4, i4 = l3.value), null !== a5) {
            var u4 = a5.value;
            if (0 == (i4 = nt(u4, i4) ? 0 : 0 | ("function" == typeof r6._calculateChangedBits ? r6._calculateChangedBits(u4, i4) : 1073741823))) {
              if (a5.children === l3.children && !ye.current) {
                t4 = ir(e4, t4, n5);
                break e;
              }
            } else for (null !== (u4 = t4.child) && (u4.return = t4); null !== u4; ) {
              var o3 = u4.dependencies;
              if (null !== o3) {
                a5 = u4.child;
                for (var c5 = o3.firstContext; null !== c5; ) {
                  if (c5.context === r6 && 0 != (c5.observedBits & i4)) {
                    1 === u4.tag && ((c5 = vt(n5, null)).tag = 2, xt(u4, c5)), u4.expirationTime < n5 && (u4.expirationTime = n5), null !== (c5 = u4.alternate) && c5.expirationTime < n5 && (c5.expirationTime = n5), pt(u4.return, n5), o3.expirationTime < n5 && (o3.expirationTime = n5);
                    break;
                  }
                  c5 = c5.next;
                }
              } else a5 = 10 === u4.tag && u4.type === t4.type ? null : u4.child;
              if (null !== a5) a5.return = u4;
              else for (a5 = u4; null !== a5; ) {
                if (a5 === t4) {
                  a5 = null;
                  break;
                }
                if (null !== (u4 = a5.sibling)) {
                  u4.return = a5.return, a5 = u4;
                  break;
                }
                a5 = a5.return;
              }
              u4 = a5;
            }
          }
          Bn(e4, t4, l3.children, n5), t4 = t4.child;
        }
        return t4;
      case 9:
        return l3 = t4.type, r6 = (i4 = t4.pendingProps).children, mt(t4, n5), r6 = r6(l3 = ht(l3, i4.unstable_observedBits)), t4.effectTag |= 1, Bn(e4, t4, r6, n5), t4.child;
      case 14:
        return i4 = it(l3 = t4.type, t4.pendingProps), An(e4, t4, l3, i4 = it(l3.type, i4), r6, n5);
      case 15:
        return Ln(e4, t4, t4.type, t4.pendingProps, r6, n5);
      case 17:
        return r6 = t4.type, l3 = t4.pendingProps, l3 = t4.elementType === r6 ? l3 : it(r6, l3), null !== e4 && (e4.alternate = null, t4.alternate = null, t4.effectTag |= 2), t4.tag = 1, xe(r6) ? (e4 = true, we(t4)) : e4 = false, mt(t4, n5), It(t4, r6, l3), Ft(t4, r6, l3, n5), Kn(null, t4, r6, true, e4, n5);
      case 19:
        return lr(e4, t4, n5);
    }
    throw Error(f3(156, t4.tag));
  };
  var Wl = null, jl = null;
  function Ol(e4, t4, n5, r6) {
    this.tag = e4, this.key = n5, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t4, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r6, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null;
  }
  function Bl(e4, t4, n5, r6) {
    return new Ol(e4, t4, n5, r6);
  }
  function Hl(e4) {
    return !(!(e4 = e4.prototype) || !e4.isReactComponent);
  }
  function Al(e4, t4) {
    var n5 = e4.alternate;
    return null === n5 ? ((n5 = Bl(e4.tag, t4, e4.key, e4.mode)).elementType = e4.elementType, n5.type = e4.type, n5.stateNode = e4.stateNode, n5.alternate = e4, e4.alternate = n5) : (n5.pendingProps = t4, n5.effectTag = 0, n5.nextEffect = null, n5.firstEffect = null, n5.lastEffect = null), n5.childExpirationTime = e4.childExpirationTime, n5.expirationTime = e4.expirationTime, n5.child = e4.child, n5.memoizedProps = e4.memoizedProps, n5.memoizedState = e4.memoizedState, n5.updateQueue = e4.updateQueue, t4 = e4.dependencies, n5.dependencies = null === t4 ? null : { expirationTime: t4.expirationTime, firstContext: t4.firstContext, responders: t4.responders }, n5.sibling = e4.sibling, n5.index = e4.index, n5.ref = e4.ref, n5;
  }
  function Ll(e4, t4, n5, r6, l3, i4) {
    var a5 = 2;
    if (r6 = e4, "function" == typeof e4) Hl(e4) && (a5 = 1);
    else if ("string" == typeof e4) a5 = 5;
    else e: switch (e4) {
      case m:
        return $l(n5.children, l3, i4, t4);
      case v3:
        a5 = 8, l3 |= 7;
        break;
      case h3:
        a5 = 8, l3 |= 1;
        break;
      case g3:
        return (e4 = Bl(12, n5, t4, 8 | l3)).elementType = g3, e4.type = g3, e4.expirationTime = i4, e4;
      case x:
        return (e4 = Bl(13, n5, t4, l3)).type = x, e4.elementType = x, e4.expirationTime = i4, e4;
      case E:
        return (e4 = Bl(19, n5, t4, l3)).elementType = E, e4.expirationTime = i4, e4;
      default:
        if ("object" == typeof e4 && null !== e4) switch (e4.$$typeof) {
          case b3:
            a5 = 10;
            break e;
          case y3:
            a5 = 9;
            break e;
          case T:
            a5 = 11;
            break e;
          case k3:
            a5 = 14;
            break e;
          case S3:
            a5 = 16, r6 = null;
            break e;
        }
        throw Error(f3(130, null == e4 ? e4 : typeof e4, ""));
    }
    return (t4 = Bl(a5, n5, t4, l3)).elementType = e4, t4.type = r6, t4.expirationTime = i4, t4;
  }
  function $l(e4, t4, n5, r6) {
    return (e4 = Bl(7, e4, r6, t4)).expirationTime = n5, e4;
  }
  function ql(e4, t4, n5) {
    return (e4 = Bl(6, e4, null, t4)).expirationTime = n5, e4;
  }
  function Vl(e4, t4, n5) {
    return (t4 = Bl(4, null !== e4.children ? e4.children : [], e4.key, t4)).expirationTime = n5, t4.stateNode = { containerInfo: e4.containerInfo, pendingChildren: null, implementation: e4.implementation }, t4;
  }
  function Kl(e4, t4, n5) {
    this.tag = t4, this.current = null, this.containerInfo = e4, this.pingCache = this.pendingChildren = null, this.finishedExpirationTime = 0, this.finishedWork = null, this.timeoutHandle = $, this.pendingContext = this.context = null, this.hydrate = n5, this.callbackNode = null, this.callbackPriority = 90, this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }
  function Gl(e4, t4) {
    var n5 = e4.firstSuspendedTime;
    return e4 = e4.lastSuspendedTime, 0 !== n5 && n5 >= t4 && e4 <= t4;
  }
  function Yl(e4, t4) {
    var n5 = e4.firstSuspendedTime, r6 = e4.lastSuspendedTime;
    n5 < t4 && (e4.firstSuspendedTime = t4), (r6 > t4 || 0 === n5) && (e4.lastSuspendedTime = t4), t4 <= e4.lastPingedTime && (e4.lastPingedTime = 0), t4 <= e4.lastExpiredTime && (e4.lastExpiredTime = 0);
  }
  function Jl(e4, t4) {
    t4 > e4.firstPendingTime && (e4.firstPendingTime = t4);
    var n5 = e4.firstSuspendedTime;
    0 !== n5 && (t4 >= n5 ? e4.firstSuspendedTime = e4.lastSuspendedTime = e4.nextKnownPendingLevel = 0 : t4 >= e4.lastSuspendedTime && (e4.lastSuspendedTime = t4 + 1), t4 > e4.nextKnownPendingLevel && (e4.nextKnownPendingLevel = t4));
  }
  function Xl(e4, t4) {
    var n5 = e4.lastExpiredTime;
    (0 === n5 || n5 > t4) && (e4.lastExpiredTime = t4);
  }
  function Zl(e4) {
    var t4 = e4._reactInternalFiber;
    if (void 0 === t4) {
      if ("function" == typeof e4.render) throw Error(f3(188));
      throw Error(f3(268, Object.keys(e4)));
    }
    return null === (e4 = U(t4)) ? null : e4.stateNode;
  }
  function ei(e4, t4) {
    null !== (e4 = e4.memoizedState) && null !== e4.dehydrated && e4.retryTime < t4 && (e4.retryTime = t4);
  }
  function ti(e4, t4) {
    ei(e4, t4), (e4 = e4.alternate) && ei(e4, t4);
  }
  var ni = { createContainer: function(e4, t4, n5) {
    return e4 = new Kl(e4, t4, n5), t4 = Bl(3, null, null, 2 === t4 ? 7 : 1 === t4 ? 3 : 0), e4.current = t4, t4.stateNode = e4;
  }, updateContainer: function(e4, t4, n5, r6) {
    var l3 = t4.current, i4 = cl(), a5 = Pt.suspense;
    i4 = sl(i4, l3, a5);
    e: if (n5) {
      t: {
        if (P(n5 = n5._reactInternalFiber) !== n5 || 1 !== n5.tag) throw Error(f3(170));
        var u4 = n5;
        do {
          switch (u4.tag) {
            case 3:
              u4 = u4.stateNode.context;
              break t;
            case 1:
              if (xe(u4.type)) {
                u4 = u4.stateNode.__reactInternalMemoizedMergedChildContext;
                break t;
              }
          }
          u4 = u4.return;
        } while (null !== u4);
        throw Error(f3(171));
      }
      if (1 === n5.tag) {
        var o3 = n5.type;
        if (xe(o3)) {
          n5 = Ce(n5, o3, u4);
          break e;
        }
      }
      n5 = u4;
    } else n5 = ge;
    return null === t4.context ? t4.context = n5 : t4.pendingContext = n5, (t4 = vt(i4, a5)).payload = { element: e4 }, null !== (r6 = void 0 === r6 ? null : r6) && (t4.callback = r6), xt(l3, t4), dl(l3, i4), i4;
  }, batchedEventUpdates: function(e4, t4) {
    var n5 = Or;
    Or |= 2;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, batchedUpdates: function(e4, t4) {
    var n5 = Or;
    Or |= 1;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, unbatchedUpdates: function(e4, t4) {
    var n5 = Or;
    Or &= -2, Or |= Ur;
    try {
      return e4(t4);
    } finally {
      (Or = n5) === Nr && Xe();
    }
  }, deferredUpdates: function(e4) {
    return Ge(97, e4);
  }, syncUpdates: function(e4, t4, n5, r6) {
    return Ge(99, e4.bind(null, t4, n5, r6));
  }, discreteUpdates: function(e4, t4, n5, r6) {
    var l3 = Or;
    Or |= 4;
    try {
      return Ge(98, e4.bind(null, t4, n5, r6));
    } finally {
      (Or = l3) === Nr && Xe();
    }
  }, flushDiscreteUpdates: function() {
    (Or & (1 | Rr | Ir)) === Nr && (function() {
      if (null !== al) {
        var e4 = al;
        al = null, e4.forEach(function(e5, t4) {
          Xl(t4, e5), hl(t4);
        }), Xe();
      }
    }(), Rl());
  }, flushControlled: function(e4) {
    var t4 = Or;
    Or |= 1;
    try {
      Ge(99, e4);
    } finally {
      (Or = t4) === Nr && Xe();
    }
  }, flushSync: yl, flushPassiveEffects: Rl, IsThisRendererActing: { current: false }, getPublicRootInstance: function(e4) {
    return (e4 = e4.current).child ? 5 === e4.child.tag ? R(e4.child.stateNode) : e4.child.stateNode : null;
  }, attemptSynchronousHydration: function(e4) {
    switch (e4.tag) {
      case 3:
        var t4 = e4.stateNode;
        t4.hydrate && function(e5, t5) {
          Xl(e5, t5), hl(e5), (Or & (Rr | Ir)) === Nr && Xe();
        }(t4, t4.firstPendingTime);
        break;
      case 13:
        yl(function() {
          return dl(e4, 1073741823);
        }), t4 = tt(cl(), 150, 100), ti(e4, t4);
    }
  }, attemptUserBlockingHydration: function(e4) {
    if (13 === e4.tag) {
      var t4 = tt(cl(), 150, 100);
      dl(e4, t4), ti(e4, t4);
    }
  }, attemptContinuousHydration: function(e4) {
    if (13 === e4.tag) {
      cl();
      var t4 = et++;
      dl(e4, t4), ti(e4, t4);
    }
  }, attemptHydrationAtCurrentPriority: function(e4) {
    if (13 === e4.tag) {
      var t4 = cl();
      dl(e4, t4 = sl(t4, e4, null)), ti(e4, t4);
    }
  }, findHostInstance: Zl, findHostInstanceWithWarning: function(e4) {
    return Zl(e4);
  }, findHostInstanceWithNoPortals: function(e4) {
    return null === (e4 = function(e5) {
      if (!(e5 = N(e5))) return null;
      for (var t4 = e5; ; ) {
        if (5 === t4.tag || 6 === t4.tag) return t4;
        if (t4.child && 4 !== t4.tag) t4.child.return = t4, t4 = t4.child;
        else {
          if (t4 === e5) break;
          for (; !t4.sibling; ) {
            if (!t4.return || t4.return === e5) return null;
            t4 = t4.return;
          }
          t4.sibling.return = t4.return, t4 = t4.sibling;
        }
      }
      return null;
    }(e4)) ? null : 20 === e4.tag ? e4.stateNode.instance : e4.stateNode;
  }, shouldSuspend: function() {
    return false;
  }, injectIntoDevTools: function(e4) {
    var t4 = e4.findFiberByHostInstance;
    return function(e5) {
      if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
      var t5 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t5.isDisabled || !t5.supportsFiber) return true;
      try {
        var n5 = t5.inject(e5);
        Wl = function(e6) {
          try {
            t5.onCommitFiberRoot(n5, e6, void 0, 64 == (64 & e6.current.effectTag));
          } catch (e7) {
          }
        }, jl = function(e6) {
          try {
            t5.onCommitFiberUnmount(n5, e6);
          } catch (e7) {
          }
        };
      } catch (e6) {
      }
      return true;
    }(l2({}, e4, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: c4.ReactCurrentDispatcher, findHostInstanceByFiber: function(e5) {
      return null === (e5 = U(e5)) ? null : e5.stateNode;
    }, findFiberByHostInstance: function(e5) {
      return t4 ? t4(e5) : null;
    }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
  } };
  i3.exports = ni.default || ni;
  var ri = i3.exports;
  return i3.exports = n4, ri;
};
var o = r4(a3.exports);
var f2 = (e4, t4) => {
  const n5 = Object.keys(e4), r5 = Object.keys(t4);
  if (n5.length !== r5.length) return false;
  for (let r6 = 0; r6 < n5.length; r6 += 1) {
    const l2 = n5[r6];
    if ("render" === l2 && !e4[l2] != !t4[l2]) return false;
    if ("children" !== l2 && e4[l2] !== t4[l2]) {
      if ("object" == typeof e4[l2] && "object" == typeof t4[l2] && f2(e4[l2], t4[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e4[l2] || "string" == typeof t4[l2])) return e4[l2] === t4[l2];
  }
  return true;
};
var c3 = {};
var s = ({ appendChild: e4, appendChildToContainer: t4, commitTextUpdate: n5, commitUpdate: r5, createInstance: l2, createTextInstance: i4, insertBefore: a4, removeChild: u4, removeChildFromContainer: s2, resetAfterCommit: d2 }) => o({ appendChild: e4, appendChildToContainer: t4, appendInitialChild: e4, createInstance: l2, createTextInstance: i4, insertBefore: a4, commitUpdate: r5, commitTextUpdate: n5, removeChild: u4, removeChildFromContainer: s2, resetAfterCommit: d2, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e5) => e5, getRootHostContext: () => c3, getChildHostContext: () => c3, prepareForCommit() {
}, clearContainer() {
}, resetTextContent() {
}, prepareUpdate: (e5, t5, n6, r6) => !f2(n6, r6) });

// node_modules/@react-pdf/reconciler/lib/index.js
var [major, minor] = import_react4.default.version.split(".").map((v3) => parseInt(v3, 10));
var renderer;
if (major >= 20 || major === 19 && minor >= 2) {
  renderer = k2;
} else if (major === 19) {
  renderer = k;
} else {
  renderer = s;
}
var renderer$1 = renderer;

// node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var omitNils = (object) => Object.fromEntries(Object.entries(object).filter((_ref) => {
  let [, value2] = _ref;
  return value2 !== void 0;
}));
var createInstance = (type, _ref) => {
  let {
    style,
    children,
    ...props
  } = _ref;
  return {
    type,
    box: {},
    style: style || {},
    props: props || {},
    children: []
  };
};
var createTextInstance = (text) => ({
  type: "TEXT_INSTANCE",
  value: text
});
var appendChild = (parent, child) => {
  const isParentText = parent.type === "TEXT" || parent.type === "LINK" || parent.type === "TSPAN" || parent.type === "NOTE";
  const isChildTextInstance = child.type === "TEXT_INSTANCE";
  const isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn(`Invalid '${child.value}' string child outside <Text> component`);
    return;
  }
  parent.children.push(child);
};
var appendChildToContainer = (parentInstance, child) => {
  if (parentInstance.type === "ROOT") {
    parentInstance.document = child;
  } else {
    appendChild(parentInstance, child);
  }
};
var insertBefore = (parentInstance, child, beforeChild) => {
  var _parentInstance$child;
  const index2 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
  if (index2 === void 0) return;
  if (index2 !== -1 && child) parentInstance.children.splice(index2, 0, child);
};
var removeChild = (parentInstance, child) => {
  var _parentInstance$child2;
  const index2 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
};
var removeChildFromContainer = (parentInstance, child) => {
  var _parentInstance$child3;
  const index2 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
};
var commitTextUpdate = (textInstance, oldText, newText) => {
  textInstance.value = newText;
};
var commitUpdate = (instance, updatePayload, type, oldProps, newProps) => {
  const {
    style,
    ...props
  } = newProps;
  instance.props = props;
  instance.style = style;
};
var createRenderer = (_ref2) => {
  let {
    onChange = () => {
    }
  } = _ref2;
  return renderer$1({
    appendChild,
    appendChildToContainer,
    commitTextUpdate,
    commitUpdate,
    createInstance,
    createTextInstance,
    insertBefore,
    removeChild,
    removeChildFromContainer,
    resetAfterCommit: onChange
  });
};
var version$1 = "4.3.2";
var packageJson = {
  version: version$1
};
var {
  version: version3
} = packageJson;
var fontStore = new FontStore();
var renderer2;
var events = {};
var pdf = (initialValue) => {
  const onChange = () => {
    var _events$change;
    const listeners3 = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (let i4 = 0; i4 < listeners3.length; i4 += 1) listeners3[i4]();
  };
  const container = {
    type: "ROOT",
    document: null
  };
  renderer2 = renderer2 || createRenderer({
    onChange
  });
  const mountNode = renderer2.createContainer(container);
  const updateContainer = (doc, callback) => {
    renderer2.updateContainer(doc, mountNode, null, callback);
  };
  if (initialValue) updateContainer(initialValue);
  const render3 = async function(compress) {
    if (compress === void 0) {
      compress = true;
    }
    const props = container.document.props || {};
    const {
      pdfVersion,
      language,
      pageLayout,
      pageMode,
      title: title3,
      author,
      subject,
      keyboards,
      creator = "react-pdf",
      producer = "react-pdf",
      creationDate = /* @__PURE__ */ new Date(),
      modificationDate
    } = props;
    const ctx = new PDFDocument({
      compress,
      pdfVersion,
      lang: language,
      displayTitle: true,
      autoFirstPage: false,
      info: omitNils({
        Title: title3,
        Author: author,
        Subject: subject,
        Keywords: keyboards,
        Creator: creator,
        Producer: producer,
        CreationDate: creationDate,
        ModificationDate: modificationDate
      })
    });
    if (pageLayout) {
      ctx._root.data.PageLayout = upperFirst(pageLayout);
    }
    if (pageMode) {
      ctx._root.data.PageMode = upperFirst(pageMode);
    }
    const layout2 = await layout(container.document, fontStore);
    const fileStream = render(ctx, layout2);
    return {
      layout: layout2,
      fileStream
    };
  };
  const callOnRender = function(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  };
  const toBlob = async () => {
    const chunks = [];
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream: instance
    } = await render3();
    return new Promise((resolve3, reject) => {
      instance.on("data", (chunk) => {
        chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
      });
      instance.on("end", () => {
        try {
          const blob = new Blob(chunks, {
            type: "application/pdf"
          });
          callOnRender({
            blob,
            _INTERNAL__LAYOUT__DATA_
          });
          resolve3(blob);
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  const toBuffer = async () => {
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream
    } = await render3();
    callOnRender({
      _INTERNAL__LAYOUT__DATA_
    });
    return fileStream;
  };
  const toString7 = async () => {
    if (true) {
      console.warn("`toString` is deprecated and will be removed in next major release");
    }
    let result = "";
    const {
      fileStream: instance
    } = await render3(false);
    return new Promise((resolve3, reject) => {
      try {
        instance.on("data", (buffer) => {
          result += buffer;
        });
        instance.on("end", () => {
          callOnRender();
          resolve3(result);
        });
      } catch (error) {
        reject(error);
      }
    });
  };
  const on3 = (event, listener) => {
    if (!events[event]) events[event] = [];
    events[event].push(listener);
  };
  const removeListener5 = (event, listener) => {
    if (!events[event]) return;
    const idx = events[event].indexOf(listener);
    if (idx > -1) events[event].splice(idx, 1);
  };
  return {
    on: on3,
    container,
    toBlob,
    toBuffer,
    toString: toString7,
    removeListener: removeListener5,
    updateContainer
  };
};
var Font = fontStore;
var StyleSheet = {
  create: (s2) => s2
};
var usePDF = function(_temp) {
  let {
    document: document2
  } = _temp === void 0 ? {} : _temp;
  const pdfInstance = (0, import_react5.useRef)(null);
  const [state2, setState] = (0, import_react5.useState)({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  });
  (0, import_react5.useEffect)(() => {
    const renderQueue = (0, import_queue.default)({
      autostart: true,
      concurrency: 1
    });
    const queueDocumentRender = () => {
      setState((prev) => ({
        ...prev,
        loading: true
      }));
      renderQueue.splice(0, renderQueue.length, () => state2.error ? Promise.resolve() : pdfInstance.current.toBlob());
    };
    const onRenderFailed = (error) => {
      console.error(error);
      setState((prev) => ({
        ...prev,
        loading: false,
        error
      }));
    };
    const onRenderSuccessful = (blob) => {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    };
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return () => {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  (0, import_react5.useEffect)(() => {
    return () => {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  const update = (0, import_react5.useCallback)((newDoc) => {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
};
var PDFViewer = (_ref) => {
  let {
    title: title3,
    style,
    className,
    children,
    innerRef,
    showToolbar = true,
    ...props
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(children), [children]);
  const src = instance.url ? `${instance.url}#toolbar=${showToolbar ? 1 : 0}` : null;
  return (0, import_jsx_runtime.jsx)("iframe", {
    src,
    title: title3,
    ref: innerRef,
    style,
    className,
    ...props
  });
};
var BlobProvider = (_ref) => {
  let {
    document: doc,
    children
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to BlobProvider");
    return null;
  }
  return children(instance);
};
var PDFDownloadLinkBase = (_ref, ref) => {
  let {
    fileName = "document.pdf",
    document: doc,
    children,
    onClick,
    href,
    ...rest
  } = _ref;
  const [instance, updateInstance] = usePDF();
  (0, import_react5.useEffect)(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  const handleDownloadIE = () => {
    if (instance && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  };
  const handleClick = (event) => {
    handleDownloadIE();
    if (typeof onClick === "function") onClick(event, instance);
  };
  return (0, import_jsx_runtime.jsx)("a", {
    href: instance.url,
    download: fileName,
    onClick: handleClick,
    ref,
    ...rest,
    children: typeof children === "function" ? children(instance) : children
  });
};
var PDFDownloadLink = (0, import_react5.forwardRef)(PDFDownloadLinkBase);
var throwEnvironmentError = (name) => {
  throw new Error(`${name} is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.`);
};
var renderToStream = () => {
  throwEnvironmentError("renderToStream");
};
var renderToBuffer = () => {
  throwEnvironmentError("renderToBuffer");
};
var renderToString = () => {
  throwEnvironmentError("renderToString");
};
var renderToFile = () => {
  throwEnvironmentError("renderToFile");
};
var render2 = () => {
  throwEnvironmentError("render");
};
var index = {
  pdf,
  usePDF,
  Font,
  version: version3,
  StyleSheet,
  PDFViewer,
  BlobProvider,
  PDFDownloadLink,
  renderToStream,
  renderToString,
  renderToFile,
  render: render2,
  ...lib_exports
};
export {
  BlobProvider,
  Canvas,
  Checkbox,
  Circle,
  ClipPath,
  Defs,
  Document,
  Ellipse,
  FieldSet,
  Font,
  G,
  Image,
  Line,
  LinearGradient,
  Link,
  List,
  Note,
  PDFDownloadLink,
  PDFViewer,
  Page,
  Path,
  Polygon,
  Polyline,
  RadialGradient,
  Rect,
  Select,
  Stop,
  StyleSheet,
  Svg,
  Text,
  TextInput,
  TextInstance,
  Tspan,
  View,
  createRenderer,
  index as default,
  pdf,
  render2 as render,
  renderToBuffer,
  renderToFile,
  renderToStream,
  renderToString,
  usePDF,
  version3 as version
};
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/png-js/lib/png-js.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/pdfkit/lib/pdfkit.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/textkit/lib/textkit.js:
  (**
   * @param nodes
   * @param availableWidths
   * @param tolerance
   * @preserve Knuth and Plass line breaking algorithm in JavaScript
   *)

@react-pdf/image/lib/index.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/reconciler/lib/reconciler-31.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/reconciler/lib/reconciler-33.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-pdf/reconciler/lib/reconciler-33.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-pdf_renderer.js.map
